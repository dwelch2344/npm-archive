{
  "_id": "apollo-cache-inmemory",
  "_rev": "174-08de31362cd2e640c650230f6b10c82f",
  "name": "apollo-cache-inmemory",
  "description": "Core abstract of Caching layer for Apollo Client",
  "dist-tags": {
    "latest": "1.6.6",
    "alpha": "1.4.0-alpha.12",
    "beta": "1.6.0-rc.2",
    "next": "1.5.0-rc.2"
  },
  "versions": {
    "0.1.0-0": {
      "name": "apollo-cache-inmemory",
      "version": "0.1.0-0",
      "description": "Inmemory caching layer for Apollo Client",
      "author": {
        "name": "James Baxley",
        "email": "james@meteor.com"
      },
      "contributors": [
        {
          "name": "James Baxley",
          "email": "james@meteor.com"
        },
        {
          "name": "Jonas Helfer",
          "email": "jonas@helfer.email"
        },
        {
          "name": "Sashko Stubailo",
          "email": "sashko@stubailo.com"
        }
      ],
      "license": "MIT",
      "main": "./lib/index.js",
      "typings": "./lib/index.d.ts",
      "repository": {
        "type": "git",
        "url": "git+https://github.com/apollographql/apollo-client.git"
      },
      "bugs": {
        "url": "https://github.com/apollographql/apollo-client/issues"
      },
      "homepage": "https://github.com/apollographql/apollo-client#readme",
      "scripts": {
        "pretest": "npm run build",
        "test": "npm run test-only --",
        "posttest": "npm run lint",
        "test-only": "mocha --reporter spec --full-trace dist/tests/tests.js",
        "test-watch": "mocha --reporter spec --full-trace dist/tests/tests.js --watch",
        "coverage": "istanbul cover ./node_modules/.bin/_mocha -- --reporter dot --full-trace dist/tests/tests.js",
        "postcoverage": "remap-istanbul --input coverage/coverage.json --type lcovonly --output coverage/lcov.info",
        "lint": "tslint --type-check -p tsconfig.json src/*.ts && tslint --type-check -p tsconfig.json tests/*.ts",
        "prebuild": "npm run clean:dist",
        "build": "tsc -p .",
        "postbuild": "cp -R ./dist/src/. ./lib",
        "watch": "tsc -w -p .",
        "clean": "npm run clean:dist && npm run clean:coverage",
        "clean:dist": "rimraf dist/* && rimraf lib/*",
        "clean:coverage": "rimraf coverage/*",
        "prepublishOnly": "npm run clean && npm run build",
        "compile:browser": "browserify ./dist/src/index.js --i apollo-cache-core --i apollo-utilities -o=./dist/index.js && npm run minify:browser",
        "minify:browser": "uglifyjs -c -m -o ./dist/index.min.js -- ./dist/index.js",
        "filesize": "npm run compile:browser"
      },
      "dependencies": {
        "apollo-utilities": "*",
        "apollo-cache-core": "*",
        "graphql-anywhere": "^4.0.0"
      },
      "devDependencies": {
        "@types/chai": "^4.0.0",
        "@types/chai-as-promised": "0.0.31",
        "@types/graphql": "~0.9.0",
        "@types/lodash": "^4.14.72",
        "@types/mocha": "^2.2.31",
        "@types/sinon": "^2.3.2",
        "browserify": "^14.4.0",
        "chai": "^4.0.2",
        "chai-as-promised": "^7.0.0",
        "fetch-mock": "^5.11.0",
        "graphql": "^0.10.3",
        "graphql-tag": "^2.4.2",
        "istanbul": "^0.4.4",
        "lodash": "^4.17.4",
        "mocha": "^3.2.0",
        "remap-istanbul": "^0.9.0",
        "rimraf": "^2.5.4",
        "sinon": "^2.3.4",
        "source-map-support": "^0.4.5",
        "tslint": "^5.0.0",
        "typescript": "^2.2.1",
        "uglifyjs": "^2.4.11"
      },
      "_id": "apollo-cache-inmemory@0.1.0-0",
      "_npmVersion": "5.3.0",
      "_nodeVersion": "8.1.2",
      "_npmUser": {
        "name": "jbaxleyiii",
        "email": "james@meteor.com"
      },
      "dist": {
        "integrity": "sha512-VdJG5ZtIlsDTViuNewLjNrebUOcBkKAKKRTu+EiDPUBwkGPtuDiBe8RUohLOWtNLSio/C3XtW78eA97RgAqNeQ==",
        "shasum": "0e7f2a3b10023e8333b81e3137de5e1956013e0a",
        "tarball": "https://registry.npmjs.org/apollo-cache-inmemory/-/apollo-cache-inmemory-0.1.0-0.tgz",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIHWjdk3CW42HtE4eeFdEFSs81Eio5ijSathQT49ToRZbAiEAvgREbpRZluGHI+lLzIAIO+0PmcyLBME1ZIPWu+1nbKQ="
          }
        ]
      },
      "maintainers": [
        {
          "name": "jbaxleyiii",
          "email": "james@meteor.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/apollo-cache-inmemory-0.1.0-0.tgz_1502480390705_0.5102138677611947"
      },
      "directories": {}
    },
    "0.1.0-1": {
      "name": "apollo-cache-inmemory",
      "version": "0.1.0-1",
      "description": "Inmemory caching layer for Apollo Client",
      "author": {
        "name": "James Baxley",
        "email": "james@meteor.com"
      },
      "contributors": [
        {
          "name": "James Baxley",
          "email": "james@meteor.com"
        },
        {
          "name": "Jonas Helfer",
          "email": "jonas@helfer.email"
        },
        {
          "name": "Sashko Stubailo",
          "email": "sashko@stubailo.com"
        }
      ],
      "license": "MIT",
      "main": "./lib/index.js",
      "typings": "./lib/index.d.ts",
      "repository": {
        "type": "git",
        "url": "git+https://github.com/apollographql/apollo-client.git"
      },
      "bugs": {
        "url": "https://github.com/apollographql/apollo-client/issues"
      },
      "homepage": "https://github.com/apollographql/apollo-client#readme",
      "scripts": {
        "pretest": "npm run build",
        "test": "npm run test-only --",
        "posttest": "npm run lint",
        "test-only": "mocha --reporter spec --full-trace dist/tests/tests.js",
        "test-watch": "mocha --reporter spec --full-trace dist/tests/tests.js --watch",
        "coverage": "istanbul cover ./node_modules/.bin/_mocha -- --reporter dot --full-trace dist/tests/tests.js",
        "postcoverage": "remap-istanbul --input coverage/coverage.json --type lcovonly --output coverage/lcov.info",
        "lint": "tslint --type-check -p tsconfig.json src/*.ts && tslint --type-check -p tsconfig.json tests/*.ts",
        "prebuild": "npm run clean:dist",
        "build": "tsc -p .",
        "postbuild": "cp -R ./dist/src/. ./lib",
        "watch": "tsc -w -p .",
        "clean": "npm run clean:dist && npm run clean:coverage",
        "clean:dist": "rimraf dist/* && rimraf lib/*",
        "clean:coverage": "rimraf coverage/*",
        "prepublishOnly": "npm run clean && npm run build",
        "compile:browser": "browserify ./dist/src/index.js --i apollo-cache-core --i apollo-utilities -o=./dist/index.js && npm run minify:browser",
        "minify:browser": "uglifyjs -c -m -o ./dist/index.min.js -- ./dist/index.js",
        "filesize": "npm run compile:browser"
      },
      "dependencies": {
        "apollo-utilities": "*",
        "apollo-cache-core": "*",
        "graphql-anywhere": "4.0.0-0"
      },
      "devDependencies": {
        "@types/chai": "^4.0.0",
        "@types/chai-as-promised": "0.0.31",
        "@types/graphql": "~0.9.0",
        "@types/lodash": "^4.14.72",
        "@types/mocha": "^2.2.31",
        "@types/sinon": "^2.3.2",
        "browserify": "^14.4.0",
        "chai": "^4.0.2",
        "chai-as-promised": "^7.0.0",
        "fetch-mock": "^5.11.0",
        "graphql": "^0.10.3",
        "graphql-tag": "^2.4.2",
        "istanbul": "^0.4.4",
        "lodash": "^4.17.4",
        "mocha": "^3.2.0",
        "remap-istanbul": "^0.9.0",
        "rimraf": "^2.5.4",
        "sinon": "^2.3.4",
        "source-map-support": "^0.4.5",
        "tslint": "^5.0.0",
        "typescript": "^2.2.1",
        "uglifyjs": "^2.4.11"
      },
      "_id": "apollo-cache-inmemory@0.1.0-1",
      "_npmVersion": "5.3.0",
      "_nodeVersion": "8.1.2",
      "_npmUser": {
        "name": "jbaxleyiii",
        "email": "james@meteor.com"
      },
      "dist": {
        "integrity": "sha512-fcIfk8cX5MVVjEV4jLnCYz9ci0MKxVhYwFeU4IJTi02CSoYR3SCNMTI0kcadRq/+4wApm0gBWMwjV7J8hlaQ9A==",
        "shasum": "b8e6201d63442edf1a3849fdd51500f3fcce04f7",
        "tarball": "https://registry.npmjs.org/apollo-cache-inmemory/-/apollo-cache-inmemory-0.1.0-1.tgz",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEYCIQDXOAs5Gw0MfSoF2ayCknGdZQe9QByDk8ltia0HJ1qJXwIhALVl9ZHkP/M3dCNElpqg0T2vmKXw5iJ0idIB7+u+m6l/"
          }
        ]
      },
      "maintainers": [
        {
          "name": "jbaxleyiii",
          "email": "james@meteor.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/apollo-cache-inmemory-0.1.0-1.tgz_1502480479531_0.682106668362394"
      },
      "directories": {}
    },
    "0.2.0-alpha.2": {
      "name": "apollo-cache-inmemory",
      "version": "0.2.0-alpha.2",
      "description": "Core abstract of Caching layer for Apollo Client",
      "author": {
        "name": "James Baxley",
        "email": "james@meteor.com"
      },
      "contributors": [
        {
          "name": "James Baxley",
          "email": "james@meteor.com"
        },
        {
          "name": "Jonas Helfer",
          "email": "jonas@helfer.email"
        },
        {
          "name": "Sashko Stubailo",
          "email": "sashko@stubailo.com"
        }
      ],
      "license": "MIT",
      "main": "./lib/index.js",
      "typings": "./lib/index.d.ts",
      "repository": {
        "type": "git",
        "url": "git+https://github.com/apollographql/apollo-client.git"
      },
      "bugs": {
        "url": "https://github.com/apollographql/apollo-client/issues"
      },
      "homepage": "https://github.com/apollographql/apollo-client#readme",
      "scripts": {
        "coverage": "jest --coverage",
        "test": "jest",
        "lint": "tslint --type-check -p tsconfig.json src/*.ts",
        "prebuild": "npm run clean",
        "build": "tsc -p .",
        "watch": "tsc -w -p .",
        "clean": "rimraf coverage/* && rimraf lib/*",
        "prepublishOnly": "npm run build",
        "build:browser": "browserify ./lib/index.js --i apollo-cache-core --i apollo-utilities -o=./lib/bundle.js && npm run minify:browser",
        "minify:browser": "uglifyjs -c -m -o ./lib/bundle.min.js -- ./lib/bundle.js",
        "filesize": "npm run build:browser"
      },
      "dependencies": {
        "apollo-cache-core": "^0.2.0-alpha.2",
        "apollo-utilities": "^0.2.0-alpha.2",
        "graphql-anywhere": "^4.0.0-alpha.2"
      },
      "devDependencies": {
        "@types/graphql": "~0.9.0",
        "@types/jest": "^20.0.7",
        "@types/lodash": "^4.14.72",
        "browserify": "^14.4.0",
        "graphql": "^0.10.3",
        "graphql-tag": "^2.4.2",
        "jest": "^20.0.4",
        "lodash": "^4.17.4",
        "rimraf": "^2.5.4",
        "ts-jest": "^20.0.10",
        "tslint": "^5.0.0",
        "typescript": "^2.2.1",
        "uglifyjs": "^2.4.11"
      },
      "jest": {
        "transform": {
          ".(ts|tsx)": "<rootDir>/node_modules/ts-jest/preprocessor.js"
        },
        "testRegex": "(/__tests__/.*|\\.(test|spec))\\.(ts|tsx|js)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "json"
        ]
      },
      "_id": "apollo-cache-inmemory@0.2.0-alpha.2",
      "_npmVersion": "5.3.0",
      "_nodeVersion": "8.1.2",
      "_npmUser": {
        "name": "jbaxleyiii",
        "email": "james@meteor.com"
      },
      "dist": {
        "integrity": "sha512-CUttNUdxKF8h4wkVKbI57UpFVpqhSfnpXuCRxRyF42CIqOdPYL+PXrv3Dv9RXU3Nv/KvEm+DBpfQ7eUVX8Hl3A==",
        "shasum": "fca7ed078e27924bb9153d2ad5c2264a46e38ba7",
        "tarball": "https://registry.npmjs.org/apollo-cache-inmemory/-/apollo-cache-inmemory-0.2.0-alpha.2.tgz",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEYCIQCv8UxVCSh+U0lPMr0WvHRylCUbEn5WyloBvBSMGaLgzgIhAPf32LnE/g5tl7hHsOkw4JbfpMV0CACMY5yJroLsa1d4"
          }
        ]
      },
      "maintainers": [
        {
          "name": "jbaxleyiii",
          "email": "james@meteor.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/apollo-cache-inmemory-0.2.0-alpha.2.tgz_1504496593686_0.4511533537879586"
      },
      "directories": {}
    },
    "0.2.0-alpha.3": {
      "name": "apollo-cache-inmemory",
      "version": "0.2.0-alpha.3",
      "description": "Core abstract of Caching layer for Apollo Client",
      "author": {
        "name": "James Baxley",
        "email": "james@meteor.com"
      },
      "contributors": [
        {
          "name": "James Baxley",
          "email": "james@meteor.com"
        },
        {
          "name": "Jonas Helfer",
          "email": "jonas@helfer.email"
        },
        {
          "name": "Sashko Stubailo",
          "email": "sashko@stubailo.com"
        }
      ],
      "license": "MIT",
      "main": "./lib/index.js",
      "typings": "./lib/index.d.ts",
      "repository": {
        "type": "git",
        "url": "git+https://github.com/apollographql/apollo-client.git"
      },
      "bugs": {
        "url": "https://github.com/apollographql/apollo-client/issues"
      },
      "homepage": "https://github.com/apollographql/apollo-client#readme",
      "scripts": {
        "coverage": "jest --coverage",
        "test": "jest",
        "lint": "tslint --type-check -p tsconfig.json src/*.ts",
        "prebuild": "npm run clean",
        "build": "tsc -p .",
        "watch": "tsc -w -p .",
        "clean": "rimraf coverage/* && rimraf lib/*",
        "prepublishOnly": "npm run build",
        "build:browser": "browserify ./lib/index.js --i apollo-cache-core --i apollo-utilities -o=./lib/bundle.js && npm run minify:browser",
        "minify:browser": "uglifyjs -c -m -o ./lib/bundle.min.js -- ./lib/bundle.js",
        "filesize": "npm run build:browser"
      },
      "dependencies": {
        "apollo-cache-core": "^0.2.0-alpha.3",
        "apollo-utilities": "^0.2.0-alpha.3",
        "graphql-anywhere": "^4.0.0-alpha.3"
      },
      "devDependencies": {
        "@types/graphql": "~0.9.0",
        "@types/jest": "^20.0.7",
        "@types/lodash": "^4.14.72",
        "browserify": "^14.4.0",
        "graphql": "^0.10.3",
        "graphql-tag": "^2.4.2",
        "jest": "^20.0.4",
        "lodash": "^4.17.4",
        "rimraf": "^2.5.4",
        "ts-jest": "^20.0.10",
        "tslint": "^5.0.0",
        "typescript": "^2.2.1",
        "uglifyjs": "^2.4.11"
      },
      "jest": {
        "transform": {
          ".(ts|tsx)": "<rootDir>/node_modules/ts-jest/preprocessor.js"
        },
        "testRegex": "(/__tests__/.*|\\.(test|spec))\\.(ts|tsx|js)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "json"
        ]
      },
      "_id": "apollo-cache-inmemory@0.2.0-alpha.3",
      "_npmVersion": "5.4.0",
      "_nodeVersion": "8.1.2",
      "_npmUser": {
        "name": "jbaxleyiii",
        "email": "james@meteor.com"
      },
      "dist": {
        "integrity": "sha512-AkkCdpxeLwKjA9lyj7TOn8QRph8TSGGhxZaKZBD3dp/6l3MnGlPsc4+z5C8hn/C7mUPF67JFKcuatHcDty8aPg==",
        "shasum": "0bb8714a68e99f3a5aae8b3395203d6e6f04053d",
        "tarball": "https://registry.npmjs.org/apollo-cache-inmemory/-/apollo-cache-inmemory-0.2.0-alpha.3.tgz",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEQCIA3sz+FIqtkV6CmAmLWX9rzcSGJB8mygE783jhl8HgYVAiAQHF4M/ZNzRSOLWxfnDoogqeW8iNOAbI2nNqjbCpzjPQ=="
          }
        ]
      },
      "maintainers": [
        {
          "name": "jbaxleyiii",
          "email": "james@meteor.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/apollo-cache-inmemory-0.2.0-alpha.3.tgz_1504625988873_0.2251863032579422"
      },
      "directories": {}
    },
    "0.2.0-alpha.4": {
      "name": "apollo-cache-inmemory",
      "version": "0.2.0-alpha.4",
      "description": "Core abstract of Caching layer for Apollo Client",
      "author": {
        "name": "James Baxley",
        "email": "james@meteor.com"
      },
      "contributors": [
        {
          "name": "James Baxley",
          "email": "james@meteor.com"
        },
        {
          "name": "Jonas Helfer",
          "email": "jonas@helfer.email"
        },
        {
          "name": "Sashko Stubailo",
          "email": "sashko@stubailo.com"
        }
      ],
      "license": "MIT",
      "main": "./lib/index.js",
      "typings": "./lib/index.d.ts",
      "repository": {
        "type": "git",
        "url": "git+https://github.com/apollographql/apollo-client.git"
      },
      "bugs": {
        "url": "https://github.com/apollographql/apollo-client/issues"
      },
      "homepage": "https://github.com/apollographql/apollo-client#readme",
      "scripts": {
        "coverage": "jest --coverage",
        "test": "jest",
        "lint": "tslint --type-check -p tsconfig.json src/*.ts",
        "prebuild": "npm run clean",
        "build": "tsc -p .",
        "watch": "tsc -w -p .",
        "clean": "rimraf coverage/* && rimraf lib/*",
        "prepublishOnly": "npm run build",
        "build:browser": "browserify ./lib/index.js --i apollo-cache-core --i apollo-utilities -o=./lib/bundle.js && npm run minify:browser",
        "minify:browser": "uglifyjs -c -m -o ./lib/bundle.min.js -- ./lib/bundle.js",
        "filesize": "npm run build:browser"
      },
      "dependencies": {
        "apollo-cache-core": "^0.2.0-alpha.4",
        "apollo-utilities": "^0.2.0-alpha.4",
        "graphql-anywhere": "^4.0.0-alpha.4"
      },
      "devDependencies": {
        "@types/graphql": "~0.9.0",
        "@types/jest": "^20.0.7",
        "@types/lodash": "^4.14.72",
        "browserify": "^14.4.0",
        "graphql": "^0.10.3",
        "graphql-tag": "^2.4.2",
        "jest": "^20.0.4",
        "lodash": "^4.17.4",
        "rimraf": "^2.5.4",
        "ts-jest": "^20.0.10",
        "tslint": "^5.0.0",
        "typescript": "^2.2.1",
        "uglifyjs": "^2.4.11"
      },
      "jest": {
        "transform": {
          ".(ts|tsx)": "<rootDir>/node_modules/ts-jest/preprocessor.js"
        },
        "testRegex": "(/__tests__/.*|\\.(test|spec))\\.(ts|tsx|js)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "json"
        ]
      },
      "_id": "apollo-cache-inmemory@0.2.0-alpha.4",
      "_npmVersion": "5.4.0",
      "_nodeVersion": "8.1.2",
      "_npmUser": {
        "name": "jbaxleyiii",
        "email": "james@meteor.com"
      },
      "dist": {
        "integrity": "sha512-iKbZ6mX/KrDBDdJpkDj5AhajjMzm2K1jM1ViIfeGXfqy8L/AVhvW92G3gavJTuGl/yfTLLDEvkgbsSZzEe2JVg==",
        "shasum": "7cec33a389d87d83f5ef6a52cb40ad4812379a8f",
        "tarball": "https://registry.npmjs.org/apollo-cache-inmemory/-/apollo-cache-inmemory-0.2.0-alpha.4.tgz",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEQCIDzuSPhrf2QPp51f5CAyo95TPJysL80VWMFDNfwB+rS3AiB4ez2gjslpAFrxL7+DIGvVC/oXZk99qD0ZZekmqbQWSg=="
          }
        ]
      },
      "maintainers": [
        {
          "name": "jbaxleyiii",
          "email": "james@meteor.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/apollo-cache-inmemory-0.2.0-alpha.4.tgz_1504755863707_0.39792304672300816"
      },
      "directories": {}
    },
    "0.2.0-alpha.5": {
      "name": "apollo-cache-inmemory",
      "version": "0.2.0-alpha.5",
      "description": "Core abstract of Caching layer for Apollo Client",
      "author": {
        "name": "James Baxley",
        "email": "james@meteor.com"
      },
      "contributors": [
        {
          "name": "James Baxley",
          "email": "james@meteor.com"
        },
        {
          "name": "Jonas Helfer",
          "email": "jonas@helfer.email"
        },
        {
          "name": "Sashko Stubailo",
          "email": "sashko@stubailo.com"
        }
      ],
      "license": "MIT",
      "main": "./lib/index.js",
      "typings": "./lib/index.d.ts",
      "repository": {
        "type": "git",
        "url": "git+https://github.com/apollographql/apollo-client.git"
      },
      "bugs": {
        "url": "https://github.com/apollographql/apollo-client/issues"
      },
      "homepage": "https://github.com/apollographql/apollo-client#readme",
      "scripts": {
        "coverage": "jest --coverage",
        "test": "jest",
        "lint": "tslint --type-check -p tsconfig.json src/*.ts",
        "prebuild": "npm run clean",
        "build": "tsc -p .",
        "watch": "tsc -w -p .",
        "clean": "rimraf coverage/* && rimraf lib/*",
        "prepublishOnly": "npm run build",
        "build:browser": "browserify ./lib/index.js --i apollo-cache-core --i apollo-utilities -o=./lib/bundle.js && npm run minify:browser",
        "minify:browser": "uglifyjs -c -m -o ./lib/bundle.min.js -- ./lib/bundle.js",
        "filesize": "npm run build:browser"
      },
      "dependencies": {
        "apollo-cache-core": "^0.2.0-alpha.5",
        "apollo-utilities": "^0.2.0-alpha.5",
        "graphql-anywhere": "^4.0.0-alpha.5"
      },
      "devDependencies": {
        "@types/graphql": "~0.9.0",
        "@types/jest": "^20.0.7",
        "@types/lodash": "^4.14.72",
        "browserify": "^14.4.0",
        "graphql": "^0.10.3",
        "graphql-tag": "^2.4.2",
        "jest": "^20.0.4",
        "lodash": "^4.17.4",
        "rimraf": "^2.5.4",
        "ts-jest": "^20.0.10",
        "tslint": "^5.0.0",
        "typescript": "^2.2.1",
        "uglifyjs": "^2.4.11"
      },
      "jest": {
        "transform": {
          ".(ts|tsx)": "<rootDir>/node_modules/ts-jest/preprocessor.js"
        },
        "testRegex": "(/__tests__/.*|\\.(test|spec))\\.(ts|tsx|js)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "json"
        ]
      },
      "_id": "apollo-cache-inmemory@0.2.0-alpha.5",
      "_npmVersion": "5.4.0",
      "_nodeVersion": "8.1.2",
      "_npmUser": {
        "name": "jbaxleyiii",
        "email": "james@meteor.com"
      },
      "dist": {
        "integrity": "sha512-/fdhEg3d0paIwjeJbXg75AGGOJ4tqYmOEA9i6EaM0jsspQFXRbmGD3lPhd60ZbNNGFD0hkJ6yPwl1rftdkZPpQ==",
        "shasum": "50c2bb3d4640f12c78458f31825334c132863ba0",
        "tarball": "https://registry.npmjs.org/apollo-cache-inmemory/-/apollo-cache-inmemory-0.2.0-alpha.5.tgz",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIE3nCZ2zVAoH8CNsKULoplvSyxfUM1KQ7nQN3Gw8gVfJAiEAypGkrP2MnMedLLOyXr5fAWOX3Uj4tbQU3/d1J40z5QM="
          }
        ]
      },
      "maintainers": [
        {
          "name": "jbaxleyiii",
          "email": "james@meteor.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/apollo-cache-inmemory-0.2.0-alpha.5.tgz_1504844698897_0.23297822521999478"
      },
      "directories": {}
    },
    "0.2.0-alpha.6": {
      "name": "apollo-cache-inmemory",
      "version": "0.2.0-alpha.6",
      "description": "Core abstract of Caching layer for Apollo Client",
      "author": {
        "name": "James Baxley",
        "email": "james@meteor.com"
      },
      "contributors": [
        {
          "name": "James Baxley",
          "email": "james@meteor.com"
        },
        {
          "name": "Jonas Helfer",
          "email": "jonas@helfer.email"
        },
        {
          "name": "Sashko Stubailo",
          "email": "sashko@stubailo.com"
        }
      ],
      "license": "MIT",
      "main": "./lib/index.js",
      "typings": "./lib/index.d.ts",
      "repository": {
        "type": "git",
        "url": "git+https://github.com/apollographql/apollo-client.git"
      },
      "bugs": {
        "url": "https://github.com/apollographql/apollo-client/issues"
      },
      "homepage": "https://github.com/apollographql/apollo-client#readme",
      "scripts": {
        "coverage": "jest --coverage",
        "test": "jest",
        "lint": "tslint --type-check -p tsconfig.json src/*.ts",
        "prebuild": "npm run clean",
        "build": "tsc -p .",
        "watch": "tsc -w -p .",
        "clean": "rimraf coverage/* && rimraf lib/*",
        "prepublishOnly": "npm run build",
        "build:browser": "browserify ./lib/index.js --i apollo-cache-core --i apollo-utilities -o=./lib/bundle.js && npm run minify:browser",
        "minify:browser": "uglifyjs -c -m -o ./lib/bundle.min.js -- ./lib/bundle.js",
        "filesize": "npm run build:browser"
      },
      "dependencies": {
        "apollo-cache-core": "^0.2.0-alpha.6",
        "apollo-utilities": "^0.2.0-alpha.6",
        "graphql-anywhere": "^4.0.0-alpha.6"
      },
      "devDependencies": {
        "@types/graphql": "~0.9.0",
        "@types/jest": "^20.0.7",
        "@types/lodash": "^4.14.72",
        "browserify": "^14.4.0",
        "graphql": "^0.10.3",
        "graphql-tag": "^2.4.2",
        "jest": "^20.0.4",
        "lodash": "^4.17.4",
        "rimraf": "^2.5.4",
        "ts-jest": "^20.0.10",
        "tslint": "^5.0.0",
        "typescript": "^2.2.1",
        "uglifyjs": "^2.4.11"
      },
      "jest": {
        "transform": {
          ".(ts|tsx)": "<rootDir>/node_modules/ts-jest/preprocessor.js"
        },
        "testRegex": "(/__tests__/.*|\\.(test|spec))\\.(ts|tsx|js)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "json"
        ]
      },
      "_id": "apollo-cache-inmemory@0.2.0-alpha.6",
      "_npmVersion": "5.4.0",
      "_nodeVersion": "8.1.2",
      "_npmUser": {
        "name": "jbaxleyiii",
        "email": "james@meteor.com"
      },
      "dist": {
        "integrity": "sha512-2yZnTm9bO7d4hvom1gyB9+QDZQgDxuQYtUH3xvpSoxnevKkqKcPYiRVkZCawSgzlx6zuZxjlglwnDmx9kuGEng==",
        "shasum": "0841ceba21f0d9791078f1c131ce5a4aac29794c",
        "tarball": "https://registry.npmjs.org/apollo-cache-inmemory/-/apollo-cache-inmemory-0.2.0-alpha.6.tgz",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIQDlcbNr9gTvpnVOgKpF8iKHPUxyuFuZu8SgtRbhihYMNgIgYXHYT31RmhS5yWYtZ6lKt7qaEK9m0H1fsQPpThO6M5o="
          }
        ]
      },
      "maintainers": [
        {
          "name": "jbaxleyiii",
          "email": "james@meteor.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/apollo-cache-inmemory-0.2.0-alpha.6.tgz_1504892018333_0.8135969990398735"
      },
      "directories": {}
    },
    "0.2.0-alpha.7": {
      "name": "apollo-cache-inmemory",
      "version": "0.2.0-alpha.7",
      "description": "Core abstract of Caching layer for Apollo Client",
      "author": {
        "name": "James Baxley",
        "email": "james@meteor.com"
      },
      "contributors": [
        {
          "name": "James Baxley",
          "email": "james@meteor.com"
        },
        {
          "name": "Jonas Helfer",
          "email": "jonas@helfer.email"
        },
        {
          "name": "Sashko Stubailo",
          "email": "sashko@stubailo.com"
        }
      ],
      "license": "MIT",
      "main": "./lib/index.js",
      "typings": "./lib/index.d.ts",
      "repository": {
        "type": "git",
        "url": "git+https://github.com/apollographql/apollo-client.git"
      },
      "bugs": {
        "url": "https://github.com/apollographql/apollo-client/issues"
      },
      "homepage": "https://github.com/apollographql/apollo-client#readme",
      "scripts": {
        "coverage": "jest --coverage",
        "test": "jest",
        "lint": "tslint --type-check -p tsconfig.json src/*.ts",
        "prebuild": "npm run clean",
        "build": "tsc -p .",
        "watch": "tsc -w -p .",
        "clean": "rimraf coverage/* && rimraf lib/*",
        "prepublishOnly": "npm run build",
        "build:browser": "browserify ./lib/index.js --i apollo-cache-core --i apollo-utilities -o=./lib/bundle.js && npm run minify:browser",
        "minify:browser": "uglifyjs -c -m -o ./lib/bundle.min.js -- ./lib/bundle.js",
        "filesize": "npm run build:browser"
      },
      "dependencies": {
        "apollo-cache-core": "^0.2.0-alpha.7",
        "apollo-utilities": "^0.2.0-alpha.6",
        "graphql-anywhere": "^4.0.0-alpha.6"
      },
      "devDependencies": {
        "@types/graphql": "~0.9.0",
        "@types/jest": "^20.0.7",
        "@types/lodash": "^4.14.72",
        "browserify": "^14.4.0",
        "graphql": "^0.10.3",
        "graphql-tag": "^2.4.2",
        "jest": "^20.0.4",
        "lodash": "^4.17.4",
        "rimraf": "^2.5.4",
        "ts-jest": "^20.0.10",
        "tslint": "^5.0.0",
        "typescript": "^2.2.1",
        "uglifyjs": "^2.4.11"
      },
      "jest": {
        "transform": {
          ".(ts|tsx)": "<rootDir>/node_modules/ts-jest/preprocessor.js"
        },
        "testRegex": "(/__tests__/.*|\\.(test|spec))\\.(ts|tsx|js)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "json"
        ]
      },
      "_id": "apollo-cache-inmemory@0.2.0-alpha.7",
      "_npmVersion": "5.4.0",
      "_nodeVersion": "8.1.2",
      "_npmUser": {
        "name": "jbaxleyiii",
        "email": "james@meteor.com"
      },
      "dist": {
        "integrity": "sha512-s0NdNNLSCEJbizUiKzi8w3WGTW86VwXh0lRXFZgUr+nOQvXNJhqPwjwAl2zmZCKmVj2fmX0iS3PBqyTcyPb83w==",
        "shasum": "818f4750c614e6b5707e603c5e8e92b5345f1139",
        "tarball": "https://registry.npmjs.org/apollo-cache-inmemory/-/apollo-cache-inmemory-0.2.0-alpha.7.tgz",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIQCFkFDZNwb2DimH8L2nWzQQMp5ulqOodYCY7mQLGQpNswIgOh17DGHPljQSTtSfpepkNuzaOSR+9qbu2DEzSjNuRBI="
          }
        ]
      },
      "maintainers": [
        {
          "name": "jbaxleyiii",
          "email": "james@meteor.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/apollo-cache-inmemory-0.2.0-alpha.7.tgz_1504917025936_0.9454611062537879"
      },
      "directories": {}
    },
    "0.2.0-alpha.8": {
      "name": "apollo-cache-inmemory",
      "version": "0.2.0-alpha.8",
      "description": "Core abstract of Caching layer for Apollo Client",
      "author": {
        "name": "James Baxley",
        "email": "james@meteor.com"
      },
      "contributors": [
        {
          "name": "James Baxley",
          "email": "james@meteor.com"
        },
        {
          "name": "Jonas Helfer",
          "email": "jonas@helfer.email"
        },
        {
          "name": "Sashko Stubailo",
          "email": "sashko@stubailo.com"
        }
      ],
      "license": "MIT",
      "main": "./lib/index.js",
      "typings": "./lib/index.d.ts",
      "repository": {
        "type": "git",
        "url": "git+https://github.com/apollographql/apollo-client.git"
      },
      "bugs": {
        "url": "https://github.com/apollographql/apollo-client/issues"
      },
      "homepage": "https://github.com/apollographql/apollo-client#readme",
      "scripts": {
        "coverage": "jest --coverage",
        "test": "jest",
        "lint": "tslint --type-check -p tsconfig.json src/*.ts",
        "prebuild": "npm run clean",
        "build": "tsc -p .",
        "watch": "tsc -w -p .",
        "clean": "rimraf coverage/* && rimraf lib/*",
        "prepublishOnly": "npm run build",
        "build:browser": "browserify ./lib/index.js --i apollo-cache-core --i apollo-utilities -o=./lib/bundle.js && npm run minify:browser",
        "minify:browser": "uglifyjs -c -m -o ./lib/bundle.min.js -- ./lib/bundle.js",
        "filesize": "npm run build:browser"
      },
      "dependencies": {
        "apollo-cache-core": "^0.2.0-alpha.8",
        "apollo-utilities": "^0.2.0-alpha.6",
        "graphql-anywhere": "^4.0.0-alpha.6"
      },
      "devDependencies": {
        "@types/graphql": "~0.9.0",
        "@types/jest": "^20.0.7",
        "@types/lodash": "^4.14.72",
        "browserify": "^14.4.0",
        "graphql": "^0.10.3",
        "graphql-tag": "^2.4.2",
        "jest": "^20.0.4",
        "lodash": "^4.17.4",
        "rimraf": "^2.5.4",
        "ts-jest": "^20.0.10",
        "tslint": "^5.0.0",
        "typescript": "^2.2.1",
        "uglifyjs": "^2.4.11"
      },
      "jest": {
        "transform": {
          ".(ts|tsx)": "<rootDir>/node_modules/ts-jest/preprocessor.js"
        },
        "testRegex": "(/__tests__/.*|\\.(test|spec))\\.(ts|tsx|js)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "json"
        ]
      },
      "_id": "apollo-cache-inmemory@0.2.0-alpha.8",
      "_npmVersion": "5.4.0",
      "_nodeVersion": "8.1.2",
      "_npmUser": {
        "name": "jbaxleyiii",
        "email": "james@meteor.com"
      },
      "dist": {
        "integrity": "sha512-VPyYg8ACEL6g9R11KH+mGBYk+pAdlIE8alWnvc9KGTqjuPmRl66pZnlunsDVVuN2XHqHBatxkMzDskTYrlcEsg==",
        "shasum": "591010ee479e012c3282bb641db85bf5af37d77b",
        "tarball": "https://registry.npmjs.org/apollo-cache-inmemory/-/apollo-cache-inmemory-0.2.0-alpha.8.tgz",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIQCiyOu3GAIaSFvyQ00tKSDDlZmVI04XWL+VBo9Dihl8VAIgPyUqqGqvsz+WDTzvnq0884FCAwAOGBVAK4DBJl1AW5M="
          }
        ]
      },
      "maintainers": [
        {
          "name": "jbaxleyiii",
          "email": "james@meteor.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/apollo-cache-inmemory-0.2.0-alpha.8.tgz_1505184609188_0.17991352220997214"
      },
      "directories": {}
    },
    "0.2.0-alpha.9": {
      "name": "apollo-cache-inmemory",
      "version": "0.2.0-alpha.9",
      "description": "Core abstract of Caching layer for Apollo Client",
      "author": {
        "name": "James Baxley",
        "email": "james@meteor.com"
      },
      "contributors": [
        {
          "name": "James Baxley",
          "email": "james@meteor.com"
        },
        {
          "name": "Jonas Helfer",
          "email": "jonas@helfer.email"
        },
        {
          "name": "Sashko Stubailo",
          "email": "sashko@stubailo.com"
        }
      ],
      "license": "MIT",
      "main": "./lib/index.js",
      "typings": "./lib/index.d.ts",
      "repository": {
        "type": "git",
        "url": "git+https://github.com/apollographql/apollo-client.git"
      },
      "bugs": {
        "url": "https://github.com/apollographql/apollo-client/issues"
      },
      "homepage": "https://github.com/apollographql/apollo-client#readme",
      "scripts": {
        "coverage": "jest --coverage",
        "test": "jest",
        "lint": "tslint --type-check -p tsconfig.json src/*.ts",
        "prebuild": "npm run clean",
        "build": "tsc -p .",
        "watch": "tsc -w -p .",
        "clean": "rimraf coverage/* && rimraf lib/*",
        "prepublishOnly": "npm run build",
        "build:browser": "browserify ./lib/index.js --i apollo-cache-core --i apollo-utilities -o=./lib/bundle.js && npm run minify:browser",
        "minify:browser": "uglifyjs -c -m -o ./lib/bundle.min.js -- ./lib/bundle.js",
        "filesize": "npm run build:browser"
      },
      "dependencies": {
        "apollo-cache-core": "^0.2.0-alpha.9",
        "apollo-utilities": "^0.2.0-alpha.6",
        "graphql-anywhere": "^4.0.0-alpha.6"
      },
      "devDependencies": {
        "@types/graphql": "~0.9.0",
        "@types/jest": "^20.0.7",
        "@types/lodash": "^4.14.72",
        "browserify": "^14.4.0",
        "graphql": "^0.10.3",
        "graphql-tag": "^2.4.2",
        "jest": "^20.0.4",
        "lodash": "^4.17.4",
        "rimraf": "^2.5.4",
        "ts-jest": "^20.0.10",
        "tslint": "^5.0.0",
        "typescript": "^2.2.1",
        "uglifyjs": "^2.4.11"
      },
      "jest": {
        "transform": {
          ".(ts|tsx)": "<rootDir>/node_modules/ts-jest/preprocessor.js"
        },
        "testRegex": "(/__tests__/.*|\\.(test|spec))\\.(ts|tsx|js)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "json"
        ]
      },
      "_id": "apollo-cache-inmemory@0.2.0-alpha.9",
      "_npmVersion": "5.4.0",
      "_nodeVersion": "8.1.2",
      "_npmUser": {
        "name": "jbaxleyiii",
        "email": "james@meteor.com"
      },
      "dist": {
        "integrity": "sha512-QWJLC/xWDuNgBtdHFrT/ycMsfgn8VYGT8FA1iy4HR5LSrTBjRSyhPP2TkBLqZr4F3E91PxiS4l5nQgGpMzyh8g==",
        "shasum": "e937f2bc904084f4b06e3d04fe5bd4a7fb1ac40e",
        "tarball": "https://registry.npmjs.org/apollo-cache-inmemory/-/apollo-cache-inmemory-0.2.0-alpha.9.tgz",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIHWvJmqNaSdaCEKN5gCa09tz2jyiDMx+3wc+EaKDhElGAiEA8Yo4SbjcQJMhT2jl+ppo51azmdD1kq7S+HHkmVgU0TA="
          }
        ]
      },
      "maintainers": [
        {
          "name": "jbaxleyiii",
          "email": "james@meteor.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/apollo-cache-inmemory-0.2.0-alpha.9.tgz_1505189258869_0.9961695889942348"
      },
      "directories": {}
    },
    "0.2.0-alpha.12": {
      "name": "apollo-cache-inmemory",
      "version": "0.2.0-alpha.12",
      "description": "Core abstract of Caching layer for Apollo Client",
      "author": {
        "name": "James Baxley",
        "email": "james@meteor.com"
      },
      "contributors": [
        {
          "name": "James Baxley",
          "email": "james@meteor.com"
        },
        {
          "name": "Jonas Helfer",
          "email": "jonas@helfer.email"
        },
        {
          "name": "Sashko Stubailo",
          "email": "sashko@stubailo.com"
        }
      ],
      "license": "MIT",
      "main": "./lib/index.js",
      "typings": "./lib/index.d.ts",
      "repository": {
        "type": "git",
        "url": "git+https://github.com/apollographql/apollo-client.git"
      },
      "bugs": {
        "url": "https://github.com/apollographql/apollo-client/issues"
      },
      "homepage": "https://github.com/apollographql/apollo-client#readme",
      "scripts": {
        "coverage": "jest --coverage",
        "test": "jest",
        "lint": "tslint --type-check -p tsconfig.json src/*.ts",
        "prebuild": "npm run clean",
        "build": "tsc -p .",
        "watch": "tsc -w -p .",
        "clean": "rimraf coverage/* && rimraf lib/*",
        "prepublishOnly": "npm run build",
        "build:browser": "browserify ./lib/index.js --i apollo-cache-core --i apollo-utilities -o=./lib/bundle.js && npm run minify:browser",
        "minify:browser": "uglifyjs -c -m -o ./lib/bundle.min.js -- ./lib/bundle.js",
        "filesize": "npm run build:browser"
      },
      "dependencies": {
        "apollo-cache": "^0.2.0-alpha.12",
        "apollo-utilities": "^0.2.0-alpha.6",
        "graphql-anywhere": "^4.0.0-alpha.6"
      },
      "devDependencies": {
        "@types/graphql": "~0.9.0",
        "@types/jest": "^20.0.7",
        "@types/lodash": "^4.14.72",
        "browserify": "^14.4.0",
        "graphql": "^0.10.3",
        "graphql-tag": "^2.4.2",
        "jest": "^20.0.4",
        "lodash": "^4.17.4",
        "rimraf": "^2.5.4",
        "ts-jest": "^20.0.10",
        "tslint": "^5.0.0",
        "typescript": "^2.2.1",
        "uglifyjs": "^2.4.11"
      },
      "jest": {
        "transform": {
          ".(ts|tsx)": "<rootDir>/node_modules/ts-jest/preprocessor.js"
        },
        "testRegex": "(/__tests__/.*|\\.(test|spec))\\.(ts|tsx|js)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "json"
        ]
      },
      "_id": "apollo-cache-inmemory@0.2.0-alpha.12",
      "_npmVersion": "5.4.0",
      "_nodeVersion": "8.1.2",
      "_npmUser": {
        "name": "jbaxleyiii",
        "email": "james@meteor.com"
      },
      "dist": {
        "integrity": "sha512-L/7d4OKlEZBaBHKdpXBYSeM9YC7NEBTuyKshn9i1qeJ1et19xYkMSit1CESXQ9MO/Yl3KaNdJIlA2/ZcckYFCQ==",
        "shasum": "913ce88b66ab6ab8956276852bad295dc3ba3cca",
        "tarball": "https://registry.npmjs.org/apollo-cache-inmemory/-/apollo-cache-inmemory-0.2.0-alpha.12.tgz",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIF3Et84+ZjaWW/8fElCLm49r/Bg3NPKxQRRoM23nxvAKAiEA+OXixrclSkBV3NbV4OgV+pXKUjxj8DQFkxeyAG7BdHg="
          }
        ]
      },
      "maintainers": [
        {
          "name": "jbaxleyiii",
          "email": "james@meteor.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/apollo-cache-inmemory-0.2.0-alpha.12.tgz_1505232237312_0.8824243964627385"
      },
      "directories": {}
    },
    "0.2.0-alpha.13": {
      "name": "apollo-cache-inmemory",
      "version": "0.2.0-alpha.13",
      "description": "Core abstract of Caching layer for Apollo Client",
      "author": {
        "name": "James Baxley",
        "email": "james@meteor.com"
      },
      "contributors": [
        {
          "name": "James Baxley",
          "email": "james@meteor.com"
        },
        {
          "name": "Jonas Helfer",
          "email": "jonas@helfer.email"
        },
        {
          "name": "Sashko Stubailo",
          "email": "sashko@stubailo.com"
        }
      ],
      "license": "MIT",
      "main": "./lib/index.js",
      "typings": "./lib/index.d.ts",
      "repository": {
        "type": "git",
        "url": "git+https://github.com/apollographql/apollo-client.git"
      },
      "bugs": {
        "url": "https://github.com/apollographql/apollo-client/issues"
      },
      "homepage": "https://github.com/apollographql/apollo-client#readme",
      "scripts": {
        "coverage": "jest --coverage",
        "test": "jest",
        "lint": "tslint --type-check -p tsconfig.json src/*.ts",
        "prebuild": "npm run clean",
        "build": "tsc -p .",
        "watch": "tsc -w -p .",
        "clean": "rimraf coverage/* && rimraf lib/*",
        "prepublishOnly": "npm run build",
        "build:browser": "browserify ./lib/index.js --i apollo-cache-core --i apollo-utilities -o=./lib/bundle.js && npm run minify:browser",
        "minify:browser": "uglifyjs -c -m -o ./lib/bundle.min.js -- ./lib/bundle.js",
        "filesize": "npm run build:browser"
      },
      "dependencies": {
        "apollo-cache": "^0.2.0-alpha.13",
        "apollo-utilities": "^0.2.0-alpha.6",
        "graphql-anywhere": "^4.0.0-alpha.6"
      },
      "devDependencies": {
        "@types/graphql": "~0.9.0",
        "@types/jest": "^20.0.7",
        "@types/lodash": "^4.14.72",
        "browserify": "^14.4.0",
        "graphql": "^0.10.3",
        "graphql-tag": "^2.4.2",
        "jest": "^20.0.4",
        "lodash": "^4.17.4",
        "rimraf": "^2.5.4",
        "ts-jest": "^20.0.10",
        "tslint": "^5.0.0",
        "typescript": "^2.2.1",
        "uglifyjs": "^2.4.11"
      },
      "jest": {
        "transform": {
          ".(ts|tsx)": "<rootDir>/node_modules/ts-jest/preprocessor.js"
        },
        "testRegex": "(/__tests__/.*|\\.(test|spec))\\.(ts|tsx|js)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "json"
        ]
      },
      "_id": "apollo-cache-inmemory@0.2.0-alpha.13",
      "_npmVersion": "5.4.0",
      "_nodeVersion": "8.1.2",
      "_npmUser": {
        "name": "jbaxleyiii",
        "email": "james@meteor.com"
      },
      "dist": {
        "integrity": "sha512-qQ9wPVuEWyKKaOimUlehYh3fm4xtHzeBvOvghiEUK7pg5s6QIj3vFCqJ90FAnPyZOsTkDEr34YeF0B/mtnhEcw==",
        "shasum": "44b79e9be202eb8e41c2431fd34ae7ac77982173",
        "tarball": "https://registry.npmjs.org/apollo-cache-inmemory/-/apollo-cache-inmemory-0.2.0-alpha.13.tgz",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEYCIQDKIjNh7pYepdSnTEHEH3gKJXdeQklLe5PJoO1yxNMLuQIhANeKzo4G4zyejWDRgP8puJscdqvN6qWyXV7sppI5PZBl"
          }
        ]
      },
      "maintainers": [
        {
          "name": "jbaxleyiii",
          "email": "james@meteor.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/apollo-cache-inmemory-0.2.0-alpha.13.tgz_1505260923912_0.9981227559037507"
      },
      "directories": {}
    },
    "0.2.0-beta.0": {
      "name": "apollo-cache-inmemory",
      "version": "0.2.0-beta.0",
      "description": "Core abstract of Caching layer for Apollo Client",
      "author": {
        "name": "James Baxley",
        "email": "james@meteor.com"
      },
      "contributors": [
        {
          "name": "James Baxley",
          "email": "james@meteor.com"
        },
        {
          "name": "Jonas Helfer",
          "email": "jonas@helfer.email"
        },
        {
          "name": "Sashko Stubailo",
          "email": "sashko@stubailo.com"
        }
      ],
      "license": "MIT",
      "main": "./lib/index.js",
      "typings": "./lib/index.d.ts",
      "repository": {
        "type": "git",
        "url": "git+https://github.com/apollographql/apollo-client.git"
      },
      "bugs": {
        "url": "https://github.com/apollographql/apollo-client/issues"
      },
      "homepage": "https://github.com/apollographql/apollo-client#readme",
      "scripts": {
        "coverage": "jest --coverage",
        "test": "jest",
        "lint": "tslint --type-check -p tsconfig.json src/*.ts",
        "prebuild": "npm run clean",
        "build": "tsc -p .",
        "watch": "tsc -w -p .",
        "clean": "rimraf coverage/* && rimraf lib/*",
        "prepublishOnly": "npm run build",
        "build:browser": "browserify ./lib/index.js --i apollo-cache-core --i apollo-utilities -o=./lib/bundle.js && npm run minify:browser",
        "minify:browser": "uglifyjs -c -m -o ./lib/bundle.min.js -- ./lib/bundle.js",
        "filesize": "npm run build:browser"
      },
      "dependencies": {
        "apollo-cache": "^0.2.0-beta.0",
        "apollo-utilities": "^0.2.0-beta.0",
        "graphql-anywhere": "^4.0.0-beta.0"
      },
      "devDependencies": {
        "@types/graphql": "~0.9.0",
        "@types/jest": "^20.0.7",
        "@types/lodash": "^4.14.72",
        "browserify": "^14.4.0",
        "graphql": "^0.10.3",
        "graphql-tag": "^2.4.2",
        "jest": "^20.0.4",
        "lodash": "^4.17.4",
        "rimraf": "^2.5.4",
        "ts-jest": "^20.0.10",
        "tslint": "^5.0.0",
        "typescript": "^2.2.1",
        "uglifyjs": "^2.4.11"
      },
      "jest": {
        "transform": {
          ".(ts|tsx)": "<rootDir>/node_modules/ts-jest/preprocessor.js"
        },
        "testRegex": "(/__tests__/.*|\\.(test|spec))\\.(ts|tsx|js)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "json"
        ]
      },
      "_id": "apollo-cache-inmemory@0.2.0-beta.0",
      "_npmVersion": "5.4.1",
      "_nodeVersion": "8.1.2",
      "_npmUser": {
        "name": "jbaxleyiii",
        "email": "james@meteor.com"
      },
      "dist": {
        "integrity": "sha512-0ZoMcOqh4ClSgylxzIplSttS/S2c/nOWeP9s23TAl+4lE7VvvQVOR4M3GFVk2ZP28UAKrlw0RPxWTOltbcwJcw==",
        "shasum": "5222423962b20739acc73de45e7fd879a79160a4",
        "tarball": "https://registry.npmjs.org/apollo-cache-inmemory/-/apollo-cache-inmemory-0.2.0-beta.0.tgz",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIQCx6LtnfUJwSxrHOPjlVE4GbCN3HkIFshmBjVAs0jkxPgIgcCYeBaKwClTx+65VoAHBok33z2rKV+OPUGb6wN4k6jM="
          }
        ]
      },
      "maintainers": [
        {
          "name": "jbaxleyiii",
          "email": "james@meteor.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/apollo-cache-inmemory-0.2.0-beta.0.tgz_1505315392136_0.9222807162441313"
      },
      "directories": {}
    },
    "0.2.0-beta.1": {
      "name": "apollo-cache-inmemory",
      "version": "0.2.0-beta.1",
      "description": "Core abstract of Caching layer for Apollo Client",
      "author": {
        "name": "James Baxley",
        "email": "james@meteor.com"
      },
      "contributors": [
        {
          "name": "James Baxley",
          "email": "james@meteor.com"
        },
        {
          "name": "Jonas Helfer",
          "email": "jonas@helfer.email"
        },
        {
          "name": "Sashko Stubailo",
          "email": "sashko@stubailo.com"
        }
      ],
      "license": "MIT",
      "main": "./lib/index.js",
      "typings": "./lib/index.d.ts",
      "repository": {
        "type": "git",
        "url": "git+https://github.com/apollographql/apollo-client.git"
      },
      "bugs": {
        "url": "https://github.com/apollographql/apollo-client/issues"
      },
      "homepage": "https://github.com/apollographql/apollo-client#readme",
      "scripts": {
        "coverage": "jest --coverage",
        "test": "jest",
        "lint": "tslint --type-check -p tsconfig.json src/*.ts",
        "prebuild": "npm run clean",
        "build": "tsc -p .",
        "watch": "tsc -w -p .",
        "clean": "rimraf coverage/* && rimraf lib/*",
        "prepublishOnly": "npm run build",
        "build:browser": "browserify ./lib/index.js --i apollo-cache-core --i apollo-utilities -o=./lib/bundle.js && npm run minify:browser",
        "minify:browser": "uglifyjs -c -m -o ./lib/bundle.min.js -- ./lib/bundle.js",
        "filesize": "npm run build:browser"
      },
      "dependencies": {
        "apollo-cache": "^0.2.0-beta.1",
        "apollo-utilities": "^0.2.0-beta.1",
        "graphql-anywhere": "^4.0.0-beta.1"
      },
      "devDependencies": {
        "@types/graphql": "0.9.4",
        "@types/jest": "20.0.8",
        "@types/lodash": "4.14.74",
        "browserify": "14.4.0",
        "graphql": "0.11.3",
        "graphql-tag": "2.4.2",
        "jest": "20.0.4",
        "lodash": "4.17.4",
        "rimraf": "2.6.2",
        "ts-jest": "20.0.14",
        "tslint": "5.7.0",
        "typescript": "2.5.2",
        "uglifyjs": "2.4.11"
      },
      "jest": {
        "transform": {
          ".(ts|tsx)": "<rootDir>/node_modules/ts-jest/preprocessor.js"
        },
        "testRegex": "(/__tests__/.*|\\.(test|spec))\\.(ts|tsx|js)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "json"
        ]
      },
      "_id": "apollo-cache-inmemory@0.2.0-beta.1",
      "_npmVersion": "5.4.2",
      "_nodeVersion": "8.1.2",
      "_npmUser": {
        "name": "jbaxleyiii",
        "email": "james@meteor.com"
      },
      "dist": {
        "integrity": "sha512-DQLfIFtTqgtECwPsogbNBsb+cZBNJFi3mGc9nHB4rEFnWEAXl3VMk9X74uGutSoKHA1edlwMT8biO4OfBiVovQ==",
        "shasum": "2b4cb9bd25eb8adf439b27ff0c1044f3c2e2baf4",
        "tarball": "https://registry.npmjs.org/apollo-cache-inmemory/-/apollo-cache-inmemory-0.2.0-beta.1.tgz",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIBIdYJ0XPGo2uZg+fimDPMtDxnTDCfEWFvlXoUNx8zvKAiEAovuQVMmRtC05oE9MCapJt3mDITz1TRH289uqx3G5CLI="
          }
        ]
      },
      "maintainers": [
        {
          "name": "jbaxleyiii",
          "email": "james@meteor.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/apollo-cache-inmemory-0.2.0-beta.1.tgz_1505997735472_0.4043287520762533"
      },
      "directories": {}
    },
    "0.2.0-beta.2": {
      "name": "apollo-cache-inmemory",
      "version": "0.2.0-beta.2",
      "description": "Core abstract of Caching layer for Apollo Client",
      "author": {
        "name": "James Baxley",
        "email": "james@meteor.com"
      },
      "contributors": [
        {
          "name": "James Baxley",
          "email": "james@meteor.com"
        },
        {
          "name": "Jonas Helfer",
          "email": "jonas@helfer.email"
        },
        {
          "name": "Sashko Stubailo",
          "email": "sashko@stubailo.com"
        }
      ],
      "license": "MIT",
      "main": "./lib/index.js",
      "typings": "./lib/index.d.ts",
      "repository": {
        "type": "git",
        "url": "git+https://github.com/apollographql/apollo-client.git"
      },
      "bugs": {
        "url": "https://github.com/apollographql/apollo-client/issues"
      },
      "homepage": "https://github.com/apollographql/apollo-client#readme",
      "scripts": {
        "coverage": "jest --coverage",
        "test": "jest",
        "lint": "tslint --type-check -p tsconfig.json src/*.ts",
        "prebuild": "npm run clean",
        "build": "tsc -p .",
        "watch": "tsc -w -p .",
        "clean": "rimraf coverage/* && rimraf lib/*",
        "prepublishOnly": "npm run build",
        "build:browser": "browserify ./lib/index.js --i apollo-cache-core --i apollo-utilities -o=./lib/bundle.js && npm run minify:browser",
        "minify:browser": "uglifyjs -c -m -o ./lib/bundle.min.js -- ./lib/bundle.js",
        "filesize": "npm run build:browser"
      },
      "dependencies": {
        "apollo-cache": "^0.2.0-beta.2",
        "apollo-utilities": "^0.2.0-beta.2",
        "graphql-anywhere": "^4.0.0-beta.2"
      },
      "devDependencies": {
        "@types/graphql": "0.9.4",
        "@types/jest": "21.1.1",
        "@types/lodash": "4.14.76",
        "browserify": "14.4.0",
        "graphql": "0.11.3",
        "graphql-tag": "2.4.2",
        "jest": "20.0.4",
        "lodash": "4.17.4",
        "rimraf": "2.6.2",
        "ts-jest": "20.0.14",
        "tslint": "5.7.0",
        "typescript": "2.5.2",
        "uglifyjs": "2.4.11"
      },
      "jest": {
        "transform": {
          ".(ts|tsx)": "<rootDir>/node_modules/ts-jest/preprocessor.js"
        },
        "testRegex": "(/__tests__/.*|\\.(test|spec))\\.(ts|tsx|js)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "json"
        ]
      },
      "_id": "apollo-cache-inmemory@0.2.0-beta.2",
      "_npmVersion": "5.4.2",
      "_nodeVersion": "8.1.2",
      "_npmUser": {
        "name": "jbaxleyiii",
        "email": "james@meteor.com"
      },
      "dist": {
        "integrity": "sha512-wPuru8odDoeqtM1htJTzkkI24lWBk3bB7O5CbdVp3sk48uea7iv1ty7P5yRJ91FFNGsSN9cSI3XRJZfNA77V6w==",
        "shasum": "f156a6aaa405c7bf728845a063fdf89db35d290e",
        "tarball": "https://registry.npmjs.org/apollo-cache-inmemory/-/apollo-cache-inmemory-0.2.0-beta.2.tgz",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCICUMZkz4juDUcHLbIeXWnp1YfJrnXjYDT/gBmRdLg6n0AiEAsPXF6T+ggoE1m2qeGD5Ow1Yb3ewGEa+ONqQRccg/iu0="
          }
        ]
      },
      "maintainers": [
        {
          "name": "jbaxleyiii",
          "email": "james@meteor.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/apollo-cache-inmemory-0.2.0-beta.2.tgz_1506435047159_0.08617852302268147"
      },
      "directories": {}
    },
    "0.2.0-beta.3": {
      "name": "apollo-cache-inmemory",
      "version": "0.2.0-beta.3",
      "description": "Core abstract of Caching layer for Apollo Client",
      "author": {
        "name": "James Baxley",
        "email": "james@meteor.com"
      },
      "contributors": [
        {
          "name": "James Baxley",
          "email": "james@meteor.com"
        },
        {
          "name": "Jonas Helfer",
          "email": "jonas@helfer.email"
        },
        {
          "name": "Sashko Stubailo",
          "email": "sashko@stubailo.com"
        }
      ],
      "license": "MIT",
      "main": "./lib/index.js",
      "typings": "./lib/index.d.ts",
      "repository": {
        "type": "git",
        "url": "git+https://github.com/apollographql/apollo-client.git"
      },
      "bugs": {
        "url": "https://github.com/apollographql/apollo-client/issues"
      },
      "homepage": "https://github.com/apollographql/apollo-client#readme",
      "scripts": {
        "coverage": "jest --coverage",
        "test": "jest",
        "lint": "tslint --type-check -p tsconfig.json src/*.ts",
        "prebuild": "npm run clean",
        "build": "tsc -p .",
        "watch": "tsc -w -p .",
        "clean": "rimraf coverage/* && rimraf lib/*",
        "prepublishOnly": "npm run build",
        "build:browser": "browserify ./lib/index.js --i apollo-cache-core --i apollo-utilities -o=./lib/bundle.js && npm run minify:browser",
        "minify:browser": "uglifyjs -c -m -o ./lib/bundle.min.js -- ./lib/bundle.js",
        "filesize": "npm run build:browser"
      },
      "dependencies": {
        "apollo-cache": "^0.2.0-beta.2",
        "apollo-utilities": "^0.2.0-beta.2",
        "graphql-anywhere": "^4.0.0-beta.2"
      },
      "devDependencies": {
        "@types/graphql": "0.9.4",
        "@types/jest": "21.1.1",
        "@types/lodash": "4.14.76",
        "browserify": "14.4.0",
        "graphql": "0.11.3",
        "graphql-tag": "2.4.2",
        "jest": "20.0.4",
        "lodash": "4.17.4",
        "rimraf": "2.6.2",
        "ts-jest": "20.0.14",
        "tslint": "5.7.0",
        "typescript": "2.5.2",
        "uglifyjs": "2.4.11"
      },
      "jest": {
        "transform": {
          ".(ts|tsx)": "<rootDir>/node_modules/ts-jest/preprocessor.js"
        },
        "testRegex": "(/__tests__/.*|\\.(test|spec))\\.(ts|tsx|js)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "json"
        ]
      },
      "_id": "apollo-cache-inmemory@0.2.0-beta.3",
      "_npmVersion": "5.4.2",
      "_nodeVersion": "8.1.2",
      "_npmUser": {
        "name": "jbaxleyiii",
        "email": "james@meteor.com"
      },
      "dist": {
        "integrity": "sha512-++FliVi/OXPiAVG2zPebxp99WnOWEibXvEJ2Zq73sZ85jHnVJ9mOGgFMatWio9zFn/jwRwQ/1YAvIRLle7/VOw==",
        "shasum": "7d10d14c6fdc3020a24059bbe9d2a154da91fa72",
        "tarball": "https://registry.npmjs.org/apollo-cache-inmemory/-/apollo-cache-inmemory-0.2.0-beta.3.tgz",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIQCPj0vLFu0l5Vm/eJmEyIUD7WIITAzz78+p36AXxt7TFwIgSbXg+Ydq/ZlZyZdd1ldr1KFA++Q5bwIV7nNTD9qTkDg="
          }
        ]
      },
      "maintainers": [
        {
          "name": "jbaxleyiii",
          "email": "james@meteor.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/apollo-cache-inmemory-0.2.0-beta.3.tgz_1506631728804_0.6419939810875803"
      },
      "directories": {}
    },
    "0.2.0-beta.4": {
      "name": "apollo-cache-inmemory",
      "version": "0.2.0-beta.4",
      "description": "Core abstract of Caching layer for Apollo Client",
      "author": {
        "name": "James Baxley",
        "email": "james@meteor.com"
      },
      "contributors": [
        {
          "name": "James Baxley",
          "email": "james@meteor.com"
        },
        {
          "name": "Jonas Helfer",
          "email": "jonas@helfer.email"
        },
        {
          "name": "Sashko Stubailo",
          "email": "sashko@stubailo.com"
        }
      ],
      "license": "MIT",
      "main": "./lib/index.js",
      "typings": "./lib/index.d.ts",
      "repository": {
        "type": "git",
        "url": "git+https://github.com/apollographql/apollo-client.git"
      },
      "bugs": {
        "url": "https://github.com/apollographql/apollo-client/issues"
      },
      "homepage": "https://github.com/apollographql/apollo-client#readme",
      "scripts": {
        "coverage": "jest --coverage",
        "test": "jest",
        "lint": "tslint --type-check -p tsconfig.json src/*.ts",
        "prebuild": "npm run clean",
        "build": "tsc -p .",
        "watch": "tsc -w -p .",
        "clean": "rimraf coverage/* && rimraf lib/*",
        "prepublishOnly": "npm run build",
        "build:browser": "browserify ./lib/index.js --i apollo-cache-core --i apollo-utilities -o=./lib/bundle.js && npm run minify:browser",
        "minify:browser": "uglifyjs -c -m -o ./lib/bundle.min.js -- ./lib/bundle.js",
        "filesize": "npm run build:browser"
      },
      "dependencies": {
        "apollo-cache": "^0.2.0-beta.2",
        "apollo-utilities": "^0.2.0-beta.2",
        "graphql-anywhere": "^4.0.0-beta.3"
      },
      "devDependencies": {
        "@types/graphql": "0.9.4",
        "@types/jest": "21.1.1",
        "@types/lodash": "4.14.76",
        "browserify": "14.4.0",
        "graphql": "0.11.3",
        "graphql-tag": "2.4.2",
        "jest": "20.0.4",
        "lodash": "4.17.4",
        "rimraf": "2.6.2",
        "ts-jest": "20.0.14",
        "tslint": "5.7.0",
        "typescript": "2.5.2",
        "uglifyjs": "2.4.11"
      },
      "jest": {
        "transform": {
          ".(ts|tsx)": "<rootDir>/node_modules/ts-jest/preprocessor.js"
        },
        "testRegex": "(/__tests__/.*|\\.(test|spec))\\.(ts|tsx|js)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "json"
        ]
      },
      "_id": "apollo-cache-inmemory@0.2.0-beta.4",
      "_npmVersion": "5.4.2",
      "_nodeVersion": "8.1.2",
      "_npmUser": {
        "name": "jbaxleyiii",
        "email": "james@meteor.com"
      },
      "dist": {
        "integrity": "sha512-e/k08+D4axnSVkBPwzQ2i92DuJWloLel2NZUs329G7ZLxETh+B5Q9dZXqvp7rDoIZmfjHmKo+C+Fw34HcANDrA==",
        "shasum": "355c98cebd01cdbd806f3fded013c7fd938453af",
        "tarball": "https://registry.npmjs.org/apollo-cache-inmemory/-/apollo-cache-inmemory-0.2.0-beta.4.tgz",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIQDXecrdMKdeB8eFqcseVe4ofXIFXHBKjhRZa2UOeVa3swIgcQdAF4oZnG4gq5PMkKd+MRkvI4J5QkTQ34nHEjHDgiI="
          }
        ]
      },
      "maintainers": [
        {
          "name": "jbaxleyiii",
          "email": "james@meteor.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/apollo-cache-inmemory-0.2.0-beta.4.tgz_1507056208149_0.881393009563908"
      },
      "directories": {}
    },
    "0.2.0-beta.5": {
      "name": "apollo-cache-inmemory",
      "version": "0.2.0-beta.5",
      "description": "Core abstract of Caching layer for Apollo Client",
      "author": {
        "name": "James Baxley",
        "email": "james@meteor.com"
      },
      "contributors": [
        {
          "name": "James Baxley",
          "email": "james@meteor.com"
        },
        {
          "name": "Jonas Helfer",
          "email": "jonas@helfer.email"
        },
        {
          "name": "Sashko Stubailo",
          "email": "sashko@stubailo.com"
        }
      ],
      "license": "MIT",
      "main": "./lib/index.js",
      "typings": "./lib/index.d.ts",
      "repository": {
        "type": "git",
        "url": "git+https://github.com/apollographql/apollo-client.git"
      },
      "bugs": {
        "url": "https://github.com/apollographql/apollo-client/issues"
      },
      "homepage": "https://github.com/apollographql/apollo-client#readme",
      "scripts": {
        "coverage": "jest --coverage",
        "test": "jest",
        "lint": "tslint --type-check -p tsconfig.json src/*.ts",
        "prebuild": "npm run clean",
        "build": "tsc -p .",
        "watch": "tsc -w -p .",
        "clean": "rimraf coverage/* && rimraf lib/*",
        "prepublishOnly": "npm run build",
        "build:browser": "browserify ./lib/index.js --i apollo-cache-core --i apollo-utilities -o=./lib/bundle.js && npm run minify:browser",
        "minify:browser": "uglifyjs -c -m -o ./lib/bundle.min.js -- ./lib/bundle.js",
        "filesize": "npm run build:browser"
      },
      "dependencies": {
        "apollo-cache": "^0.2.0-beta.3",
        "apollo-utilities": "^0.2.0-beta.3",
        "graphql-anywhere": "^4.0.0-beta.4"
      },
      "devDependencies": {
        "@types/graphql": "0.9.4",
        "@types/jest": "21.1.2",
        "@types/lodash": "4.14.77",
        "browserify": "14.4.0",
        "graphql": "0.11.7",
        "graphql-tag": "2.4.2",
        "jest": "20.0.4",
        "lodash": "4.17.4",
        "rimraf": "2.6.2",
        "ts-jest": "20.0.14",
        "tslint": "5.7.0",
        "typescript": "2.5.2",
        "uglifyjs": "2.4.11"
      },
      "jest": {
        "transform": {
          ".(ts|tsx)": "<rootDir>/node_modules/ts-jest/preprocessor.js"
        },
        "testRegex": "(/__tests__/.*|\\.(test|spec))\\.(ts|tsx|js)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "json"
        ]
      },
      "_id": "apollo-cache-inmemory@0.2.0-beta.5",
      "_npmVersion": "5.4.2",
      "_nodeVersion": "8.1.2",
      "_npmUser": {
        "name": "jbaxleyiii",
        "email": "james@meteor.com"
      },
      "dist": {
        "integrity": "sha512-4mO8G8OKQ196DT97nJxGJt+eBcf9MeVqQWnHVfVXXJFAP6wCF9axPysYrB98kIMbVWcsIVlYl3vOJOE2tM+pNQ==",
        "shasum": "1998c2ea160e355bc71121ce5e1eba3a3400480e",
        "tarball": "https://registry.npmjs.org/apollo-cache-inmemory/-/apollo-cache-inmemory-0.2.0-beta.5.tgz",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEQCIEOzdsSCvbTJzRwyqK7x7yfZYyx9nCHJmvbT1zQQXLUSAiB8XFCs7ktHdtiMWP6MzKVg2nvTHonKTRN57Z8n2xGGDA=="
          }
        ]
      },
      "maintainers": [
        {
          "name": "jbaxleyiii",
          "email": "james@meteor.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/apollo-cache-inmemory-0.2.0-beta.5.tgz_1507687841339_0.4910438018850982"
      },
      "directories": {}
    },
    "0.2.0-beta.6": {
      "name": "apollo-cache-inmemory",
      "version": "0.2.0-beta.6",
      "description": "Core abstract of Caching layer for Apollo Client",
      "author": {
        "name": "James Baxley",
        "email": "james@meteor.com"
      },
      "contributors": [
        {
          "name": "James Baxley",
          "email": "james@meteor.com"
        },
        {
          "name": "Jonas Helfer",
          "email": "jonas@helfer.email"
        },
        {
          "name": "Sashko Stubailo",
          "email": "sashko@stubailo.com"
        }
      ],
      "license": "MIT",
      "main": "./lib/index.js",
      "typings": "./lib/index.d.ts",
      "repository": {
        "type": "git",
        "url": "git+https://github.com/apollographql/apollo-client.git"
      },
      "bugs": {
        "url": "https://github.com/apollographql/apollo-client/issues"
      },
      "homepage": "https://github.com/apollographql/apollo-client#readme",
      "scripts": {
        "coverage": "jest --coverage",
        "test": "jest",
        "lint": "tslint --type-check -p tsconfig.json src/*.ts",
        "prebuild": "npm run clean",
        "build": "tsc -p .",
        "watch": "tsc -w -p .",
        "clean": "rimraf coverage/* && rimraf lib/*",
        "prepublishOnly": "npm run build",
        "build:browser": "browserify ./lib/index.js --i apollo-cache-core --i apollo-utilities -o=./lib/bundle.js && npm run minify:browser",
        "minify:browser": "uglifyjs -c -m -o ./lib/bundle.min.js -- ./lib/bundle.js",
        "filesize": "npm run build:browser"
      },
      "dependencies": {
        "apollo-cache": "^0.2.0-beta.4",
        "apollo-utilities": "^0.2.0-beta.4",
        "graphql-anywhere": "^4.0.0-beta.5"
      },
      "devDependencies": {
        "@types/graphql": "0.9.4",
        "@types/jest": "21.1.2",
        "@types/lodash": "4.14.77",
        "browserify": "14.4.0",
        "graphql": "0.11.7",
        "graphql-tag": "2.4.2",
        "jest": "20.0.4",
        "lodash": "4.17.4",
        "rimraf": "2.6.2",
        "ts-jest": "20.0.14",
        "tslint": "5.7.0",
        "typescript": "2.5.2",
        "uglifyjs": "2.4.11"
      },
      "jest": {
        "transform": {
          ".(ts|tsx)": "<rootDir>/node_modules/ts-jest/preprocessor.js"
        },
        "testRegex": "(/__tests__/.*|\\.(test|spec))\\.(ts|tsx|js)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "json"
        ]
      },
      "_id": "apollo-cache-inmemory@0.2.0-beta.6",
      "_npmVersion": "5.4.2",
      "_nodeVersion": "8.1.2",
      "_npmUser": {
        "name": "jbaxleyiii",
        "email": "james@meteor.com"
      },
      "dist": {
        "integrity": "sha512-WHlR5je4By05LXhcJ0UMgo3vKVbRfPRY9WJW79cd63slmpcNdPWUrCtItX5hMwUj5ywN9cozH+KTMLeslVzlBg==",
        "shasum": "fdaf5abac045f2412936650720ead7c059c0d390",
        "tarball": "https://registry.npmjs.org/apollo-cache-inmemory/-/apollo-cache-inmemory-0.2.0-beta.6.tgz",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEQCID3sNB+2yVLFQAPCT7T2dhxrosa9OF0ntB+UZgZ9i7gzAiA/rglaC1ofKHI7XurbFhbNGBP3d5UbFdfXjY6Vr4EEzw=="
          }
        ]
      },
      "maintainers": [
        {
          "name": "jbaxleyiii",
          "email": "james@meteor.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/apollo-cache-inmemory-0.2.0-beta.6.tgz_1507708880880_0.8590169185772538"
      },
      "directories": {}
    },
    "0.2.0-rc.0": {
      "name": "apollo-cache-inmemory",
      "version": "0.2.0-rc.0",
      "description": "Core abstract of Caching layer for Apollo Client",
      "author": {
        "name": "James Baxley",
        "email": "james@meteor.com"
      },
      "contributors": [
        {
          "name": "James Baxley",
          "email": "james@meteor.com"
        },
        {
          "name": "Jonas Helfer",
          "email": "jonas@helfer.email"
        },
        {
          "name": "Sashko Stubailo",
          "email": "sashko@stubailo.com"
        }
      ],
      "license": "MIT",
      "main": "./lib/index.js",
      "typings": "./lib/index.d.ts",
      "repository": {
        "type": "git",
        "url": "git+https://github.com/apollographql/apollo-client.git"
      },
      "bugs": {
        "url": "https://github.com/apollographql/apollo-client/issues"
      },
      "homepage": "https://github.com/apollographql/apollo-client#readme",
      "scripts": {
        "coverage": "jest --coverage",
        "test": "jest",
        "lint": "tslint --type-check -p tsconfig.json src/*.ts",
        "prebuild": "npm run clean",
        "build": "tsc -p .",
        "watch": "tsc -w -p .",
        "clean": "rimraf coverage/* && rimraf lib/*",
        "prepublishOnly": "npm run build",
        "build:browser": "browserify ./lib/index.js --i apollo-cache-core --i apollo-utilities -o=./lib/bundle.js && npm run minify:browser",
        "minify:browser": "uglifyjs -c -m -o ./lib/bundle.min.js -- ./lib/bundle.js",
        "filesize": "npm run build:browser"
      },
      "dependencies": {
        "apollo-cache": "^0.2.0-rc.0",
        "apollo-utilities": "^0.2.0-rc.0",
        "graphql-anywhere": "^4.0.0-rc.0"
      },
      "devDependencies": {
        "@types/graphql": "0.9.4",
        "@types/jest": "21.1.2",
        "@types/lodash": "4.14.77",
        "browserify": "14.4.0",
        "graphql": "0.11.7",
        "graphql-tag": "2.4.2",
        "jest": "20.0.4",
        "lodash": "4.17.4",
        "rimraf": "2.6.2",
        "ts-jest": "20.0.14",
        "tslint": "5.7.0",
        "typescript": "2.5.2",
        "uglifyjs": "2.4.11"
      },
      "jest": {
        "transform": {
          ".(ts|tsx)": "<rootDir>/node_modules/ts-jest/preprocessor.js"
        },
        "testRegex": "(/__tests__/.*|\\.(test|spec))\\.(ts|tsx|js)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "json"
        ]
      },
      "_id": "apollo-cache-inmemory@0.2.0-rc.0",
      "_npmVersion": "5.4.2",
      "_nodeVersion": "8.1.2",
      "_npmUser": {
        "name": "jbaxleyiii",
        "email": "james@meteor.com"
      },
      "dist": {
        "integrity": "sha512-2O9eq7vGb+anoYTRE1pH4/Rne+0ym46PX/5r9nm5IKMI8dt2imSbxd1V1jNv4AABhnZG/bev9Rc52NNe5dWQ0g==",
        "shasum": "511acdb23e07e4d9d8f5310a75815ce6c28d8c68",
        "tarball": "https://registry.npmjs.org/apollo-cache-inmemory/-/apollo-cache-inmemory-0.2.0-rc.0.tgz",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIQCnPS/RR/RMJCZUZDWKwHK2on/0py6XsXQ3gTFKOQ2MVgIgO9j0VyZJaIR6nRMGBl67Ls4EQlyhgJTzqKtfSStzIRA="
          }
        ]
      },
      "maintainers": [
        {
          "name": "jbaxleyiii",
          "email": "james@meteor.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/apollo-cache-inmemory-0.2.0-rc.0.tgz_1507709408566_0.2980459926184267"
      },
      "directories": {}
    },
    "0.2.0-rc.1": {
      "name": "apollo-cache-inmemory",
      "version": "0.2.0-rc.1",
      "description": "Core abstract of Caching layer for Apollo Client",
      "author": {
        "name": "James Baxley",
        "email": "james@meteor.com"
      },
      "contributors": [
        {
          "name": "James Baxley",
          "email": "james@meteor.com"
        },
        {
          "name": "Jonas Helfer",
          "email": "jonas@helfer.email"
        },
        {
          "name": "Sashko Stubailo",
          "email": "sashko@stubailo.com"
        }
      ],
      "license": "MIT",
      "main": "./lib/index.js",
      "typings": "./lib/index.d.ts",
      "repository": {
        "type": "git",
        "url": "git+https://github.com/apollographql/apollo-client.git"
      },
      "bugs": {
        "url": "https://github.com/apollographql/apollo-client/issues"
      },
      "homepage": "https://github.com/apollographql/apollo-client#readme",
      "scripts": {
        "coverage": "jest --coverage",
        "test": "jest",
        "lint": "tslint --type-check -p tsconfig.json src/*.ts",
        "prebuild": "npm run clean",
        "build": "tsc -p .",
        "watch": "tsc -w -p .",
        "clean": "rimraf coverage/* && rimraf lib/*",
        "prepublishOnly": "npm run build",
        "build:browser": "browserify ./lib/index.js --i apollo-cache-core --i apollo-utilities -o=./lib/bundle.js && npm run minify:browser",
        "minify:browser": "uglifyjs -c -m -o ./lib/bundle.min.js -- ./lib/bundle.js",
        "filesize": "npm run build:browser"
      },
      "dependencies": {
        "apollo-cache": "^0.2.0-rc.0",
        "apollo-utilities": "^0.2.0-rc.0",
        "graphql-anywhere": "^4.0.0-rc.0"
      },
      "devDependencies": {
        "@types/graphql": "0.9.4",
        "@types/jest": "21.1.2",
        "@types/lodash": "4.14.77",
        "browserify": "14.4.0",
        "graphql": "0.11.7",
        "graphql-tag": "2.4.2",
        "jest": "20.0.4",
        "lodash": "4.17.4",
        "rimraf": "2.6.2",
        "ts-jest": "20.0.14",
        "tslint": "5.7.0",
        "typescript": "2.5.2",
        "uglifyjs": "2.4.11"
      },
      "jest": {
        "transform": {
          ".(ts|tsx)": "<rootDir>/node_modules/ts-jest/preprocessor.js"
        },
        "testRegex": "(/__tests__/.*|\\.(test|spec))\\.(ts|tsx|js)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "json"
        ]
      },
      "_id": "apollo-cache-inmemory@0.2.0-rc.1",
      "_npmVersion": "5.5.1",
      "_nodeVersion": "8.1.2",
      "_npmUser": {
        "name": "jbaxleyiii",
        "email": "james@meteor.com"
      },
      "dist": {
        "integrity": "sha512-kNwkCSD0GMInUAEWENt5Kyi717mboTLAqXg3J/03aLcKK7SM+Z6Z8dsU4Z7mxR6H/p7wcXNhdzv2tn5+UMiv3A==",
        "shasum": "7690d1bb31b2591e10009e7b662096c14f14440f",
        "tarball": "https://registry.npmjs.org/apollo-cache-inmemory/-/apollo-cache-inmemory-0.2.0-rc.1.tgz",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIQCRcWLpJ4ECc3DVRQ221XeSU8/2gh/fA2XgUqglgJzf2gIgaegxzVftkvPedA5ucdSTwJQkfczgXM1e0EUFcObo5YI="
          }
        ]
      },
      "maintainers": [
        {
          "name": "jbaxleyiii",
          "email": "james@meteor.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/apollo-cache-inmemory-0.2.0-rc.1.tgz_1507928663873_0.7574682256672531"
      },
      "directories": {}
    },
    "0.2.0-rc.2": {
      "name": "apollo-cache-inmemory",
      "version": "0.2.0-rc.2",
      "description": "Core abstract of Caching layer for Apollo Client",
      "author": {
        "name": "James Baxley",
        "email": "james@meteor.com"
      },
      "contributors": [
        {
          "name": "James Baxley",
          "email": "james@meteor.com"
        },
        {
          "name": "Jonas Helfer",
          "email": "jonas@helfer.email"
        },
        {
          "name": "Sashko Stubailo",
          "email": "sashko@stubailo.com"
        }
      ],
      "license": "MIT",
      "main": "./lib/index.js",
      "typings": "./lib/index.d.ts",
      "repository": {
        "type": "git",
        "url": "git+https://github.com/apollographql/apollo-client.git"
      },
      "bugs": {
        "url": "https://github.com/apollographql/apollo-client/issues"
      },
      "homepage": "https://github.com/apollographql/apollo-client#readme",
      "scripts": {
        "coverage": "jest --coverage",
        "test": "jest",
        "lint": "tslint --type-check -p tsconfig.json src/*.ts",
        "prebuild": "npm run clean",
        "build": "tsc -p .",
        "watch": "tsc -w -p .",
        "clean": "rimraf coverage/* && rimraf lib/*",
        "prepublishOnly": "npm run build",
        "build:browser": "browserify ./lib/index.js --i apollo-cache-core --i apollo-utilities -o=./lib/bundle.js && npm run minify:browser",
        "minify:browser": "uglifyjs -c -m -o ./lib/bundle.min.js -- ./lib/bundle.js",
        "filesize": "npm run build:browser"
      },
      "dependencies": {
        "apollo-cache": "^0.2.0-rc.1",
        "apollo-utilities": "^0.2.0-rc.1",
        "graphql-anywhere": "^4.0.0-rc.1"
      },
      "devDependencies": {
        "@types/graphql": "0.9.4",
        "@types/jest": "21.1.2",
        "@types/lodash": "4.14.77",
        "browserify": "14.4.0",
        "graphql": "0.11.7",
        "graphql-tag": "2.4.2",
        "jest": "20.0.4",
        "lodash": "4.17.4",
        "rimraf": "2.6.2",
        "ts-jest": "20.0.14",
        "tslint": "5.7.0",
        "typescript": "2.5.2",
        "uglifyjs": "2.4.11"
      },
      "jest": {
        "transform": {
          ".(ts|tsx)": "<rootDir>/node_modules/ts-jest/preprocessor.js"
        },
        "testRegex": "(/__tests__/.*|\\.(test|spec))\\.(ts|tsx|js)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "json"
        ]
      },
      "_id": "apollo-cache-inmemory@0.2.0-rc.2",
      "_npmVersion": "5.5.1",
      "_nodeVersion": "8.1.2",
      "_npmUser": {
        "name": "jbaxleyiii",
        "email": "james@meteor.com"
      },
      "dist": {
        "integrity": "sha512-R9YRyW457xDr9znqq2pRjkVs8WbXf9Wx/V31nzYuyIQL5CQU7lQa1dsFDLKy+vXIgMvGCZqNLAsxIxLsXeS84w==",
        "shasum": "407d07df24b0f68eac3a7e43511ff4a812646b19",
        "tarball": "https://registry.npmjs.org/apollo-cache-inmemory/-/apollo-cache-inmemory-0.2.0-rc.2.tgz",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIQDofBkjPtKdD5XKI83m/3FCGpnqxE0HNIWszcL0wtbF5wIgCIXHS6MtHCJ+QHTYHTi8l0zTNnHZHaYsCPTQkhPkL0g="
          }
        ]
      },
      "maintainers": [
        {
          "name": "jbaxleyiii",
          "email": "james@meteor.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/apollo-cache-inmemory-0.2.0-rc.2.tgz_1508457920211_0.30687127308920026"
      },
      "directories": {}
    },
    "0.2.0-rc.3": {
      "name": "apollo-cache-inmemory",
      "version": "0.2.0-rc.3",
      "description": "Core abstract of Caching layer for Apollo Client",
      "author": {
        "name": "James Baxley",
        "email": "james@meteor.com"
      },
      "contributors": [
        {
          "name": "James Baxley",
          "email": "james@meteor.com"
        },
        {
          "name": "Jonas Helfer",
          "email": "jonas@helfer.email"
        },
        {
          "name": "Sashko Stubailo",
          "email": "sashko@stubailo.com"
        }
      ],
      "license": "MIT",
      "main": "./lib/index.js",
      "typings": "./lib/index.d.ts",
      "repository": {
        "type": "git",
        "url": "git+https://github.com/apollographql/apollo-client.git"
      },
      "bugs": {
        "url": "https://github.com/apollographql/apollo-client/issues"
      },
      "homepage": "https://github.com/apollographql/apollo-client#readme",
      "scripts": {
        "coverage": "jest --coverage",
        "test": "jest",
        "lint": "tslint --type-check -p tsconfig.json src/*.ts",
        "prebuild": "npm run clean",
        "build": "tsc -p .",
        "watch": "tsc -w -p .",
        "clean": "rimraf coverage/* && rimraf lib/*",
        "prepublishOnly": "npm run build",
        "build:browser": "browserify ./lib/index.js --i apollo-cache-core --i apollo-utilities -o=./lib/bundle.js && npm run minify:browser",
        "minify:browser": "uglifyjs -c -m -o ./lib/bundle.min.js -- ./lib/bundle.js",
        "filesize": "npm run build:browser"
      },
      "dependencies": {
        "apollo-cache": "^0.2.0-rc.2",
        "apollo-utilities": "^0.2.0-rc.2",
        "graphql-anywhere": "^4.0.0-rc.2"
      },
      "devDependencies": {
        "@types/graphql": "0.9.4",
        "@types/jest": "21.1.2",
        "@types/lodash": "4.14.78",
        "browserify": "14.5.0",
        "graphql": "0.11.7",
        "graphql-tag": "2.4.2",
        "jest": "20.0.4",
        "lodash": "4.17.4",
        "rimraf": "2.6.2",
        "ts-jest": "20.0.14",
        "tslint": "5.7.0",
        "typescript": "2.5.2",
        "uglifyjs": "2.4.11"
      },
      "jest": {
        "transform": {
          ".(ts|tsx)": "<rootDir>/node_modules/ts-jest/preprocessor.js"
        },
        "testRegex": "(/__tests__/.*|\\.(test|spec))\\.(ts|tsx|js)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "json"
        ]
      },
      "_id": "apollo-cache-inmemory@0.2.0-rc.3",
      "_npmVersion": "5.5.1",
      "_nodeVersion": "8.1.2",
      "_npmUser": {
        "name": "jbaxleyiii",
        "email": "james@meteor.com"
      },
      "dist": {
        "integrity": "sha512-ccoZy3/IrGW0wjO/moE4w1uDUDq/8MX16CwlxlC+2RiKivIbLRNYXyqyg+q/wt9pH5ENgXFhLEHLedNCAPAcqA==",
        "shasum": "25790d9272ae69b23921f76265dbfd1173382b67",
        "tarball": "https://registry.npmjs.org/apollo-cache-inmemory/-/apollo-cache-inmemory-0.2.0-rc.3.tgz",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEQCIGIeMIzqRjbB8dvpfe5ovo8PBg8RDTOzw8yTVfnjOuc3AiBH5BRGOg84opeWmg3Ecx2NrnBk+mW5Ph9BTYjrdUneoA=="
          }
        ]
      },
      "maintainers": [
        {
          "name": "jbaxleyiii",
          "email": "james@meteor.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/apollo-cache-inmemory-0.2.0-rc.3.tgz_1508509598249_0.9120101521257311"
      },
      "directories": {}
    },
    "0.2.0-rc.4": {
      "name": "apollo-cache-inmemory",
      "version": "0.2.0-rc.4",
      "description": "Core abstract of Caching layer for Apollo Client",
      "author": {
        "name": "James Baxley",
        "email": "james@meteor.com"
      },
      "contributors": [
        {
          "name": "James Baxley",
          "email": "james@meteor.com"
        },
        {
          "name": "Jonas Helfer",
          "email": "jonas@helfer.email"
        },
        {
          "name": "Sashko Stubailo",
          "email": "sashko@stubailo.com"
        }
      ],
      "license": "MIT",
      "main": "./lib/index.js",
      "typings": "./lib/index.d.ts",
      "repository": {
        "type": "git",
        "url": "git+https://github.com/apollographql/apollo-client.git"
      },
      "bugs": {
        "url": "https://github.com/apollographql/apollo-client/issues"
      },
      "homepage": "https://github.com/apollographql/apollo-client#readme",
      "scripts": {
        "coverage": "jest --coverage",
        "test": "jest",
        "lint": "tslint --type-check -p tsconfig.json src/*.ts",
        "prebuild": "npm run clean",
        "build": "tsc -p .",
        "watch": "tsc -w -p .",
        "clean": "rimraf coverage/* && rimraf lib/*",
        "prepublishOnly": "npm run build",
        "build:browser": "browserify ./lib/index.js --i apollo-cache-core --i apollo-utilities -o=./lib/bundle.js && npm run minify:browser",
        "minify:browser": "uglifyjs -c -m -o ./lib/bundle.min.js -- ./lib/bundle.js",
        "filesize": "npm run build:browser"
      },
      "dependencies": {
        "apollo-cache": "^0.2.0-rc.3",
        "apollo-utilities": "^0.2.0-rc.3",
        "graphql-anywhere": "^4.0.0-rc.3"
      },
      "devDependencies": {
        "@types/graphql": "0.9.4",
        "@types/jest": "21.1.2",
        "@types/lodash": "4.14.78",
        "browserify": "14.5.0",
        "graphql": "0.11.7",
        "graphql-tag": "2.4.2",
        "jest": "20.0.4",
        "lodash": "4.17.4",
        "rimraf": "2.6.2",
        "ts-jest": "20.0.14",
        "tslint": "5.8.0",
        "typescript": "2.5.2",
        "uglifyjs": "2.4.11"
      },
      "jest": {
        "transform": {
          ".(ts|tsx)": "<rootDir>/node_modules/ts-jest/preprocessor.js"
        },
        "testRegex": "(/__tests__/.*|\\.(test|spec))\\.(ts|tsx|js)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "json"
        ]
      },
      "_id": "apollo-cache-inmemory@0.2.0-rc.4",
      "_npmVersion": "5.5.1",
      "_nodeVersion": "8.1.2",
      "_npmUser": {
        "name": "jbaxleyiii",
        "email": "james@meteor.com"
      },
      "dist": {
        "integrity": "sha512-gtcjQkk5zms4Enz6LL0ZeIrU0QJJ6f1PK+gaW56f65tTPf+H20th1I1OQZFKQf85Aojfpz8gItO3tmrFGzHyQA==",
        "shasum": "17ac2519ee14f21fc03b0181384b0c160b860c23",
        "tarball": "https://registry.npmjs.org/apollo-cache-inmemory/-/apollo-cache-inmemory-0.2.0-rc.4.tgz",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEQCIF7VKoLZVHulis1cl/0/qCPsRUvDQYQMR8dn1OAwjWisAiAPJMtudhqXpNSR6WRRC+KYKrPW0kSH/xRSfoKojCb7pQ=="
          }
        ]
      },
      "maintainers": [
        {
          "name": "jbaxleyiii",
          "email": "james@meteor.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/apollo-cache-inmemory-0.2.0-rc.4.tgz_1508822856542_0.15002366388216615"
      },
      "directories": {}
    },
    "1.0.0": {
      "name": "apollo-cache-inmemory",
      "version": "1.0.0",
      "description": "Core abstract of Caching layer for Apollo Client",
      "author": {
        "name": "James Baxley",
        "email": "james@meteor.com"
      },
      "contributors": [
        {
          "name": "James Baxley",
          "email": "james@meteor.com"
        },
        {
          "name": "Jonas Helfer",
          "email": "jonas@helfer.email"
        },
        {
          "name": "Sashko Stubailo",
          "email": "sashko@stubailo.com"
        }
      ],
      "license": "MIT",
      "main": "./lib/index.js",
      "typings": "./lib/index.d.ts",
      "repository": {
        "type": "git",
        "url": "git+https://github.com/apollographql/apollo-client.git"
      },
      "bugs": {
        "url": "https://github.com/apollographql/apollo-client/issues"
      },
      "homepage": "https://github.com/apollographql/apollo-client#readme",
      "scripts": {
        "coverage": "jest --coverage",
        "test": "jest",
        "lint": "tslint --type-check -p tsconfig.json src/*.ts",
        "prebuild": "npm run clean",
        "build": "tsc -p .",
        "watch": "tsc -w -p .",
        "clean": "rimraf coverage/* && rimraf lib/*",
        "prepublishOnly": "npm run build",
        "build:browser": "browserify ./lib/index.js --i apollo-cache-core --i apollo-utilities -o=./lib/bundle.js && npm run minify:browser",
        "minify:browser": "uglifyjs -c -m -o ./lib/bundle.min.js -- ./lib/bundle.js",
        "filesize": "npm run build:browser"
      },
      "dependencies": {
        "apollo-cache": "^1.0.0",
        "apollo-utilities": "^1.0.0",
        "graphql-anywhere": "^4.0.0"
      },
      "devDependencies": {
        "@types/graphql": "0.9.4",
        "@types/jest": "21.1.2",
        "@types/lodash": "4.14.78",
        "browserify": "14.5.0",
        "graphql": "0.11.7",
        "graphql-tag": "2.4.2",
        "jest": "20.0.4",
        "lodash": "4.17.4",
        "rimraf": "2.6.2",
        "ts-jest": "20.0.14",
        "tslint": "5.8.0",
        "typescript": "2.5.2",
        "uglifyjs": "2.4.11"
      },
      "jest": {
        "transform": {
          ".(ts|tsx)": "<rootDir>/node_modules/ts-jest/preprocessor.js"
        },
        "testRegex": "(/__tests__/.*|\\.(test|spec))\\.(ts|tsx|js)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "json"
        ]
      },
      "_id": "apollo-cache-inmemory@1.0.0",
      "_npmVersion": "5.5.1",
      "_nodeVersion": "8.1.2",
      "_npmUser": {
        "name": "jbaxleyiii",
        "email": "james@meteor.com"
      },
      "dist": {
        "integrity": "sha512-8jRQOajNK+OHWhmOGOVbemAXOx2RFSHT8vwBu9fN89H1GiEjG9azOEH8nFRj0mlkL3tDwqDxLvvFqWDCpFn8SQ==",
        "shasum": "5bff079d5b70402cd76ecc7c700851aa025d9993",
        "tarball": "https://registry.npmjs.org/apollo-cache-inmemory/-/apollo-cache-inmemory-1.0.0.tgz",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIGqE9jhfG0Yb/Ht26hVpRepHZa4QISHCnn4gDFEHqOR3AiEA18cgaqefTB36tjLbw5Y/iBBRtWtJAmSZaarSWQBfhMA="
          }
        ]
      },
      "maintainers": [
        {
          "name": "jbaxleyiii",
          "email": "james@meteor.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/apollo-cache-inmemory-1.0.0.tgz_1508871145845_0.7037060400471091"
      },
      "directories": {}
    },
    "1.1.0-beta.0": {
      "name": "apollo-cache-inmemory",
      "version": "1.1.0-beta.0",
      "description": "Core abstract of Caching layer for Apollo Client",
      "author": {
        "name": "James Baxley",
        "email": "james@meteor.com"
      },
      "contributors": [
        {
          "name": "James Baxley",
          "email": "james@meteor.com"
        },
        {
          "name": "Jonas Helfer",
          "email": "jonas@helfer.email"
        },
        {
          "name": "Sashko Stubailo",
          "email": "sashko@stubailo.com"
        }
      ],
      "license": "MIT",
      "main": "./lib/index.js",
      "typings": "./lib/index.d.ts",
      "repository": {
        "type": "git",
        "url": "git+https://github.com/apollographql/apollo-client.git"
      },
      "bugs": {
        "url": "https://github.com/apollographql/apollo-client/issues"
      },
      "homepage": "https://github.com/apollographql/apollo-client#readme",
      "scripts": {
        "coverage": "jest --coverage",
        "test": "jest",
        "lint": "tslint --type-check -p tsconfig.json src/*.ts",
        "prebuild": "npm run clean",
        "build": "tsc -p .",
        "watch": "tsc -w -p .",
        "clean": "rimraf coverage/* && rimraf lib/*",
        "prepublishOnly": "npm run build",
        "build:browser": "browserify ./lib/index.js --i apollo-cache-core --i apollo-utilities -o=./lib/bundle.js && npm run minify:browser",
        "minify:browser": "uglifyjs -c -m -o ./lib/bundle.min.js -- ./lib/bundle.js",
        "filesize": "npm run build:browser"
      },
      "dependencies": {
        "apollo-cache": "^1.0.0",
        "apollo-utilities": "^1.0.0",
        "graphql-anywhere": "^4.0.0"
      },
      "devDependencies": {
        "@types/graphql": "0.9.4",
        "@types/jest": "21.1.2",
        "@types/lodash": "4.14.80",
        "browserify": "14.5.0",
        "graphql": "0.11.7",
        "graphql-tag": "2.4.2",
        "jest": "20.0.4",
        "lodash": "4.17.4",
        "rimraf": "2.6.2",
        "ts-jest": "20.0.14",
        "tslint": "5.8.0",
        "typescript": "2.5.2",
        "uglifyjs": "2.4.11"
      },
      "jest": {
        "transform": {
          ".(ts|tsx)": "<rootDir>/node_modules/ts-jest/preprocessor.js"
        },
        "testRegex": "(/__tests__/.*|\\.(test|spec))\\.(ts|tsx|js)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "json"
        ]
      },
      "_id": "apollo-cache-inmemory@1.1.0-beta.0",
      "_npmVersion": "5.5.1",
      "_nodeVersion": "8.1.2",
      "_npmUser": {
        "name": "jbaxleyiii",
        "email": "james@meteor.com"
      },
      "dist": {
        "integrity": "sha512-xwGVUpgICYD4tATqRlOk475Q4WCGYadUvzuE3FVf/Zj3c3YudEqefTYUXN3oOiiqIouFrMouFXe06V8AwWLhpQ==",
        "shasum": "3bcf91a7aad8cd60fa7a31787083e2015d5a9b15",
        "tarball": "https://registry.npmjs.org/apollo-cache-inmemory/-/apollo-cache-inmemory-1.1.0-beta.0.tgz",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCICMZxkVwCJFXoNHf2jaDyalUjy8j8Hp/7AacKSE+2nmaAiEAk4dHNb3Ke9n0cjbEevbIHzkeHGfBXl7gyI674KXaqdE="
          }
        ]
      },
      "maintainers": [
        {
          "name": "jbaxleyiii",
          "email": "james@meteor.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/apollo-cache-inmemory-1.1.0-beta.0.tgz_1509546542485_0.3449793520849198"
      },
      "directories": {}
    },
    "1.1.0-beta.1": {
      "name": "apollo-cache-inmemory",
      "version": "1.1.0-beta.1",
      "description": "Core abstract of Caching layer for Apollo Client",
      "author": {
        "name": "James Baxley",
        "email": "james@meteor.com"
      },
      "contributors": [
        {
          "name": "James Baxley",
          "email": "james@meteor.com"
        },
        {
          "name": "Jonas Helfer",
          "email": "jonas@helfer.email"
        },
        {
          "name": "Sashko Stubailo",
          "email": "sashko@stubailo.com"
        }
      ],
      "license": "MIT",
      "main": "./lib/index.js",
      "typings": "./lib/index.d.ts",
      "repository": {
        "type": "git",
        "url": "git+https://github.com/apollographql/apollo-client.git"
      },
      "bugs": {
        "url": "https://github.com/apollographql/apollo-client/issues"
      },
      "homepage": "https://github.com/apollographql/apollo-client#readme",
      "scripts": {
        "coverage": "jest --coverage",
        "test": "jest",
        "lint": "tslint --type-check -p tsconfig.json src/*.ts",
        "prebuild": "npm run clean",
        "build": "tsc -p .",
        "watch": "tsc -w -p .",
        "clean": "rimraf coverage/* && rimraf lib/*",
        "prepublishOnly": "npm run build",
        "build:browser": "browserify ./lib/index.js --i apollo-cache-core --i apollo-utilities -o=./lib/bundle.js && npm run minify:browser",
        "minify:browser": "uglifyjs -c -m -o ./lib/bundle.min.js -- ./lib/bundle.js",
        "filesize": "npm run build:browser"
      },
      "dependencies": {
        "apollo-cache": "^1.0.0",
        "apollo-utilities": "^1.0.0",
        "graphql-anywhere": "^4.0.0"
      },
      "peerDependencies": {
        "graphql": "0.11.7"
      },
      "devDependencies": {
        "@types/graphql": "0.9.4",
        "@types/jest": "21.1.2",
        "@types/lodash": "4.14.80",
        "browserify": "14.5.0",
        "graphql": "0.11.7",
        "graphql-tag": "2.4.2",
        "jest": "20.0.4",
        "lodash": "4.17.4",
        "rimraf": "2.6.2",
        "ts-jest": "20.0.14",
        "tslint": "5.8.0",
        "typescript": "2.5.2",
        "uglifyjs": "2.4.11"
      },
      "jest": {
        "transform": {
          ".(ts|tsx)": "<rootDir>/node_modules/ts-jest/preprocessor.js"
        },
        "testRegex": "(/__tests__/.*|\\.(test|spec))\\.(ts|tsx|js)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "json"
        ]
      },
      "_id": "apollo-cache-inmemory@1.1.0-beta.1",
      "_npmVersion": "5.5.1",
      "_nodeVersion": "8.1.2",
      "_npmUser": {
        "name": "jbaxleyiii",
        "email": "james@meteor.com"
      },
      "dist": {
        "integrity": "sha512-5mMpyK63x82GH0qK7TWxy9cCBLnZJZg4BNnh8p9yPobEbyijHayUuJv+HJOxUFPEtwG2ncsfK233QJV7optjpg==",
        "shasum": "fdcaa5496374eed7b234da54bc8aa7406a10a2de",
        "tarball": "https://registry.npmjs.org/apollo-cache-inmemory/-/apollo-cache-inmemory-1.1.0-beta.1.tgz",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEYCIQDhXj/GPtSRTtHSwr+vNcmhKmejeG9O8PElww5qvcSP2AIhANpwHN580fPn0XZj+QFs7dPSXfXR/LuAjAORXm+0f9cj"
          }
        ]
      },
      "maintainers": [
        {
          "name": "jbaxleyiii",
          "email": "james@meteor.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/apollo-cache-inmemory-1.1.0-beta.1.tgz_1509546671278_0.6745469230227172"
      },
      "directories": {}
    },
    "1.1.0": {
      "name": "apollo-cache-inmemory",
      "version": "1.1.0",
      "description": "Core abstract of Caching layer for Apollo Client",
      "author": {
        "name": "James Baxley",
        "email": "james@meteor.com"
      },
      "contributors": [
        {
          "name": "James Baxley",
          "email": "james@meteor.com"
        },
        {
          "name": "Jonas Helfer",
          "email": "jonas@helfer.email"
        },
        {
          "name": "Sashko Stubailo",
          "email": "sashko@stubailo.com"
        }
      ],
      "license": "MIT",
      "main": "./lib/index.js",
      "typings": "./lib/index.d.ts",
      "repository": {
        "type": "git",
        "url": "git+https://github.com/apollographql/apollo-client.git"
      },
      "bugs": {
        "url": "https://github.com/apollographql/apollo-client/issues"
      },
      "homepage": "https://github.com/apollographql/apollo-client#readme",
      "scripts": {
        "coverage": "jest --coverage",
        "test": "jest",
        "lint": "tslint --type-check -p tsconfig.json src/*.ts",
        "prebuild": "npm run clean",
        "build": "tsc -p .",
        "watch": "tsc -w -p .",
        "clean": "rimraf coverage/* && rimraf lib/*",
        "prepublishOnly": "npm run build",
        "build:browser": "browserify ./lib/index.js --i apollo-cache-core --i apollo-utilities --i graphql -o=./lib/bundle.js && npm run minify:browser",
        "minify:browser": "uglifyjs -c -m -o ./lib/bundle.min.js -- ./lib/bundle.js",
        "filesize": "npm run build:browser"
      },
      "dependencies": {
        "apollo-cache": "^1.0.0",
        "apollo-utilities": "^1.0.0",
        "graphql-anywhere": "^4.0.0"
      },
      "peerDependencies": {
        "graphql": "0.11.7"
      },
      "devDependencies": {
        "@types/graphql": "0.9.4",
        "@types/jest": "21.1.2",
        "@types/lodash": "4.14.82",
        "browserify": "14.5.0",
        "graphql": "0.11.7",
        "graphql-tag": "2.4.2",
        "jest": "20.0.4",
        "lodash": "4.17.4",
        "rimraf": "2.6.2",
        "ts-jest": "20.0.14",
        "tslint": "5.8.0",
        "typescript": "2.5.2",
        "uglifyjs": "2.4.11"
      },
      "jest": {
        "transform": {
          ".(ts|tsx)": "<rootDir>/node_modules/ts-jest/preprocessor.js"
        },
        "testRegex": "(/__tests__/.*|\\.(test|spec))\\.(ts|tsx|js)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "json"
        ]
      },
      "_id": "apollo-cache-inmemory@1.1.0",
      "_npmVersion": "5.5.1",
      "_nodeVersion": "8.1.2",
      "_npmUser": {
        "name": "jbaxleyiii",
        "email": "james@meteor.com"
      },
      "dist": {
        "integrity": "sha512-5XVl0dVa0y8nEFrwT5fdF2vkwpwg6smuMSj6xvckLnQU66TcEiQchImOO/cuE+RJf/2M3xabpnoBQgTJ3MUPew==",
        "shasum": "8b35f21da142419f0d68b6fff908f8ed4370ac8d",
        "tarball": "https://registry.npmjs.org/apollo-cache-inmemory/-/apollo-cache-inmemory-1.1.0.tgz",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIQDfbUhws6kaOKpHqxwUSzZ+zuPMsUfu1UYdcZgKm1W8nQIgYOVXvMt3v4ZOExlWl032dSgcQEm8nDWCQ0CiVcKL9MY="
          }
        ]
      },
      "maintainers": [
        {
          "name": "jbaxleyiii",
          "email": "james@meteor.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/apollo-cache-inmemory-1.1.0.tgz_1509983899347_0.784445493016392"
      },
      "directories": {}
    },
    "1.1.1": {
      "name": "apollo-cache-inmemory",
      "version": "1.1.1",
      "description": "Core abstract of Caching layer for Apollo Client",
      "author": {
        "name": "James Baxley",
        "email": "james@meteor.com"
      },
      "contributors": [
        {
          "name": "James Baxley",
          "email": "james@meteor.com"
        },
        {
          "name": "Jonas Helfer",
          "email": "jonas@helfer.email"
        },
        {
          "name": "Sashko Stubailo",
          "email": "sashko@stubailo.com"
        }
      ],
      "license": "MIT",
      "main": "./lib/bundle.umd.js",
      "module": "./lib/index.js",
      "jsnext:main": "/lib/index.js",
      "typings": "./lib/index.d.ts",
      "repository": {
        "type": "git",
        "url": "git+https://github.com/apollographql/apollo-client.git"
      },
      "bugs": {
        "url": "https://github.com/apollographql/apollo-client/issues"
      },
      "homepage": "https://github.com/apollographql/apollo-client#readme",
      "scripts": {
        "coverage": "jest --coverage",
        "test": "jest",
        "lint": "tslint --type-check -p tsconfig.json src/*.ts",
        "prebuild": "npm run clean",
        "build": "tsc -p .",
        "postbuild": "npm run bundle",
        "bundle": "rollup -c rollup.config.js",
        "watch": "tsc -w -p .",
        "clean": "rimraf coverage/* && rimraf lib/*",
        "prepublishOnly": "npm run build",
        "build:browser": "browserify ./lib/bundle.umd.js --i apollo-cache --i apollo-utilities --i graphql -o=./lib/bundle.js && npm run minify:browser",
        "minify:browser": "uglifyjs -c -m -o ./lib/bundle.min.js -- ./lib/bundle.js",
        "filesize": "npm run build:browser"
      },
      "dependencies": {
        "apollo-cache": "^1.0.1",
        "apollo-utilities": "^1.0.2",
        "graphql-anywhere": "^4.0.1"
      },
      "peerDependencies": {
        "graphql": "0.11.7"
      },
      "devDependencies": {
        "@types/graphql": "0.9.4",
        "@types/jest": "21.1.6",
        "@types/lodash": "4.14.85",
        "browserify": "14.5.0",
        "graphql": "0.11.7",
        "graphql-tag": "2.4.2",
        "jest": "20.0.4",
        "lodash": "4.17.4",
        "rimraf": "2.6.2",
        "rollup": "0.50.0",
        "ts-jest": "20.0.14",
        "tslint": "5.8.0",
        "typescript": "2.5.2",
        "uglifyjs": "2.4.11"
      },
      "jest": {
        "transform": {
          ".(ts|tsx)": "<rootDir>/node_modules/ts-jest/preprocessor.js"
        },
        "testRegex": "(/__tests__/.*|\\.(test|spec))\\.(ts|tsx|js)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "json"
        ]
      },
      "_id": "apollo-cache-inmemory@1.1.1",
      "_npmVersion": "5.5.1",
      "_nodeVersion": "8.9.0",
      "_npmUser": {
        "name": "jbaxleyiii",
        "email": "james@meteor.com"
      },
      "dist": {
        "integrity": "sha512-I0cOOuHJvsFdFO7wBqptueiEQmKcM9Yu05IKDI0QQ0KtYMuH1bJvuh/g55GuwYMXVbqSqmJzkk6xOGtsyR/FRA==",
        "shasum": "1511f00eb845da88504abf867f408c3026a909ba",
        "tarball": "https://registry.npmjs.org/apollo-cache-inmemory/-/apollo-cache-inmemory-1.1.1.tgz",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEYCIQDleVIR2UrhXOhmEUFQhAEOfnuYjDTslMO0y5mf+E0bVgIhANOBelUcuFuDqvbbXN3fvSNkAS9R5lVwCco6xtCgOv+i"
          }
        ]
      },
      "maintainers": [
        {
          "name": "jbaxleyiii",
          "email": "james@meteor.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/apollo-cache-inmemory-1.1.1.tgz_1510801056833_0.5172016352880746"
      },
      "directories": {}
    },
    "1.1.2": {
      "name": "apollo-cache-inmemory",
      "version": "1.1.2",
      "description": "Core abstract of Caching layer for Apollo Client",
      "author": {
        "name": "James Baxley",
        "email": "james@meteor.com"
      },
      "contributors": [
        {
          "name": "James Baxley",
          "email": "james@meteor.com"
        },
        {
          "name": "Jonas Helfer",
          "email": "jonas@helfer.email"
        },
        {
          "name": "Sashko Stubailo",
          "email": "sashko@stubailo.com"
        }
      ],
      "license": "MIT",
      "main": "./lib/bundle.umd.js",
      "module": "./lib/index.js",
      "jsnext:main": "/lib/index.js",
      "typings": "./lib/index.d.ts",
      "repository": {
        "type": "git",
        "url": "git+https://github.com/apollographql/apollo-client.git"
      },
      "bugs": {
        "url": "https://github.com/apollographql/apollo-client/issues"
      },
      "homepage": "https://github.com/apollographql/apollo-client#readme",
      "scripts": {
        "coverage": "jest --coverage",
        "test": "jest",
        "lint": "tslint --type-check -p tsconfig.json src/*.ts",
        "prebuild": "npm run clean",
        "build": "tsc -p .",
        "postbuild": "npm run bundle",
        "bundle": "rollup -c rollup.config.js",
        "watch": "tsc -w -p .",
        "clean": "rimraf coverage/* && rimraf lib/*",
        "prepublishOnly": "npm run build",
        "build:browser": "browserify ./lib/bundle.umd.js --i apollo-cache --i apollo-utilities --i graphql -o=./lib/bundle.js && npm run minify:browser",
        "minify:browser": "uglifyjs -c -m -o ./lib/bundle.min.js -- ./lib/bundle.js",
        "filesize": "npm run build:browser"
      },
      "dependencies": {
        "apollo-cache": "^1.0.2",
        "apollo-utilities": "^1.0.3",
        "graphql-anywhere": "^4.0.2"
      },
      "peerDependencies": {
        "graphql": "0.11.7"
      },
      "devDependencies": {
        "@types/graphql": "0.11.7",
        "@types/jest": "21.1.8",
        "@types/lodash": "4.14.86",
        "browserify": "14.5.0",
        "graphql": "0.11.7",
        "graphql-tag": "2.4.2",
        "jest": "20.0.4",
        "lodash": "4.17.4",
        "rimraf": "2.6.2",
        "rollup": "0.52.0",
        "ts-jest": "20.0.14",
        "tslint": "5.8.0",
        "typescript": "2.5.2",
        "uglifyjs": "2.4.11"
      },
      "jest": {
        "transform": {
          ".(ts|tsx)": "<rootDir>/node_modules/ts-jest/preprocessor.js"
        },
        "testRegex": "(/__tests__/.*|\\.(test|spec))\\.(ts|tsx|js)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "json"
        ]
      },
      "_id": "apollo-cache-inmemory@1.1.2",
      "_npmVersion": "5.5.1",
      "_nodeVersion": "8.9.0",
      "_npmUser": {
        "name": "jbaxleyiii",
        "email": "james@meteor.com"
      },
      "dist": {
        "integrity": "sha512-1yKyiphcO5c1rjnf7Wtnmq8lMb0yHafN1japwolfqdcfTzxW+zXntV8SlYHrULZxVPQE9K0q4/2gX03q7NeUtQ==",
        "shasum": "555d4d76cbea78b1454013f61aa8a8bc8131601f",
        "tarball": "https://registry.npmjs.org/apollo-cache-inmemory/-/apollo-cache-inmemory-1.1.2.tgz",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIDwchVFT4u5/9EEMDLb+f/oqhFOfEghzSu4I9Q6WtK/sAiEAp6VBCSrTF1L8nTgFeJHkom+hd7BWwfyWzqHblnvGSXk="
          }
        ]
      },
      "maintainers": [
        {
          "name": "jbaxleyiii",
          "email": "james@meteor.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/apollo-cache-inmemory-1.1.2.tgz_1512068608694_0.42974282638169825"
      },
      "directories": {}
    },
    "1.1.3": {
      "name": "apollo-cache-inmemory",
      "version": "1.1.3",
      "description": "Core abstract of Caching layer for Apollo Client",
      "author": {
        "name": "James Baxley",
        "email": "james@meteor.com"
      },
      "contributors": [
        {
          "name": "James Baxley",
          "email": "james@meteor.com"
        },
        {
          "name": "Jonas Helfer",
          "email": "jonas@helfer.email"
        },
        {
          "name": "Sashko Stubailo",
          "email": "sashko@stubailo.com"
        }
      ],
      "license": "MIT",
      "main": "./lib/bundle.umd.js",
      "module": "./lib/index.js",
      "jsnext:main": "./lib/index.js",
      "typings": "./lib/index.d.ts",
      "repository": {
        "type": "git",
        "url": "git+https://github.com/apollographql/apollo-client.git"
      },
      "bugs": {
        "url": "https://github.com/apollographql/apollo-client/issues"
      },
      "homepage": "https://github.com/apollographql/apollo-client#readme",
      "scripts": {
        "coverage": "jest --coverage",
        "test": "jest",
        "lint": "tslint --type-check -p tsconfig.json src/*.ts",
        "prebuild": "npm run clean",
        "build": "tsc -p .",
        "postbuild": "npm run bundle",
        "bundle": "rollup -c rollup.config.js",
        "watch": "tsc -w -p .",
        "clean": "rimraf coverage/* && rimraf lib/*",
        "prepublishOnly": "npm run build",
        "build:browser": "browserify ./lib/bundle.umd.js --i apollo-cache --i apollo-utilities --i graphql -o=./lib/bundle.js && npm run minify:browser",
        "minify:browser": "uglifyjs -c -m -o ./lib/bundle.min.js -- ./lib/bundle.js",
        "filesize": "npm run build:browser"
      },
      "dependencies": {
        "apollo-cache": "^1.0.1",
        "apollo-utilities": "^1.0.2",
        "graphql-anywhere": "^4.0.1"
      },
      "peerDependencies": {
        "graphql": "0.11.7"
      },
      "devDependencies": {
        "@types/graphql": "0.11.7",
        "@types/jest": "21.1.8",
        "@types/lodash": "4.14.87",
        "browserify": "14.5.0",
        "graphql": "0.11.7",
        "graphql-tag": "2.4.2",
        "jest": "20.0.4",
        "lodash": "4.17.4",
        "rimraf": "2.6.2",
        "rollup": "0.52.1",
        "ts-jest": "20.0.14",
        "tslint": "5.8.0",
        "typescript": "2.5.2",
        "uglifyjs": "2.4.11"
      },
      "jest": {
        "transform": {
          ".(ts|tsx)": "<rootDir>/node_modules/ts-jest/preprocessor.js"
        },
        "testRegex": "(/__tests__/.*|\\.(test|spec))\\.(ts|tsx|js)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "json"
        ]
      },
      "_id": "apollo-cache-inmemory@1.1.3",
      "_npmVersion": "5.5.1",
      "_nodeVersion": "8.9.0",
      "_npmUser": {
        "name": "jbaxleyiii",
        "email": "james@meteor.com"
      },
      "dist": {
        "integrity": "sha512-0VsSZjutGchfC9Upzi+09BowxqhbE54rmATQvJVFqjOWcP6axMQm6zIsVL4Ky/cWf7E/dhXspQDiNnka1XJz7g==",
        "shasum": "24aea981e2552ad1e34361862c1a140596707a2e",
        "tarball": "https://registry.npmjs.org/apollo-cache-inmemory/-/apollo-cache-inmemory-1.1.3.tgz",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEYCIQCqdNeteFnasdm7rsIJ9cKTYcDeVAGRfT84mFhwmsqyRgIhAKYJBIRuJHIrMcUJJi5McYS82tcUcXE8sQOsRgW6dpHX"
          }
        ]
      },
      "maintainers": [
        {
          "name": "jbaxleyiii",
          "email": "james@meteor.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/apollo-cache-inmemory-1.1.3.tgz_1512565800418_0.1264729939866811"
      },
      "directories": {}
    },
    "1.1.4": {
      "name": "apollo-cache-inmemory",
      "version": "1.1.4",
      "description": "Core abstract of Caching layer for Apollo Client",
      "author": {
        "name": "James Baxley",
        "email": "james@meteor.com"
      },
      "contributors": [
        {
          "name": "James Baxley",
          "email": "james@meteor.com"
        },
        {
          "name": "Jonas Helfer",
          "email": "jonas@helfer.email"
        },
        {
          "name": "Sashko Stubailo",
          "email": "sashko@stubailo.com"
        }
      ],
      "license": "MIT",
      "main": "./lib/bundle.umd.js",
      "module": "./lib/index.js",
      "jsnext:main": "./lib/index.js",
      "typings": "./lib/index.d.ts",
      "repository": {
        "type": "git",
        "url": "git+https://github.com/apollographql/apollo-client.git"
      },
      "bugs": {
        "url": "https://github.com/apollographql/apollo-client/issues"
      },
      "homepage": "https://github.com/apollographql/apollo-client#readme",
      "scripts": {
        "coverage": "jest --coverage",
        "test": "jest",
        "lint": "tslint --type-check -p tsconfig.json src/*.ts",
        "prebuild": "npm run clean",
        "build": "tsc -p .",
        "postbuild": "npm run bundle",
        "bundle": "rollup -c rollup.config.js",
        "watch": "tsc -w -p .",
        "clean": "rimraf coverage/* && rimraf lib/*",
        "prepublishOnly": "npm run build",
        "build:browser": "browserify ./lib/bundle.umd.js --i apollo-cache --i apollo-utilities --i graphql -o=./lib/bundle.js && npm run minify:browser",
        "minify:browser": "uglifyjs -c -m -o ./lib/bundle.min.js -- ./lib/bundle.js",
        "filesize": "npm run build:browser"
      },
      "dependencies": {
        "apollo-cache": "^1.0.2",
        "apollo-utilities": "^1.0.3",
        "graphql-anywhere": "^4.0.1"
      },
      "peerDependencies": {
        "graphql": "0.11.7"
      },
      "devDependencies": {
        "@types/graphql": "0.11.7",
        "@types/jest": "21.1.8",
        "@types/lodash": "4.14.88",
        "browserify": "14.5.0",
        "graphql": "0.11.7",
        "graphql-tag": "2.6.0",
        "jest": "20.0.4",
        "lodash": "4.17.4",
        "rimraf": "2.6.2",
        "rollup": "0.52.1",
        "ts-jest": "20.0.14",
        "tslint": "5.8.0",
        "typescript": "2.5.2",
        "uglifyjs": "2.4.11"
      },
      "jest": {
        "transform": {
          ".(ts|tsx)": "<rootDir>/node_modules/ts-jest/preprocessor.js"
        },
        "testRegex": "(/__tests__/.*|\\.(test|spec))\\.(ts|tsx|js)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "json"
        ]
      },
      "_id": "apollo-cache-inmemory@1.1.4",
      "_npmVersion": "5.5.1",
      "_nodeVersion": "8.9.0",
      "_npmUser": {
        "name": "jbaxleyiii",
        "email": "james@meteor.com"
      },
      "dist": {
        "integrity": "sha512-TGDLpk9IGc7jn5DLQVLM9U2UvIa3GNFZtuy2cw+ZUd4RVZ8XH5TMUAXnZkyl0y+Qp3W9i10t3xuC5SmUGHHWWw==",
        "shasum": "63485b18f56f9ceb912df235b42959e890c89747",
        "tarball": "https://registry.npmjs.org/apollo-cache-inmemory/-/apollo-cache-inmemory-1.1.4.tgz",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEQCIGdUGCjzKl2R4SkCgQqiILKAb5mbFVMT6/bwc/uW+v6IAiA78qfbn1ALRN69tyuLKJknKCYYaQBbT9+Ml/Y5BDyDtw=="
          }
        ]
      },
      "maintainers": [
        {
          "name": "jbaxleyiii",
          "email": "james@meteor.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/apollo-cache-inmemory-1.1.4.tgz_1512747077772_0.9597976238001138"
      },
      "directories": {}
    },
    "1.1.5": {
      "name": "apollo-cache-inmemory",
      "version": "1.1.5",
      "description": "Core abstract of Caching layer for Apollo Client",
      "author": {
        "name": "James Baxley",
        "email": "james@meteor.com"
      },
      "contributors": [
        {
          "name": "James Baxley",
          "email": "james@meteor.com"
        },
        {
          "name": "Jonas Helfer",
          "email": "jonas@helfer.email"
        },
        {
          "name": "Sashko Stubailo",
          "email": "sashko@stubailo.com"
        }
      ],
      "license": "MIT",
      "main": "./lib/bundle.umd.js",
      "module": "./lib/index.js",
      "jsnext:main": "./lib/index.js",
      "typings": "./lib/index.d.ts",
      "repository": {
        "type": "git",
        "url": "git+https://github.com/apollographql/apollo-client.git"
      },
      "bugs": {
        "url": "https://github.com/apollographql/apollo-client/issues"
      },
      "homepage": "https://github.com/apollographql/apollo-client#readme",
      "scripts": {
        "coverage": "jest --coverage",
        "test": "jest",
        "lint": "tslint --type-check -p tsconfig.json src/*.ts",
        "prebuild": "npm run clean",
        "build": "tsc -p .",
        "postbuild": "npm run bundle",
        "bundle": "rollup -c rollup.config.js",
        "watch": "tsc -w -p .",
        "clean": "rimraf coverage/* && rimraf lib/*",
        "prepublishOnly": "npm run build",
        "build:browser": "browserify ./lib/bundle.umd.js --i apollo-cache --i apollo-utilities --i graphql -o=./lib/bundle.js && npm run minify:browser",
        "minify:browser": "uglifyjs -c -m -o ./lib/bundle.min.js -- ./lib/bundle.js",
        "filesize": "npm run build:browser"
      },
      "dependencies": {
        "apollo-cache": "^1.1.0",
        "apollo-utilities": "^1.0.4",
        "graphql-anywhere": "^4.1.1"
      },
      "peerDependencies": {
        "graphql": "0.11.7 || ^0.12.0"
      },
      "devDependencies": {
        "@types/graphql": "0.11.7",
        "@types/jest": "21.1.10",
        "@types/lodash": "4.14.92",
        "browserify": "15.0.0",
        "graphql": "0.12.3",
        "graphql-tag": "2.6.1",
        "jest": "20.0.4",
        "lodash": "4.17.4",
        "rimraf": "2.6.2",
        "rollup": "0.53.3",
        "ts-jest": "20.0.14",
        "tslint": "5.8.0",
        "typescript": "2.5.2",
        "uglifyjs": "2.4.11"
      },
      "jest": {
        "transform": {
          ".(ts|tsx)": "<rootDir>/node_modules/ts-jest/preprocessor.js"
        },
        "testRegex": "(/__tests__/.*|\\.(test|spec))\\.(ts|tsx|js)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "json"
        ]
      },
      "_id": "apollo-cache-inmemory@1.1.5",
      "_npmVersion": "5.6.0",
      "_nodeVersion": "8.9.0",
      "_npmUser": {
        "name": "jbaxleyiii",
        "email": "james@meteor.com"
      },
      "dist": {
        "integrity": "sha512-Gy9g4RZUfIJwxaZuMF3ZqplYaiFSfgJYmepYTIP+zL+9dqV1Er8EIICJqVlc4T2uWXHQ9U01iK5Hu1g9pV85tg==",
        "shasum": "74111367fd59caee120197ef663dcb2516971300",
        "tarball": "https://registry.npmjs.org/apollo-cache-inmemory/-/apollo-cache-inmemory-1.1.5.tgz",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIQDt191ZO2DD+PGEWMbTBLQPiQfV01I3UMhj9uMr/R/wkwIgdHdx3PFbOrARe5FYRGhPvR9HnRaSA7Yb3/MlGZbxUKE="
          }
        ]
      },
      "maintainers": [
        {
          "name": "jbaxleyiii",
          "email": "james@meteor.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/apollo-cache-inmemory-1.1.5.tgz_1515184516914_0.6174931610003114"
      },
      "directories": {}
    },
    "1.1.7": {
      "name": "apollo-cache-inmemory",
      "version": "1.1.7",
      "description": "Core abstract of Caching layer for Apollo Client",
      "author": {
        "name": "James Baxley",
        "email": "james@meteor.com"
      },
      "contributors": [
        {
          "name": "James Baxley",
          "email": "james@meteor.com"
        },
        {
          "name": "Jonas Helfer",
          "email": "jonas@helfer.email"
        },
        {
          "name": "Sashko Stubailo",
          "email": "sashko@stubailo.com"
        }
      ],
      "license": "MIT",
      "main": "./lib/bundle.umd.js",
      "module": "./lib/index.js",
      "jsnext:main": "./lib/index.js",
      "typings": "./lib/index.d.ts",
      "repository": {
        "type": "git",
        "url": "git+https://github.com/apollographql/apollo-client.git"
      },
      "bugs": {
        "url": "https://github.com/apollographql/apollo-client/issues"
      },
      "homepage": "https://github.com/apollographql/apollo-client#readme",
      "scripts": {
        "coverage": "jest --coverage",
        "test": "jest",
        "lint": "tslint --type-check -p tsconfig.json src/*.ts",
        "prebuild": "npm run clean",
        "build": "tsc -p .",
        "postbuild": "npm run bundle",
        "bundle": "rollup -c rollup.config.js",
        "watch": "tsc -w -p .",
        "clean": "rimraf coverage/* && rimraf lib/*",
        "prepublishOnly": "npm run build",
        "build:browser": "browserify ./lib/bundle.umd.js --i apollo-cache --i apollo-utilities --i graphql -o=./lib/bundle.js && npm run minify:browser",
        "minify:browser": "uglifyjs -c -m -o ./lib/bundle.min.js -- ./lib/bundle.js",
        "filesize": "npm run build:browser"
      },
      "dependencies": {
        "apollo-cache": "^1.1.2",
        "apollo-utilities": "^1.0.6",
        "graphql-anywhere": "^4.1.3"
      },
      "peerDependencies": {
        "graphql": "0.11.7 || ^0.12.0"
      },
      "devDependencies": {
        "@types/graphql": "0.12.3",
        "@types/jest": "21.1.10",
        "@types/lodash": "4.14.97",
        "browserify": "15.2.0",
        "graphql": "0.12.3",
        "graphql-tag": "2.6.1",
        "jest": "20.0.4",
        "lodash": "4.17.4",
        "rimraf": "2.6.2",
        "rollup": "0.55.1",
        "ts-jest": "20.0.14",
        "tslint": "5.9.1",
        "typescript": "2.5.2",
        "uglifyjs": "2.4.11"
      },
      "jest": {
        "transform": {
          ".(ts|tsx)": "<rootDir>/node_modules/ts-jest/preprocessor.js"
        },
        "testRegex": "(/__tests__/.*|\\.(test|spec))\\.(ts|tsx|js)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "json"
        ]
      },
      "_id": "apollo-cache-inmemory@1.1.7",
      "_npmVersion": "5.6.0",
      "_nodeVersion": "9.4.0",
      "_npmUser": {
        "name": "jbaxleyiii",
        "email": "james@meteor.com"
      },
      "dist": {
        "integrity": "sha512-qckP7ptk03qvk1UR1/tiy+vVswFyF2Ix06T53RxWLCeWuXvFfEM0mzmcAwGA0Rh3qC3p/GkQTmADJ/9pnltCkg==",
        "shasum": "15e6200f70431414d29bd5f20e86d81739e26430",
        "tarball": "https://registry.npmjs.org/apollo-cache-inmemory/-/apollo-cache-inmemory-1.1.7.tgz",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIBLoqy0AhSM7McAH0A3dkCrJlPXPgnRS4FuVzHej9G7CAiEAjLPHQbYYA5gm2BvHlHVNbjWgVHnXj/gLVjwlq8KMB2E="
          }
        ]
      },
      "maintainers": [
        {
          "email": "peggyrayzis@gmail.com",
          "name": "peggyrayzis"
        },
        {
          "email": "james@meteor.com",
          "name": "jbaxleyiii"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/apollo-cache-inmemory-1.1.7.tgz_1517587227888_0.3937000564765185"
      },
      "directories": {}
    },
    "1.1.8": {
      "name": "apollo-cache-inmemory",
      "version": "1.1.8",
      "description": "Core abstract of Caching layer for Apollo Client",
      "author": {
        "name": "James Baxley",
        "email": "james@meteor.com"
      },
      "contributors": [
        {
          "name": "James Baxley",
          "email": "james@meteor.com"
        },
        {
          "name": "Jonas Helfer",
          "email": "jonas@helfer.email"
        },
        {
          "name": "Sashko Stubailo",
          "email": "sashko@stubailo.com"
        }
      ],
      "license": "MIT",
      "main": "./lib/bundle.umd.js",
      "module": "./lib/index.js",
      "jsnext:main": "./lib/index.js",
      "typings": "./lib/index.d.ts",
      "repository": {
        "type": "git",
        "url": "git+https://github.com/apollographql/apollo-client.git"
      },
      "bugs": {
        "url": "https://github.com/apollographql/apollo-client/issues"
      },
      "homepage": "https://github.com/apollographql/apollo-client#readme",
      "scripts": {
        "coverage": "jest --coverage",
        "test": "jest",
        "lint": "tslint --type-check -p tsconfig.json src/*.ts",
        "prebuild": "npm run clean",
        "build": "tsc -p .",
        "postbuild": "npm run bundle",
        "bundle": "rollup -c rollup.config.js",
        "watch": "tsc -w -p .",
        "clean": "rimraf coverage/* && rimraf lib/*",
        "prepublishOnly": "npm run build",
        "build:browser": "browserify ./lib/bundle.umd.js --i apollo-cache --i apollo-utilities --i graphql -o=./lib/bundle.js && npm run minify:browser",
        "minify:browser": "uglifyjs -c -m -o ./lib/bundle.min.js -- ./lib/bundle.js",
        "filesize": "npm run build:browser"
      },
      "dependencies": {
        "apollo-cache": "^1.1.3",
        "apollo-utilities": "^1.0.7",
        "graphql-anywhere": "^4.1.4"
      },
      "peerDependencies": {
        "graphql": "0.11.7 || ^0.12.0"
      },
      "devDependencies": {
        "@types/graphql": "0.12.3",
        "@types/jest": "21.1.10",
        "@types/lodash": "4.14.97",
        "browserify": "15.2.0",
        "graphql": "0.12.3",
        "graphql-tag": "2.6.1",
        "jest": "20.0.4",
        "lodash": "4.17.4",
        "rimraf": "2.6.2",
        "rollup": "0.55.5",
        "ts-jest": "20.0.14",
        "tslint": "5.9.1",
        "typescript": "2.5.2",
        "uglifyjs": "2.4.11"
      },
      "jest": {
        "transform": {
          ".(ts|tsx)": "<rootDir>/node_modules/ts-jest/preprocessor.js"
        },
        "testRegex": "(/__tests__/.*|\\.(test|spec))\\.(ts|tsx|js)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "json"
        ]
      },
      "_id": "apollo-cache-inmemory@1.1.8",
      "_npmVersion": "5.3.0",
      "_nodeVersion": "8.4.0",
      "_npmUser": {
        "name": "peggyrayzis",
        "email": "peggyrayzis@gmail.com"
      },
      "dist": {
        "integrity": "sha512-N2uczGD/wqx0uPnRXCGzNlPsdRPGUA0pXet2sZfpQLJqQiASx9iFbJL3lRSGWL0I5d1Td3Edd8osZNLOO0frmQ==",
        "shasum": "7dab68846a674fbe75c7a74641a206fafb2dea30",
        "tarball": "https://registry.npmjs.org/apollo-cache-inmemory/-/apollo-cache-inmemory-1.1.8.tgz",
        "fileCount": 60,
        "unpackedSize": 373490,
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEYCIQC0ATbZQdJh1P6QDy+lYA0Gxprqp/84mzBizPjAesDQxAIhAJwVGNNRcpcFsSmAAyPENXEXYhwS1SSBkE7CUgmjfuof"
          }
        ]
      },
      "maintainers": [
        {
          "email": "james@meteor.com",
          "name": "jbaxleyiii"
        },
        {
          "email": "peggyrayzis@gmail.com",
          "name": "peggyrayzis"
        }
      ],
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/apollo-cache-inmemory_1.1.8_1518639392595_0.36894307484810773"
      },
      "_hasShrinkwrap": false
    },
    "1.1.9": {
      "name": "apollo-cache-inmemory",
      "version": "1.1.9",
      "description": "Core abstract of Caching layer for Apollo Client",
      "author": {
        "name": "James Baxley",
        "email": "james@meteor.com"
      },
      "contributors": [
        {
          "name": "James Baxley",
          "email": "james@meteor.com"
        },
        {
          "name": "Jonas Helfer",
          "email": "jonas@helfer.email"
        },
        {
          "name": "Sashko Stubailo",
          "email": "sashko@stubailo.com"
        }
      ],
      "license": "MIT",
      "main": "./lib/bundle.umd.js",
      "module": "./lib/index.js",
      "jsnext:main": "./lib/index.js",
      "typings": "./lib/index.d.ts",
      "repository": {
        "type": "git",
        "url": "git+https://github.com/apollographql/apollo-client.git"
      },
      "bugs": {
        "url": "https://github.com/apollographql/apollo-client/issues"
      },
      "homepage": "https://github.com/apollographql/apollo-client#readme",
      "scripts": {
        "coverage": "jest --coverage",
        "test": "jest",
        "lint": "tslint --type-check -p tsconfig.json src/*.ts",
        "prebuild": "npm run clean",
        "build": "tsc -p .",
        "postbuild": "npm run bundle",
        "bundle": "rollup -c rollup.config.js",
        "watch": "tsc -w -p .",
        "clean": "rimraf coverage/* && rimraf lib/*",
        "prepublishOnly": "npm run build",
        "build:browser": "browserify ./lib/bundle.umd.js --i apollo-cache --i apollo-utilities --i graphql -o=./lib/bundle.js && npm run minify:browser",
        "minify:browser": "uglifyjs -c -m -o ./lib/bundle.min.js -- ./lib/bundle.js",
        "filesize": "npm run build:browser"
      },
      "dependencies": {
        "apollo-cache": "^1.1.4",
        "apollo-utilities": "^1.0.8",
        "graphql-anywhere": "^4.1.5"
      },
      "peerDependencies": {
        "graphql": "0.11.7 || ^0.12.0"
      },
      "devDependencies": {
        "@types/graphql": "0.12.3",
        "@types/jest": "21.1.10",
        "@types/lodash": "4.14.97",
        "browserify": "15.2.0",
        "graphql": "0.12.3",
        "graphql-tag": "2.6.1",
        "jest": "20.0.4",
        "lodash": "4.17.4",
        "rimraf": "2.6.2",
        "rollup": "0.55.5",
        "ts-jest": "20.0.14",
        "tslint": "5.9.1",
        "typescript": "2.5.2",
        "uglifyjs": "2.4.11"
      },
      "jest": {
        "transform": {
          ".(ts|tsx)": "<rootDir>/node_modules/ts-jest/preprocessor.js"
        },
        "testRegex": "(/__tests__/.*|\\.(test|spec))\\.(ts|tsx|js)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "json"
        ]
      },
      "_id": "apollo-cache-inmemory@1.1.9",
      "_npmVersion": "5.3.0",
      "_nodeVersion": "8.4.0",
      "_npmUser": {
        "name": "peggyrayzis",
        "email": "peggyrayzis@gmail.com"
      },
      "dist": {
        "integrity": "sha512-Bo53czxEg4yblqrzH9ej9sHN6bXQktEKVDNwuAyWcAM8FAUH4ewzsZ+0rF8reN6fyCFKq09z6+vFWLIE2+U8ew==",
        "shasum": "8bcd05e8ec4e7dc5ffda7f68252244cab3197b71",
        "tarball": "https://registry.npmjs.org/apollo-cache-inmemory/-/apollo-cache-inmemory-1.1.9.tgz",
        "fileCount": 60,
        "unpackedSize": 373712,
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIFmjoLiKGerNQEmyN5dQjyAPHlELr+kvKHzbMpVKk4jDAiEA+m3XaxN7JX8nq6rE1ARHML9uhAxQezjbCTvlwjQ8LuI="
          }
        ]
      },
      "maintainers": [
        {
          "email": "james@meteor.com",
          "name": "jbaxleyiii"
        },
        {
          "email": "peggyrayzis@gmail.com",
          "name": "peggyrayzis"
        }
      ],
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/apollo-cache-inmemory_1.1.9_1518652583130_0.9870686233056287"
      },
      "_hasShrinkwrap": false
    },
    "1.1.10": {
      "name": "apollo-cache-inmemory",
      "version": "1.1.10",
      "description": "Core abstract of Caching layer for Apollo Client",
      "author": {
        "name": "James Baxley",
        "email": "james@meteor.com"
      },
      "contributors": [
        {
          "name": "James Baxley",
          "email": "james@meteor.com"
        },
        {
          "name": "Jonas Helfer",
          "email": "jonas@helfer.email"
        },
        {
          "name": "Sashko Stubailo",
          "email": "sashko@stubailo.com"
        },
        {
          "name": "James Burgess",
          "email": "jamesmillerburgess@gmail.com"
        }
      ],
      "license": "MIT",
      "main": "./lib/bundle.umd.js",
      "module": "./lib/index.js",
      "jsnext:main": "./lib/index.js",
      "typings": "./lib/index.d.ts",
      "repository": {
        "type": "git",
        "url": "git+https://github.com/apollographql/apollo-client.git"
      },
      "bugs": {
        "url": "https://github.com/apollographql/apollo-client/issues"
      },
      "homepage": "https://github.com/apollographql/apollo-client#readme",
      "scripts": {
        "coverage": "jest --coverage",
        "test": "jest",
        "lint": "tslint --type-check -p tsconfig.json src/*.ts",
        "prebuild": "npm run clean",
        "build": "tsc -p .",
        "postbuild": "npm run bundle",
        "bundle": "rollup -c rollup.config.js",
        "watch": "tsc -w -p .",
        "clean": "rimraf coverage/* && rimraf lib/*",
        "prepublishOnly": "npm run build",
        "build:browser": "browserify ./lib/bundle.umd.js --i apollo-cache --i apollo-utilities --i graphql -o=./lib/bundle.js && npm run minify:browser",
        "minify:browser": "uglifyjs -c -m -o ./lib/bundle.min.js -- ./lib/bundle.js",
        "filesize": "npm run build:browser"
      },
      "dependencies": {
        "apollo-cache": "^1.1.5",
        "apollo-utilities": "^1.0.9",
        "graphql-anywhere": "^4.1.6"
      },
      "peerDependencies": {
        "graphql": "0.11.7 || ^0.12.0 || ^0.13.0"
      },
      "devDependencies": {
        "@types/graphql": "0.12.4",
        "@types/jest": "21.1.10",
        "@types/lodash": "4.14.102",
        "browserify": "15.2.0",
        "graphql": "0.13.1",
        "graphql-tag": "2.8.0",
        "jest": "20.0.4",
        "lodash": "4.17.5",
        "rimraf": "2.6.2",
        "rollup": "0.56.4",
        "ts-jest": "20.0.14",
        "tslint": "5.9.1",
        "typescript": "2.5.2",
        "uglifyjs": "2.4.11"
      },
      "jest": {
        "transform": {
          ".(ts|tsx)": "<rootDir>/node_modules/ts-jest/preprocessor.js"
        },
        "testRegex": "(/__tests__/.*|\\.(test|spec))\\.(ts|tsx|js)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "json"
        ],
        "mapCoverage": true
      },
      "_id": "apollo-cache-inmemory@1.1.10",
      "_npmVersion": "5.3.0",
      "_nodeVersion": "8.4.0",
      "_npmUser": {
        "name": "peggyrayzis",
        "email": "peggyrayzis@gmail.com"
      },
      "dist": {
        "integrity": "sha512-fGwP/wn9Y0DG942FmEX2Z58f5dquqb9ERpFGhjijSt92vHudDxgoHgNbng2H7Y/pqsOo8ixgL8t8d4+uItIyVg==",
        "shasum": "472442c6c59395159ae7d686ea33056248b26125",
        "tarball": "https://registry.npmjs.org/apollo-cache-inmemory/-/apollo-cache-inmemory-1.1.10.tgz",
        "fileCount": 60,
        "unpackedSize": 373837,
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIAWPIzTRAmFBlobNHbu/l5GFRG/AccGTBkMDG8xOiK1DAiEAtA/a7/zLS5MgaelB2eRWNkSwVDkiB/TtYCmGbeuMs/s="
          }
        ]
      },
      "maintainers": [
        {
          "email": "james@meteor.com",
          "name": "jbaxleyiii"
        },
        {
          "email": "peggyrayzis@gmail.com",
          "name": "peggyrayzis"
        }
      ],
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/apollo-cache-inmemory_1.1.10_1520355742755_0.07899792505101577"
      },
      "_hasShrinkwrap": false
    },
    "1.1.11": {
      "name": "apollo-cache-inmemory",
      "version": "1.1.11",
      "description": "Core abstract of Caching layer for Apollo Client",
      "author": {
        "name": "James Baxley",
        "email": "james@meteor.com"
      },
      "contributors": [
        {
          "name": "James Baxley",
          "email": "james@meteor.com"
        },
        {
          "name": "Jonas Helfer",
          "email": "jonas@helfer.email"
        },
        {
          "name": "Sashko Stubailo",
          "email": "sashko@stubailo.com"
        },
        {
          "name": "James Burgess",
          "email": "jamesmillerburgess@gmail.com"
        }
      ],
      "license": "MIT",
      "main": "./lib/bundle.umd.js",
      "module": "./lib/index.js",
      "jsnext:main": "./lib/index.js",
      "typings": "./lib/index.d.ts",
      "repository": {
        "type": "git",
        "url": "git+https://github.com/apollographql/apollo-client.git"
      },
      "bugs": {
        "url": "https://github.com/apollographql/apollo-client/issues"
      },
      "homepage": "https://github.com/apollographql/apollo-client#readme",
      "scripts": {
        "coverage": "jest --coverage",
        "test": "jest",
        "lint": "tslint --type-check -p tsconfig.json src/*.ts",
        "prebuild": "npm run clean",
        "build": "tsc -p .",
        "postbuild": "npm run bundle",
        "bundle": "rollup -c rollup.config.js",
        "watch": "tsc -w -p .",
        "clean": "rimraf coverage/* && rimraf lib/*",
        "prepublishOnly": "npm run build",
        "build:browser": "browserify ./lib/bundle.umd.js --i apollo-cache --i apollo-utilities --i graphql -o=./lib/bundle.js && npm run minify:browser",
        "minify:browser": "uglifyjs -c -m -o ./lib/bundle.min.js -- ./lib/bundle.js",
        "filesize": "npm run build:browser"
      },
      "dependencies": {
        "apollo-cache": "^1.1.6",
        "apollo-utilities": "^1.0.10",
        "graphql-anywhere": "^4.1.7"
      },
      "peerDependencies": {
        "graphql": "0.11.7 || ^0.12.0 || ^0.13.0"
      },
      "devDependencies": {
        "@types/graphql": "0.12.4",
        "@types/jest": "21.1.10",
        "@types/lodash": "4.14.102",
        "browserify": "15.2.0",
        "graphql": "0.13.1",
        "graphql-tag": "2.8.0",
        "jest": "20.0.4",
        "lodash": "4.17.5",
        "rimraf": "2.6.2",
        "rollup": "0.56.4",
        "ts-jest": "20.0.14",
        "tslint": "5.9.1",
        "typescript": "2.5.2",
        "uglifyjs": "2.4.11"
      },
      "jest": {
        "transform": {
          ".(ts|tsx)": "<rootDir>/node_modules/ts-jest/preprocessor.js"
        },
        "testRegex": "(/__tests__/.*|\\.(test|spec))\\.(ts|tsx|js)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "json"
        ],
        "mapCoverage": true
      },
      "_id": "apollo-cache-inmemory@1.1.11",
      "_npmVersion": "5.3.0",
      "_nodeVersion": "8.4.0",
      "_npmUser": {
        "name": "peggyrayzis",
        "email": "peggyrayzis@gmail.com"
      },
      "dist": {
        "integrity": "sha512-5GUbnOtVdh6bbYcQuEXeOdWJC1qL1LLhoJWreHQcR7rG8RB230J9bxsfEmPEFMjAfkBCeYKUIlE7kZzu/8q1UQ==",
        "shasum": "2a96ad076f40575d622c4a45b1eeced18b2dc8ec",
        "tarball": "https://registry.npmjs.org/apollo-cache-inmemory/-/apollo-cache-inmemory-1.1.11.tgz",
        "fileCount": 60,
        "unpackedSize": 373815,
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEQCIFl77TMCGLKYGh0AiFNfL+9zJNT7XG2hWwAH5e3y4k80AiBUGDcqde8LC/rf3McChc9lvFOLn03rwGLQU8hSiZGsYA=="
          }
        ]
      },
      "maintainers": [
        {
          "email": "james@meteor.com",
          "name": "jbaxleyiii"
        },
        {
          "email": "peggyrayzis@gmail.com",
          "name": "peggyrayzis"
        }
      ],
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/apollo-cache-inmemory_1.1.11_1520962048353_0.22117076947962233"
      },
      "_hasShrinkwrap": false
    },
    "1.1.12": {
      "name": "apollo-cache-inmemory",
      "version": "1.1.12",
      "description": "Core abstract of Caching layer for Apollo Client",
      "author": {
        "name": "James Baxley",
        "email": "james@meteor.com"
      },
      "contributors": [
        {
          "name": "James Baxley",
          "email": "james@meteor.com"
        },
        {
          "name": "Jonas Helfer",
          "email": "jonas@helfer.email"
        },
        {
          "name": "Sashko Stubailo",
          "email": "sashko@stubailo.com"
        },
        {
          "name": "James Burgess",
          "email": "jamesmillerburgess@gmail.com"
        },
        {
          "name": "Bazyli Brzóska",
          "email": "bazyli.brzoska@gmail.com"
        }
      ],
      "license": "MIT",
      "main": "./lib/bundle.umd.js",
      "module": "./lib/index.js",
      "jsnext:main": "./lib/index.js",
      "typings": "./lib/index.d.ts",
      "repository": {
        "type": "git",
        "url": "git+https://github.com/apollographql/apollo-client.git"
      },
      "bugs": {
        "url": "https://github.com/apollographql/apollo-client/issues"
      },
      "homepage": "https://github.com/apollographql/apollo-client#readme",
      "scripts": {
        "coverage": "jest --coverage",
        "test": "jest",
        "lint": "tslint --type-check -p tsconfig.json src/*.ts",
        "prebuild": "npm run clean",
        "build": "tsc -p .",
        "postbuild": "npm run bundle",
        "bundle": "rollup -c rollup.config.js",
        "watch": "tsc -w -p .",
        "clean": "rimraf coverage/* && rimraf lib/*",
        "prepublishOnly": "npm run build",
        "build:browser": "browserify ./lib/bundle.umd.js --i apollo-cache --i apollo-utilities --i graphql -o=./lib/bundle.js && npm run minify:browser",
        "minify:browser": "uglifyjs -c -m -o ./lib/bundle.min.js -- ./lib/bundle.js",
        "filesize": "npm run build:browser"
      },
      "dependencies": {
        "apollo-cache": "^1.1.7",
        "apollo-utilities": "^1.0.11",
        "graphql-anywhere": "^4.1.8"
      },
      "peerDependencies": {
        "graphql": "0.11.7 || ^0.12.0 || ^0.13.0"
      },
      "devDependencies": {
        "@types/graphql": "0.12.5",
        "@types/jest": "21.1.10",
        "@types/lodash": "4.14.105",
        "browserify": "15.2.0",
        "graphql": "0.13.2",
        "graphql-tag": "2.8.0",
        "jest": "20.0.4",
        "lodash": "4.17.5",
        "rimraf": "2.6.2",
        "rollup": "0.56.4",
        "ts-jest": "20.0.14",
        "tslint": "5.9.1",
        "typescript": "2.5.2",
        "uglifyjs": "2.4.11"
      },
      "jest": {
        "transform": {
          ".(ts|tsx)": "<rootDir>/node_modules/ts-jest/preprocessor.js"
        },
        "testRegex": "(/__tests__/.*|\\.(test|spec))\\.(ts|tsx|js)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "json"
        ]
      },
      "_id": "apollo-cache-inmemory@1.1.12",
      "_npmVersion": "5.8.0",
      "_nodeVersion": "9.4.0",
      "_npmUser": {
        "name": "jbaxleyiii",
        "email": "james@meteor.com"
      },
      "dist": {
        "integrity": "sha512-dcdialPw2n+bj5S5CLmTdEWrl6g1n3rn4mACZJoUxMLyf2lBzuk99I4hfA2BCO4USkbwe69qC99P1I/T4w8WHg==",
        "shasum": "ab489bf046b3e026556ab28bdebb6e010cac9531",
        "tarball": "https://registry.npmjs.org/apollo-cache-inmemory/-/apollo-cache-inmemory-1.1.12.tgz",
        "fileCount": 61,
        "unpackedSize": 410524,
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEQCID7sDuSGFzbxnNWnbHfb5Q0hwFI433ANkuBLz2/UAbmkAiAOezKQBae5tY3vHvQuZDGGBrSlwezC0rNduGqi8jl2cw=="
          }
        ]
      },
      "maintainers": [
        {
          "email": "james@meteor.com",
          "name": "jbaxleyiii"
        },
        {
          "email": "peggyrayzis@gmail.com",
          "name": "peggyrayzis"
        }
      ],
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/apollo-cache-inmemory_1.1.12_1522071366445_0.40759642037929544"
      },
      "_hasShrinkwrap": false
    },
    "1.2.0": {
      "name": "apollo-cache-inmemory",
      "version": "1.2.0",
      "description": "Core abstract of Caching layer for Apollo Client",
      "author": {
        "name": "James Baxley",
        "email": "james@meteor.com"
      },
      "contributors": [
        {
          "name": "James Baxley",
          "email": "james@meteor.com"
        },
        {
          "name": "Jonas Helfer",
          "email": "jonas@helfer.email"
        },
        {
          "name": "Sashko Stubailo",
          "email": "sashko@stubailo.com"
        },
        {
          "name": "James Burgess",
          "email": "jamesmillerburgess@gmail.com"
        },
        {
          "name": "Bazyli Brzóska",
          "email": "bazyli.brzoska@gmail.com"
        }
      ],
      "license": "MIT",
      "main": "./lib/bundle.umd.js",
      "module": "./lib/index.js",
      "jsnext:main": "./lib/index.js",
      "typings": "./lib/index.d.ts",
      "repository": {
        "type": "git",
        "url": "git+https://github.com/apollographql/apollo-client.git"
      },
      "bugs": {
        "url": "https://github.com/apollographql/apollo-client/issues"
      },
      "homepage": "https://github.com/apollographql/apollo-client#readme",
      "scripts": {
        "coverage": "jest --coverage",
        "test": "jest",
        "lint": "tslint --type-check -p tsconfig.json src/*.ts",
        "prebuild": "npm run clean",
        "build": "tsc -p .",
        "postbuild": "npm run bundle",
        "bundle": "rollup -c rollup.config.js",
        "watch": "tsc -w -p .",
        "clean": "rimraf coverage/* && rimraf lib/*",
        "prepublishOnly": "npm run build",
        "build:browser": "browserify ./lib/bundle.umd.js --i apollo-cache --i apollo-utilities --i graphql -o=./lib/bundle.js && npm run minify:browser",
        "minify:browser": "uglifyjs -c -m -o ./lib/bundle.min.js -- ./lib/bundle.js",
        "filesize": "npm run build:browser"
      },
      "dependencies": {
        "apollo-cache": "^1.1.8",
        "apollo-utilities": "^1.0.12",
        "graphql-anywhere": "^4.1.9"
      },
      "peerDependencies": {
        "graphql": "0.11.7 || ^0.12.0 || ^0.13.0"
      },
      "devDependencies": {
        "@types/graphql": "0.12.7",
        "@types/jest": "21.1.10",
        "@types/lodash": "4.14.108",
        "browserify": "15.2.0",
        "graphql": "0.13.2",
        "graphql-tag": "2.9.2",
        "jest": "20.0.4",
        "lodash": "4.17.10",
        "rimraf": "2.6.2",
        "rollup": "0.58.2",
        "ts-jest": "20.0.14",
        "tslint": "5.9.1",
        "typescript": "2.5.2",
        "uglifyjs": "2.4.11"
      },
      "jest": {
        "transform": {
          ".(ts|tsx)": "<rootDir>/node_modules/ts-jest/preprocessor.js"
        },
        "testRegex": "(/__tests__/.*|\\.(test|spec))\\.(ts|tsx|js)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "json"
        ]
      },
      "_id": "apollo-cache-inmemory@1.2.0",
      "_npmVersion": "5.8.0",
      "_nodeVersion": "8.11.1",
      "_npmUser": {
        "name": "benjamn",
        "email": "ben@benjamn.com"
      },
      "dist": {
        "integrity": "sha512-8upCp7SrM2F71CJJy2xhuqSrlbBjfAplZWmCvUrIf8d6XD2L+KBtwKK6LU4N030n6sGsLoandoQN4nP/+Jcz/A==",
        "shasum": "a5b98fd67a810215b2d03e4a924cf0c554d6ebb4",
        "tarball": "https://registry.npmjs.org/apollo-cache-inmemory/-/apollo-cache-inmemory-1.2.0.tgz",
        "fileCount": 61,
        "unpackedSize": 416161,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJa6gMLCRA9TVsSAnZWagAA6O0P/jnHKvei/WoIHWpLkzzi\nml0DMwSFHtm5sCASHUnFN4lSKcRkJGutvFdNuxr2rsSrUIa0abxmt+/1BwSa\nc73rnA3nx8b9aTf+XyoTsaEQQB6ktnk0uYXvVSCaqDji9eH264mVcfafxQLv\nKqhUmKL1vXXP8oGHxKs/U4dLMHUSErC+lg9SuK/CivA6fH1bQs9TKQjfRcZc\n8+eV6g6RyTHJYGGKygQeELJ1OHl4KH1cdsqzmZVMTxxc6EeymUEmCLObDFDg\nxWaUWOP2sy/EVl6Q/25qEqthQwfbRvDk6sNPQ3L5HdARUC5TbYy5N54dNt+K\nICgRKYL1fZ5cSAfb7kS+ZVkARplN2jn3dYDA9cV6ZnIRptJA6VH0wJ80dHmI\nusD43ByROQ5e94gN7T55n+AJbQMyjBSo/0P4FZtlEHTq6Ir+xR8Ya1MlFMpI\nZTnqBMW1hgTE8Nf1cQC3zI5M9LugWmpLRmaiZp9nDQHY7CV0hKUZOjyEqkYC\ntmeEAyXwQYpKch8mbtS5fOih4S9I2Uyi2QHTfU25ckvXZ1McLslVbAiPB1iy\n4UpnvIVvOv6gAInEyG1VvfNu4Omrr2me7Zjkl9qNOWkSup2jlKwAjQpWLNBb\nMzXQxZS8R+HQzZE9g/DHHK2JA27dtD2CHaDV20qufKmpTFBXPEGpCEh3jZs7\nFFea\r\n=C3Ei\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIGAbNsca2+KZ8y/3mrjUl9szU7ECELsPWViYd1INM93OAiEAySVaa/fPX+gZmtw4uv0dTehQ4DDvExMsfq6lX5EB3Hg="
          }
        ]
      },
      "maintainers": [
        {
          "email": "ben@benjamn.com",
          "name": "benjamn"
        },
        {
          "email": "james@meteor.com",
          "name": "jbaxleyiii"
        },
        {
          "email": "npm@meteor.com",
          "name": "mdg"
        },
        {
          "email": "peggyrayzis@gmail.com",
          "name": "peggyrayzis"
        }
      ],
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/apollo-cache-inmemory_1.2.0_1525285641850_0.03151587579951487"
      },
      "_hasShrinkwrap": false
    },
    "1.2.1": {
      "name": "apollo-cache-inmemory",
      "version": "1.2.1",
      "description": "Core abstract of Caching layer for Apollo Client",
      "author": {
        "name": "James Baxley",
        "email": "james@meteor.com"
      },
      "contributors": [
        {
          "name": "James Baxley",
          "email": "james@meteor.com"
        },
        {
          "name": "Jonas Helfer",
          "email": "jonas@helfer.email"
        },
        {
          "name": "Sashko Stubailo",
          "email": "sashko@stubailo.com"
        },
        {
          "name": "James Burgess",
          "email": "jamesmillerburgess@gmail.com"
        },
        {
          "name": "Bazyli Brzóska",
          "email": "bazyli.brzoska@gmail.com"
        }
      ],
      "license": "MIT",
      "main": "./lib/bundle.umd.js",
      "module": "./lib/index.js",
      "jsnext:main": "./lib/index.js",
      "typings": "./lib/index.d.ts",
      "repository": {
        "type": "git",
        "url": "git+https://github.com/apollographql/apollo-client.git"
      },
      "bugs": {
        "url": "https://github.com/apollographql/apollo-client/issues"
      },
      "homepage": "https://github.com/apollographql/apollo-client#readme",
      "scripts": {
        "coverage": "jest --coverage",
        "test": "jest",
        "lint": "tslint --type-check -p tsconfig.json src/*.ts",
        "prebuild": "npm run clean",
        "build": "tsc -p .",
        "postbuild": "npm run bundle",
        "bundle": "rollup -c rollup.config.js",
        "watch": "tsc -w -p .",
        "clean": "rimraf coverage/* && rimraf lib/*",
        "prepublishOnly": "npm run build",
        "build:browser": "browserify ./lib/bundle.umd.js --i apollo-cache --i apollo-utilities --i graphql -o=./lib/bundle.js && npm run minify:browser",
        "minify:browser": "uglifyjs -c -m -o ./lib/bundle.min.js -- ./lib/bundle.js",
        "filesize": "npm run build:browser"
      },
      "dependencies": {
        "apollo-cache": "^1.1.8",
        "apollo-utilities": "^1.0.12",
        "graphql-anywhere": "^4.1.10"
      },
      "peerDependencies": {
        "graphql": "0.11.7 || ^0.12.0 || ^0.13.0"
      },
      "devDependencies": {
        "@types/graphql": "0.12.7",
        "@types/jest": "21.1.10",
        "@types/lodash": "4.14.108",
        "browserify": "15.2.0",
        "graphql": "0.13.2",
        "graphql-tag": "2.9.2",
        "jest": "20.0.4",
        "lodash": "4.17.10",
        "rimraf": "2.6.2",
        "rollup": "0.58.2",
        "ts-jest": "20.0.14",
        "tslint": "5.9.1",
        "typescript": "2.5.2",
        "uglifyjs": "2.4.11"
      },
      "jest": {
        "transform": {
          ".(ts|tsx)": "<rootDir>/node_modules/ts-jest/preprocessor.js"
        },
        "testRegex": "(/__tests__/.*|\\.(test|spec))\\.(ts|tsx|js)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "json"
        ]
      },
      "_id": "apollo-cache-inmemory@1.2.1",
      "_npmVersion": "5.8.0",
      "_nodeVersion": "8.11.1",
      "_npmUser": {
        "name": "benjamn",
        "email": "ben@benjamn.com"
      },
      "dist": {
        "integrity": "sha512-WZ5EGmJqellVX+PPmq0QeqeQJiZCjjfmkp3x+MV3DRMwTzT2jeJYQAYGIzJuq8PjG4V0vljVJK/Ad93PHqzgdQ==",
        "shasum": "1f8222270aa7983eb9d2ac30057196378ab3bb01",
        "tarball": "https://registry.npmjs.org/apollo-cache-inmemory/-/apollo-cache-inmemory-1.2.1.tgz",
        "fileCount": 61,
        "unpackedSize": 416162,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJa7Na3CRA9TVsSAnZWagAAqzgP/1BAeBQJx0C6jISZ+mRX\nwMoYRiH20EnA1x+tu6RqtV1X7rl+SmyjPcj6anEBX03/1R8uuoVLP1CMdIwM\nRca2aVgZ0gslf6WnT/UXa5GTY3BktZJKbtzFc8vv34fDmBAygPEDDspT7tPL\nPnWOJLLABJfW4hP0eVK3glNXinzU7BowcpLeC4x+IDwUSyL1FXkXHJciUQvF\nST2rLb7mBMUOZYOCZdP1F/YOmsKbzGDgay1vOAp9FYLC122p0Y06RRtpOZGf\n7nHbPGE/ilW1niXSi2Tzj+o4EGR0PSn8LE1Nc9hk8hWlpsyyMd8Y3SCZK8K6\nCS4XJCv8eTXwyRaqAsjwLaEHFtkFivCbKQqJOzwWy0RWmjEfb5bqoTDwRztc\nvi8OzkAXBmcby+2SN25kU4dSGPJJm+eishL8W7ugQ4AWqCeSXNYXOcFNjJCX\nLnXO3eq35h567X/GGbDt7g8RtbPXJCrBhVbyYJqxRK7OpZPttGYFA+AKMkao\nmoeUVy+dZjewmsN5bMj36mgyhVJ6Sp+DxeFN55U3b2gg9/LR5otYAMG1iEqj\nWm2I9BhuSdvbnPZqyELAuUhhBTGvSJM0W2/DfcyIJUHnt+LuB+xA/RNYsXVu\n5vmdeFNgeXaoIhZebh/4b9k0rxvDCXYPME4foH85llTmro/+mE5S+UOoUCqw\nzgmn\r\n=DOly\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIQCCRL9h1itkQgMnDqgJKx0KwYtOb+zB7i/uJtIynuHpWwIgDR47efMXEnTZWUl0n0QyKmFObwWDvgygJL1TUy5GUyk="
          }
        ]
      },
      "maintainers": [
        {
          "email": "ben@benjamn.com",
          "name": "benjamn"
        },
        {
          "email": "james@meteor.com",
          "name": "jbaxleyiii"
        },
        {
          "email": "npm@meteor.com",
          "name": "mdg"
        },
        {
          "email": "peggyrayzis@gmail.com",
          "name": "peggyrayzis"
        }
      ],
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/apollo-cache-inmemory_1.2.1_1525470901912_0.9901453045637767"
      },
      "_hasShrinkwrap": false
    },
    "1.2.2": {
      "name": "apollo-cache-inmemory",
      "version": "1.2.2",
      "description": "Core abstract of Caching layer for Apollo Client",
      "author": {
        "name": "James Baxley",
        "email": "james@meteor.com"
      },
      "contributors": [
        {
          "name": "James Baxley",
          "email": "james@meteor.com"
        },
        {
          "name": "Jonas Helfer",
          "email": "jonas@helfer.email"
        },
        {
          "name": "Sashko Stubailo",
          "email": "sashko@stubailo.com"
        },
        {
          "name": "James Burgess",
          "email": "jamesmillerburgess@gmail.com"
        },
        {
          "name": "Bazyli Brzóska",
          "email": "bazyli.brzoska@gmail.com"
        }
      ],
      "license": "MIT",
      "main": "./lib/bundle.umd.js",
      "module": "./lib/index.js",
      "jsnext:main": "./lib/index.js",
      "typings": "./lib/index.d.ts",
      "sideEffects": false,
      "repository": {
        "type": "git",
        "url": "git+https://github.com/apollographql/apollo-client.git"
      },
      "bugs": {
        "url": "https://github.com/apollographql/apollo-client/issues"
      },
      "homepage": "https://github.com/apollographql/apollo-client#readme",
      "scripts": {
        "coverage": "jest --coverage",
        "test": "jest",
        "lint": "tslint --type-check -p tsconfig.json src/*.ts",
        "prebuild": "npm run clean",
        "build": "tsc -p .",
        "postbuild": "npm run bundle",
        "bundle": "rollup -c rollup.config.js",
        "watch": "tsc -w -p .",
        "clean": "rimraf coverage/* && rimraf lib/*",
        "prepublishOnly": "npm run build",
        "build:browser": "browserify ./lib/bundle.umd.js --i apollo-cache --i apollo-utilities --i graphql -o=./lib/bundle.js && npm run minify:browser",
        "minify:browser": "uglifyjs -c -m -o ./lib/bundle.min.js -- ./lib/bundle.js",
        "filesize": "npm run build:browser"
      },
      "dependencies": {
        "apollo-cache": "^1.1.9",
        "apollo-utilities": "^1.0.13",
        "graphql-anywhere": "^4.1.11"
      },
      "peerDependencies": {
        "graphql": "0.11.7 || ^0.12.0 || ^0.13.0"
      },
      "devDependencies": {
        "@types/graphql": "0.12.7",
        "@types/jest": "22.2.3",
        "@types/lodash": "4.14.109",
        "browserify": "15.2.0",
        "graphql": "0.13.2",
        "graphql-tag": "2.9.2",
        "jest": "23.0.0",
        "lodash": "4.17.10",
        "rimraf": "2.6.2",
        "rollup": "0.59.4",
        "ts-jest": "20.0.14",
        "tslint": "5.10.0",
        "typescript": "2.8.3",
        "uglifyjs": "2.4.11"
      },
      "jest": {
        "transform": {
          ".(ts|tsx)": "<rootDir>/node_modules/ts-jest/preprocessor.js"
        },
        "testRegex": "(/__tests__/.*|\\.(test|spec))\\.(ts|tsx|js)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "json"
        ]
      },
      "_id": "apollo-cache-inmemory@1.2.2",
      "_npmVersion": "6.0.0",
      "_nodeVersion": "8.11.1",
      "_npmUser": {
        "name": "hwillson",
        "email": "hugh@octonary.com"
      },
      "dist": {
        "integrity": "sha512-UtkQDqrPJUfMe0/XfZqRiGF11CyOS5PnNmyPxNwUctoWnq8+KgHquAw21TDijlB47sC/ogBk98S25WMPc0D7NA==",
        "shasum": "051b1fec5b3cec1b348bd7ac9c713a72a0bba45b",
        "tarball": "https://registry.npmjs.org/apollo-cache-inmemory/-/apollo-cache-inmemory-1.2.2.tgz",
        "fileCount": 61,
        "unpackedSize": 424097,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJbDgbwCRA9TVsSAnZWagAAW1sP/RytsV8ZYY1RwzUi+1Rh\n3LWqBvVcYSw2RsUs7rUllz69uTaLH8VFr1YNy2YZPGCYQkPTNJE+VuhV9zCe\nqhE3W9hipA1tPvVpvvQUulrLjlP1fuE6p6Vur5DcqSGGd8GyNGRrZTpm62bv\n+UEJ6h3P+saeYEVdoI1CocF7vq/opBhgDAJ47gjQ9NxhQmCARFPjeu6D5JDp\n+0XeLXw2Bb4kLN2lM9rXNww4rn93mqErS5Fz+gqE4OxRY7WKbW6cV8a+403T\ntDq06zUnaHbETsURymwVJ53GVLqoeC7YM4AzYEcWme4J6ddz676d86zLFLly\n+LwBjkJ1T2309s4xbQP/eVgHyqJxeqew77FS+WlNxKfQAPctppAh1uJ6GVys\nM+nF1rZdsEjpoAnpUf4HmwfwClM4qoOnnuvPpLUPusetHEHMbhRAMZyAwwkX\n97+j+O8FN6u+lTWAzjeysy+Hv6c0RGV4PVt0jHgI7IK8jSlAZbdkmX6jpHo6\nFtF/2ZSBRrtcqtfN4k72/m3Jz4geLr9F5xJXiKK1kuYCeobD42edcFzY8R4O\nJcrU8wNu79sN+mPg8ML0ICUjlkp07J4NOIvAVzW9oPTakdyrnHxFx1LRU0zp\nYme2sif3dhmOR52OzG9wWbEY2IY3dBuenANzhtrMXaRLIu/jWHTCSgDzvESI\nBKHO\r\n=PP/Z\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIDU+3y08HHDG+RwQIQThBVI3TI8gUVOK+xsBaXJx5pDxAiEAsmTKCC3N4kpZdELUYMeDRaiadG4ffRSQOLRYuyPvhxM="
          }
        ]
      },
      "maintainers": [
        {
          "email": "ben@benjamn.com",
          "name": "benjamn"
        },
        {
          "email": "james@meteor.com",
          "name": "jbaxleyiii"
        },
        {
          "email": "npm@meteor.com",
          "name": "mdg"
        },
        {
          "email": "peggyrayzis@gmail.com",
          "name": "peggyrayzis"
        }
      ],
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/apollo-cache-inmemory_1.2.2_1527645934863_0.4239652555304021"
      },
      "_hasShrinkwrap": false
    },
    "1.3.0-beta.0": {
      "name": "apollo-cache-inmemory",
      "version": "1.3.0-beta.0",
      "description": "Core abstract of Caching layer for Apollo Client",
      "author": {
        "name": "James Baxley",
        "email": "james@meteor.com"
      },
      "contributors": [
        {
          "name": "James Baxley",
          "email": "james@meteor.com"
        },
        {
          "name": "Jonas Helfer",
          "email": "jonas@helfer.email"
        },
        {
          "name": "Sashko Stubailo",
          "email": "sashko@stubailo.com"
        },
        {
          "name": "James Burgess",
          "email": "jamesmillerburgess@gmail.com"
        },
        {
          "name": "Bazyli Brzóska",
          "email": "bazyli.brzoska@gmail.com"
        }
      ],
      "license": "MIT",
      "main": "./lib/bundle.umd.js",
      "module": "./lib/index.js",
      "jsnext:main": "./lib/index.js",
      "typings": "./lib/index.d.ts",
      "sideEffects": false,
      "repository": {
        "type": "git",
        "url": "git+https://github.com/apollographql/apollo-client.git"
      },
      "bugs": {
        "url": "https://github.com/apollographql/apollo-client/issues"
      },
      "homepage": "https://github.com/apollographql/apollo-client#readme",
      "scripts": {
        "coverage": "jest --coverage",
        "test": "jest",
        "lint": "tslint --type-check -p tsconfig.json src/*.ts",
        "prebuild": "npm run clean",
        "build": "tsc -p .",
        "postbuild": "npm run bundle",
        "bundle": "rollup -c rollup.config.js",
        "watch": "tsc -w -p .",
        "clean": "rimraf coverage/* && rimraf lib/*",
        "prepublishOnly": "npm run build",
        "build:browser": "browserify ./lib/bundle.umd.js --i apollo-cache --i apollo-utilities --i graphql -o=./lib/bundle.js && npm run minify:browser",
        "minify:browser": "uglifyjs -c -m -o ./lib/bundle.min.js -- ./lib/bundle.js",
        "filesize": "npm run build:browser"
      },
      "dependencies": {
        "apollo-cache": "^1.1.9",
        "apollo-utilities": "^1.0.13",
        "optimism": "^0.6.4"
      },
      "peerDependencies": {
        "graphql": "0.11.7 || ^0.12.0 || ^0.13.0"
      },
      "devDependencies": {
        "@types/graphql": "0.12.7",
        "@types/jest": "22.2.3",
        "@types/lodash": "4.14.109",
        "browserify": "15.2.0",
        "graphql": "0.13.2",
        "graphql-tag": "2.9.2",
        "jest": "23.0.0",
        "lodash": "4.17.10",
        "rimraf": "2.6.2",
        "rollup": "0.59.4",
        "ts-jest": "20.0.14",
        "tslint": "5.10.0",
        "typescript": "2.8.3",
        "uglifyjs": "2.4.11"
      },
      "jest": {
        "transform": {
          ".(ts|tsx)": "<rootDir>/node_modules/ts-jest/preprocessor.js"
        },
        "testRegex": "(/__tests__/.*|\\.(test|spec))\\.(ts|tsx|js)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "json"
        ]
      },
      "readme": "---\ntitle: InMemoryCache\ndescription: An explanation of `apollo-cache-inmemory`\n---\n\n`apollo-cache-inmemory` is the recommended cache implementation for Apollo Client 2.0. `InMemoryCache` is a normalized data store that supports all of Apollo Client 1.0's features without the dependency on Redux.\n\nIn some instances, you may need to manipulate the cache directly, such as updating the store after a mutation. We'll cover some common use cases [here](#recipes).\n\n<h2 id=\"installation\">Installation</h2>\n\n```\nnpm install apollo-cache-inmemory --save\n```\n\nAfter installing the package, you'll want to initialize the cache constructor. Then, you can pass in your newly created cache to ApolloClient.\n\n```js\nimport { InMemoryCache } from 'apollo-cache-inmemory';\nimport { HttpLink } from 'apollo-link-http';\nimport ApolloClient from 'apollo-client';\n\nconst cache = new InMemoryCache();\n\nconst client = new ApolloClient({\n  link: new HttpLink(),\n  cache\n});\n```\n\n<h2 id=\"configuration\">Configuration</h2>\n\nThe `InMemoryCache` constructor takes an optional config object with properties to customize your cache:\n\n- addTypename: A boolean to determine whether to add __typename to the document (default: `true`)\n- dataIdFromObject: A function that takes a data object and returns a unique identifier to be used when normalizing the data in the store. Learn more about how to customize `dataIdFromObject` in the [Normalization](#normalization) section.\n- fragmentMatcher: By default, the `InMemoryCache` uses a heuristic fragment matcher. If you are using fragments on unions and interfaces, you will need to use an `IntrospectionFragmentMatcher`. For more information, please read [our guide to setting up fragment matching for unions & interfaces](https://www.apollographql.com/docs/react/advanced/fragments.html#fragment-matcher).\n\n<h2 id=\"normalization\">Normalization</h2>\n\nThe `InMemoryCache` normalizes your data before saving it to the store by splitting the result into individual objects, creating a unique identifier for each object, and storing those objects in a flattened data structure. By default, `InMemoryCache` will attempt to use the commonly found primary keys of `id` and `_id` for the unique identifier if they exist along with `__typename` on an object.\n\nIf `id` and `_id` are not specified, or if `__typename` is not specified, `InMemoryCache` will fall back to the path to the object in the query, such as `ROOT_QUERY.allPeople.0` for the first record returned on the `allPeople` root query.\n\nThis \"getter\" behavior for unique identifiers can be configured manually via the `dataIdFromObject` option passed to the `InMemoryCache` constructor, so you can pick which field is used if some of your data follows unorthodox primary key conventions.\n\nFor example, if you wanted to key off of the `key` field for all of your data, you could configure `dataIdFromObject` like so:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => object.key\n});\n```\n\nThis also allows you to use different unique identifiers for different data types by keying off of the `__typename` property attached to every object typed by GraphQL.  For example:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => {\n    switch (object.__typename) {\n      case 'foo': return object.key; // use `key` as the primary key\n      case 'bar': return object.blah; // use `blah` as the priamry key\n      default: return object.id || object._id; // fall back to `id` and `_id` for all other types\n    }\n  }\n});\n```\n\n<h2 id=\"direct\">Direct Cache Access</h2>\n\nTo interact directly with your cache, you can use the Apollo Client class methods readQuery, readFragment, writeQuery, and writeFragment. These methods are available to us via the [`DataProxy` interface](http://dev.apollodata.com/core/apollo-client-api.html#DataProxy). Accessing these methods will vary slightly based on your view layer implementation. If you are using React, you can wrap your component in the `withApollo` higher order component, which will give you access to `this.props.client`. From there, you can use the methods to control your data.\n\nAny code demonstration in the following sections will assume that we have already initialized an instance of  `ApolloClient` and that we have imported the `gql` tag from `graphql-tag`.\n\n<h3 id=\"readquery\">readQuery</h3>\n\nThe `readQuery` method is very similar to the [`query` method on `ApolloClient`][] except that `readQuery` will _never_ make a request to your GraphQL server. The `query` method, on the other hand, may send a request to your server if the appropriate data is not in your cache whereas `readQuery` will throw an error if the data is not in your cache. `readQuery` will _always_ read from the cache. You can use `readQuery` by giving it a GraphQL query like so:\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo {\n      todo(id: 5) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n});\n```\n\nIf all of the data needed to fulfill this read is in Apollo Client’s normalized data cache then a data object will be returned in the shape of the query you wanted to read. If not all of the data needed to fulfill this read is in Apollo Client’s cache then an error will be thrown instead, so make sure to only read data that you know you have!\n\nYou can also pass variables into `readQuery`.\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo($id: Int!) {\n      todo(id: $id) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n  variables: {\n    id: 5,\n  },\n});\n```\n\n<h3 id=\"readfragment\">readFragment</h3>\n\nThis method allows you great flexibility around the data in your cache. Whereas `readQuery` only allowed you to read data from your root query type, `readFragment` allows you to read data from _any node you have queried_. This is incredibly powerful. You use this method as follows:\n\n```js\nconst todo = client.readFragment({\n  id: ..., // `id` is any id that could be returned by `dataIdFromObject`.\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\nThe first argument is the id of the data you want to read from the cache. That id must be a value that was returned by the `dataIdFromObject` function you defined when initializing `ApolloClient`. So for example if you initialized `ApolloClient` like so:\n\n```js\nconst client = new ApolloClient({\n  ...,\n  dataIdFromObject: object => object.id,\n});\n```\n\n…and you requested a todo before with an id of `5`, then you can read that todo out of your cache with the following:\n\n```js\nconst todo = client.readFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\n> **Note:** Most people add a `__typename` to the id in `dataIdFromObject`. If you do this then don’t forget to add the `__typename` when you are reading a fragment as well. So for example your id may be `Todo_5` and not just `5`.\n\nIf a todo with that id does not exist in the cache you will get `null` back. If a todo of that id does exist in the cache, but that todo does not have the `text` field then an error will be thrown.\n\nThe beauty of `readFragment` is that the todo could have come from anywhere! The todo could have been selected as a singleton (`{ todo(id: 5) { ... } }`), the todo could have come from a list of todos (`{ todos { ... } }`), or the todo could have come from a mutation (`mutation { createTodo { ... } }`). As long as at some point your GraphQL server gave you a todo with the provided id and fields `id`, `text`, and `completed` you can read it from the cache at any part of your code.\n\n<h3 id=\"writequery-and-writefragment\">writeQuery` and `writeFragment</h3>\n\nNot only can you read arbitrary data from the Apollo Client cache, but you can also write any data that you would like to the cache. The methods you use to do this are `writeQuery` and `writeFragment`. They will allow you to change data in your local cache, but it is important to remember that *they will not change any data on your server*. If you reload your environment then changes made with `writeQuery` and `writeFragment` will disappear.\n\nThese methods have the same signature as their `readQuery` and `readFragment` counterparts except they also require an additional `data` variable. So for example, if you wanted to update the `completed` flag locally for your todo with id `'5'` you could execute the following:\n\n```js\nclient.writeFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      completed\n    }\n  `,\n  data: {\n    completed: true,\n  },\n});\n```\n\nAny subscriber to the Apollo Client store will instantly see this update and render new UI accordingly.\n\n> **Note:** Again, remember that using `writeQuery` or `writeFragment` only changes data *locally*. If you reload your environment then changes made with these methods will no longer exist.\n\nOr if you wanted to add a new todo to a list fetched from the server, you could use `readQuery` and `writeQuery` together.\n\n```js\nconst query = gql`\n  query MyTodoAppQuery {\n    todos {\n      id\n      text\n      completed\n    }\n  }\n`;\n\nconst data = client.readQuery({ query });\n\nconst myNewTodo = {\n  id: '6',\n  text: 'Start using Apollo Client.',\n  completed: false,\n};\n\nclient.writeQuery({\n  query,\n  data: {\n    todos: [...data.todos, myNewTodo],\n  },\n});\n```\n\n<h2 id=\"recipes\">Recipes</h2>\n\nHere are some common situations where you would need to access the cache directly. If you're manipulating the cache in an interesting way and would like your example to be featured, please send in a pull request!\n\n<h3 id=\"server\">Server side rendering</h3>\n\nFirst, you will need to initialize an `InMemoryCache` on the server and create an instance of `ApolloClient`. In the initial serialized HTML payload from the server, you should include a script tag that extracts the data from the cache.\n\n```js\n`<script>\n  window.__APOLLO_STATE__=${JSON.stringify(cache.extract())}\n</script>`\n```\n\nOn the client, you can rehydrate the cache using the initial data passed from the server:\n\n```js\ncache: new Cache().restore(window.__APOLLO_STATE__)\n```\n\nIf you would like to learn more about server side rendering, please check our our more in depth guide [here].\n<!---\nTODO (PEGGY): Add link to SSR\n-->\n\n<h3 id=\"server\">Updating the cache after a mutation</h3>\n\nBeing able to read and write to the Apollo cache from anywhere in your application gives you a lot of power over your data. However, there is one place where we most often want to update our cached data: after a mutation. As such, Apollo Client has optimized the experience for updating your cache with the read and write methods after a mutation with the `update` function. Let us say that we have the following GraphQL mutation:\n\n```graphql\nmutation TodoCreateMutation($text: String!) {\n  createTodo(text: $text) {\n    id\n    text\n    completed\n  }\n}\n```\n\nWe may also have the following GraphQL query:\n\n```graphql\nquery TodoAppQuery {\n  todos {\n    id\n    text\n    completed\n  }\n}\n```\n\nAt the end of our mutation we want our query to include the new todo like we had sent our `TodoAppQuery` a second time after the mutation finished without actually sending the query. To do this we can use the `update` function provided as an option of the `client.mutate` method. To update your cache with the mutation just write code that looks like:\n\n```js\n// We assume that the GraphQL operations `TodoCreateMutation` and\n// `TodoAppQuery` have already been defined using the `gql` tag.\n\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    // Read the data from our cache for this query.\n    const data = proxy.readQuery({ query: TodoAppQuery });\n\n    // Add our todo from the mutation to the end.\n    data.todos.push(createTodo);\n\n    // Write our data back to the cache.\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nThe first `proxy` argument is an instance of [`DataProxy`][] has the same four methods that we just learned exist on the Apollo Client: `readQuery`, `readFragment`, `writeQuery`, and `writeFragment`. The reason we call them on a `proxy` object here instead of on our `client` instance is that we can easily apply optimistic updates (which we will demonstrate in a bit). The `proxy` object also provides an isolated transaction which shields you from any other mutations going on at the same time, and the `proxy` object also batches writes together until the very end.\n\nIf you provide an `optimisticResponse` option to the mutation then the `update` function will be run twice. Once immediately after you call `client.mutate` with the data from `optimisticResponse`. After the mutation successfully executes against the server the changes made in the first call to `update` will be rolled back and `update` will be called with the *actual* data returned by the mutation and not just the optimistic response.\n\nPutting it all together:\n\n```js\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  optimisticResponse: {\n    id: -1, // -1 is a temporary id for the optimistic response.\n    text,\n    completed: false,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    const data = proxy.readQuery({ query: TodoAppQuery });\n    data.todos.push(createTodo);\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nAs you can see the `update` function on `client.mutate` provides extra change management functionality specific to the use case of a mutation while still providing you the powerful data control APIs that are available on `client`.\n\nThe `update` function is not a good place for side-effects as it may be called multiple times. Also, you may not call any of the methods on `proxy` asynchronously.\n\n",
      "readmeFilename": "README.md",
      "_id": "apollo-cache-inmemory@1.3.0-beta.0",
      "_npmVersion": "5.10.0",
      "_nodeVersion": "8.11.2",
      "_npmUser": {
        "name": "benjamn",
        "email": "ben@benjamn.com"
      },
      "dist": {
        "integrity": "sha512-ULQ1BB62/eXQDUWmQlDP1EzjEeOo2mqUUGtnPTreGBgQ0AY8B4Rqd0DP6kp/oSY3vCZAGJ10H0bezVh4OH2rqw==",
        "shasum": "c64cd095a1d02334baa698972362daede90857ee",
        "tarball": "https://registry.npmjs.org/apollo-cache-inmemory/-/apollo-cache-inmemory-1.3.0-beta.0.tgz",
        "fileCount": 73,
        "unpackedSize": 449444,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJbH/VRCRA9TVsSAnZWagAATkUP/3uUIPLvammpSg9ALai1\nDjSCOioSBWTnfSNyXUxKX+1i0goAdcTiOTZnQjJX0HxlV92IzbC36Wo6jr9S\nQsODnSWiIslCJLIQm8Ul/Ag0IL+FpbH45SGYRHIHmEkS7sDu48gmaSrCEA77\nR0RL25IplJQUdvpiuJJ+w6omlV34Jt7LPmlJZl2+H1pbqdSJ0mSrXZDSqoPn\nfnHtUk5+OjSIKid1rUsHpxdTy0+eC7qFyqIs9n/QN7p2N1zGWtuoIIRQstlF\n53AybghrYStjYuAnxzKGWGU9maXOZI8tqaWhAdSpYFEaedyEAO58GNUMcwmw\nMZYDx1vGgSBG4Aa2/WeehKzRHuXiJyc7sW+sqz+Je4jZ7meh9gOM4Di0c1PE\nKj/f5ZlMfavkAjgUysOYqzMn5sZD80hZ4WVfGk9ib3J77+mmHYvaHEjkAXim\nk1yhqBNr3D7NR1gqFTyrpeWXi995ZQFB1Y4h3EKXx7w9SpKVhPJowgM98M1G\nzXua1K4ikiQeTRdkRreZw2VnSFct+0VI+UKwrZ4SMeArnzOY1E6PoVqy2894\nQLHiKw25X12wtNnBUOrHydW/rFa4RyFobOFnZ0VfPYC3/bQe4eFz4zPuwt5K\nIYFWz67SDHCng72zAo6ODnHU9ySdHUFEolH2TLAgoMui9qXWlgLs1JLL8Ync\n7F8/\r\n=MMOh\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIQDwK+j+4s8D+/BRlOOKCiENafD/JtQZ/WvdOPfAUNoq7AIgX6C/bKyw2REQdbv3cWNsr61UKaRWh2seGTqxlGjjN14="
          }
        ]
      },
      "maintainers": [
        {
          "email": "ben@benjamn.com",
          "name": "benjamn"
        },
        {
          "email": "james@meteor.com",
          "name": "jbaxleyiii"
        },
        {
          "email": "npm@meteor.com",
          "name": "mdg"
        },
        {
          "email": "peggyrayzis@gmail.com",
          "name": "peggyrayzis"
        }
      ],
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/apollo-cache-inmemory_1.3.0-beta.0_1528821072535_0.5418950150058286"
      },
      "_hasShrinkwrap": false
    },
    "1.2.3": {
      "name": "apollo-cache-inmemory",
      "version": "1.2.3",
      "description": "Core abstract of Caching layer for Apollo Client",
      "author": {
        "name": "James Baxley",
        "email": "james@meteor.com"
      },
      "contributors": [
        {
          "name": "James Baxley",
          "email": "james@meteor.com"
        },
        {
          "name": "Jonas Helfer",
          "email": "jonas@helfer.email"
        },
        {
          "name": "Sashko Stubailo",
          "email": "sashko@stubailo.com"
        },
        {
          "name": "James Burgess",
          "email": "jamesmillerburgess@gmail.com"
        },
        {
          "name": "Bazyli Brzóska",
          "email": "bazyli.brzoska@gmail.com"
        }
      ],
      "license": "MIT",
      "main": "./lib/bundle.umd.js",
      "module": "./lib/index.js",
      "jsnext:main": "./lib/index.js",
      "typings": "./lib/index.d.ts",
      "sideEffects": false,
      "repository": {
        "type": "git",
        "url": "git+https://github.com/apollographql/apollo-client.git"
      },
      "bugs": {
        "url": "https://github.com/apollographql/apollo-client/issues"
      },
      "homepage": "https://github.com/apollographql/apollo-client#readme",
      "scripts": {
        "coverage": "jest --coverage",
        "test": "jest",
        "lint": "tslint --type-check -p tsconfig.json src/*.ts",
        "prebuild": "npm run clean",
        "build": "tsc -p .",
        "postbuild": "npm run bundle",
        "bundle": "rollup -c rollup.config.js",
        "watch": "tsc -w -p .",
        "clean": "rimraf coverage/* && rimraf lib/*",
        "prepublishOnly": "npm run build",
        "build:browser": "browserify ./lib/bundle.umd.js --i apollo-cache --i apollo-utilities --i graphql -o=./lib/bundle.js && npm run minify:browser",
        "minify:browser": "uglifyjs -c -m -o ./lib/bundle.min.js -- ./lib/bundle.js",
        "filesize": "npm run build:browser"
      },
      "dependencies": {
        "apollo-cache": "^1.1.10",
        "apollo-utilities": "^1.0.14",
        "graphql-anywhere": "^4.1.12"
      },
      "peerDependencies": {
        "graphql": "0.11.7 || ^0.12.0 || ^0.13.0"
      },
      "devDependencies": {
        "@types/graphql": "0.12.7",
        "@types/jest": "22.2.3",
        "@types/lodash": "4.14.109",
        "browserify": "15.2.0",
        "graphql": "0.13.2",
        "graphql-tag": "2.9.2",
        "jest": "23.0.0",
        "lodash": "4.17.10",
        "rimraf": "2.6.2",
        "rollup": "0.59.4",
        "ts-jest": "20.0.14",
        "tslint": "5.10.0",
        "typescript": "2.8.3",
        "uglifyjs": "2.4.11"
      },
      "jest": {
        "transform": {
          ".(ts|tsx)": "<rootDir>/node_modules/ts-jest/preprocessor.js"
        },
        "testRegex": "(/__tests__/.*|\\.(test|spec))\\.(ts|tsx|js)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "json"
        ]
      },
      "_id": "apollo-cache-inmemory@1.2.3",
      "_npmVersion": "6.0.0",
      "_nodeVersion": "8.11.1",
      "_npmUser": {
        "name": "mdg",
        "email": "npm@meteor.com"
      },
      "dist": {
        "integrity": "sha512-72tqFjI/Vhy/dU+F/EhVXNDakegFd29gRA+lonuOBKozx9iBny5m1yzXX9oAjorpR6Bdx6Vt0dWT8LpWL/2rew==",
        "shasum": "873915049dc0f5bbea808d314223eae235d155cd",
        "tarball": "https://registry.npmjs.org/apollo-cache-inmemory/-/apollo-cache-inmemory-1.2.3.tgz",
        "fileCount": 61,
        "unpackedSize": 427314,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJbIPOxCRA9TVsSAnZWagAAO10QAKLt8TboojR3QYc1xxzY\nlJhE0lIYSTx3rBKIoZ03sOJBr/9FFU1nO0qqrQwNnqtJSLFUBaIJn/CWooSG\nWf4mhp4hB1LvECPdg+jRlzvGuXEf3rrGni7/dl9GMiNYt60WF3xrIcKns7eZ\n9taHjn4fzCGF/X8dCp5SmVaS0wF6O4Ht3Qq5L+zHUzVr36qniaHN5lF/c3+K\nLZW1GRUT8UGAMyt4KpgaSlgmF7rFcq4vb44MvNUU/N9pimSEuwcQumou0oko\npQfs0kUEb/Or3k0HB6cu1TvCNWh0rJF0q+bML6DaXBxGmk3rEvCeBxJui3BS\nE2tezABoMDcwhzvDfb4xrGQ3aPC/gMUVaUmK++aJJEbW+khUMbpVsWyL6bQh\nSpZ7y/D0JVdK1rcNWAi3bNKxL4psL3ECVGnz1hincGDtsjY+b3IAPwum5AbV\nmA76HhjLBCaBUM1nv4n3/I0RTW6S5bNJEJaa3PtBAzPnQ7Z4gKYig97eRSOK\nej2dmgP04+DHO36a2FLith9IRLyKjMK7o0LmQOpaic3UQ+OPpa3dmfNTd6nB\n9bCDszZv+TfVBaQr3MYfacEYpVyonz1yofilHYyl6K2vNXqnCDcR4O4Cnufu\nk+l7lC4VaS/iljYENp90jbpzI16Zu4AQNJGmgwp3QnEdfe131lO1RCRZCKKH\nSlF/\r\n=Beat\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIQDCXpuzUL4P4p5+XZZfXyc6dlMP7HMNiiKu5j0Y2NCCBAIgFvIFUYMzPWoU6NYc20Lzm92Ndk/OuSr234Q/4RgzHEY="
          }
        ]
      },
      "maintainers": [
        {
          "email": "ben@benjamn.com",
          "name": "benjamn"
        },
        {
          "email": "james@meteor.com",
          "name": "jbaxleyiii"
        },
        {
          "email": "npm@meteor.com",
          "name": "mdg"
        },
        {
          "email": "peggyrayzis@gmail.com",
          "name": "peggyrayzis"
        }
      ],
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/apollo-cache-inmemory_1.2.3_1528886191441_0.9040318357872605"
      },
      "_hasShrinkwrap": false
    },
    "1.2.4": {
      "name": "apollo-cache-inmemory",
      "version": "1.2.4",
      "description": "Core abstract of Caching layer for Apollo Client",
      "author": {
        "name": "James Baxley",
        "email": "james@meteor.com"
      },
      "contributors": [
        {
          "name": "James Baxley",
          "email": "james@meteor.com"
        },
        {
          "name": "Jonas Helfer",
          "email": "jonas@helfer.email"
        },
        {
          "name": "Sashko Stubailo",
          "email": "sashko@stubailo.com"
        },
        {
          "name": "James Burgess",
          "email": "jamesmillerburgess@gmail.com"
        },
        {
          "name": "Bazyli Brzóska",
          "email": "bazyli.brzoska@gmail.com"
        }
      ],
      "license": "MIT",
      "main": "./lib/bundle.umd.js",
      "module": "./lib/index.js",
      "jsnext:main": "./lib/index.js",
      "typings": "./lib/index.d.ts",
      "sideEffects": false,
      "repository": {
        "type": "git",
        "url": "git+https://github.com/apollographql/apollo-client.git"
      },
      "bugs": {
        "url": "https://github.com/apollographql/apollo-client/issues"
      },
      "homepage": "https://github.com/apollographql/apollo-client#readme",
      "scripts": {
        "coverage": "jest --coverage",
        "test": "jest",
        "lint": "tslint --type-check -p tsconfig.json src/*.ts",
        "prebuild": "npm run clean",
        "build": "tsc -p .",
        "postbuild": "npm run bundle",
        "bundle": "rollup -c rollup.config.js",
        "watch": "tsc -w -p .",
        "clean": "rimraf coverage/* && rimraf lib/*",
        "prepublishOnly": "npm run build",
        "build:browser": "browserify ./lib/bundle.umd.js --i apollo-cache --i apollo-utilities --i graphql -o=./lib/bundle.js && npm run minify:browser",
        "minify:browser": "uglifyjs -c -m -o ./lib/bundle.min.js -- ./lib/bundle.js",
        "filesize": "npm run build:browser"
      },
      "dependencies": {
        "apollo-cache": "^1.1.11",
        "apollo-utilities": "^1.0.15",
        "graphql-anywhere": "^4.1.13"
      },
      "peerDependencies": {
        "graphql": "0.11.7 || ^0.12.0 || ^0.13.0"
      },
      "devDependencies": {
        "@types/graphql": "0.12.7",
        "@types/jest": "22.2.3",
        "@types/lodash": "4.14.109",
        "browserify": "15.2.0",
        "graphql": "0.13.2",
        "graphql-tag": "2.9.2",
        "jest": "23.0.0",
        "lodash": "4.17.10",
        "rimraf": "2.6.2",
        "rollup": "0.59.4",
        "ts-jest": "20.0.14",
        "tslint": "5.10.0",
        "typescript": "2.8.3",
        "uglifyjs": "2.4.11"
      },
      "jest": {
        "transform": {
          ".(ts|tsx)": "<rootDir>/node_modules/ts-jest/preprocessor.js"
        },
        "testRegex": "(/__tests__/.*|\\.(test|spec))\\.(ts|tsx|js)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "json"
        ]
      },
      "_id": "apollo-cache-inmemory@1.2.4",
      "_npmVersion": "6.0.0",
      "_nodeVersion": "8.11.1",
      "_npmUser": {
        "name": "mdg",
        "email": "npm@meteor.com"
      },
      "dist": {
        "integrity": "sha512-F1dsS3S6WMcX1eoykltryPwV3LHZKUJgBgLcUBJjpvDu6C8cdE+aN6V6rbIm76lNWZKncy8afs+0brn0a+TUUQ==",
        "shasum": "452e731a6777756d744d493a3223cf04f8e50c9b",
        "tarball": "https://registry.npmjs.org/apollo-cache-inmemory/-/apollo-cache-inmemory-1.2.4.tgz",
        "fileCount": 61,
        "unpackedSize": 427343,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJbIc4TCRA9TVsSAnZWagAANxsP/AvIeNGpIiPGD/u492Lq\n1U4Jlg7W1FAjf8zFHMIeNW49IPeNoWnR6Gxv08KBFCcQI55WV/f+1bOtvL5b\n4Z2NvrjMtKDqCvZjxiPQeEYvHIuEZzkG77akvHAFEs6rDCVS3UlXvCfGpUeZ\nQINhtv7ZYtDKMt6A4KbaeAOU26snGxwJF2CtmRPSjpCP5W2XfBnNJpA/fslP\nBBjPMCfBrZdCp+LwmOiiyUPn+DGe/w9PRDRyPZthZEx0gEznngtCJf7vc8Ck\nScvaHce+/eNaJJP6hRv1wMy1HATdwpUaY6zYd4zEKz1Bixf+xoeDR0UKrjUU\nmSzwYr4wNDYOiqQ233PMQm8tVOfMp3jqjIav4lbMlVvMMxf5bCWkepHuTBN4\nyOylfpeYvpiTKvC3mtgBPYeLTE4NVA4HRbtSGyzwjVT6AV9tHl6W8qh0bTu2\nu5Lw4IfpFY1HPxZzvWTp7yyCVdBHUsBR5OuxVNpURwdI/UbnuBnWYkU1EyD0\n2KWvRlLyhD2qlrUkZySbPM/Yfrzi957YsmpFHVhhfjkEZs4a/Kag0ilwHxIx\nZezHPJniAFLSZQNl1ajtSSA4yMckcp7Kb5XY8rBL2LZUHSbPdGSrKfO3Pr3Z\n2r8P6JCWUMudvmVcsQt6PjUH+vJD4v4zQ1NPKvv3C440ZHbLMgLUnf0oot2b\nJCxy\r\n=cMBc\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEQCIFgaFzEBhiXKIkfGqB0Ni9kY/GUPWK+mtyKR/5JSMbsyAiB3Cp10mdIoQZj7sQwz43S3OtG6FPJ6MD7SiEWG7+C9Zw=="
          }
        ]
      },
      "maintainers": [
        {
          "email": "ben@benjamn.com",
          "name": "benjamn"
        },
        {
          "email": "james@meteor.com",
          "name": "jbaxleyiii"
        },
        {
          "email": "npm@meteor.com",
          "name": "mdg"
        },
        {
          "email": "peggyrayzis@gmail.com",
          "name": "peggyrayzis"
        }
      ],
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/apollo-cache-inmemory_1.2.4_1528942097981_0.8813755742811424"
      },
      "_hasShrinkwrap": false
    },
    "1.3.0-beta.1": {
      "name": "apollo-cache-inmemory",
      "version": "1.3.0-beta.1",
      "description": "Core abstract of Caching layer for Apollo Client",
      "author": {
        "name": "James Baxley",
        "email": "james@meteor.com"
      },
      "contributors": [
        {
          "name": "James Baxley",
          "email": "james@meteor.com"
        },
        {
          "name": "Jonas Helfer",
          "email": "jonas@helfer.email"
        },
        {
          "name": "Sashko Stubailo",
          "email": "sashko@stubailo.com"
        },
        {
          "name": "James Burgess",
          "email": "jamesmillerburgess@gmail.com"
        },
        {
          "name": "Bazyli Brzóska",
          "email": "bazyli.brzoska@gmail.com"
        }
      ],
      "license": "MIT",
      "main": "./lib/bundle.umd.js",
      "module": "./lib/index.js",
      "jsnext:main": "./lib/index.js",
      "typings": "./lib/index.d.ts",
      "sideEffects": false,
      "repository": {
        "type": "git",
        "url": "git+https://github.com/apollographql/apollo-client.git"
      },
      "bugs": {
        "url": "https://github.com/apollographql/apollo-client/issues"
      },
      "homepage": "https://github.com/apollographql/apollo-client#readme",
      "scripts": {
        "coverage": "jest --coverage",
        "test": "jest",
        "lint": "tslint --type-check -p tsconfig.json src/*.ts",
        "prebuild": "npm run clean",
        "build": "tsc -p .",
        "postbuild": "npm run bundle",
        "bundle": "rollup -c rollup.config.js",
        "watch": "tsc -w -p .",
        "clean": "rimraf coverage/* && rimraf lib/*",
        "prepublishOnly": "npm run build",
        "build:browser": "browserify ./lib/bundle.umd.js --i apollo-cache --i apollo-utilities --i graphql -o=./lib/bundle.js && npm run minify:browser",
        "minify:browser": "uglifyjs -c -m -o ./lib/bundle.min.js -- ./lib/bundle.js",
        "filesize": "npm run build:browser"
      },
      "dependencies": {
        "apollo-cache": "^1.1.11",
        "apollo-utilities": "^1.0.15",
        "optimism": "^0.6.4"
      },
      "peerDependencies": {
        "graphql": "0.11.7 || ^0.12.0 || ^0.13.0"
      },
      "devDependencies": {
        "@types/graphql": "0.12.7",
        "@types/jest": "22.2.3",
        "@types/lodash": "4.14.109",
        "browserify": "15.2.0",
        "graphql": "0.13.2",
        "graphql-tag": "2.9.2",
        "jest": "23.0.0",
        "lodash": "4.17.10",
        "rimraf": "2.6.2",
        "rollup": "0.59.4",
        "ts-jest": "20.0.14",
        "tslint": "5.10.0",
        "typescript": "2.8.3",
        "uglifyjs": "2.4.11"
      },
      "jest": {
        "transform": {
          ".(ts|tsx)": "<rootDir>/node_modules/ts-jest/preprocessor.js"
        },
        "testRegex": "(/__tests__/.*|\\.(test|spec))\\.(ts|tsx|js)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "json"
        ]
      },
      "readme": "---\ntitle: InMemoryCache\ndescription: An explanation of `apollo-cache-inmemory`\n---\n\n`apollo-cache-inmemory` is the recommended cache implementation for Apollo Client 2.0. `InMemoryCache` is a normalized data store that supports all of Apollo Client 1.0's features without the dependency on Redux.\n\nIn some instances, you may need to manipulate the cache directly, such as updating the store after a mutation. We'll cover some common use cases [here](#recipes).\n\n<h2 id=\"installation\">Installation</h2>\n\n```\nnpm install apollo-cache-inmemory --save\n```\n\nAfter installing the package, you'll want to initialize the cache constructor. Then, you can pass in your newly created cache to ApolloClient.\n\n```js\nimport { InMemoryCache } from 'apollo-cache-inmemory';\nimport { HttpLink } from 'apollo-link-http';\nimport ApolloClient from 'apollo-client';\n\nconst cache = new InMemoryCache();\n\nconst client = new ApolloClient({\n  link: new HttpLink(),\n  cache\n});\n```\n\n<h2 id=\"configuration\">Configuration</h2>\n\nThe `InMemoryCache` constructor takes an optional config object with properties to customize your cache:\n\n- addTypename: A boolean to determine whether to add __typename to the document (default: `true`)\n- dataIdFromObject: A function that takes a data object and returns a unique identifier to be used when normalizing the data in the store. Learn more about how to customize `dataIdFromObject` in the [Normalization](#normalization) section.\n- fragmentMatcher: By default, the `InMemoryCache` uses a heuristic fragment matcher. If you are using fragments on unions and interfaces, you will need to use an `IntrospectionFragmentMatcher`. For more information, please read [our guide to setting up fragment matching for unions & interfaces](https://www.apollographql.com/docs/react/advanced/fragments.html#fragment-matcher).\n\n<h2 id=\"normalization\">Normalization</h2>\n\nThe `InMemoryCache` normalizes your data before saving it to the store by splitting the result into individual objects, creating a unique identifier for each object, and storing those objects in a flattened data structure. By default, `InMemoryCache` will attempt to use the commonly found primary keys of `id` and `_id` for the unique identifier if they exist along with `__typename` on an object.\n\nIf `id` and `_id` are not specified, or if `__typename` is not specified, `InMemoryCache` will fall back to the path to the object in the query, such as `ROOT_QUERY.allPeople.0` for the first record returned on the `allPeople` root query.\n\nThis \"getter\" behavior for unique identifiers can be configured manually via the `dataIdFromObject` option passed to the `InMemoryCache` constructor, so you can pick which field is used if some of your data follows unorthodox primary key conventions.\n\nFor example, if you wanted to key off of the `key` field for all of your data, you could configure `dataIdFromObject` like so:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => object.key\n});\n```\n\nThis also allows you to use different unique identifiers for different data types by keying off of the `__typename` property attached to every object typed by GraphQL.  For example:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => {\n    switch (object.__typename) {\n      case 'foo': return object.key; // use `key` as the primary key\n      case 'bar': return object.blah; // use `blah` as the priamry key\n      default: return object.id || object._id; // fall back to `id` and `_id` for all other types\n    }\n  }\n});\n```\n\n<h2 id=\"direct\">Direct Cache Access</h2>\n\nTo interact directly with your cache, you can use the Apollo Client class methods readQuery, readFragment, writeQuery, and writeFragment. These methods are available to us via the [`DataProxy` interface](http://dev.apollodata.com/core/apollo-client-api.html#DataProxy). Accessing these methods will vary slightly based on your view layer implementation. If you are using React, you can wrap your component in the `withApollo` higher order component, which will give you access to `this.props.client`. From there, you can use the methods to control your data.\n\nAny code demonstration in the following sections will assume that we have already initialized an instance of  `ApolloClient` and that we have imported the `gql` tag from `graphql-tag`.\n\n<h3 id=\"readquery\">readQuery</h3>\n\nThe `readQuery` method is very similar to the [`query` method on `ApolloClient`][] except that `readQuery` will _never_ make a request to your GraphQL server. The `query` method, on the other hand, may send a request to your server if the appropriate data is not in your cache whereas `readQuery` will throw an error if the data is not in your cache. `readQuery` will _always_ read from the cache. You can use `readQuery` by giving it a GraphQL query like so:\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo {\n      todo(id: 5) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n});\n```\n\nIf all of the data needed to fulfill this read is in Apollo Client’s normalized data cache then a data object will be returned in the shape of the query you wanted to read. If not all of the data needed to fulfill this read is in Apollo Client’s cache then an error will be thrown instead, so make sure to only read data that you know you have!\n\nYou can also pass variables into `readQuery`.\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo($id: Int!) {\n      todo(id: $id) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n  variables: {\n    id: 5,\n  },\n});\n```\n\n<h3 id=\"readfragment\">readFragment</h3>\n\nThis method allows you great flexibility around the data in your cache. Whereas `readQuery` only allowed you to read data from your root query type, `readFragment` allows you to read data from _any node you have queried_. This is incredibly powerful. You use this method as follows:\n\n```js\nconst todo = client.readFragment({\n  id: ..., // `id` is any id that could be returned by `dataIdFromObject`.\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\nThe first argument is the id of the data you want to read from the cache. That id must be a value that was returned by the `dataIdFromObject` function you defined when initializing `ApolloClient`. So for example if you initialized `ApolloClient` like so:\n\n```js\nconst client = new ApolloClient({\n  ...,\n  dataIdFromObject: object => object.id,\n});\n```\n\n…and you requested a todo before with an id of `5`, then you can read that todo out of your cache with the following:\n\n```js\nconst todo = client.readFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\n> **Note:** Most people add a `__typename` to the id in `dataIdFromObject`. If you do this then don’t forget to add the `__typename` when you are reading a fragment as well. So for example your id may be `Todo_5` and not just `5`.\n\nIf a todo with that id does not exist in the cache you will get `null` back. If a todo of that id does exist in the cache, but that todo does not have the `text` field then an error will be thrown.\n\nThe beauty of `readFragment` is that the todo could have come from anywhere! The todo could have been selected as a singleton (`{ todo(id: 5) { ... } }`), the todo could have come from a list of todos (`{ todos { ... } }`), or the todo could have come from a mutation (`mutation { createTodo { ... } }`). As long as at some point your GraphQL server gave you a todo with the provided id and fields `id`, `text`, and `completed` you can read it from the cache at any part of your code.\n\n<h3 id=\"writequery-and-writefragment\">writeQuery` and `writeFragment</h3>\n\nNot only can you read arbitrary data from the Apollo Client cache, but you can also write any data that you would like to the cache. The methods you use to do this are `writeQuery` and `writeFragment`. They will allow you to change data in your local cache, but it is important to remember that *they will not change any data on your server*. If you reload your environment then changes made with `writeQuery` and `writeFragment` will disappear.\n\nThese methods have the same signature as their `readQuery` and `readFragment` counterparts except they also require an additional `data` variable. So for example, if you wanted to update the `completed` flag locally for your todo with id `'5'` you could execute the following:\n\n```js\nclient.writeFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      completed\n    }\n  `,\n  data: {\n    completed: true,\n  },\n});\n```\n\nAny subscriber to the Apollo Client store will instantly see this update and render new UI accordingly.\n\n> **Note:** Again, remember that using `writeQuery` or `writeFragment` only changes data *locally*. If you reload your environment then changes made with these methods will no longer exist.\n\nOr if you wanted to add a new todo to a list fetched from the server, you could use `readQuery` and `writeQuery` together.\n\n```js\nconst query = gql`\n  query MyTodoAppQuery {\n    todos {\n      id\n      text\n      completed\n    }\n  }\n`;\n\nconst data = client.readQuery({ query });\n\nconst myNewTodo = {\n  id: '6',\n  text: 'Start using Apollo Client.',\n  completed: false,\n};\n\nclient.writeQuery({\n  query,\n  data: {\n    todos: [...data.todos, myNewTodo],\n  },\n});\n```\n\n<h2 id=\"recipes\">Recipes</h2>\n\nHere are some common situations where you would need to access the cache directly. If you're manipulating the cache in an interesting way and would like your example to be featured, please send in a pull request!\n\n<h3 id=\"server\">Server side rendering</h3>\n\nFirst, you will need to initialize an `InMemoryCache` on the server and create an instance of `ApolloClient`. In the initial serialized HTML payload from the server, you should include a script tag that extracts the data from the cache.\n\n```js\n`<script>\n  window.__APOLLO_STATE__=${JSON.stringify(cache.extract())}\n</script>`\n```\n\nOn the client, you can rehydrate the cache using the initial data passed from the server:\n\n```js\ncache: new Cache().restore(window.__APOLLO_STATE__)\n```\n\nIf you would like to learn more about server side rendering, please check our our more in depth guide [here].\n<!---\nTODO (PEGGY): Add link to SSR\n-->\n\n<h3 id=\"server\">Updating the cache after a mutation</h3>\n\nBeing able to read and write to the Apollo cache from anywhere in your application gives you a lot of power over your data. However, there is one place where we most often want to update our cached data: after a mutation. As such, Apollo Client has optimized the experience for updating your cache with the read and write methods after a mutation with the `update` function. Let us say that we have the following GraphQL mutation:\n\n```graphql\nmutation TodoCreateMutation($text: String!) {\n  createTodo(text: $text) {\n    id\n    text\n    completed\n  }\n}\n```\n\nWe may also have the following GraphQL query:\n\n```graphql\nquery TodoAppQuery {\n  todos {\n    id\n    text\n    completed\n  }\n}\n```\n\nAt the end of our mutation we want our query to include the new todo like we had sent our `TodoAppQuery` a second time after the mutation finished without actually sending the query. To do this we can use the `update` function provided as an option of the `client.mutate` method. To update your cache with the mutation just write code that looks like:\n\n```js\n// We assume that the GraphQL operations `TodoCreateMutation` and\n// `TodoAppQuery` have already been defined using the `gql` tag.\n\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    // Read the data from our cache for this query.\n    const data = proxy.readQuery({ query: TodoAppQuery });\n\n    // Add our todo from the mutation to the end.\n    data.todos.push(createTodo);\n\n    // Write our data back to the cache.\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nThe first `proxy` argument is an instance of [`DataProxy`][] has the same four methods that we just learned exist on the Apollo Client: `readQuery`, `readFragment`, `writeQuery`, and `writeFragment`. The reason we call them on a `proxy` object here instead of on our `client` instance is that we can easily apply optimistic updates (which we will demonstrate in a bit). The `proxy` object also provides an isolated transaction which shields you from any other mutations going on at the same time, and the `proxy` object also batches writes together until the very end.\n\nIf you provide an `optimisticResponse` option to the mutation then the `update` function will be run twice. Once immediately after you call `client.mutate` with the data from `optimisticResponse`. After the mutation successfully executes against the server the changes made in the first call to `update` will be rolled back and `update` will be called with the *actual* data returned by the mutation and not just the optimistic response.\n\nPutting it all together:\n\n```js\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  optimisticResponse: {\n    id: -1, // -1 is a temporary id for the optimistic response.\n    text,\n    completed: false,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    const data = proxy.readQuery({ query: TodoAppQuery });\n    data.todos.push(createTodo);\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nAs you can see the `update` function on `client.mutate` provides extra change management functionality specific to the use case of a mutation while still providing you the powerful data control APIs that are available on `client`.\n\nThe `update` function is not a good place for side-effects as it may be called multiple times. Also, you may not call any of the methods on `proxy` asynchronously.\n\n",
      "readmeFilename": "README.md",
      "_id": "apollo-cache-inmemory@1.3.0-beta.1",
      "_npmVersion": "6.1.0",
      "_nodeVersion": "8.11.3",
      "_npmUser": {
        "name": "benjamn",
        "email": "ben@benjamn.com"
      },
      "dist": {
        "integrity": "sha512-Wx8sJisHSAHFdQ19xd+MEQn290UZQoAteTggz8ehhvveuBeQDUGKX67UhyFVwVsSAVh0NpC8L8wXxoSpV1N99Q==",
        "shasum": "de0a054aad628e62172cf2a837c211795a271167",
        "tarball": "https://registry.npmjs.org/apollo-cache-inmemory/-/apollo-cache-inmemory-1.3.0-beta.1.tgz",
        "fileCount": 73,
        "unpackedSize": 449470,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJbI8bsCRA9TVsSAnZWagAA1bsP/imzxVvzPUPh2BfPppkC\nST51LMqCiGoU7JN6b+PmHIoacWbK0rrXLdWUL+UwHaylxAfB0wpxjz8Tqz/S\nU9B0CvHjvNJTCCvYdIc1zosAGmeKYqiRCJ4btGjY2ZG0gcuvKjnsJbO0qPoX\nKz/ZeZGGYOEmgu2jP41Iv5tgU+Thm6NlGU+tygJdBO4QojKc3hFeXmpWQZcz\nexQQgXI4xPUAPj+KR4ukbywlaMTiih5gih4zwv12qzpAkVIkXW/du5587m0O\nHotfmkTP9OykdmyMCY7lH1vh98SOkw/v5AROc+ecm3f666cUXZVEg3JaIBgL\nIugqMBdn7cLoSaBI0TRKXUPvB2kvfgsqKJzjLiXP5sTYujcco3tJZsVaeHwW\nGxW/XkIX1+94n3MV9t5lIg0F9mC0R8loU979YlsovClsW/qmI8clRJW+rh+W\nBlfcUxWChVVCtqjgF1umXaOBoFaPb5+Qc+Njr7ijmOMpVH8bEPHn88R8EYEX\nEANu6rg7dUXqD2doYiZl2WbIAvHk9SF8epSCfT75LhGjZn5tymLeT9jYQGv1\nyu/LYXsMg8wSOw3tNBce0ji8g07Hp6IU3/CRz3NlQ14D0VQUE8GHX6aYnWEZ\nx2aN/0DoPnG+tDXOIMdIHd6I/XW17hjHiEvY4UT1jfSB2OkVe5FNaxkz7dOU\nhDoa\r\n=T6c6\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIQCiiUKUtJG3QBpgVLx/p9lXLtx8aH5cRF3Y20gb88Y8XQIgdIBWjgeZlGSY8lPXwC7wZZxXFsdbbR3GTbyBipntQI4="
          }
        ]
      },
      "maintainers": [
        {
          "email": "ben@benjamn.com",
          "name": "benjamn"
        },
        {
          "email": "james@meteor.com",
          "name": "jbaxleyiii"
        },
        {
          "email": "npm@meteor.com",
          "name": "mdg"
        },
        {
          "email": "peggyrayzis@gmail.com",
          "name": "peggyrayzis"
        }
      ],
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/apollo-cache-inmemory_1.3.0-beta.1_1529071339779_0.8212176988722333"
      },
      "_hasShrinkwrap": false
    },
    "1.3.0-beta.2": {
      "name": "apollo-cache-inmemory",
      "version": "1.3.0-beta.2",
      "description": "Core abstract of Caching layer for Apollo Client",
      "author": {
        "name": "James Baxley",
        "email": "james@meteor.com"
      },
      "contributors": [
        {
          "name": "James Baxley",
          "email": "james@meteor.com"
        },
        {
          "name": "Jonas Helfer",
          "email": "jonas@helfer.email"
        },
        {
          "name": "Sashko Stubailo",
          "email": "sashko@stubailo.com"
        },
        {
          "name": "James Burgess",
          "email": "jamesmillerburgess@gmail.com"
        },
        {
          "name": "Bazyli Brzóska",
          "email": "bazyli.brzoska@gmail.com"
        }
      ],
      "license": "MIT",
      "main": "./lib/bundle.umd.js",
      "module": "./lib/index.js",
      "jsnext:main": "./lib/index.js",
      "typings": "./lib/index.d.ts",
      "sideEffects": false,
      "repository": {
        "type": "git",
        "url": "git+https://github.com/apollographql/apollo-client.git"
      },
      "bugs": {
        "url": "https://github.com/apollographql/apollo-client/issues"
      },
      "homepage": "https://github.com/apollographql/apollo-client#readme",
      "scripts": {
        "coverage": "jest --coverage",
        "test": "jest",
        "lint": "tslint --type-check -p tsconfig.json src/*.ts",
        "prebuild": "npm run clean",
        "build": "tsc -p .",
        "postbuild": "npm run bundle",
        "bundle": "rollup -c rollup.config.js",
        "watch": "tsc -w -p .",
        "clean": "rimraf coverage/* && rimraf lib/*",
        "prepublishOnly": "npm run build",
        "build:browser": "browserify ./lib/bundle.umd.js --i apollo-cache --i apollo-utilities --i graphql -o=./lib/bundle.js && npm run minify:browser",
        "minify:browser": "uglifyjs -c -m -o ./lib/bundle.min.js -- ./lib/bundle.js",
        "filesize": "npm run build:browser"
      },
      "dependencies": {
        "apollo-cache": "^1.1.11",
        "apollo-utilities": "^1.0.15",
        "optimism": "^0.6.4"
      },
      "peerDependencies": {
        "graphql": "0.11.7 || ^0.12.0 || ^0.13.0"
      },
      "devDependencies": {
        "@types/graphql": "0.12.7",
        "@types/jest": "22.2.3",
        "@types/lodash": "4.14.109",
        "browserify": "15.2.0",
        "graphql": "0.13.2",
        "graphql-tag": "2.9.2",
        "jest": "23.0.0",
        "lodash": "4.17.10",
        "rimraf": "2.6.2",
        "rollup": "0.59.4",
        "ts-jest": "20.0.14",
        "tslint": "5.10.0",
        "typescript": "2.8.3",
        "uglifyjs": "2.4.11"
      },
      "jest": {
        "transform": {
          ".(ts|tsx)": "<rootDir>/node_modules/ts-jest/preprocessor.js"
        },
        "testRegex": "(/__tests__/.*|\\.(test|spec))\\.(ts|tsx|js)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "json"
        ]
      },
      "_id": "apollo-cache-inmemory@1.3.0-beta.2",
      "_npmVersion": "6.1.0",
      "_nodeVersion": "8.11.3",
      "_npmUser": {
        "name": "benjamn",
        "email": "ben@benjamn.com"
      },
      "dist": {
        "integrity": "sha512-mSPEjETnjBK+/qjSs9Tr99s1UKCQN2n5q3fRPLrGEQ2n2rHAga2E0+u7+VfKGZUASQFAWDOAQRoPF8um65a4lQ==",
        "shasum": "35b3686e345a47878eceeff9aee6e0439db7d412",
        "tarball": "https://registry.npmjs.org/apollo-cache-inmemory/-/apollo-cache-inmemory-1.3.0-beta.2.tgz",
        "fileCount": 73,
        "unpackedSize": 450267,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJbJCPnCRA9TVsSAnZWagAAVLwP/R25vQlmx+/DtHnI8fwF\nL/TfUGPlrz2iz6SFL1Zbej3M+2DMzwxioDn3a0P5F21geqMOXGSYFDNE0p7c\nFESpISoNkyi0HSvF52FHUM7sosey9Lfmf/lbe7MN4J7xvmcrfFmQf+mW9wuF\nMUTWut8swJWK9NVKLPknDX6GMwNHoL5b70y5vE26ZIiturrOvsAnjeuEtm6P\n+C2/S2dUITdYUQr9QBLromtTd/S24+DQSbF3d3ckfLqPYiO4aeuyOIR4TyEu\niKP1aSW4Z6XnCLZArXnkJE1tx267Q2BQSYwqgfHOxZOlDu8Bxip0Hvr1c3S/\n43P2F2OedCURxjwP7ZKhPxANorU/RenYPiUXSm3ymBtCMi28P2q85LmjlGAo\nRPmPMrGfGwOfu6JtXnMgBylecS1eFY7VVsC8zklATGYsgS2MV99laZZAVxtf\ng/tPadNo6VpslopChk4v20IxeHJpvCWbsQwO1Aw090SvjRltxIHo1mINk/L2\nLWUpxkp2ZD1qw5nY4UqGAX/RZdMPXVt1gYJi4soQAc/w5zbJ1f3sCTw9bQNE\niX3uE7x26tFSme0L2lR+0mLZamRrAejheqyXo7Xgxlq/qgJwLbo9AXmbLakV\nK3iR1xrda6+MRcV6PKmF2NGWnhDFRB5YR+8lbLxiD65poKZQ2+tXWGzqFkvF\nSC56\r\n=Y1ft\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEYCIQCaU02MuVGoda45oq3vl9gxwPkXGPy+MDds1kaNWg23YwIhAJyMNg9ZZXCOhmQYlSbwEnq7ph4Wx1ZkXc5K2BHA1y0V"
          }
        ]
      },
      "maintainers": [
        {
          "email": "ben@benjamn.com",
          "name": "benjamn"
        },
        {
          "email": "james@meteor.com",
          "name": "jbaxleyiii"
        },
        {
          "email": "npm@meteor.com",
          "name": "mdg"
        },
        {
          "email": "peggyrayzis@gmail.com",
          "name": "peggyrayzis"
        }
      ],
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/apollo-cache-inmemory_1.3.0-beta.2_1529095141477_0.916600266436093"
      },
      "_hasShrinkwrap": false
    },
    "1.2.5": {
      "name": "apollo-cache-inmemory",
      "version": "1.2.5",
      "description": "Core abstract of Caching layer for Apollo Client",
      "author": {
        "name": "James Baxley",
        "email": "james@meteor.com"
      },
      "contributors": [
        {
          "name": "James Baxley",
          "email": "james@meteor.com"
        },
        {
          "name": "Jonas Helfer",
          "email": "jonas@helfer.email"
        },
        {
          "name": "Sashko Stubailo",
          "email": "sashko@stubailo.com"
        },
        {
          "name": "James Burgess",
          "email": "jamesmillerburgess@gmail.com"
        },
        {
          "name": "Bazyli Brzóska",
          "email": "bazyli.brzoska@gmail.com"
        }
      ],
      "license": "MIT",
      "main": "./lib/bundle.umd.js",
      "module": "./lib/index.js",
      "jsnext:main": "./lib/index.js",
      "typings": "./lib/index.d.ts",
      "sideEffects": false,
      "repository": {
        "type": "git",
        "url": "git+https://github.com/apollographql/apollo-client.git"
      },
      "bugs": {
        "url": "https://github.com/apollographql/apollo-client/issues"
      },
      "homepage": "https://github.com/apollographql/apollo-client#readme",
      "scripts": {
        "coverage": "jest --coverage",
        "test": "jest",
        "lint": "tslint --type-check -p tsconfig.json src/*.ts",
        "prebuild": "npm run clean",
        "build": "tsc -p .",
        "postbuild": "npm run bundle",
        "bundle": "rollup -c rollup.config.js",
        "watch": "tsc -w -p .",
        "clean": "rimraf coverage/* && rimraf lib/*",
        "prepublishOnly": "npm run build",
        "build:browser": "browserify ./lib/bundle.umd.js --i apollo-cache --i apollo-utilities --i graphql -o=./lib/bundle.js && npm run minify:browser",
        "minify:browser": "uglifyjs -c -m -o ./lib/bundle.min.js -- ./lib/bundle.js",
        "filesize": "npm run build:browser"
      },
      "dependencies": {
        "apollo-cache": "^1.1.12",
        "apollo-utilities": "^1.0.16",
        "graphql-anywhere": "^4.1.14"
      },
      "peerDependencies": {
        "graphql": "0.11.7 || ^0.12.0 || ^0.13.0"
      },
      "devDependencies": {
        "@types/graphql": "0.12.7",
        "@types/jest": "22.2.3",
        "@types/lodash": "4.14.109",
        "browserify": "15.2.0",
        "graphql": "0.13.2",
        "graphql-tag": "2.9.2",
        "jest": "23.0.0",
        "lodash": "4.17.10",
        "rimraf": "2.6.2",
        "rollup": "0.59.4",
        "ts-jest": "20.0.14",
        "tslint": "5.10.0",
        "typescript": "2.8.3",
        "uglifyjs": "2.4.11"
      },
      "jest": {
        "transform": {
          ".(ts|tsx)": "<rootDir>/node_modules/ts-jest/preprocessor.js"
        },
        "testRegex": "(/__tests__/.*|\\.(test|spec))\\.(ts|tsx|js)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "json"
        ]
      },
      "_id": "apollo-cache-inmemory@1.2.5",
      "_npmVersion": "6.0.0",
      "_nodeVersion": "8.11.1",
      "_npmUser": {
        "name": "mdg",
        "email": "npm@meteor.com"
      },
      "dist": {
        "integrity": "sha512-D9KIT4bq7ORm0BVXjSIxU09SvTUunWKxM63Lvr81hR83I7B7RRM3uFBDUV9VG8rlIGkD+1obBNlW2ycerFV8wQ==",
        "shasum": "b57951947b1db486a60db11c7dcfc6b112e5abe9",
        "tarball": "https://registry.npmjs.org/apollo-cache-inmemory/-/apollo-cache-inmemory-1.2.5.tgz",
        "fileCount": 61,
        "unpackedSize": 427374,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJbKa1qCRA9TVsSAnZWagAAQCoP/3J64Sj0kUMzdIbO9XnH\ncseGSdswKSxG9s94CiPKr8ZE3+ZvlPFuctrYXb6y79PAB7tpPyIJuw5WOCJk\nK3GudqyeoHTspmiYGuAA9rmf8ftboWC6zkLYet1Lg/SR4xGnYRy/Vj/E6F7C\nKkQ0CsOewPszeTl8nr2mLOCTXN1OuaTokh8dPM7n8uCuFFP99/AtZ21jCh2T\nq0+kHSh4iiRPOvKiOeq6yECpWK+kz5n4rFeVUiEbnf794J9bL/j2FbD60ksX\n3l8AE1ahjU9E9Pr40woCe0Aem6o1szCeAj5KzVeB4zweGMs35AINharx7/8g\n45Dlf1JZGi6udMgApckmxF32hwo3RHFc5M3nYhDFe35fmZ0eTuYxyhR4qfAs\nLqBWBg1yqedA0wEB2QdLoqeh6nwYLM0ILi1NpFeiPaxdpZAp7ddqewQxKI4X\nA0lMyvRqtizDEhZ+tQk7jEPrsQTBo4AIip0oReSeXyFEclSvUU+NnnFJPOpO\n9s1zQeVyPA3q0IpIngtiHJv0oX6gTPJiHxoRY59N6BYyim+z3snS6aa0y18Q\nhOjJjiobwBdGmC63sZ/pS10ZRsqW0aw43aO1Q/w/VPBTyy4+FP2uEy8Bi1zc\nZa7yawY7kJwfUv4g9IJSAQ28LUmrdUy+Dj/VNWrwfYneSSIUmP3r3HKPrpO3\nJYAb\r\n=zRS/\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIQDVTaE+qDF9OIlsEyhdW5oaQnSxgS7BFQHuFD/+sdLRhAIgH/WVVJNMBUYiUWZVL17ZBCju94nXV3J3oSvyiE+t/C4="
          }
        ]
      },
      "maintainers": [
        {
          "email": "ben@benjamn.com",
          "name": "benjamn"
        },
        {
          "email": "james@meteor.com",
          "name": "jbaxleyiii"
        },
        {
          "email": "npm@meteor.com",
          "name": "mdg"
        },
        {
          "email": "peggyrayzis@gmail.com",
          "name": "peggyrayzis"
        }
      ],
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/apollo-cache-inmemory_1.2.5_1529458025720_0.01769352377736655"
      },
      "_hasShrinkwrap": false
    },
    "1.3.0-beta.3": {
      "name": "apollo-cache-inmemory",
      "version": "1.3.0-beta.3",
      "description": "Core abstract of Caching layer for Apollo Client",
      "author": {
        "name": "James Baxley",
        "email": "james@meteor.com"
      },
      "contributors": [
        {
          "name": "James Baxley",
          "email": "james@meteor.com"
        },
        {
          "name": "Jonas Helfer",
          "email": "jonas@helfer.email"
        },
        {
          "name": "Sashko Stubailo",
          "email": "sashko@stubailo.com"
        },
        {
          "name": "James Burgess",
          "email": "jamesmillerburgess@gmail.com"
        },
        {
          "name": "Bazyli Brzóska",
          "email": "bazyli.brzoska@gmail.com"
        }
      ],
      "license": "MIT",
      "main": "./lib/bundle.umd.js",
      "module": "./lib/index.js",
      "jsnext:main": "./lib/index.js",
      "typings": "./lib/index.d.ts",
      "sideEffects": false,
      "repository": {
        "type": "git",
        "url": "git+https://github.com/apollographql/apollo-client.git"
      },
      "bugs": {
        "url": "https://github.com/apollographql/apollo-client/issues"
      },
      "homepage": "https://github.com/apollographql/apollo-client#readme",
      "scripts": {
        "coverage": "jest --coverage",
        "test": "jest",
        "lint": "tslint --type-check -p tsconfig.json src/*.ts",
        "prebuild": "npm run clean",
        "build": "tsc -p .",
        "postbuild": "npm run bundle",
        "bundle": "rollup -c rollup.config.js",
        "watch": "tsc -w -p .",
        "clean": "rimraf coverage/* && rimraf lib/*",
        "prepublishOnly": "npm run build",
        "build:browser": "browserify ./lib/bundle.umd.js --i apollo-cache --i apollo-utilities --i graphql -o=./lib/bundle.js && npm run minify:browser",
        "minify:browser": "uglifyjs -c -m -o ./lib/bundle.min.js -- ./lib/bundle.js",
        "filesize": "npm run build:browser"
      },
      "dependencies": {
        "apollo-cache": "^1.1.12",
        "apollo-utilities": "^1.0.16",
        "optimism": "^0.6.4"
      },
      "peerDependencies": {
        "graphql": "0.11.7 || ^0.12.0 || ^0.13.0"
      },
      "devDependencies": {
        "@types/graphql": "0.12.7",
        "@types/jest": "22.2.3",
        "@types/lodash": "4.14.109",
        "browserify": "15.2.0",
        "graphql": "0.13.2",
        "graphql-tag": "2.9.2",
        "jest": "23.0.0",
        "lodash": "4.17.10",
        "rimraf": "2.6.2",
        "rollup": "0.59.4",
        "ts-jest": "20.0.14",
        "tslint": "5.10.0",
        "typescript": "2.8.3",
        "uglifyjs": "2.4.11"
      },
      "jest": {
        "transform": {
          ".(ts|tsx)": "<rootDir>/node_modules/ts-jest/preprocessor.js"
        },
        "testRegex": "(/__tests__/.*|\\.(test|spec))\\.(ts|tsx|js)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "json"
        ]
      },
      "readme": "---\ntitle: InMemoryCache\ndescription: An explanation of `apollo-cache-inmemory`\n---\n\n`apollo-cache-inmemory` is the recommended cache implementation for Apollo Client 2.0. `InMemoryCache` is a normalized data store that supports all of Apollo Client 1.0's features without the dependency on Redux.\n\nIn some instances, you may need to manipulate the cache directly, such as updating the store after a mutation. We'll cover some common use cases [here](#recipes).\n\n<h2 id=\"installation\">Installation</h2>\n\n```\nnpm install apollo-cache-inmemory --save\n```\n\nAfter installing the package, you'll want to initialize the cache constructor. Then, you can pass in your newly created cache to ApolloClient.\n\n```js\nimport { InMemoryCache } from 'apollo-cache-inmemory';\nimport { HttpLink } from 'apollo-link-http';\nimport ApolloClient from 'apollo-client';\n\nconst cache = new InMemoryCache();\n\nconst client = new ApolloClient({\n  link: new HttpLink(),\n  cache\n});\n```\n\n<h2 id=\"configuration\">Configuration</h2>\n\nThe `InMemoryCache` constructor takes an optional config object with properties to customize your cache:\n\n- addTypename: A boolean to determine whether to add __typename to the document (default: `true`)\n- dataIdFromObject: A function that takes a data object and returns a unique identifier to be used when normalizing the data in the store. Learn more about how to customize `dataIdFromObject` in the [Normalization](#normalization) section.\n- fragmentMatcher: By default, the `InMemoryCache` uses a heuristic fragment matcher. If you are using fragments on unions and interfaces, you will need to use an `IntrospectionFragmentMatcher`. For more information, please read [our guide to setting up fragment matching for unions & interfaces](https://www.apollographql.com/docs/react/advanced/fragments.html#fragment-matcher).\n\n<h2 id=\"normalization\">Normalization</h2>\n\nThe `InMemoryCache` normalizes your data before saving it to the store by splitting the result into individual objects, creating a unique identifier for each object, and storing those objects in a flattened data structure. By default, `InMemoryCache` will attempt to use the commonly found primary keys of `id` and `_id` for the unique identifier if they exist along with `__typename` on an object.\n\nIf `id` and `_id` are not specified, or if `__typename` is not specified, `InMemoryCache` will fall back to the path to the object in the query, such as `ROOT_QUERY.allPeople.0` for the first record returned on the `allPeople` root query.\n\nThis \"getter\" behavior for unique identifiers can be configured manually via the `dataIdFromObject` option passed to the `InMemoryCache` constructor, so you can pick which field is used if some of your data follows unorthodox primary key conventions.\n\nFor example, if you wanted to key off of the `key` field for all of your data, you could configure `dataIdFromObject` like so:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => object.key\n});\n```\n\nThis also allows you to use different unique identifiers for different data types by keying off of the `__typename` property attached to every object typed by GraphQL.  For example:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => {\n    switch (object.__typename) {\n      case 'foo': return object.key; // use `key` as the primary key\n      case 'bar': return object.blah; // use `blah` as the priamry key\n      default: return object.id || object._id; // fall back to `id` and `_id` for all other types\n    }\n  }\n});\n```\n\n<h2 id=\"direct\">Direct Cache Access</h2>\n\nTo interact directly with your cache, you can use the Apollo Client class methods readQuery, readFragment, writeQuery, and writeFragment. These methods are available to us via the [`DataProxy` interface](http://dev.apollodata.com/core/apollo-client-api.html#DataProxy). Accessing these methods will vary slightly based on your view layer implementation. If you are using React, you can wrap your component in the `withApollo` higher order component, which will give you access to `this.props.client`. From there, you can use the methods to control your data.\n\nAny code demonstration in the following sections will assume that we have already initialized an instance of  `ApolloClient` and that we have imported the `gql` tag from `graphql-tag`.\n\n<h3 id=\"readquery\">readQuery</h3>\n\nThe `readQuery` method is very similar to the [`query` method on `ApolloClient`][] except that `readQuery` will _never_ make a request to your GraphQL server. The `query` method, on the other hand, may send a request to your server if the appropriate data is not in your cache whereas `readQuery` will throw an error if the data is not in your cache. `readQuery` will _always_ read from the cache. You can use `readQuery` by giving it a GraphQL query like so:\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo {\n      todo(id: 5) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n});\n```\n\nIf all of the data needed to fulfill this read is in Apollo Client’s normalized data cache then a data object will be returned in the shape of the query you wanted to read. If not all of the data needed to fulfill this read is in Apollo Client’s cache then an error will be thrown instead, so make sure to only read data that you know you have!\n\nYou can also pass variables into `readQuery`.\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo($id: Int!) {\n      todo(id: $id) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n  variables: {\n    id: 5,\n  },\n});\n```\n\n<h3 id=\"readfragment\">readFragment</h3>\n\nThis method allows you great flexibility around the data in your cache. Whereas `readQuery` only allowed you to read data from your root query type, `readFragment` allows you to read data from _any node you have queried_. This is incredibly powerful. You use this method as follows:\n\n```js\nconst todo = client.readFragment({\n  id: ..., // `id` is any id that could be returned by `dataIdFromObject`.\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\nThe first argument is the id of the data you want to read from the cache. That id must be a value that was returned by the `dataIdFromObject` function you defined when initializing `ApolloClient`. So for example if you initialized `ApolloClient` like so:\n\n```js\nconst client = new ApolloClient({\n  ...,\n  dataIdFromObject: object => object.id,\n});\n```\n\n…and you requested a todo before with an id of `5`, then you can read that todo out of your cache with the following:\n\n```js\nconst todo = client.readFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\n> **Note:** Most people add a `__typename` to the id in `dataIdFromObject`. If you do this then don’t forget to add the `__typename` when you are reading a fragment as well. So for example your id may be `Todo_5` and not just `5`.\n\nIf a todo with that id does not exist in the cache you will get `null` back. If a todo of that id does exist in the cache, but that todo does not have the `text` field then an error will be thrown.\n\nThe beauty of `readFragment` is that the todo could have come from anywhere! The todo could have been selected as a singleton (`{ todo(id: 5) { ... } }`), the todo could have come from a list of todos (`{ todos { ... } }`), or the todo could have come from a mutation (`mutation { createTodo { ... } }`). As long as at some point your GraphQL server gave you a todo with the provided id and fields `id`, `text`, and `completed` you can read it from the cache at any part of your code.\n\n<h3 id=\"writequery-and-writefragment\">writeQuery` and `writeFragment</h3>\n\nNot only can you read arbitrary data from the Apollo Client cache, but you can also write any data that you would like to the cache. The methods you use to do this are `writeQuery` and `writeFragment`. They will allow you to change data in your local cache, but it is important to remember that *they will not change any data on your server*. If you reload your environment then changes made with `writeQuery` and `writeFragment` will disappear.\n\nThese methods have the same signature as their `readQuery` and `readFragment` counterparts except they also require an additional `data` variable. So for example, if you wanted to update the `completed` flag locally for your todo with id `'5'` you could execute the following:\n\n```js\nclient.writeFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      completed\n    }\n  `,\n  data: {\n    completed: true,\n  },\n});\n```\n\nAny subscriber to the Apollo Client store will instantly see this update and render new UI accordingly.\n\n> **Note:** Again, remember that using `writeQuery` or `writeFragment` only changes data *locally*. If you reload your environment then changes made with these methods will no longer exist.\n\nOr if you wanted to add a new todo to a list fetched from the server, you could use `readQuery` and `writeQuery` together.\n\n```js\nconst query = gql`\n  query MyTodoAppQuery {\n    todos {\n      id\n      text\n      completed\n    }\n  }\n`;\n\nconst data = client.readQuery({ query });\n\nconst myNewTodo = {\n  id: '6',\n  text: 'Start using Apollo Client.',\n  completed: false,\n};\n\nclient.writeQuery({\n  query,\n  data: {\n    todos: [...data.todos, myNewTodo],\n  },\n});\n```\n\n<h2 id=\"recipes\">Recipes</h2>\n\nHere are some common situations where you would need to access the cache directly. If you're manipulating the cache in an interesting way and would like your example to be featured, please send in a pull request!\n\n<h3 id=\"server\">Server side rendering</h3>\n\nFirst, you will need to initialize an `InMemoryCache` on the server and create an instance of `ApolloClient`. In the initial serialized HTML payload from the server, you should include a script tag that extracts the data from the cache.\n\n```js\n`<script>\n  window.__APOLLO_STATE__=${JSON.stringify(cache.extract())}\n</script>`\n```\n\nOn the client, you can rehydrate the cache using the initial data passed from the server:\n\n```js\ncache: new Cache().restore(window.__APOLLO_STATE__)\n```\n\nIf you would like to learn more about server side rendering, please check our our more in depth guide [here].\n<!---\nTODO (PEGGY): Add link to SSR\n-->\n\n<h3 id=\"server\">Updating the cache after a mutation</h3>\n\nBeing able to read and write to the Apollo cache from anywhere in your application gives you a lot of power over your data. However, there is one place where we most often want to update our cached data: after a mutation. As such, Apollo Client has optimized the experience for updating your cache with the read and write methods after a mutation with the `update` function. Let us say that we have the following GraphQL mutation:\n\n```graphql\nmutation TodoCreateMutation($text: String!) {\n  createTodo(text: $text) {\n    id\n    text\n    completed\n  }\n}\n```\n\nWe may also have the following GraphQL query:\n\n```graphql\nquery TodoAppQuery {\n  todos {\n    id\n    text\n    completed\n  }\n}\n```\n\nAt the end of our mutation we want our query to include the new todo like we had sent our `TodoAppQuery` a second time after the mutation finished without actually sending the query. To do this we can use the `update` function provided as an option of the `client.mutate` method. To update your cache with the mutation just write code that looks like:\n\n```js\n// We assume that the GraphQL operations `TodoCreateMutation` and\n// `TodoAppQuery` have already been defined using the `gql` tag.\n\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    // Read the data from our cache for this query.\n    const data = proxy.readQuery({ query: TodoAppQuery });\n\n    // Add our todo from the mutation to the end.\n    data.todos.push(createTodo);\n\n    // Write our data back to the cache.\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nThe first `proxy` argument is an instance of [`DataProxy`][] has the same four methods that we just learned exist on the Apollo Client: `readQuery`, `readFragment`, `writeQuery`, and `writeFragment`. The reason we call them on a `proxy` object here instead of on our `client` instance is that we can easily apply optimistic updates (which we will demonstrate in a bit). The `proxy` object also provides an isolated transaction which shields you from any other mutations going on at the same time, and the `proxy` object also batches writes together until the very end.\n\nIf you provide an `optimisticResponse` option to the mutation then the `update` function will be run twice. Once immediately after you call `client.mutate` with the data from `optimisticResponse`. After the mutation successfully executes against the server the changes made in the first call to `update` will be rolled back and `update` will be called with the *actual* data returned by the mutation and not just the optimistic response.\n\nPutting it all together:\n\n```js\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  optimisticResponse: {\n    id: -1, // -1 is a temporary id for the optimistic response.\n    text,\n    completed: false,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    const data = proxy.readQuery({ query: TodoAppQuery });\n    data.todos.push(createTodo);\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nAs you can see the `update` function on `client.mutate` provides extra change management functionality specific to the use case of a mutation while still providing you the powerful data control APIs that are available on `client`.\n\nThe `update` function is not a good place for side-effects as it may be called multiple times. Also, you may not call any of the methods on `proxy` asynchronously.\n\n",
      "readmeFilename": "README.md",
      "_id": "apollo-cache-inmemory@1.3.0-beta.3",
      "_npmVersion": "6.1.0",
      "_nodeVersion": "8.11.3",
      "_npmUser": {
        "name": "benjamn",
        "email": "ben@benjamn.com"
      },
      "dist": {
        "integrity": "sha512-Zd7n7jOhMl8M+9acjvnaXZuwyDNsvwA96XQ13GlG9YqKIX8Acot+YtAMMqonqSCiYkGZ2dei8cv2FD6dVMsUpQ==",
        "shasum": "74606d64d37eca0772544728450678c2f17cb0c1",
        "tarball": "https://registry.npmjs.org/apollo-cache-inmemory/-/apollo-cache-inmemory-1.3.0-beta.3.tgz",
        "fileCount": 73,
        "unpackedSize": 451766,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJbKt5YCRA9TVsSAnZWagAAEcUQAJbLGsy6qE3IY6gyFLIv\nIQP2DglnTd7HSiPqJsrB15WCdCAHHCvp/xl0zpa6MQVmwz319Il8wIJhYux0\n59EZffRGwtxpTTleM9Drhf5wAGDBnVzO1XJHVQt/DMyooo8eXTIUNXjAhkIV\nnQW4vI61afeKQOhgxrbhT+JBF+A7iULgvpGZ4joL23X25KkFO8s73Z8/f0Ey\nfk5uuy4jVsXNlccq/A52nnt6ukceJlFZX44y0f6wQfc49sNKyxCCJ3DvdbSy\nNTTmjXs6wt3P2n2lL+QzNcN27sdNn+3u4mEdjD7leMRPGjGPpuw0dCz+hpJ0\n2tlHHgnJg3d9jEnh+NrCzxN1EzlyKQ5IFqvSnGDAKW/HVYioJz594Bq7RdCu\n7sikJJyRsW+vDTUOFlfVr/bEF4X8SOJwl9GgK/3XdfwF0IbapB+zsSkDFDMs\nJZP8CaTAGbxslsIe4b26GKeceHW7E7EvdYXQU/j+hjuGnSEcJeavH+WZVUXJ\n2DfVYn73pswBPp4Xplsr4tkQCGxuRDueRuSYX0kIGnOaGG8aab/75UORcWGe\nG6bSfehXkf7z0tiSWFQsuP6x1IE86kDDu1CFz9d67FDWx1l2uY9yzqdX1ly7\nUvnv4rBp/jTMpfh/2VtDWAoyhVYeY0aTbks2+9bZJQoEUkTaOclQo+PLmOgo\nveT3\r\n=n80S\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIQCbvYpo/9Ln3eDwlkjZHCTWV747n4o3oKBbk2ioD4NDBgIgRADiqwQWk8Izm8OidWW+cGzO5e2k8R1YCBJELhxrgv8="
          }
        ]
      },
      "maintainers": [
        {
          "email": "ben@benjamn.com",
          "name": "benjamn"
        },
        {
          "email": "james@meteor.com",
          "name": "jbaxleyiii"
        },
        {
          "email": "npm@meteor.com",
          "name": "mdg"
        },
        {
          "email": "peggyrayzis@gmail.com",
          "name": "peggyrayzis"
        }
      ],
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/apollo-cache-inmemory_1.3.0-beta.3_1529536087411_0.5552098743491314"
      },
      "_hasShrinkwrap": false
    },
    "1.3.0-beta.4": {
      "name": "apollo-cache-inmemory",
      "version": "1.3.0-beta.4",
      "description": "Core abstract of Caching layer for Apollo Client",
      "author": {
        "name": "James Baxley",
        "email": "james@meteor.com"
      },
      "contributors": [
        {
          "name": "James Baxley",
          "email": "james@meteor.com"
        },
        {
          "name": "Jonas Helfer",
          "email": "jonas@helfer.email"
        },
        {
          "name": "Sashko Stubailo",
          "email": "sashko@stubailo.com"
        },
        {
          "name": "James Burgess",
          "email": "jamesmillerburgess@gmail.com"
        },
        {
          "name": "Bazyli Brzóska",
          "email": "bazyli.brzoska@gmail.com"
        }
      ],
      "license": "MIT",
      "main": "./lib/bundle.umd.js",
      "module": "./lib/index.js",
      "jsnext:main": "./lib/index.js",
      "typings": "./lib/index.d.ts",
      "sideEffects": false,
      "repository": {
        "type": "git",
        "url": "git+https://github.com/apollographql/apollo-client.git"
      },
      "bugs": {
        "url": "https://github.com/apollographql/apollo-client/issues"
      },
      "homepage": "https://github.com/apollographql/apollo-client#readme",
      "scripts": {
        "coverage": "jest --coverage",
        "test": "jest",
        "lint": "tslint --type-check -p tsconfig.json src/*.ts",
        "prebuild": "npm run clean",
        "build": "tsc -p .",
        "postbuild": "npm run bundle",
        "bundle": "rollup -c rollup.config.js",
        "watch": "tsc -w -p .",
        "clean": "rimraf coverage/* && rimraf lib/*",
        "prepublishOnly": "npm run build",
        "build:browser": "browserify ./lib/bundle.umd.js --i apollo-cache --i apollo-utilities --i graphql -o=./lib/bundle.js && npm run minify:browser",
        "minify:browser": "uglifyjs -c -m -o ./lib/bundle.min.js -- ./lib/bundle.js",
        "filesize": "npm run build:browser"
      },
      "dependencies": {
        "apollo-cache": "^1.1.12",
        "apollo-utilities": "^1.0.16",
        "optimism": "^0.6.5"
      },
      "peerDependencies": {
        "graphql": "0.11.7 || ^0.12.0 || ^0.13.0"
      },
      "devDependencies": {
        "@types/graphql": "0.12.7",
        "@types/jest": "22.2.3",
        "@types/lodash": "4.14.110",
        "browserify": "15.2.0",
        "graphql": "0.13.2",
        "graphql-tag": "2.9.2",
        "jest": "23.0.0",
        "lodash": "4.17.10",
        "rimraf": "2.6.2",
        "rollup": "0.62.0",
        "ts-jest": "20.0.14",
        "tslint": "5.10.0",
        "typescript": "2.9.2",
        "uglifyjs": "2.4.11"
      },
      "jest": {
        "transform": {
          ".(ts|tsx)": "<rootDir>/node_modules/ts-jest/preprocessor.js"
        },
        "testRegex": "(/__tests__/.*|\\.(test|spec))\\.(ts|tsx|js)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "json"
        ]
      },
      "readme": "---\ntitle: InMemoryCache\ndescription: An explanation of `apollo-cache-inmemory`\n---\n\n`apollo-cache-inmemory` is the recommended cache implementation for Apollo Client 2.0. `InMemoryCache` is a normalized data store that supports all of Apollo Client 1.0's features without the dependency on Redux.\n\nIn some instances, you may need to manipulate the cache directly, such as updating the store after a mutation. We'll cover some common use cases [here](#recipes).\n\n<h2 id=\"installation\">Installation</h2>\n\n```\nnpm install apollo-cache-inmemory --save\n```\n\nAfter installing the package, you'll want to initialize the cache constructor. Then, you can pass in your newly created cache to ApolloClient.\n\n```js\nimport { InMemoryCache } from 'apollo-cache-inmemory';\nimport { HttpLink } from 'apollo-link-http';\nimport ApolloClient from 'apollo-client';\n\nconst cache = new InMemoryCache();\n\nconst client = new ApolloClient({\n  link: new HttpLink(),\n  cache\n});\n```\n\n<h2 id=\"configuration\">Configuration</h2>\n\nThe `InMemoryCache` constructor takes an optional config object with properties to customize your cache:\n\n- addTypename: A boolean to determine whether to add __typename to the document (default: `true`)\n- dataIdFromObject: A function that takes a data object and returns a unique identifier to be used when normalizing the data in the store. Learn more about how to customize `dataIdFromObject` in the [Normalization](#normalization) section.\n- fragmentMatcher: By default, the `InMemoryCache` uses a heuristic fragment matcher. If you are using fragments on unions and interfaces, you will need to use an `IntrospectionFragmentMatcher`. For more information, please read [our guide to setting up fragment matching for unions & interfaces](https://www.apollographql.com/docs/react/advanced/fragments.html#fragment-matcher).\n\n<h2 id=\"normalization\">Normalization</h2>\n\nThe `InMemoryCache` normalizes your data before saving it to the store by splitting the result into individual objects, creating a unique identifier for each object, and storing those objects in a flattened data structure. By default, `InMemoryCache` will attempt to use the commonly found primary keys of `id` and `_id` for the unique identifier if they exist along with `__typename` on an object.\n\nIf `id` and `_id` are not specified, or if `__typename` is not specified, `InMemoryCache` will fall back to the path to the object in the query, such as `ROOT_QUERY.allPeople.0` for the first record returned on the `allPeople` root query.\n\nThis \"getter\" behavior for unique identifiers can be configured manually via the `dataIdFromObject` option passed to the `InMemoryCache` constructor, so you can pick which field is used if some of your data follows unorthodox primary key conventions.\n\nFor example, if you wanted to key off of the `key` field for all of your data, you could configure `dataIdFromObject` like so:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => object.key\n});\n```\n\nThis also allows you to use different unique identifiers for different data types by keying off of the `__typename` property attached to every object typed by GraphQL.  For example:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => {\n    switch (object.__typename) {\n      case 'foo': return object.key; // use `key` as the primary key\n      case 'bar': return object.blah; // use `blah` as the priamry key\n      default: return object.id || object._id; // fall back to `id` and `_id` for all other types\n    }\n  }\n});\n```\n\n<h2 id=\"direct\">Direct Cache Access</h2>\n\nTo interact directly with your cache, you can use the Apollo Client class methods readQuery, readFragment, writeQuery, and writeFragment. These methods are available to us via the [`DataProxy` interface](http://dev.apollodata.com/core/apollo-client-api.html#DataProxy). Accessing these methods will vary slightly based on your view layer implementation. If you are using React, you can wrap your component in the `withApollo` higher order component, which will give you access to `this.props.client`. From there, you can use the methods to control your data.\n\nAny code demonstration in the following sections will assume that we have already initialized an instance of  `ApolloClient` and that we have imported the `gql` tag from `graphql-tag`.\n\n<h3 id=\"readquery\">readQuery</h3>\n\nThe `readQuery` method is very similar to the [`query` method on `ApolloClient`][] except that `readQuery` will _never_ make a request to your GraphQL server. The `query` method, on the other hand, may send a request to your server if the appropriate data is not in your cache whereas `readQuery` will throw an error if the data is not in your cache. `readQuery` will _always_ read from the cache. You can use `readQuery` by giving it a GraphQL query like so:\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo {\n      todo(id: 5) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n});\n```\n\nIf all of the data needed to fulfill this read is in Apollo Client’s normalized data cache then a data object will be returned in the shape of the query you wanted to read. If not all of the data needed to fulfill this read is in Apollo Client’s cache then an error will be thrown instead, so make sure to only read data that you know you have!\n\nYou can also pass variables into `readQuery`.\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo($id: Int!) {\n      todo(id: $id) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n  variables: {\n    id: 5,\n  },\n});\n```\n\n<h3 id=\"readfragment\">readFragment</h3>\n\nThis method allows you great flexibility around the data in your cache. Whereas `readQuery` only allowed you to read data from your root query type, `readFragment` allows you to read data from _any node you have queried_. This is incredibly powerful. You use this method as follows:\n\n```js\nconst todo = client.readFragment({\n  id: ..., // `id` is any id that could be returned by `dataIdFromObject`.\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\nThe first argument is the id of the data you want to read from the cache. That id must be a value that was returned by the `dataIdFromObject` function you defined when initializing `ApolloClient`. So for example if you initialized `ApolloClient` like so:\n\n```js\nconst client = new ApolloClient({\n  ...,\n  dataIdFromObject: object => object.id,\n});\n```\n\n…and you requested a todo before with an id of `5`, then you can read that todo out of your cache with the following:\n\n```js\nconst todo = client.readFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\n> **Note:** Most people add a `__typename` to the id in `dataIdFromObject`. If you do this then don’t forget to add the `__typename` when you are reading a fragment as well. So for example your id may be `Todo_5` and not just `5`.\n\nIf a todo with that id does not exist in the cache you will get `null` back. If a todo of that id does exist in the cache, but that todo does not have the `text` field then an error will be thrown.\n\nThe beauty of `readFragment` is that the todo could have come from anywhere! The todo could have been selected as a singleton (`{ todo(id: 5) { ... } }`), the todo could have come from a list of todos (`{ todos { ... } }`), or the todo could have come from a mutation (`mutation { createTodo { ... } }`). As long as at some point your GraphQL server gave you a todo with the provided id and fields `id`, `text`, and `completed` you can read it from the cache at any part of your code.\n\n<h3 id=\"writequery-and-writefragment\">writeQuery` and `writeFragment</h3>\n\nNot only can you read arbitrary data from the Apollo Client cache, but you can also write any data that you would like to the cache. The methods you use to do this are `writeQuery` and `writeFragment`. They will allow you to change data in your local cache, but it is important to remember that *they will not change any data on your server*. If you reload your environment then changes made with `writeQuery` and `writeFragment` will disappear.\n\nThese methods have the same signature as their `readQuery` and `readFragment` counterparts except they also require an additional `data` variable. So for example, if you wanted to update the `completed` flag locally for your todo with id `'5'` you could execute the following:\n\n```js\nclient.writeFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      completed\n    }\n  `,\n  data: {\n    completed: true,\n  },\n});\n```\n\nAny subscriber to the Apollo Client store will instantly see this update and render new UI accordingly.\n\n> **Note:** Again, remember that using `writeQuery` or `writeFragment` only changes data *locally*. If you reload your environment then changes made with these methods will no longer exist.\n\nOr if you wanted to add a new todo to a list fetched from the server, you could use `readQuery` and `writeQuery` together.\n\n```js\nconst query = gql`\n  query MyTodoAppQuery {\n    todos {\n      id\n      text\n      completed\n    }\n  }\n`;\n\nconst data = client.readQuery({ query });\n\nconst myNewTodo = {\n  id: '6',\n  text: 'Start using Apollo Client.',\n  completed: false,\n};\n\nclient.writeQuery({\n  query,\n  data: {\n    todos: [...data.todos, myNewTodo],\n  },\n});\n```\n\n<h2 id=\"recipes\">Recipes</h2>\n\nHere are some common situations where you would need to access the cache directly. If you're manipulating the cache in an interesting way and would like your example to be featured, please send in a pull request!\n\n<h3 id=\"server\">Server side rendering</h3>\n\nFirst, you will need to initialize an `InMemoryCache` on the server and create an instance of `ApolloClient`. In the initial serialized HTML payload from the server, you should include a script tag that extracts the data from the cache.\n\n```js\n`<script>\n  window.__APOLLO_STATE__=${JSON.stringify(cache.extract())}\n</script>`\n```\n\nOn the client, you can rehydrate the cache using the initial data passed from the server:\n\n```js\ncache: new Cache().restore(window.__APOLLO_STATE__)\n```\n\nIf you would like to learn more about server side rendering, please check our our more in depth guide [here].\n<!---\nTODO (PEGGY): Add link to SSR\n-->\n\n<h3 id=\"server\">Updating the cache after a mutation</h3>\n\nBeing able to read and write to the Apollo cache from anywhere in your application gives you a lot of power over your data. However, there is one place where we most often want to update our cached data: after a mutation. As such, Apollo Client has optimized the experience for updating your cache with the read and write methods after a mutation with the `update` function. Let us say that we have the following GraphQL mutation:\n\n```graphql\nmutation TodoCreateMutation($text: String!) {\n  createTodo(text: $text) {\n    id\n    text\n    completed\n  }\n}\n```\n\nWe may also have the following GraphQL query:\n\n```graphql\nquery TodoAppQuery {\n  todos {\n    id\n    text\n    completed\n  }\n}\n```\n\nAt the end of our mutation we want our query to include the new todo like we had sent our `TodoAppQuery` a second time after the mutation finished without actually sending the query. To do this we can use the `update` function provided as an option of the `client.mutate` method. To update your cache with the mutation just write code that looks like:\n\n```js\n// We assume that the GraphQL operations `TodoCreateMutation` and\n// `TodoAppQuery` have already been defined using the `gql` tag.\n\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    // Read the data from our cache for this query.\n    const data = proxy.readQuery({ query: TodoAppQuery });\n\n    // Add our todo from the mutation to the end.\n    data.todos.push(createTodo);\n\n    // Write our data back to the cache.\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nThe first `proxy` argument is an instance of [`DataProxy`][] has the same four methods that we just learned exist on the Apollo Client: `readQuery`, `readFragment`, `writeQuery`, and `writeFragment`. The reason we call them on a `proxy` object here instead of on our `client` instance is that we can easily apply optimistic updates (which we will demonstrate in a bit). The `proxy` object also provides an isolated transaction which shields you from any other mutations going on at the same time, and the `proxy` object also batches writes together until the very end.\n\nIf you provide an `optimisticResponse` option to the mutation then the `update` function will be run twice. Once immediately after you call `client.mutate` with the data from `optimisticResponse`. After the mutation successfully executes against the server the changes made in the first call to `update` will be rolled back and `update` will be called with the *actual* data returned by the mutation and not just the optimistic response.\n\nPutting it all together:\n\n```js\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  optimisticResponse: {\n    id: -1, // -1 is a temporary id for the optimistic response.\n    text,\n    completed: false,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    const data = proxy.readQuery({ query: TodoAppQuery });\n    data.todos.push(createTodo);\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nAs you can see the `update` function on `client.mutate` provides extra change management functionality specific to the use case of a mutation while still providing you the powerful data control APIs that are available on `client`.\n\nThe `update` function is not a good place for side-effects as it may be called multiple times. Also, you may not call any of the methods on `proxy` asynchronously.\n\n",
      "readmeFilename": "README.md",
      "_id": "apollo-cache-inmemory@1.3.0-beta.4",
      "_npmVersion": "6.1.0",
      "_nodeVersion": "8.11.3",
      "_npmUser": {
        "name": "benjamn",
        "email": "ben@benjamn.com"
      },
      "dist": {
        "integrity": "sha512-viWsVsoyAUUOnQ6fCB/0tAhmctpv2ZsDCZXcTR+3+nivfyfkbYivtWJw4p3+w4YzSKl/3tXqDE4ppeM0PBboIg==",
        "shasum": "874e0de79a95a0d766adadc580bac516c5b30d4e",
        "tarball": "https://registry.npmjs.org/apollo-cache-inmemory/-/apollo-cache-inmemory-1.3.0-beta.4.tgz",
        "fileCount": 73,
        "unpackedSize": 451706,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJbPmL5CRA9TVsSAnZWagAAzDgP/0VuJMUtRitrr7l9uCJ+\nAFQI/VjhSvfDwSCwCFP/aEBayg1XJyI9AZXw8FbfT8NuuGOx/I5g9UZfcVEj\njpescc+MznqfmrE/0q5uR/HMaph37WWa6BWaM9kh9+d5iFEhURpOCyYqKkFa\nfmIuPZQq3+rPKLHAL1XhM9UeqfNgKHDXgjblMQrdUEDUpy6NnhF50fVLwVJ6\nPumUxgLZBKgmFItaLjhUS7f6JcaxeGKRf85kc1CfYdJUt3yoq/92PfK9k8+3\n3DQBdFYkgvnWg0nadW7Mn4yimk/aKYig1fKcTyiG6plscuBrZdYQMo5/YFjD\nkJK9fLre+xJLnebSIUJZpMbE79lvpmCbvGYH4goU8pSW4YAQyvZErBQW4DQn\nQq09ILavGlINVbY6hWNCzC2VkV5ZTwx8TqqcLThnR/XGKbdor+dKdOlI2cuG\nFH16OAo5Vk0PS50OxvQ7FGWkQaUm13/yiwXIj4LBH0lb4TqcISjVvzHYkaME\nxTu1ARRGDwcgIcW0RlaiSvJfC/DrUUsYeVFCC4fnjkmUymvdiqKL1oIuw+EL\nQyCosDj455OOJ+K4dscUrvO4qr5FI5Cz6Je9s4HNJoEvkpoNSkkMY5GDoaOL\nlHtSXgmzENeHWIJ019NXxYVk3H3qFxFokjYPGPf2p6RBSujUf/0AfDTWN8zW\nWfb9\r\n=rlZT\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEQCIF9Vn/7zM8+pIO+YJzdBUgKuUcJNoSi9V+F7+g+F3QFmAiAF/NmmZ/Xba5X5zcTjBvVGuoH66nSpT6Lp0ToJ1RwYLw=="
          }
        ]
      },
      "maintainers": [
        {
          "email": "ben@benjamn.com",
          "name": "benjamn"
        },
        {
          "email": "james@meteor.com",
          "name": "jbaxleyiii"
        },
        {
          "email": "npm@meteor.com",
          "name": "mdg"
        },
        {
          "email": "peggyrayzis@gmail.com",
          "name": "peggyrayzis"
        }
      ],
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/apollo-cache-inmemory_1.3.0-beta.4_1530815225674_0.09087141344451921"
      },
      "_hasShrinkwrap": false
    },
    "1.3.0-beta.5": {
      "name": "apollo-cache-inmemory",
      "version": "1.3.0-beta.5",
      "description": "Core abstract of Caching layer for Apollo Client",
      "author": {
        "name": "James Baxley",
        "email": "james@meteor.com"
      },
      "contributors": [
        {
          "name": "James Baxley",
          "email": "james@meteor.com"
        },
        {
          "name": "Jonas Helfer",
          "email": "jonas@helfer.email"
        },
        {
          "name": "Sashko Stubailo",
          "email": "sashko@stubailo.com"
        },
        {
          "name": "James Burgess",
          "email": "jamesmillerburgess@gmail.com"
        },
        {
          "name": "Bazyli Brzóska",
          "email": "bazyli.brzoska@gmail.com"
        }
      ],
      "license": "MIT",
      "main": "./lib/bundle.umd.js",
      "module": "./lib/index.js",
      "jsnext:main": "./lib/index.js",
      "typings": "./lib/index.d.ts",
      "sideEffects": false,
      "repository": {
        "type": "git",
        "url": "git+https://github.com/apollographql/apollo-client.git"
      },
      "bugs": {
        "url": "https://github.com/apollographql/apollo-client/issues"
      },
      "homepage": "https://github.com/apollographql/apollo-client#readme",
      "scripts": {
        "coverage": "jest --coverage",
        "test": "jest",
        "lint": "tslint --type-check -p tsconfig.json src/*.ts",
        "prebuild": "npm run clean",
        "build": "tsc -p .",
        "postbuild": "npm run bundle",
        "bundle": "rollup -c rollup.config.js",
        "watch": "tsc -w -p .",
        "clean": "rimraf coverage/* && rimraf lib/*",
        "prepublishOnly": "npm run build",
        "build:browser": "browserify ./lib/bundle.umd.js --i apollo-cache --i apollo-utilities --i graphql -o=./lib/bundle.js && npm run minify:browser",
        "minify:browser": "uglifyjs -c -m -o ./lib/bundle.min.js -- ./lib/bundle.js",
        "filesize": "npm run build:browser"
      },
      "dependencies": {
        "apollo-cache": "^1.1.12",
        "apollo-utilities": "^1.0.16",
        "optimism": "^0.6.5"
      },
      "peerDependencies": {
        "graphql": "0.11.7 || ^0.12.0 || ^0.13.0"
      },
      "devDependencies": {
        "@types/graphql": "0.12.7",
        "@types/jest": "22.2.3",
        "@types/lodash": "4.14.112",
        "browserify": "15.2.0",
        "graphql": "0.13.2",
        "graphql-tag": "2.9.2",
        "jest": "23.0.0",
        "lodash": "4.17.10",
        "rimraf": "2.6.2",
        "rollup": "0.62.0",
        "ts-jest": "20.0.14",
        "tslint": "5.10.0",
        "typescript": "2.9.2",
        "uglifyjs": "2.4.11"
      },
      "jest": {
        "transform": {
          ".(ts|tsx)": "<rootDir>/node_modules/ts-jest/preprocessor.js"
        },
        "testRegex": "(/__tests__/.*|\\.(test|spec))\\.(ts|tsx|js)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "json"
        ]
      },
      "readme": "---\ntitle: InMemoryCache\ndescription: An explanation of `apollo-cache-inmemory`\n---\n\n`apollo-cache-inmemory` is the recommended cache implementation for Apollo Client 2.0. `InMemoryCache` is a normalized data store that supports all of Apollo Client 1.0's features without the dependency on Redux.\n\nIn some instances, you may need to manipulate the cache directly, such as updating the store after a mutation. We'll cover some common use cases [here](#recipes).\n\n<h2 id=\"installation\">Installation</h2>\n\n```\nnpm install apollo-cache-inmemory --save\n```\n\nAfter installing the package, you'll want to initialize the cache constructor. Then, you can pass in your newly created cache to ApolloClient.\n\n```js\nimport { InMemoryCache } from 'apollo-cache-inmemory';\nimport { HttpLink } from 'apollo-link-http';\nimport ApolloClient from 'apollo-client';\n\nconst cache = new InMemoryCache();\n\nconst client = new ApolloClient({\n  link: new HttpLink(),\n  cache\n});\n```\n\n<h2 id=\"configuration\">Configuration</h2>\n\nThe `InMemoryCache` constructor takes an optional config object with properties to customize your cache:\n\n- addTypename: A boolean to determine whether to add __typename to the document (default: `true`)\n- dataIdFromObject: A function that takes a data object and returns a unique identifier to be used when normalizing the data in the store. Learn more about how to customize `dataIdFromObject` in the [Normalization](#normalization) section.\n- fragmentMatcher: By default, the `InMemoryCache` uses a heuristic fragment matcher. If you are using fragments on unions and interfaces, you will need to use an `IntrospectionFragmentMatcher`. For more information, please read [our guide to setting up fragment matching for unions & interfaces](https://www.apollographql.com/docs/react/advanced/fragments.html#fragment-matcher).\n\n<h2 id=\"normalization\">Normalization</h2>\n\nThe `InMemoryCache` normalizes your data before saving it to the store by splitting the result into individual objects, creating a unique identifier for each object, and storing those objects in a flattened data structure. By default, `InMemoryCache` will attempt to use the commonly found primary keys of `id` and `_id` for the unique identifier if they exist along with `__typename` on an object.\n\nIf `id` and `_id` are not specified, or if `__typename` is not specified, `InMemoryCache` will fall back to the path to the object in the query, such as `ROOT_QUERY.allPeople.0` for the first record returned on the `allPeople` root query.\n\nThis \"getter\" behavior for unique identifiers can be configured manually via the `dataIdFromObject` option passed to the `InMemoryCache` constructor, so you can pick which field is used if some of your data follows unorthodox primary key conventions.\n\nFor example, if you wanted to key off of the `key` field for all of your data, you could configure `dataIdFromObject` like so:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => object.key\n});\n```\n\nThis also allows you to use different unique identifiers for different data types by keying off of the `__typename` property attached to every object typed by GraphQL.  For example:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => {\n    switch (object.__typename) {\n      case 'foo': return object.key; // use `key` as the primary key\n      case 'bar': return object.blah; // use `blah` as the priamry key\n      default: return object.id || object._id; // fall back to `id` and `_id` for all other types\n    }\n  }\n});\n```\n\n<h2 id=\"direct\">Direct Cache Access</h2>\n\nTo interact directly with your cache, you can use the Apollo Client class methods readQuery, readFragment, writeQuery, and writeFragment. These methods are available to us via the [`DataProxy` interface](http://dev.apollodata.com/core/apollo-client-api.html#DataProxy). Accessing these methods will vary slightly based on your view layer implementation. If you are using React, you can wrap your component in the `withApollo` higher order component, which will give you access to `this.props.client`. From there, you can use the methods to control your data.\n\nAny code demonstration in the following sections will assume that we have already initialized an instance of  `ApolloClient` and that we have imported the `gql` tag from `graphql-tag`.\n\n<h3 id=\"readquery\">readQuery</h3>\n\nThe `readQuery` method is very similar to the [`query` method on `ApolloClient`][] except that `readQuery` will _never_ make a request to your GraphQL server. The `query` method, on the other hand, may send a request to your server if the appropriate data is not in your cache whereas `readQuery` will throw an error if the data is not in your cache. `readQuery` will _always_ read from the cache. You can use `readQuery` by giving it a GraphQL query like so:\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo {\n      todo(id: 5) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n});\n```\n\nIf all of the data needed to fulfill this read is in Apollo Client’s normalized data cache then a data object will be returned in the shape of the query you wanted to read. If not all of the data needed to fulfill this read is in Apollo Client’s cache then an error will be thrown instead, so make sure to only read data that you know you have!\n\nYou can also pass variables into `readQuery`.\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo($id: Int!) {\n      todo(id: $id) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n  variables: {\n    id: 5,\n  },\n});\n```\n\n<h3 id=\"readfragment\">readFragment</h3>\n\nThis method allows you great flexibility around the data in your cache. Whereas `readQuery` only allowed you to read data from your root query type, `readFragment` allows you to read data from _any node you have queried_. This is incredibly powerful. You use this method as follows:\n\n```js\nconst todo = client.readFragment({\n  id: ..., // `id` is any id that could be returned by `dataIdFromObject`.\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\nThe first argument is the id of the data you want to read from the cache. That id must be a value that was returned by the `dataIdFromObject` function you defined when initializing `ApolloClient`. So for example if you initialized `ApolloClient` like so:\n\n```js\nconst client = new ApolloClient({\n  ...,\n  dataIdFromObject: object => object.id,\n});\n```\n\n…and you requested a todo before with an id of `5`, then you can read that todo out of your cache with the following:\n\n```js\nconst todo = client.readFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\n> **Note:** Most people add a `__typename` to the id in `dataIdFromObject`. If you do this then don’t forget to add the `__typename` when you are reading a fragment as well. So for example your id may be `Todo_5` and not just `5`.\n\nIf a todo with that id does not exist in the cache you will get `null` back. If a todo of that id does exist in the cache, but that todo does not have the `text` field then an error will be thrown.\n\nThe beauty of `readFragment` is that the todo could have come from anywhere! The todo could have been selected as a singleton (`{ todo(id: 5) { ... } }`), the todo could have come from a list of todos (`{ todos { ... } }`), or the todo could have come from a mutation (`mutation { createTodo { ... } }`). As long as at some point your GraphQL server gave you a todo with the provided id and fields `id`, `text`, and `completed` you can read it from the cache at any part of your code.\n\n<h3 id=\"writequery-and-writefragment\">writeQuery` and `writeFragment</h3>\n\nNot only can you read arbitrary data from the Apollo Client cache, but you can also write any data that you would like to the cache. The methods you use to do this are `writeQuery` and `writeFragment`. They will allow you to change data in your local cache, but it is important to remember that *they will not change any data on your server*. If you reload your environment then changes made with `writeQuery` and `writeFragment` will disappear.\n\nThese methods have the same signature as their `readQuery` and `readFragment` counterparts except they also require an additional `data` variable. So for example, if you wanted to update the `completed` flag locally for your todo with id `'5'` you could execute the following:\n\n```js\nclient.writeFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      completed\n    }\n  `,\n  data: {\n    completed: true,\n  },\n});\n```\n\nAny subscriber to the Apollo Client store will instantly see this update and render new UI accordingly.\n\n> **Note:** Again, remember that using `writeQuery` or `writeFragment` only changes data *locally*. If you reload your environment then changes made with these methods will no longer exist.\n\nOr if you wanted to add a new todo to a list fetched from the server, you could use `readQuery` and `writeQuery` together.\n\n```js\nconst query = gql`\n  query MyTodoAppQuery {\n    todos {\n      id\n      text\n      completed\n    }\n  }\n`;\n\nconst data = client.readQuery({ query });\n\nconst myNewTodo = {\n  id: '6',\n  text: 'Start using Apollo Client.',\n  completed: false,\n};\n\nclient.writeQuery({\n  query,\n  data: {\n    todos: [...data.todos, myNewTodo],\n  },\n});\n```\n\n<h2 id=\"recipes\">Recipes</h2>\n\nHere are some common situations where you would need to access the cache directly. If you're manipulating the cache in an interesting way and would like your example to be featured, please send in a pull request!\n\n<h3 id=\"server\">Server side rendering</h3>\n\nFirst, you will need to initialize an `InMemoryCache` on the server and create an instance of `ApolloClient`. In the initial serialized HTML payload from the server, you should include a script tag that extracts the data from the cache.\n\n```js\n`<script>\n  window.__APOLLO_STATE__=${JSON.stringify(cache.extract())}\n</script>`\n```\n\nOn the client, you can rehydrate the cache using the initial data passed from the server:\n\n```js\ncache: new Cache().restore(window.__APOLLO_STATE__)\n```\n\nIf you would like to learn more about server side rendering, please check our our more in depth guide [here].\n<!---\nTODO (PEGGY): Add link to SSR\n-->\n\n<h3 id=\"server\">Updating the cache after a mutation</h3>\n\nBeing able to read and write to the Apollo cache from anywhere in your application gives you a lot of power over your data. However, there is one place where we most often want to update our cached data: after a mutation. As such, Apollo Client has optimized the experience for updating your cache with the read and write methods after a mutation with the `update` function. Let us say that we have the following GraphQL mutation:\n\n```graphql\nmutation TodoCreateMutation($text: String!) {\n  createTodo(text: $text) {\n    id\n    text\n    completed\n  }\n}\n```\n\nWe may also have the following GraphQL query:\n\n```graphql\nquery TodoAppQuery {\n  todos {\n    id\n    text\n    completed\n  }\n}\n```\n\nAt the end of our mutation we want our query to include the new todo like we had sent our `TodoAppQuery` a second time after the mutation finished without actually sending the query. To do this we can use the `update` function provided as an option of the `client.mutate` method. To update your cache with the mutation just write code that looks like:\n\n```js\n// We assume that the GraphQL operations `TodoCreateMutation` and\n// `TodoAppQuery` have already been defined using the `gql` tag.\n\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    // Read the data from our cache for this query.\n    const data = proxy.readQuery({ query: TodoAppQuery });\n\n    // Add our todo from the mutation to the end.\n    data.todos.push(createTodo);\n\n    // Write our data back to the cache.\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nThe first `proxy` argument is an instance of [`DataProxy`][] has the same four methods that we just learned exist on the Apollo Client: `readQuery`, `readFragment`, `writeQuery`, and `writeFragment`. The reason we call them on a `proxy` object here instead of on our `client` instance is that we can easily apply optimistic updates (which we will demonstrate in a bit). The `proxy` object also provides an isolated transaction which shields you from any other mutations going on at the same time, and the `proxy` object also batches writes together until the very end.\n\nIf you provide an `optimisticResponse` option to the mutation then the `update` function will be run twice. Once immediately after you call `client.mutate` with the data from `optimisticResponse`. After the mutation successfully executes against the server the changes made in the first call to `update` will be rolled back and `update` will be called with the *actual* data returned by the mutation and not just the optimistic response.\n\nPutting it all together:\n\n```js\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  optimisticResponse: {\n    id: -1, // -1 is a temporary id for the optimistic response.\n    text,\n    completed: false,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    const data = proxy.readQuery({ query: TodoAppQuery });\n    data.todos.push(createTodo);\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nAs you can see the `update` function on `client.mutate` provides extra change management functionality specific to the use case of a mutation while still providing you the powerful data control APIs that are available on `client`.\n\nThe `update` function is not a good place for side-effects as it may be called multiple times. Also, you may not call any of the methods on `proxy` asynchronously.\n\n",
      "readmeFilename": "README.md",
      "_id": "apollo-cache-inmemory@1.3.0-beta.5",
      "_npmVersion": "5.10.0",
      "_nodeVersion": "8.11.3",
      "_npmUser": {
        "name": "benjamn",
        "email": "ben@benjamn.com"
      },
      "dist": {
        "integrity": "sha512-abZSSGvF3OE+7Ze/mdogVu0jIKRAE3njvPSPXVmQPmGHp0VHDePmucryKb8WuEcjFpCl3SCOtOA5sAW++DDsxQ==",
        "shasum": "ef71dfa7e104d0be763c9949df52363256af9080",
        "tarball": "https://registry.npmjs.org/apollo-cache-inmemory/-/apollo-cache-inmemory-1.3.0-beta.5.tgz",
        "fileCount": 73,
        "unpackedSize": 453381,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJbTolLCRA9TVsSAnZWagAA5d8P/27q9i39BBK2HuX6Jmqn\nENHugKrRLkr4Frp/sGgswFny0nEfENJuIq+Al47WEZhyrKN9JLuptoKi8OhD\ngwCw3+DdD+7eJZufYGjDjWMjMu5sGb9Pa8hVyxn/MZ2dy9O643jfVJMcjIGQ\nbFBpiG8Z74jM8fPt8k5rbgZ1RhUOLRQEFrZCGoI6rmdfWtBsU5Is/N0N+HD9\n9hPkpWFLBW/ylw+Wt1nUxiXiBy9jDVXk7bHepFykLpz4+nclTjb75UKcfprN\nam2cd3l08sOtjiWDvbJEghSHzGSEJz2H3roGAmPv+se4vrO/ITf/anaoIneU\nrJezuDfPc0xcJw7VbPyZj4qzL9IFZZCS0+hciRt6ufk19lpjctw/76qU9KKy\nZmTwtOwsgs7/w41L8nXDjySRSBxagWi0Lkjsplzp4PnnqnSoYejvl1Sqqt0K\nUTjK+IRzZc7uf95S/6yyJQ1Z4VzNDveKAi7ueb2Aai0SeZh4wotNT+hp+KPO\nbwVy86ZcaRd2h0npz/4N1VwXUvSpkRAyAyt3qSSO9OLXRfgGTEUXfEe+JGWv\nbr1OlnMyaK+3Dp5wLkN/Zyc7cfEVIqw4YkwA2jn1DIEmXc5nBgfFOxxACAPs\nSEOTqCpD94tDh3RGwMId0cH6dhe2YVCoGEImwlrbHFI6e8QyFLvhxO8VIiwh\nLoB4\r\n=kiNL\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIA2x9rEWyPvEb3rP765m+49EodOEKntbrB6s5FgFx1MBAiEAyQg4y8ZnsTtjbRiFWEb0WaljoBplQA1vFB5+ai3u1+c="
          }
        ]
      },
      "maintainers": [
        {
          "email": "ben@benjamn.com",
          "name": "benjamn"
        },
        {
          "email": "james@meteor.com",
          "name": "jbaxleyiii"
        },
        {
          "email": "npm@meteor.com",
          "name": "mdg"
        },
        {
          "email": "peggyrayzis@gmail.com",
          "name": "peggyrayzis"
        }
      ],
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/apollo-cache-inmemory_1.3.0-beta.5_1531873611611_0.2800242132949933"
      },
      "_hasShrinkwrap": false
    },
    "1.2.6-alpha.1": {
      "name": "apollo-cache-inmemory",
      "version": "1.2.6-alpha.1",
      "description": "Core abstract of Caching layer for Apollo Client",
      "author": {
        "name": "James Baxley",
        "email": "james@meteor.com"
      },
      "contributors": [
        {
          "name": "James Baxley",
          "email": "james@meteor.com"
        },
        {
          "name": "Jonas Helfer",
          "email": "jonas@helfer.email"
        },
        {
          "name": "Sashko Stubailo",
          "email": "sashko@stubailo.com"
        },
        {
          "name": "James Burgess",
          "email": "jamesmillerburgess@gmail.com"
        },
        {
          "name": "Bazyli Brzóska",
          "email": "bazyli.brzoska@gmail.com"
        }
      ],
      "license": "MIT",
      "main": "./lib/bundle.umd.js",
      "module": "./lib/index.js",
      "jsnext:main": "./lib/index.js",
      "typings": "./lib/index.d.ts",
      "sideEffects": false,
      "repository": {
        "type": "git",
        "url": "git+https://github.com/apollographql/apollo-client.git"
      },
      "bugs": {
        "url": "https://github.com/apollographql/apollo-client/issues"
      },
      "homepage": "https://github.com/apollographql/apollo-client#readme",
      "scripts": {
        "coverage": "jest --coverage",
        "test": "jest",
        "lint": "tslint --type-check -p tsconfig.json src/*.ts",
        "prebuild": "npm run clean",
        "build": "tsc -p .",
        "postbuild": "npm run bundle",
        "bundle": "rollup -c rollup.config.js",
        "watch": "tsc -w -p .",
        "clean": "rimraf coverage/* && rimraf lib/*",
        "prepublishOnly": "npm run build",
        "build:browser": "browserify ./lib/bundle.umd.js --i apollo-cache --i apollo-utilities --i graphql -o=./lib/bundle.js && npm run minify:browser",
        "minify:browser": "uglifyjs -c -m -o ./lib/bundle.min.js -- ./lib/bundle.js",
        "filesize": "npm run build:browser"
      },
      "dependencies": {
        "apollo-cache": "^1.1.13-alpha.1",
        "apollo-utilities": "^1.0.17-alpha.1",
        "graphql-anywhere": "^4.1.15-alpha.1"
      },
      "peerDependencies": {
        "graphql": "0.11.7 || ^0.12.0 || ^0.13.0"
      },
      "devDependencies": {
        "@types/graphql": "0.12.7",
        "@types/jest": "22.2.3",
        "@types/lodash": "4.14.112",
        "browserify": "15.2.0",
        "graphql": "0.13.2",
        "graphql-tag": "2.9.2",
        "jest": "23.0.0",
        "lodash": "4.17.10",
        "rimraf": "2.6.2",
        "rollup": "0.62.0",
        "ts-jest": "20.0.14",
        "tslint": "5.11.0",
        "typescript": "2.9.2",
        "uglifyjs": "2.4.11"
      },
      "jest": {
        "transform": {
          ".(ts|tsx)": "<rootDir>/node_modules/ts-jest/preprocessor.js"
        },
        "testRegex": "(/__tests__/.*|\\.(test|spec))\\.(ts|tsx|js)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "json"
        ]
      },
      "readme": "---\ntitle: InMemoryCache\ndescription: An explanation of `apollo-cache-inmemory`\n---\n\n`apollo-cache-inmemory` is the recommended cache implementation for Apollo Client 2.0. `InMemoryCache` is a normalized data store that supports all of Apollo Client 1.0's features without the dependency on Redux.\n\nIn some instances, you may need to manipulate the cache directly, such as updating the store after a mutation. We'll cover some common use cases [here](#recipes).\n\n<h2 id=\"installation\">Installation</h2>\n\n```\nnpm install apollo-cache-inmemory --save\n```\n\nAfter installing the package, you'll want to initialize the cache constructor. Then, you can pass in your newly created cache to ApolloClient.\n\n```js\nimport { InMemoryCache } from 'apollo-cache-inmemory';\nimport { HttpLink } from 'apollo-link-http';\nimport ApolloClient from 'apollo-client';\n\nconst cache = new InMemoryCache();\n\nconst client = new ApolloClient({\n  link: new HttpLink(),\n  cache\n});\n```\n\n<h2 id=\"configuration\">Configuration</h2>\n\nThe `InMemoryCache` constructor takes an optional config object with properties to customize your cache:\n\n- addTypename: A boolean to determine whether to add __typename to the document (default: `true`)\n- dataIdFromObject: A function that takes a data object and returns a unique identifier to be used when normalizing the data in the store. Learn more about how to customize `dataIdFromObject` in the [Normalization](#normalization) section.\n- fragmentMatcher: By default, the `InMemoryCache` uses a heuristic fragment matcher. If you are using fragments on unions and interfaces, you will need to use an `IntrospectionFragmentMatcher`. For more information, please read [our guide to setting up fragment matching for unions & interfaces](https://www.apollographql.com/docs/react/advanced/fragments.html#fragment-matcher).\n\n<h2 id=\"normalization\">Normalization</h2>\n\nThe `InMemoryCache` normalizes your data before saving it to the store by splitting the result into individual objects, creating a unique identifier for each object, and storing those objects in a flattened data structure. By default, `InMemoryCache` will attempt to use the commonly found primary keys of `id` and `_id` for the unique identifier if they exist along with `__typename` on an object.\n\nIf `id` and `_id` are not specified, or if `__typename` is not specified, `InMemoryCache` will fall back to the path to the object in the query, such as `ROOT_QUERY.allPeople.0` for the first record returned on the `allPeople` root query.\n\nThis \"getter\" behavior for unique identifiers can be configured manually via the `dataIdFromObject` option passed to the `InMemoryCache` constructor, so you can pick which field is used if some of your data follows unorthodox primary key conventions.\n\nFor example, if you wanted to key off of the `key` field for all of your data, you could configure `dataIdFromObject` like so:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => object.key\n});\n```\n\nThis also allows you to use different unique identifiers for different data types by keying off of the `__typename` property attached to every object typed by GraphQL.  For example:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => {\n    switch (object.__typename) {\n      case 'foo': return object.key; // use `key` as the primary key\n      case 'bar': return object.blah; // use `blah` as the priamry key\n      default: return object.id || object._id; // fall back to `id` and `_id` for all other types\n    }\n  }\n});\n```\n\n<h2 id=\"direct\">Direct Cache Access</h2>\n\nTo interact directly with your cache, you can use the Apollo Client class methods readQuery, readFragment, writeQuery, and writeFragment. These methods are available to us via the [`DataProxy` interface](http://dev.apollodata.com/core/apollo-client-api.html#DataProxy). Accessing these methods will vary slightly based on your view layer implementation. If you are using React, you can wrap your component in the `withApollo` higher order component, which will give you access to `this.props.client`. From there, you can use the methods to control your data.\n\nAny code demonstration in the following sections will assume that we have already initialized an instance of  `ApolloClient` and that we have imported the `gql` tag from `graphql-tag`.\n\n<h3 id=\"readquery\">readQuery</h3>\n\nThe `readQuery` method is very similar to the [`query` method on `ApolloClient`][] except that `readQuery` will _never_ make a request to your GraphQL server. The `query` method, on the other hand, may send a request to your server if the appropriate data is not in your cache whereas `readQuery` will throw an error if the data is not in your cache. `readQuery` will _always_ read from the cache. You can use `readQuery` by giving it a GraphQL query like so:\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo {\n      todo(id: 5) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n});\n```\n\nIf all of the data needed to fulfill this read is in Apollo Client’s normalized data cache then a data object will be returned in the shape of the query you wanted to read. If not all of the data needed to fulfill this read is in Apollo Client’s cache then an error will be thrown instead, so make sure to only read data that you know you have!\n\nYou can also pass variables into `readQuery`.\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo($id: Int!) {\n      todo(id: $id) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n  variables: {\n    id: 5,\n  },\n});\n```\n\n<h3 id=\"readfragment\">readFragment</h3>\n\nThis method allows you great flexibility around the data in your cache. Whereas `readQuery` only allowed you to read data from your root query type, `readFragment` allows you to read data from _any node you have queried_. This is incredibly powerful. You use this method as follows:\n\n```js\nconst todo = client.readFragment({\n  id: ..., // `id` is any id that could be returned by `dataIdFromObject`.\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\nThe first argument is the id of the data you want to read from the cache. That id must be a value that was returned by the `dataIdFromObject` function you defined when initializing `ApolloClient`. So for example if you initialized `ApolloClient` like so:\n\n```js\nconst client = new ApolloClient({\n  ...,\n  dataIdFromObject: object => object.id,\n});\n```\n\n…and you requested a todo before with an id of `5`, then you can read that todo out of your cache with the following:\n\n```js\nconst todo = client.readFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\n> **Note:** Most people add a `__typename` to the id in `dataIdFromObject`. If you do this then don’t forget to add the `__typename` when you are reading a fragment as well. So for example your id may be `Todo_5` and not just `5`.\n\nIf a todo with that id does not exist in the cache you will get `null` back. If a todo of that id does exist in the cache, but that todo does not have the `text` field then an error will be thrown.\n\nThe beauty of `readFragment` is that the todo could have come from anywhere! The todo could have been selected as a singleton (`{ todo(id: 5) { ... } }`), the todo could have come from a list of todos (`{ todos { ... } }`), or the todo could have come from a mutation (`mutation { createTodo { ... } }`). As long as at some point your GraphQL server gave you a todo with the provided id and fields `id`, `text`, and `completed` you can read it from the cache at any part of your code.\n\n<h3 id=\"writequery-and-writefragment\">writeQuery` and `writeFragment</h3>\n\nNot only can you read arbitrary data from the Apollo Client cache, but you can also write any data that you would like to the cache. The methods you use to do this are `writeQuery` and `writeFragment`. They will allow you to change data in your local cache, but it is important to remember that *they will not change any data on your server*. If you reload your environment then changes made with `writeQuery` and `writeFragment` will disappear.\n\nThese methods have the same signature as their `readQuery` and `readFragment` counterparts except they also require an additional `data` variable. So for example, if you wanted to update the `completed` flag locally for your todo with id `'5'` you could execute the following:\n\n```js\nclient.writeFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      completed\n    }\n  `,\n  data: {\n    completed: true,\n  },\n});\n```\n\nAny subscriber to the Apollo Client store will instantly see this update and render new UI accordingly.\n\n> **Note:** Again, remember that using `writeQuery` or `writeFragment` only changes data *locally*. If you reload your environment then changes made with these methods will no longer exist.\n\nOr if you wanted to add a new todo to a list fetched from the server, you could use `readQuery` and `writeQuery` together.\n\n```js\nconst query = gql`\n  query MyTodoAppQuery {\n    todos {\n      id\n      text\n      completed\n    }\n  }\n`;\n\nconst data = client.readQuery({ query });\n\nconst myNewTodo = {\n  id: '6',\n  text: 'Start using Apollo Client.',\n  completed: false,\n};\n\nclient.writeQuery({\n  query,\n  data: {\n    todos: [...data.todos, myNewTodo],\n  },\n});\n```\n\n<h2 id=\"recipes\">Recipes</h2>\n\nHere are some common situations where you would need to access the cache directly. If you're manipulating the cache in an interesting way and would like your example to be featured, please send in a pull request!\n\n<h3 id=\"server\">Server side rendering</h3>\n\nFirst, you will need to initialize an `InMemoryCache` on the server and create an instance of `ApolloClient`. In the initial serialized HTML payload from the server, you should include a script tag that extracts the data from the cache.\n\n```js\n`<script>\n  window.__APOLLO_STATE__=${JSON.stringify(cache.extract())}\n</script>`\n```\n\nOn the client, you can rehydrate the cache using the initial data passed from the server:\n\n```js\ncache: new Cache().restore(window.__APOLLO_STATE__)\n```\n\nIf you would like to learn more about server side rendering, please check our our more in depth guide [here].\n<!---\nTODO (PEGGY): Add link to SSR\n-->\n\n<h3 id=\"server\">Updating the cache after a mutation</h3>\n\nBeing able to read and write to the Apollo cache from anywhere in your application gives you a lot of power over your data. However, there is one place where we most often want to update our cached data: after a mutation. As such, Apollo Client has optimized the experience for updating your cache with the read and write methods after a mutation with the `update` function. Let us say that we have the following GraphQL mutation:\n\n```graphql\nmutation TodoCreateMutation($text: String!) {\n  createTodo(text: $text) {\n    id\n    text\n    completed\n  }\n}\n```\n\nWe may also have the following GraphQL query:\n\n```graphql\nquery TodoAppQuery {\n  todos {\n    id\n    text\n    completed\n  }\n}\n```\n\nAt the end of our mutation we want our query to include the new todo like we had sent our `TodoAppQuery` a second time after the mutation finished without actually sending the query. To do this we can use the `update` function provided as an option of the `client.mutate` method. To update your cache with the mutation just write code that looks like:\n\n```js\n// We assume that the GraphQL operations `TodoCreateMutation` and\n// `TodoAppQuery` have already been defined using the `gql` tag.\n\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    // Read the data from our cache for this query.\n    const data = proxy.readQuery({ query: TodoAppQuery });\n\n    // Add our todo from the mutation to the end.\n    data.todos.push(createTodo);\n\n    // Write our data back to the cache.\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nThe first `proxy` argument is an instance of [`DataProxy`][] has the same four methods that we just learned exist on the Apollo Client: `readQuery`, `readFragment`, `writeQuery`, and `writeFragment`. The reason we call them on a `proxy` object here instead of on our `client` instance is that we can easily apply optimistic updates (which we will demonstrate in a bit). The `proxy` object also provides an isolated transaction which shields you from any other mutations going on at the same time, and the `proxy` object also batches writes together until the very end.\n\nIf you provide an `optimisticResponse` option to the mutation then the `update` function will be run twice. Once immediately after you call `client.mutate` with the data from `optimisticResponse`. After the mutation successfully executes against the server the changes made in the first call to `update` will be rolled back and `update` will be called with the *actual* data returned by the mutation and not just the optimistic response.\n\nPutting it all together:\n\n```js\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  optimisticResponse: {\n    id: -1, // -1 is a temporary id for the optimistic response.\n    text,\n    completed: false,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    const data = proxy.readQuery({ query: TodoAppQuery });\n    data.todos.push(createTodo);\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nAs you can see the `update` function on `client.mutate` provides extra change management functionality specific to the use case of a mutation while still providing you the powerful data control APIs that are available on `client`.\n\nThe `update` function is not a good place for side-effects as it may be called multiple times. Also, you may not call any of the methods on `proxy` asynchronously.\n\n",
      "readmeFilename": "README.md",
      "_id": "apollo-cache-inmemory@1.2.6-alpha.1",
      "_npmVersion": "5.6.0",
      "_nodeVersion": "8.11.2",
      "_npmUser": {
        "name": "mdg",
        "email": "npm@meteor.com"
      },
      "dist": {
        "integrity": "sha512-HgQLWmMw/VkDenw+Gv/P0uYY8yeiwj3r15XZYQKmroTXgXEyIS3K8hoB08ZYUborJabb5RWKc+0r2jsi2OGDNQ==",
        "shasum": "51a9850b60a278cbc5154cd3e36c7c4a989c920d",
        "tarball": "https://registry.npmjs.org/apollo-cache-inmemory/-/apollo-cache-inmemory-1.2.6-alpha.1.tgz",
        "fileCount": 61,
        "unpackedSize": 427598,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJbUMqMCRA9TVsSAnZWagAAaUIP/0AyQnf8gkX1J4b3eUXJ\nZ6cGNN3Qw6Fu5EWYx8Z1qvfZKOBoUOwaA35DuBhSlX6zY1EeaH9PPaVJZTwz\nXifcLaqOd1V81llDjpfLLnd/+/6clV2nDU62iptnOXKQKzerwMxp126nYkKg\nq0Pcl9vZZ2pAZRY8S4MmnQdDdYCbjSdLKwKe4sx96+lzYYq7osYEZE3xy0JT\nTKuO+HSokLx4F4b6I1WcEsKW11GEaHuacL2eQ/yKJjpHafp7lvB0mha+pscF\nKW5tt5GGCIQwYgjoZr8qZvfPg1EPl9MSya0Da7rqEf81dVO4e170wfpmNHTE\nuWypc2zevYCpnIeGRW6xWjru4YVve+DeoXloCsfVdaxkwzNWJLJUQTEirwwL\neEYtvKEyuMW5LP5uJphrhhtcB2TRypYniE3iXUISxBn7RO8dyeNJp3RUIMAx\nckc97rOs1ZzHR6VMxhe979C5kwmmEqW3gJpPb/RkefvghDenufZDgGMJFOQv\n5PdN4/9TPgBf4iMOmUle/gOf8gU9SF+niK3MJD90o211KUmpG9E9ggJABvsB\nkNVdXnQP7lffpbfFtWtXDZO7EEHlqvy75RlGMQWabA8slkGcWLOV1wjMIhMr\nJ78CwwvSI4Tt+/Y401/Jn10IetiXl4IZUa+lNPnijT11tOEQH/4PVlHKWkf4\nI+M9\r\n=5KDb\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIDdCtItHGDlFrMQAUCes9PPGyHmfcKNz1DKXged81pBwAiEAvC2mBPhjG33cdqZhlxRCfqHpKIiW8mIzYWpt5LO2LVk="
          }
        ]
      },
      "maintainers": [
        {
          "email": "ben@benjamn.com",
          "name": "benjamn"
        },
        {
          "email": "james@meteor.com",
          "name": "jbaxleyiii"
        },
        {
          "email": "npm@meteor.com",
          "name": "mdg"
        },
        {
          "email": "peggyrayzis@gmail.com",
          "name": "peggyrayzis"
        }
      ],
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/apollo-cache-inmemory_1.2.6-alpha.1_1532021388067_0.7184988508785186"
      },
      "_hasShrinkwrap": false
    },
    "1.2.6-alpha.2": {
      "name": "apollo-cache-inmemory",
      "version": "1.2.6-alpha.2",
      "description": "Core abstract of Caching layer for Apollo Client",
      "author": {
        "name": "James Baxley",
        "email": "james@meteor.com"
      },
      "contributors": [
        {
          "name": "James Baxley",
          "email": "james@meteor.com"
        },
        {
          "name": "Jonas Helfer",
          "email": "jonas@helfer.email"
        },
        {
          "name": "Sashko Stubailo",
          "email": "sashko@stubailo.com"
        },
        {
          "name": "James Burgess",
          "email": "jamesmillerburgess@gmail.com"
        },
        {
          "name": "Bazyli Brzóska",
          "email": "bazyli.brzoska@gmail.com"
        }
      ],
      "license": "MIT",
      "main": "./lib/bundle.umd.js",
      "module": "./lib/index.js",
      "jsnext:main": "./lib/index.js",
      "typings": "./lib/index.d.ts",
      "sideEffects": false,
      "repository": {
        "type": "git",
        "url": "git+https://github.com/apollographql/apollo-client.git"
      },
      "bugs": {
        "url": "https://github.com/apollographql/apollo-client/issues"
      },
      "homepage": "https://github.com/apollographql/apollo-client#readme",
      "scripts": {
        "coverage": "jest --coverage",
        "test": "jest",
        "lint": "tslint --type-check -p tsconfig.json src/*.ts",
        "prebuild": "npm run clean",
        "build": "tsc -p .",
        "postbuild": "npm run bundle",
        "bundle": "rollup -c rollup.config.js",
        "watch": "tsc -w -p .",
        "clean": "rimraf coverage/* && rimraf lib/*",
        "prepublishOnly": "npm run build",
        "build:browser": "browserify ./lib/bundle.umd.js --i apollo-cache --i apollo-utilities --i graphql -o=./lib/bundle.js && npm run minify:browser",
        "minify:browser": "uglifyjs -c -m -o ./lib/bundle.min.js -- ./lib/bundle.js",
        "filesize": "npm run build:browser"
      },
      "dependencies": {
        "apollo-cache": "^1.1.13-alpha.2",
        "apollo-utilities": "^1.0.17-alpha.2",
        "graphql-anywhere": "^4.1.15-alpha.2"
      },
      "peerDependencies": {
        "graphql": "0.11.7 || ^0.12.0 || ^0.13.0"
      },
      "devDependencies": {
        "@types/graphql": "0.12.7",
        "@types/jest": "22.2.3",
        "@types/lodash": "4.14.112",
        "browserify": "15.2.0",
        "graphql": "0.13.2",
        "graphql-tag": "2.9.2",
        "jest": "23.0.0",
        "lodash": "4.17.10",
        "rimraf": "2.6.2",
        "rollup": "0.62.0",
        "ts-jest": "20.0.14",
        "tslint": "5.11.0",
        "typescript": "2.9.2",
        "uglifyjs": "2.4.11"
      },
      "jest": {
        "transform": {
          ".(ts|tsx)": "<rootDir>/node_modules/ts-jest/preprocessor.js"
        },
        "testRegex": "(/__tests__/.*|\\.(test|spec))\\.(ts|tsx|js)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "json"
        ]
      },
      "readme": "---\ntitle: InMemoryCache\ndescription: An explanation of `apollo-cache-inmemory`\n---\n\n`apollo-cache-inmemory` is the recommended cache implementation for Apollo Client 2.0. `InMemoryCache` is a normalized data store that supports all of Apollo Client 1.0's features without the dependency on Redux.\n\nIn some instances, you may need to manipulate the cache directly, such as updating the store after a mutation. We'll cover some common use cases [here](#recipes).\n\n<h2 id=\"installation\">Installation</h2>\n\n```\nnpm install apollo-cache-inmemory --save\n```\n\nAfter installing the package, you'll want to initialize the cache constructor. Then, you can pass in your newly created cache to ApolloClient.\n\n```js\nimport { InMemoryCache } from 'apollo-cache-inmemory';\nimport { HttpLink } from 'apollo-link-http';\nimport ApolloClient from 'apollo-client';\n\nconst cache = new InMemoryCache();\n\nconst client = new ApolloClient({\n  link: new HttpLink(),\n  cache\n});\n```\n\n<h2 id=\"configuration\">Configuration</h2>\n\nThe `InMemoryCache` constructor takes an optional config object with properties to customize your cache:\n\n- addTypename: A boolean to determine whether to add __typename to the document (default: `true`)\n- dataIdFromObject: A function that takes a data object and returns a unique identifier to be used when normalizing the data in the store. Learn more about how to customize `dataIdFromObject` in the [Normalization](#normalization) section.\n- fragmentMatcher: By default, the `InMemoryCache` uses a heuristic fragment matcher. If you are using fragments on unions and interfaces, you will need to use an `IntrospectionFragmentMatcher`. For more information, please read [our guide to setting up fragment matching for unions & interfaces](https://www.apollographql.com/docs/react/advanced/fragments.html#fragment-matcher).\n\n<h2 id=\"normalization\">Normalization</h2>\n\nThe `InMemoryCache` normalizes your data before saving it to the store by splitting the result into individual objects, creating a unique identifier for each object, and storing those objects in a flattened data structure. By default, `InMemoryCache` will attempt to use the commonly found primary keys of `id` and `_id` for the unique identifier if they exist along with `__typename` on an object.\n\nIf `id` and `_id` are not specified, or if `__typename` is not specified, `InMemoryCache` will fall back to the path to the object in the query, such as `ROOT_QUERY.allPeople.0` for the first record returned on the `allPeople` root query.\n\nThis \"getter\" behavior for unique identifiers can be configured manually via the `dataIdFromObject` option passed to the `InMemoryCache` constructor, so you can pick which field is used if some of your data follows unorthodox primary key conventions.\n\nFor example, if you wanted to key off of the `key` field for all of your data, you could configure `dataIdFromObject` like so:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => object.key\n});\n```\n\nThis also allows you to use different unique identifiers for different data types by keying off of the `__typename` property attached to every object typed by GraphQL.  For example:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => {\n    switch (object.__typename) {\n      case 'foo': return object.key; // use `key` as the primary key\n      case 'bar': return object.blah; // use `blah` as the priamry key\n      default: return object.id || object._id; // fall back to `id` and `_id` for all other types\n    }\n  }\n});\n```\n\n<h2 id=\"direct\">Direct Cache Access</h2>\n\nTo interact directly with your cache, you can use the Apollo Client class methods readQuery, readFragment, writeQuery, and writeFragment. These methods are available to us via the [`DataProxy` interface](http://dev.apollodata.com/core/apollo-client-api.html#DataProxy). Accessing these methods will vary slightly based on your view layer implementation. If you are using React, you can wrap your component in the `withApollo` higher order component, which will give you access to `this.props.client`. From there, you can use the methods to control your data.\n\nAny code demonstration in the following sections will assume that we have already initialized an instance of  `ApolloClient` and that we have imported the `gql` tag from `graphql-tag`.\n\n<h3 id=\"readquery\">readQuery</h3>\n\nThe `readQuery` method is very similar to the [`query` method on `ApolloClient`][] except that `readQuery` will _never_ make a request to your GraphQL server. The `query` method, on the other hand, may send a request to your server if the appropriate data is not in your cache whereas `readQuery` will throw an error if the data is not in your cache. `readQuery` will _always_ read from the cache. You can use `readQuery` by giving it a GraphQL query like so:\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo {\n      todo(id: 5) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n});\n```\n\nIf all of the data needed to fulfill this read is in Apollo Client’s normalized data cache then a data object will be returned in the shape of the query you wanted to read. If not all of the data needed to fulfill this read is in Apollo Client’s cache then an error will be thrown instead, so make sure to only read data that you know you have!\n\nYou can also pass variables into `readQuery`.\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo($id: Int!) {\n      todo(id: $id) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n  variables: {\n    id: 5,\n  },\n});\n```\n\n<h3 id=\"readfragment\">readFragment</h3>\n\nThis method allows you great flexibility around the data in your cache. Whereas `readQuery` only allowed you to read data from your root query type, `readFragment` allows you to read data from _any node you have queried_. This is incredibly powerful. You use this method as follows:\n\n```js\nconst todo = client.readFragment({\n  id: ..., // `id` is any id that could be returned by `dataIdFromObject`.\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\nThe first argument is the id of the data you want to read from the cache. That id must be a value that was returned by the `dataIdFromObject` function you defined when initializing `ApolloClient`. So for example if you initialized `ApolloClient` like so:\n\n```js\nconst client = new ApolloClient({\n  ...,\n  dataIdFromObject: object => object.id,\n});\n```\n\n…and you requested a todo before with an id of `5`, then you can read that todo out of your cache with the following:\n\n```js\nconst todo = client.readFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\n> **Note:** Most people add a `__typename` to the id in `dataIdFromObject`. If you do this then don’t forget to add the `__typename` when you are reading a fragment as well. So for example your id may be `Todo_5` and not just `5`.\n\nIf a todo with that id does not exist in the cache you will get `null` back. If a todo of that id does exist in the cache, but that todo does not have the `text` field then an error will be thrown.\n\nThe beauty of `readFragment` is that the todo could have come from anywhere! The todo could have been selected as a singleton (`{ todo(id: 5) { ... } }`), the todo could have come from a list of todos (`{ todos { ... } }`), or the todo could have come from a mutation (`mutation { createTodo { ... } }`). As long as at some point your GraphQL server gave you a todo with the provided id and fields `id`, `text`, and `completed` you can read it from the cache at any part of your code.\n\n<h3 id=\"writequery-and-writefragment\">writeQuery` and `writeFragment</h3>\n\nNot only can you read arbitrary data from the Apollo Client cache, but you can also write any data that you would like to the cache. The methods you use to do this are `writeQuery` and `writeFragment`. They will allow you to change data in your local cache, but it is important to remember that *they will not change any data on your server*. If you reload your environment then changes made with `writeQuery` and `writeFragment` will disappear.\n\nThese methods have the same signature as their `readQuery` and `readFragment` counterparts except they also require an additional `data` variable. So for example, if you wanted to update the `completed` flag locally for your todo with id `'5'` you could execute the following:\n\n```js\nclient.writeFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      completed\n    }\n  `,\n  data: {\n    completed: true,\n  },\n});\n```\n\nAny subscriber to the Apollo Client store will instantly see this update and render new UI accordingly.\n\n> **Note:** Again, remember that using `writeQuery` or `writeFragment` only changes data *locally*. If you reload your environment then changes made with these methods will no longer exist.\n\nOr if you wanted to add a new todo to a list fetched from the server, you could use `readQuery` and `writeQuery` together.\n\n```js\nconst query = gql`\n  query MyTodoAppQuery {\n    todos {\n      id\n      text\n      completed\n    }\n  }\n`;\n\nconst data = client.readQuery({ query });\n\nconst myNewTodo = {\n  id: '6',\n  text: 'Start using Apollo Client.',\n  completed: false,\n};\n\nclient.writeQuery({\n  query,\n  data: {\n    todos: [...data.todos, myNewTodo],\n  },\n});\n```\n\n<h2 id=\"recipes\">Recipes</h2>\n\nHere are some common situations where you would need to access the cache directly. If you're manipulating the cache in an interesting way and would like your example to be featured, please send in a pull request!\n\n<h3 id=\"server\">Server side rendering</h3>\n\nFirst, you will need to initialize an `InMemoryCache` on the server and create an instance of `ApolloClient`. In the initial serialized HTML payload from the server, you should include a script tag that extracts the data from the cache.\n\n```js\n`<script>\n  window.__APOLLO_STATE__=${JSON.stringify(cache.extract())}\n</script>`\n```\n\nOn the client, you can rehydrate the cache using the initial data passed from the server:\n\n```js\ncache: new Cache().restore(window.__APOLLO_STATE__)\n```\n\nIf you would like to learn more about server side rendering, please check our our more in depth guide [here].\n<!---\nTODO (PEGGY): Add link to SSR\n-->\n\n<h3 id=\"server\">Updating the cache after a mutation</h3>\n\nBeing able to read and write to the Apollo cache from anywhere in your application gives you a lot of power over your data. However, there is one place where we most often want to update our cached data: after a mutation. As such, Apollo Client has optimized the experience for updating your cache with the read and write methods after a mutation with the `update` function. Let us say that we have the following GraphQL mutation:\n\n```graphql\nmutation TodoCreateMutation($text: String!) {\n  createTodo(text: $text) {\n    id\n    text\n    completed\n  }\n}\n```\n\nWe may also have the following GraphQL query:\n\n```graphql\nquery TodoAppQuery {\n  todos {\n    id\n    text\n    completed\n  }\n}\n```\n\nAt the end of our mutation we want our query to include the new todo like we had sent our `TodoAppQuery` a second time after the mutation finished without actually sending the query. To do this we can use the `update` function provided as an option of the `client.mutate` method. To update your cache with the mutation just write code that looks like:\n\n```js\n// We assume that the GraphQL operations `TodoCreateMutation` and\n// `TodoAppQuery` have already been defined using the `gql` tag.\n\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    // Read the data from our cache for this query.\n    const data = proxy.readQuery({ query: TodoAppQuery });\n\n    // Add our todo from the mutation to the end.\n    data.todos.push(createTodo);\n\n    // Write our data back to the cache.\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nThe first `proxy` argument is an instance of [`DataProxy`][] has the same four methods that we just learned exist on the Apollo Client: `readQuery`, `readFragment`, `writeQuery`, and `writeFragment`. The reason we call them on a `proxy` object here instead of on our `client` instance is that we can easily apply optimistic updates (which we will demonstrate in a bit). The `proxy` object also provides an isolated transaction which shields you from any other mutations going on at the same time, and the `proxy` object also batches writes together until the very end.\n\nIf you provide an `optimisticResponse` option to the mutation then the `update` function will be run twice. Once immediately after you call `client.mutate` with the data from `optimisticResponse`. After the mutation successfully executes against the server the changes made in the first call to `update` will be rolled back and `update` will be called with the *actual* data returned by the mutation and not just the optimistic response.\n\nPutting it all together:\n\n```js\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  optimisticResponse: {\n    id: -1, // -1 is a temporary id for the optimistic response.\n    text,\n    completed: false,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    const data = proxy.readQuery({ query: TodoAppQuery });\n    data.todos.push(createTodo);\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nAs you can see the `update` function on `client.mutate` provides extra change management functionality specific to the use case of a mutation while still providing you the powerful data control APIs that are available on `client`.\n\nThe `update` function is not a good place for side-effects as it may be called multiple times. Also, you may not call any of the methods on `proxy` asynchronously.\n\n",
      "readmeFilename": "README.md",
      "_id": "apollo-cache-inmemory@1.2.6-alpha.2",
      "_npmVersion": "6.1.0",
      "_nodeVersion": "10.6.0",
      "_npmUser": {
        "name": "mdg",
        "email": "npm@meteor.com"
      },
      "dist": {
        "integrity": "sha512-k7Ow4wAo+XTUttOHNbYI4Kp1tpwRhOHxd73pULz+4fn6bV68TexcGLJVKA35arnnaKLs4Nhg7MijDRuXp7hXqg==",
        "shasum": "31412f0502ddf17eaf0a1f403742fe957707a9df",
        "tarball": "https://registry.npmjs.org/apollo-cache-inmemory/-/apollo-cache-inmemory-1.2.6-alpha.2.tgz",
        "fileCount": 61,
        "unpackedSize": 427598,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJbVd6vCRA9TVsSAnZWagAA/XcP/RGG0fbdyOE2UOd/fOZN\nl/+WjvbtQGoGjrHwMCb2c/KTOgfjVjoDmGwfyVRxlLTA+K91VjBTTxy8xMaZ\nDC6yvY6azgEiowyAmxCHDWeYZd6WqfF7vlrAx6w2+CCKqPhuUk+tRIwO20f2\nfup9qOQ6qWTHgWtioU12IRvNo/Y9C4v+ygi/HNFWhMMFC3bv07fWr8fPOfey\nq56xhlX8qXFqoqLWNm708kvNX8HzLh++292kl6FKbeKTn5Y1vEK36P6XOxZo\n1+r8ahIYIn3dAYfoWhWhxRE+jE0e/X+6VeU8XNbexAYeZcNMbC1TM9mgp4AQ\ntvTBg4sE++oyp3cgeN+1FVwcHxSyyhvIoSOYrpEZ6AhT9pACRwHcT9GCYJ87\nnSVOGBO0weXCa6NseE4/smuZ2tLuLYKEXvSB8xLF4Y7a/wAI1vt/lLzL4wQs\n8sdxeDVLrD5BqIoDHkbeUrvKjG3pSLwXKi49oYFhSyZDx2x1NPPcdxSNqBm4\nnZf2JTkjbSKZKG7PBDzfBK6A7Uox96jHmh9ba6s1M2qdXBnf8Ef0ywchrV4G\nQ1aMftLMJpcz/UN44mA8/HyBubxM27SRD4fEbPfhOheTKRMrAObnHtJR+T4f\nl9ei10ay5oOc/j2omoaYCMryV6al+eNwwTohUvOgLkoyYWF/66ODLZAc0y6C\nDLth\r\n=iz5s\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIQDrgVOzrkUMrqoX3weW3ugM9tKaUevBnmHFKk4rJ1XkegIgdmOeqgRWZKh4QpCySy5dXAsPYkE84mrTxB4RwChsqko="
          }
        ]
      },
      "maintainers": [
        {
          "email": "ben@benjamn.com",
          "name": "benjamn"
        },
        {
          "email": "james@meteor.com",
          "name": "jbaxleyiii"
        },
        {
          "email": "npm@meteor.com",
          "name": "mdg"
        },
        {
          "email": "peggyrayzis@gmail.com",
          "name": "peggyrayzis"
        }
      ],
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/apollo-cache-inmemory_1.2.6-alpha.2_1532354222974_0.3426795875078483"
      },
      "_hasShrinkwrap": false
    },
    "1.2.6": {
      "name": "apollo-cache-inmemory",
      "version": "1.2.6",
      "description": "Core abstract of Caching layer for Apollo Client",
      "author": {
        "name": "James Baxley",
        "email": "james@meteor.com"
      },
      "contributors": [
        {
          "name": "James Baxley",
          "email": "james@meteor.com"
        },
        {
          "name": "Jonas Helfer",
          "email": "jonas@helfer.email"
        },
        {
          "name": "Sashko Stubailo",
          "email": "sashko@stubailo.com"
        },
        {
          "name": "James Burgess",
          "email": "jamesmillerburgess@gmail.com"
        },
        {
          "name": "Bazyli Brzóska",
          "email": "bazyli.brzoska@gmail.com"
        }
      ],
      "license": "MIT",
      "main": "./lib/bundle.umd.js",
      "module": "./lib/index.js",
      "jsnext:main": "./lib/index.js",
      "typings": "./lib/index.d.ts",
      "sideEffects": false,
      "repository": {
        "type": "git",
        "url": "git+https://github.com/apollographql/apollo-client.git"
      },
      "bugs": {
        "url": "https://github.com/apollographql/apollo-client/issues"
      },
      "homepage": "https://github.com/apollographql/apollo-client#readme",
      "scripts": {
        "coverage": "jest --coverage",
        "test": "jest",
        "lint": "tslint --type-check -p tsconfig.json src/*.ts",
        "prebuild": "npm run clean",
        "build": "tsc -p .",
        "postbuild": "npm run bundle",
        "bundle": "rollup -c rollup.config.js",
        "watch": "tsc -w -p .",
        "clean": "rimraf coverage/* && rimraf lib/*",
        "prepublishOnly": "npm run build",
        "build:browser": "browserify ./lib/bundle.umd.js --i apollo-cache --i apollo-utilities --i graphql -o=./lib/bundle.js && npm run minify:browser",
        "minify:browser": "uglifyjs -c -m -o ./lib/bundle.min.js -- ./lib/bundle.js",
        "filesize": "npm run build:browser"
      },
      "dependencies": {
        "apollo-cache": "^1.1.13",
        "apollo-utilities": "^1.0.17",
        "graphql-anywhere": "^4.1.15"
      },
      "peerDependencies": {
        "graphql": "0.11.7 || ^0.12.0 || ^0.13.0"
      },
      "devDependencies": {
        "@types/graphql": "0.12.7",
        "@types/jest": "22.2.3",
        "@types/lodash": "4.14.112",
        "browserify": "15.2.0",
        "graphql": "0.13.2",
        "graphql-tag": "2.9.2",
        "jest": "23.0.0",
        "lodash": "4.17.10",
        "rimraf": "2.6.2",
        "rollup": "0.63.4",
        "ts-jest": "20.0.14",
        "tslint": "5.11.0",
        "typescript": "2.9.2",
        "uglifyjs": "2.4.11"
      },
      "jest": {
        "transform": {
          ".(ts|tsx)": "<rootDir>/node_modules/ts-jest/preprocessor.js"
        },
        "testRegex": "(/__tests__/.*|\\.(test|spec))\\.(ts|tsx|js)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "json"
        ]
      },
      "_id": "apollo-cache-inmemory@1.2.6",
      "_npmVersion": "5.6.0",
      "_nodeVersion": "8.11.2",
      "_npmUser": {
        "name": "mdg",
        "email": "npm@meteor.com"
      },
      "dist": {
        "integrity": "sha512-Hz4VMfOz0iVtqAHQQWbkhBkVEDxrIPkc77poEfW1/Xq2snloAYD0o78yRQS+PrLuq2irlnL3Q/aVgrKC0uUcgA==",
        "shasum": "85e2a52d63ea275117596c93a46a4e3b42b89b13",
        "tarball": "https://registry.npmjs.org/apollo-cache-inmemory/-/apollo-cache-inmemory-1.2.6.tgz",
        "fileCount": 61,
        "unpackedSize": 428999,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJbV4CDCRA9TVsSAnZWagAA/7oP/1SNXjOhELzrBbh15BT/\nd8TJWMt0PTPO/4Yo95IoY9c3tyMRUSlIPzIlrYXe7dMzxQWMwGvWLEy3nxbJ\nuAWBrh03QiwoHIMazxlbM+zkMqAJ09TqXFYLWYFJcnJFkk5wTq738+SyYkEQ\nMENC7l3QY29gJT5qCoI8tjEaXo3ROyvmiWaag9glM7Oj4DMZ/QypafnauGxz\nasK7IQOwUuDHtKTe6JX14MIaqo2aWFvE6Q8vksTWqLlD2dbbWKPz1tYhKma/\nBo9QBkf389SgpJl9DcvVJ3on6dbAII7HEC7ebdlrmVEw65BuFT3UH9DPjUm6\nWtOK3LUf9eeSARhPvIwu+yfIX993LgXcLRseDKx3T4ZmARii3w32nQaNvsQN\n/YuCxBVjWyatTpj+5+rFNTOd0b7eTyE1dzV6+gCKj5M8mfeuZca2+t1bu4IX\nRglo+svvaMf08TwzjDvXyedIzsRWbukPEfBNbPjf9eJXCRf7pkVrYBOIztV7\nM52x73OY2DSPwo024DNm3qxWVHPSzTCZARCkfhaXNl+3qmZwMphN/doFahyv\nhjwkag1ACq8yMD7/9FO/f4tMXSmJR1UsIKrLqAnDfUFOLgMiFFH6xD3rdKOU\nIA4+qqiP1bvE0k66N5qhKkdi8SiniJUtBVnHEcj+wVgqsOHeDUjti80fJiZx\nv/Cg\r\n=rks1\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIG+eCSL5QH80mp/QxKQtXgzuOkEqWj4BGdEtgjPcqh3KAiEA8iiBbFD1X0epPfFLYKtGCzotGMyzhHxzDdtfXKKjlh8="
          }
        ]
      },
      "maintainers": [
        {
          "email": "ben@benjamn.com",
          "name": "benjamn"
        },
        {
          "email": "james@meteor.com",
          "name": "jbaxleyiii"
        },
        {
          "email": "npm@meteor.com",
          "name": "mdg"
        },
        {
          "email": "peggyrayzis@gmail.com",
          "name": "peggyrayzis"
        }
      ],
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/apollo-cache-inmemory_1.2.6_1532461187620_0.9941036796945355"
      },
      "_hasShrinkwrap": false
    },
    "1.2.6-alpha.3": {
      "name": "apollo-cache-inmemory",
      "version": "1.2.6-alpha.3",
      "description": "Core abstract of Caching layer for Apollo Client",
      "author": {
        "name": "James Baxley",
        "email": "james@meteor.com"
      },
      "contributors": [
        {
          "name": "James Baxley",
          "email": "james@meteor.com"
        },
        {
          "name": "Jonas Helfer",
          "email": "jonas@helfer.email"
        },
        {
          "name": "Sashko Stubailo",
          "email": "sashko@stubailo.com"
        },
        {
          "name": "James Burgess",
          "email": "jamesmillerburgess@gmail.com"
        },
        {
          "name": "Bazyli Brzóska",
          "email": "bazyli.brzoska@gmail.com"
        }
      ],
      "license": "MIT",
      "main": "./lib/bundle.umd.js",
      "module": "./lib/index.js",
      "jsnext:main": "./lib/index.js",
      "typings": "./lib/index.d.ts",
      "sideEffects": false,
      "repository": {
        "type": "git",
        "url": "git+https://github.com/apollographql/apollo-client.git"
      },
      "bugs": {
        "url": "https://github.com/apollographql/apollo-client/issues"
      },
      "homepage": "https://github.com/apollographql/apollo-client#readme",
      "scripts": {
        "coverage": "jest --coverage",
        "test": "jest",
        "lint": "tslint --type-check -p tsconfig.json src/*.ts",
        "prebuild": "npm run clean",
        "build": "tsc -p .",
        "postbuild": "npm run bundle",
        "bundle": "rollup -c rollup.config.js",
        "watch": "tsc -w -p .",
        "clean": "rimraf coverage/* && rimraf lib/*",
        "prepublishOnly": "npm run build",
        "build:browser": "browserify ./lib/bundle.umd.js --i apollo-cache --i apollo-utilities --i graphql -o=./lib/bundle.js && npm run minify:browser",
        "minify:browser": "uglifyjs -c -m -o ./lib/bundle.min.js -- ./lib/bundle.js",
        "filesize": "npm run build:browser"
      },
      "dependencies": {
        "apollo-cache": "^1.1.13-alpha.3",
        "apollo-utilities": "^1.0.17-alpha.3",
        "graphql-anywhere": "^4.1.15-alpha.3"
      },
      "peerDependencies": {
        "graphql": "0.11.7 || ^0.12.0 || ^0.13.0"
      },
      "devDependencies": {
        "@types/graphql": "0.12.7",
        "@types/jest": "22.2.3",
        "@types/lodash": "4.14.112",
        "browserify": "15.2.0",
        "graphql": "0.13.2",
        "graphql-tag": "2.9.2",
        "jest": "23.0.0",
        "lodash": "4.17.10",
        "rimraf": "2.6.2",
        "rollup": "0.62.0",
        "ts-jest": "20.0.14",
        "tslint": "5.11.0",
        "typescript": "2.9.2",
        "uglifyjs": "2.4.11"
      },
      "jest": {
        "transform": {
          ".(ts|tsx)": "<rootDir>/node_modules/ts-jest/preprocessor.js"
        },
        "testRegex": "(/__tests__/.*|\\.(test|spec))\\.(ts|tsx|js)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "json"
        ]
      },
      "readme": "---\ntitle: InMemoryCache\ndescription: An explanation of `apollo-cache-inmemory`\n---\n\n`apollo-cache-inmemory` is the recommended cache implementation for Apollo Client 2.0. `InMemoryCache` is a normalized data store that supports all of Apollo Client 1.0's features without the dependency on Redux.\n\nIn some instances, you may need to manipulate the cache directly, such as updating the store after a mutation. We'll cover some common use cases [here](#recipes).\n\n<h2 id=\"installation\">Installation</h2>\n\n```\nnpm install apollo-cache-inmemory --save\n```\n\nAfter installing the package, you'll want to initialize the cache constructor. Then, you can pass in your newly created cache to ApolloClient.\n\n```js\nimport { InMemoryCache } from 'apollo-cache-inmemory';\nimport { HttpLink } from 'apollo-link-http';\nimport ApolloClient from 'apollo-client';\n\nconst cache = new InMemoryCache();\n\nconst client = new ApolloClient({\n  link: new HttpLink(),\n  cache\n});\n```\n\n<h2 id=\"configuration\">Configuration</h2>\n\nThe `InMemoryCache` constructor takes an optional config object with properties to customize your cache:\n\n- addTypename: A boolean to determine whether to add __typename to the document (default: `true`)\n- dataIdFromObject: A function that takes a data object and returns a unique identifier to be used when normalizing the data in the store. Learn more about how to customize `dataIdFromObject` in the [Normalization](#normalization) section.\n- fragmentMatcher: By default, the `InMemoryCache` uses a heuristic fragment matcher. If you are using fragments on unions and interfaces, you will need to use an `IntrospectionFragmentMatcher`. For more information, please read [our guide to setting up fragment matching for unions & interfaces](https://www.apollographql.com/docs/react/advanced/fragments.html#fragment-matcher).\n\n<h2 id=\"normalization\">Normalization</h2>\n\nThe `InMemoryCache` normalizes your data before saving it to the store by splitting the result into individual objects, creating a unique identifier for each object, and storing those objects in a flattened data structure. By default, `InMemoryCache` will attempt to use the commonly found primary keys of `id` and `_id` for the unique identifier if they exist along with `__typename` on an object.\n\nIf `id` and `_id` are not specified, or if `__typename` is not specified, `InMemoryCache` will fall back to the path to the object in the query, such as `ROOT_QUERY.allPeople.0` for the first record returned on the `allPeople` root query.\n\nThis \"getter\" behavior for unique identifiers can be configured manually via the `dataIdFromObject` option passed to the `InMemoryCache` constructor, so you can pick which field is used if some of your data follows unorthodox primary key conventions.\n\nFor example, if you wanted to key off of the `key` field for all of your data, you could configure `dataIdFromObject` like so:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => object.key\n});\n```\n\nThis also allows you to use different unique identifiers for different data types by keying off of the `__typename` property attached to every object typed by GraphQL.  For example:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => {\n    switch (object.__typename) {\n      case 'foo': return object.key; // use `key` as the primary key\n      case 'bar': return object.blah; // use `blah` as the priamry key\n      default: return object.id || object._id; // fall back to `id` and `_id` for all other types\n    }\n  }\n});\n```\n\n<h2 id=\"direct\">Direct Cache Access</h2>\n\nTo interact directly with your cache, you can use the Apollo Client class methods readQuery, readFragment, writeQuery, and writeFragment. These methods are available to us via the [`DataProxy` interface](http://dev.apollodata.com/core/apollo-client-api.html#DataProxy). Accessing these methods will vary slightly based on your view layer implementation. If you are using React, you can wrap your component in the `withApollo` higher order component, which will give you access to `this.props.client`. From there, you can use the methods to control your data.\n\nAny code demonstration in the following sections will assume that we have already initialized an instance of  `ApolloClient` and that we have imported the `gql` tag from `graphql-tag`.\n\n<h3 id=\"readquery\">readQuery</h3>\n\nThe `readQuery` method is very similar to the [`query` method on `ApolloClient`][] except that `readQuery` will _never_ make a request to your GraphQL server. The `query` method, on the other hand, may send a request to your server if the appropriate data is not in your cache whereas `readQuery` will throw an error if the data is not in your cache. `readQuery` will _always_ read from the cache. You can use `readQuery` by giving it a GraphQL query like so:\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo {\n      todo(id: 5) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n});\n```\n\nIf all of the data needed to fulfill this read is in Apollo Client’s normalized data cache then a data object will be returned in the shape of the query you wanted to read. If not all of the data needed to fulfill this read is in Apollo Client’s cache then an error will be thrown instead, so make sure to only read data that you know you have!\n\nYou can also pass variables into `readQuery`.\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo($id: Int!) {\n      todo(id: $id) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n  variables: {\n    id: 5,\n  },\n});\n```\n\n<h3 id=\"readfragment\">readFragment</h3>\n\nThis method allows you great flexibility around the data in your cache. Whereas `readQuery` only allowed you to read data from your root query type, `readFragment` allows you to read data from _any node you have queried_. This is incredibly powerful. You use this method as follows:\n\n```js\nconst todo = client.readFragment({\n  id: ..., // `id` is any id that could be returned by `dataIdFromObject`.\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\nThe first argument is the id of the data you want to read from the cache. That id must be a value that was returned by the `dataIdFromObject` function you defined when initializing `ApolloClient`. So for example if you initialized `ApolloClient` like so:\n\n```js\nconst client = new ApolloClient({\n  ...,\n  dataIdFromObject: object => object.id,\n});\n```\n\n…and you requested a todo before with an id of `5`, then you can read that todo out of your cache with the following:\n\n```js\nconst todo = client.readFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\n> **Note:** Most people add a `__typename` to the id in `dataIdFromObject`. If you do this then don’t forget to add the `__typename` when you are reading a fragment as well. So for example your id may be `Todo_5` and not just `5`.\n\nIf a todo with that id does not exist in the cache you will get `null` back. If a todo of that id does exist in the cache, but that todo does not have the `text` field then an error will be thrown.\n\nThe beauty of `readFragment` is that the todo could have come from anywhere! The todo could have been selected as a singleton (`{ todo(id: 5) { ... } }`), the todo could have come from a list of todos (`{ todos { ... } }`), or the todo could have come from a mutation (`mutation { createTodo { ... } }`). As long as at some point your GraphQL server gave you a todo with the provided id and fields `id`, `text`, and `completed` you can read it from the cache at any part of your code.\n\n<h3 id=\"writequery-and-writefragment\">writeQuery` and `writeFragment</h3>\n\nNot only can you read arbitrary data from the Apollo Client cache, but you can also write any data that you would like to the cache. The methods you use to do this are `writeQuery` and `writeFragment`. They will allow you to change data in your local cache, but it is important to remember that *they will not change any data on your server*. If you reload your environment then changes made with `writeQuery` and `writeFragment` will disappear.\n\nThese methods have the same signature as their `readQuery` and `readFragment` counterparts except they also require an additional `data` variable. So for example, if you wanted to update the `completed` flag locally for your todo with id `'5'` you could execute the following:\n\n```js\nclient.writeFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      completed\n    }\n  `,\n  data: {\n    completed: true,\n  },\n});\n```\n\nAny subscriber to the Apollo Client store will instantly see this update and render new UI accordingly.\n\n> **Note:** Again, remember that using `writeQuery` or `writeFragment` only changes data *locally*. If you reload your environment then changes made with these methods will no longer exist.\n\nOr if you wanted to add a new todo to a list fetched from the server, you could use `readQuery` and `writeQuery` together.\n\n```js\nconst query = gql`\n  query MyTodoAppQuery {\n    todos {\n      id\n      text\n      completed\n    }\n  }\n`;\n\nconst data = client.readQuery({ query });\n\nconst myNewTodo = {\n  id: '6',\n  text: 'Start using Apollo Client.',\n  completed: false,\n};\n\nclient.writeQuery({\n  query,\n  data: {\n    todos: [...data.todos, myNewTodo],\n  },\n});\n```\n\n<h2 id=\"recipes\">Recipes</h2>\n\nHere are some common situations where you would need to access the cache directly. If you're manipulating the cache in an interesting way and would like your example to be featured, please send in a pull request!\n\n<h3 id=\"server\">Server side rendering</h3>\n\nFirst, you will need to initialize an `InMemoryCache` on the server and create an instance of `ApolloClient`. In the initial serialized HTML payload from the server, you should include a script tag that extracts the data from the cache.\n\n```js\n`<script>\n  window.__APOLLO_STATE__=${JSON.stringify(cache.extract())}\n</script>`\n```\n\nOn the client, you can rehydrate the cache using the initial data passed from the server:\n\n```js\ncache: new Cache().restore(window.__APOLLO_STATE__)\n```\n\nIf you would like to learn more about server side rendering, please check our our more in depth guide [here].\n<!---\nTODO (PEGGY): Add link to SSR\n-->\n\n<h3 id=\"server\">Updating the cache after a mutation</h3>\n\nBeing able to read and write to the Apollo cache from anywhere in your application gives you a lot of power over your data. However, there is one place where we most often want to update our cached data: after a mutation. As such, Apollo Client has optimized the experience for updating your cache with the read and write methods after a mutation with the `update` function. Let us say that we have the following GraphQL mutation:\n\n```graphql\nmutation TodoCreateMutation($text: String!) {\n  createTodo(text: $text) {\n    id\n    text\n    completed\n  }\n}\n```\n\nWe may also have the following GraphQL query:\n\n```graphql\nquery TodoAppQuery {\n  todos {\n    id\n    text\n    completed\n  }\n}\n```\n\nAt the end of our mutation we want our query to include the new todo like we had sent our `TodoAppQuery` a second time after the mutation finished without actually sending the query. To do this we can use the `update` function provided as an option of the `client.mutate` method. To update your cache with the mutation just write code that looks like:\n\n```js\n// We assume that the GraphQL operations `TodoCreateMutation` and\n// `TodoAppQuery` have already been defined using the `gql` tag.\n\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    // Read the data from our cache for this query.\n    const data = proxy.readQuery({ query: TodoAppQuery });\n\n    // Add our todo from the mutation to the end.\n    data.todos.push(createTodo);\n\n    // Write our data back to the cache.\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nThe first `proxy` argument is an instance of [`DataProxy`][] has the same four methods that we just learned exist on the Apollo Client: `readQuery`, `readFragment`, `writeQuery`, and `writeFragment`. The reason we call them on a `proxy` object here instead of on our `client` instance is that we can easily apply optimistic updates (which we will demonstrate in a bit). The `proxy` object also provides an isolated transaction which shields you from any other mutations going on at the same time, and the `proxy` object also batches writes together until the very end.\n\nIf you provide an `optimisticResponse` option to the mutation then the `update` function will be run twice. Once immediately after you call `client.mutate` with the data from `optimisticResponse`. After the mutation successfully executes against the server the changes made in the first call to `update` will be rolled back and `update` will be called with the *actual* data returned by the mutation and not just the optimistic response.\n\nPutting it all together:\n\n```js\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  optimisticResponse: {\n    id: -1, // -1 is a temporary id for the optimistic response.\n    text,\n    completed: false,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    const data = proxy.readQuery({ query: TodoAppQuery });\n    data.todos.push(createTodo);\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nAs you can see the `update` function on `client.mutate` provides extra change management functionality specific to the use case of a mutation while still providing you the powerful data control APIs that are available on `client`.\n\nThe `update` function is not a good place for side-effects as it may be called multiple times. Also, you may not call any of the methods on `proxy` asynchronously.\n\n",
      "readmeFilename": "README.md",
      "_id": "apollo-cache-inmemory@1.2.6-alpha.3",
      "_npmVersion": "6.1.0",
      "_nodeVersion": "10.6.0",
      "_npmUser": {
        "name": "mdg",
        "email": "npm@meteor.com"
      },
      "dist": {
        "integrity": "sha512-7PGNEseAsHm+5o2KCUB3pABZFTG27S348aeRjnN9kwIXKs2CeYAWN22bgNJe3mRaK0EmUMKu22abCZNE9fyOgA==",
        "shasum": "b1549da700dddc9ca5f30835f449b7abb8e9574a",
        "tarball": "https://registry.npmjs.org/apollo-cache-inmemory/-/apollo-cache-inmemory-1.2.6-alpha.3.tgz",
        "fileCount": 61,
        "unpackedSize": 428211,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJbV5noCRA9TVsSAnZWagAAt2IP/0Jvg0wUDxd5M8Erfkoa\nX+8qLA+JcO5jmXJrwBq5wHWgPao11jvVQ3UwuS80sCXmVpcaF6lSQCkuJyqg\nUB76XavwjYPOak3wuB58R0SF2F7HSmStYL/Y+J8k3ip5gjfDZ6PCah1P+5dZ\nyqWVMJNDr3Vwwvzzq/QOUM4P6HXnNVDcHhhhXTV+X05P1wD4Q+RQeqb6jmyb\ng8wXM63aTmKKq3kWk2Nmrv4ZeG/kYaUmECc/ju4S002MojcIQs18mQFsPp/P\nP/F+14IsoWWAruD9sOxJCsWXouFkUZql6fJ1KxQl5xMqdX3Lzpwu6svD/vSv\nRlyrTMTfngwTd5s9RaoQocQYVC8oBrooKtZ9i2VgXJfoQZqk0uCEaIq+ObrK\n8221AU731Y+PgSzGU0Z1mscLGFFHvvQw0zAj2Vj4HfasF65J8mUplZ/vtqRk\nXPc6qiMyY9H0JEZMWrGZ2GVaeN7lG1iFb4Xn13ssJTvA2XshzUXWLrwXLZ1q\nUFZ6ph/1eDlKpEDsduPdrhcevF8mmT7VDYP+NxXRL6iAfY1ucRzDKxpWuV/U\nWzbtC18kiIrAqaiEHJ2E6fOLXScRinrzOUHVhQUwFbIF6wCMtWCb63wMAhdV\nlXYWhZc8Q9kvqivxbNXYLgknnbbpIKz/3O69SkX0VnH/y1oTlGFn/wJC2A1Y\nHK5q\r\n=dKh7\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIC9ZdvoSnGNO1NPL81M7zORo6cawnHyTPMCm1Q7eCG4YAiEA5byvGECrWnRJPY6HlXSiydNo+phZq7+kHA0Lxikq5oY="
          }
        ]
      },
      "maintainers": [
        {
          "email": "ben@benjamn.com",
          "name": "benjamn"
        },
        {
          "email": "james@meteor.com",
          "name": "jbaxleyiii"
        },
        {
          "email": "npm@meteor.com",
          "name": "mdg"
        },
        {
          "email": "peggyrayzis@gmail.com",
          "name": "peggyrayzis"
        }
      ],
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/apollo-cache-inmemory_1.2.6-alpha.3_1532467688166_0.8876219323931924"
      },
      "_hasShrinkwrap": false
    },
    "1.2.6-alpha.4": {
      "name": "apollo-cache-inmemory",
      "version": "1.2.6-alpha.4",
      "description": "Core abstract of Caching layer for Apollo Client",
      "author": {
        "name": "James Baxley",
        "email": "james@meteor.com"
      },
      "contributors": [
        {
          "name": "James Baxley",
          "email": "james@meteor.com"
        },
        {
          "name": "Jonas Helfer",
          "email": "jonas@helfer.email"
        },
        {
          "name": "Sashko Stubailo",
          "email": "sashko@stubailo.com"
        },
        {
          "name": "James Burgess",
          "email": "jamesmillerburgess@gmail.com"
        },
        {
          "name": "Bazyli Brzóska",
          "email": "bazyli.brzoska@gmail.com"
        }
      ],
      "license": "MIT",
      "main": "./lib/bundle.umd.js",
      "module": "./lib/index.js",
      "jsnext:main": "./lib/index.js",
      "typings": "./lib/index.d.ts",
      "sideEffects": false,
      "repository": {
        "type": "git",
        "url": "git+https://github.com/apollographql/apollo-client.git"
      },
      "bugs": {
        "url": "https://github.com/apollographql/apollo-client/issues"
      },
      "homepage": "https://github.com/apollographql/apollo-client#readme",
      "scripts": {
        "coverage": "jest --coverage",
        "test": "jest",
        "lint": "tslint --type-check -p tsconfig.json src/*.ts",
        "prebuild": "npm run clean",
        "build": "tsc -p .",
        "postbuild": "npm run bundle",
        "bundle": "rollup -c rollup.config.js",
        "watch": "tsc -w -p .",
        "clean": "rimraf coverage/* && rimraf lib/*",
        "prepublishOnly": "npm run build",
        "build:browser": "browserify ./lib/bundle.umd.js --i apollo-cache --i apollo-utilities --i graphql -o=./lib/bundle.js && npm run minify:browser",
        "minify:browser": "uglifyjs -c -m -o ./lib/bundle.min.js -- ./lib/bundle.js",
        "filesize": "npm run build:browser"
      },
      "dependencies": {
        "apollo-cache": "^1.1.13-alpha.4",
        "apollo-utilities": "^1.0.17-alpha.4",
        "graphql-anywhere": "^4.1.15-alpha.4"
      },
      "peerDependencies": {
        "graphql": "0.11.7 || ^0.12.0 || ^0.13.0"
      },
      "devDependencies": {
        "@types/graphql": "0.12.7",
        "@types/jest": "22.2.3",
        "@types/lodash": "4.14.112",
        "browserify": "15.2.0",
        "graphql": "0.13.2",
        "graphql-tag": "2.9.2",
        "jest": "23.0.0",
        "lodash": "4.17.10",
        "rimraf": "2.6.2",
        "rollup": "0.62.0",
        "ts-jest": "20.0.14",
        "tslint": "5.11.0",
        "typescript": "2.9.2",
        "uglifyjs": "2.4.11"
      },
      "jest": {
        "transform": {
          ".(ts|tsx)": "<rootDir>/node_modules/ts-jest/preprocessor.js"
        },
        "testRegex": "(/__tests__/.*|\\.(test|spec))\\.(ts|tsx|js)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "json"
        ]
      },
      "readme": "---\ntitle: InMemoryCache\ndescription: An explanation of `apollo-cache-inmemory`\n---\n\n`apollo-cache-inmemory` is the recommended cache implementation for Apollo Client 2.0. `InMemoryCache` is a normalized data store that supports all of Apollo Client 1.0's features without the dependency on Redux.\n\nIn some instances, you may need to manipulate the cache directly, such as updating the store after a mutation. We'll cover some common use cases [here](#recipes).\n\n<h2 id=\"installation\">Installation</h2>\n\n```\nnpm install apollo-cache-inmemory --save\n```\n\nAfter installing the package, you'll want to initialize the cache constructor. Then, you can pass in your newly created cache to ApolloClient.\n\n```js\nimport { InMemoryCache } from 'apollo-cache-inmemory';\nimport { HttpLink } from 'apollo-link-http';\nimport ApolloClient from 'apollo-client';\n\nconst cache = new InMemoryCache();\n\nconst client = new ApolloClient({\n  link: new HttpLink(),\n  cache\n});\n```\n\n<h2 id=\"configuration\">Configuration</h2>\n\nThe `InMemoryCache` constructor takes an optional config object with properties to customize your cache:\n\n- addTypename: A boolean to determine whether to add __typename to the document (default: `true`)\n- dataIdFromObject: A function that takes a data object and returns a unique identifier to be used when normalizing the data in the store. Learn more about how to customize `dataIdFromObject` in the [Normalization](#normalization) section.\n- fragmentMatcher: By default, the `InMemoryCache` uses a heuristic fragment matcher. If you are using fragments on unions and interfaces, you will need to use an `IntrospectionFragmentMatcher`. For more information, please read [our guide to setting up fragment matching for unions & interfaces](https://www.apollographql.com/docs/react/advanced/fragments.html#fragment-matcher).\n\n<h2 id=\"normalization\">Normalization</h2>\n\nThe `InMemoryCache` normalizes your data before saving it to the store by splitting the result into individual objects, creating a unique identifier for each object, and storing those objects in a flattened data structure. By default, `InMemoryCache` will attempt to use the commonly found primary keys of `id` and `_id` for the unique identifier if they exist along with `__typename` on an object.\n\nIf `id` and `_id` are not specified, or if `__typename` is not specified, `InMemoryCache` will fall back to the path to the object in the query, such as `ROOT_QUERY.allPeople.0` for the first record returned on the `allPeople` root query.\n\nThis \"getter\" behavior for unique identifiers can be configured manually via the `dataIdFromObject` option passed to the `InMemoryCache` constructor, so you can pick which field is used if some of your data follows unorthodox primary key conventions.\n\nFor example, if you wanted to key off of the `key` field for all of your data, you could configure `dataIdFromObject` like so:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => object.key\n});\n```\n\nThis also allows you to use different unique identifiers for different data types by keying off of the `__typename` property attached to every object typed by GraphQL.  For example:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => {\n    switch (object.__typename) {\n      case 'foo': return object.key; // use `key` as the primary key\n      case 'bar': return object.blah; // use `blah` as the priamry key\n      default: return object.id || object._id; // fall back to `id` and `_id` for all other types\n    }\n  }\n});\n```\n\n<h2 id=\"direct\">Direct Cache Access</h2>\n\nTo interact directly with your cache, you can use the Apollo Client class methods readQuery, readFragment, writeQuery, and writeFragment. These methods are available to us via the [`DataProxy` interface](http://dev.apollodata.com/core/apollo-client-api.html#DataProxy). Accessing these methods will vary slightly based on your view layer implementation. If you are using React, you can wrap your component in the `withApollo` higher order component, which will give you access to `this.props.client`. From there, you can use the methods to control your data.\n\nAny code demonstration in the following sections will assume that we have already initialized an instance of  `ApolloClient` and that we have imported the `gql` tag from `graphql-tag`.\n\n<h3 id=\"readquery\">readQuery</h3>\n\nThe `readQuery` method is very similar to the [`query` method on `ApolloClient`][] except that `readQuery` will _never_ make a request to your GraphQL server. The `query` method, on the other hand, may send a request to your server if the appropriate data is not in your cache whereas `readQuery` will throw an error if the data is not in your cache. `readQuery` will _always_ read from the cache. You can use `readQuery` by giving it a GraphQL query like so:\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo {\n      todo(id: 5) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n});\n```\n\nIf all of the data needed to fulfill this read is in Apollo Client’s normalized data cache then a data object will be returned in the shape of the query you wanted to read. If not all of the data needed to fulfill this read is in Apollo Client’s cache then an error will be thrown instead, so make sure to only read data that you know you have!\n\nYou can also pass variables into `readQuery`.\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo($id: Int!) {\n      todo(id: $id) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n  variables: {\n    id: 5,\n  },\n});\n```\n\n<h3 id=\"readfragment\">readFragment</h3>\n\nThis method allows you great flexibility around the data in your cache. Whereas `readQuery` only allowed you to read data from your root query type, `readFragment` allows you to read data from _any node you have queried_. This is incredibly powerful. You use this method as follows:\n\n```js\nconst todo = client.readFragment({\n  id: ..., // `id` is any id that could be returned by `dataIdFromObject`.\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\nThe first argument is the id of the data you want to read from the cache. That id must be a value that was returned by the `dataIdFromObject` function you defined when initializing `ApolloClient`. So for example if you initialized `ApolloClient` like so:\n\n```js\nconst client = new ApolloClient({\n  ...,\n  dataIdFromObject: object => object.id,\n});\n```\n\n…and you requested a todo before with an id of `5`, then you can read that todo out of your cache with the following:\n\n```js\nconst todo = client.readFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\n> **Note:** Most people add a `__typename` to the id in `dataIdFromObject`. If you do this then don’t forget to add the `__typename` when you are reading a fragment as well. So for example your id may be `Todo_5` and not just `5`.\n\nIf a todo with that id does not exist in the cache you will get `null` back. If a todo of that id does exist in the cache, but that todo does not have the `text` field then an error will be thrown.\n\nThe beauty of `readFragment` is that the todo could have come from anywhere! The todo could have been selected as a singleton (`{ todo(id: 5) { ... } }`), the todo could have come from a list of todos (`{ todos { ... } }`), or the todo could have come from a mutation (`mutation { createTodo { ... } }`). As long as at some point your GraphQL server gave you a todo with the provided id and fields `id`, `text`, and `completed` you can read it from the cache at any part of your code.\n\n<h3 id=\"writequery-and-writefragment\">writeQuery` and `writeFragment</h3>\n\nNot only can you read arbitrary data from the Apollo Client cache, but you can also write any data that you would like to the cache. The methods you use to do this are `writeQuery` and `writeFragment`. They will allow you to change data in your local cache, but it is important to remember that *they will not change any data on your server*. If you reload your environment then changes made with `writeQuery` and `writeFragment` will disappear.\n\nThese methods have the same signature as their `readQuery` and `readFragment` counterparts except they also require an additional `data` variable. So for example, if you wanted to update the `completed` flag locally for your todo with id `'5'` you could execute the following:\n\n```js\nclient.writeFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      completed\n    }\n  `,\n  data: {\n    completed: true,\n  },\n});\n```\n\nAny subscriber to the Apollo Client store will instantly see this update and render new UI accordingly.\n\n> **Note:** Again, remember that using `writeQuery` or `writeFragment` only changes data *locally*. If you reload your environment then changes made with these methods will no longer exist.\n\nOr if you wanted to add a new todo to a list fetched from the server, you could use `readQuery` and `writeQuery` together.\n\n```js\nconst query = gql`\n  query MyTodoAppQuery {\n    todos {\n      id\n      text\n      completed\n    }\n  }\n`;\n\nconst data = client.readQuery({ query });\n\nconst myNewTodo = {\n  id: '6',\n  text: 'Start using Apollo Client.',\n  completed: false,\n};\n\nclient.writeQuery({\n  query,\n  data: {\n    todos: [...data.todos, myNewTodo],\n  },\n});\n```\n\n<h2 id=\"recipes\">Recipes</h2>\n\nHere are some common situations where you would need to access the cache directly. If you're manipulating the cache in an interesting way and would like your example to be featured, please send in a pull request!\n\n<h3 id=\"server\">Server side rendering</h3>\n\nFirst, you will need to initialize an `InMemoryCache` on the server and create an instance of `ApolloClient`. In the initial serialized HTML payload from the server, you should include a script tag that extracts the data from the cache.\n\n```js\n`<script>\n  window.__APOLLO_STATE__=${JSON.stringify(cache.extract())}\n</script>`\n```\n\nOn the client, you can rehydrate the cache using the initial data passed from the server:\n\n```js\ncache: new Cache().restore(window.__APOLLO_STATE__)\n```\n\nIf you would like to learn more about server side rendering, please check our our more in depth guide [here].\n<!---\nTODO (PEGGY): Add link to SSR\n-->\n\n<h3 id=\"server\">Updating the cache after a mutation</h3>\n\nBeing able to read and write to the Apollo cache from anywhere in your application gives you a lot of power over your data. However, there is one place where we most often want to update our cached data: after a mutation. As such, Apollo Client has optimized the experience for updating your cache with the read and write methods after a mutation with the `update` function. Let us say that we have the following GraphQL mutation:\n\n```graphql\nmutation TodoCreateMutation($text: String!) {\n  createTodo(text: $text) {\n    id\n    text\n    completed\n  }\n}\n```\n\nWe may also have the following GraphQL query:\n\n```graphql\nquery TodoAppQuery {\n  todos {\n    id\n    text\n    completed\n  }\n}\n```\n\nAt the end of our mutation we want our query to include the new todo like we had sent our `TodoAppQuery` a second time after the mutation finished without actually sending the query. To do this we can use the `update` function provided as an option of the `client.mutate` method. To update your cache with the mutation just write code that looks like:\n\n```js\n// We assume that the GraphQL operations `TodoCreateMutation` and\n// `TodoAppQuery` have already been defined using the `gql` tag.\n\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    // Read the data from our cache for this query.\n    const data = proxy.readQuery({ query: TodoAppQuery });\n\n    // Add our todo from the mutation to the end.\n    data.todos.push(createTodo);\n\n    // Write our data back to the cache.\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nThe first `proxy` argument is an instance of [`DataProxy`][] has the same four methods that we just learned exist on the Apollo Client: `readQuery`, `readFragment`, `writeQuery`, and `writeFragment`. The reason we call them on a `proxy` object here instead of on our `client` instance is that we can easily apply optimistic updates (which we will demonstrate in a bit). The `proxy` object also provides an isolated transaction which shields you from any other mutations going on at the same time, and the `proxy` object also batches writes together until the very end.\n\nIf you provide an `optimisticResponse` option to the mutation then the `update` function will be run twice. Once immediately after you call `client.mutate` with the data from `optimisticResponse`. After the mutation successfully executes against the server the changes made in the first call to `update` will be rolled back and `update` will be called with the *actual* data returned by the mutation and not just the optimistic response.\n\nPutting it all together:\n\n```js\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  optimisticResponse: {\n    id: -1, // -1 is a temporary id for the optimistic response.\n    text,\n    completed: false,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    const data = proxy.readQuery({ query: TodoAppQuery });\n    data.todos.push(createTodo);\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nAs you can see the `update` function on `client.mutate` provides extra change management functionality specific to the use case of a mutation while still providing you the powerful data control APIs that are available on `client`.\n\nThe `update` function is not a good place for side-effects as it may be called multiple times. Also, you may not call any of the methods on `proxy` asynchronously.\n\n",
      "readmeFilename": "README.md",
      "_id": "apollo-cache-inmemory@1.2.6-alpha.4",
      "_npmVersion": "6.1.0",
      "_nodeVersion": "10.6.0",
      "_npmUser": {
        "name": "mdg",
        "email": "npm@meteor.com"
      },
      "dist": {
        "integrity": "sha512-MnOvXnG8NsX2zT4qhiCYOjspMBfsEjFzle+NiSpM8ubeBWPo5vkq/HYm7OlO7WEvb5fUisIU0GQ9LfXu29DsOw==",
        "shasum": "9d9b01c86a58ff741711dfd448941bf3f6664599",
        "tarball": "https://registry.npmjs.org/apollo-cache-inmemory/-/apollo-cache-inmemory-1.2.6-alpha.4.tgz",
        "fileCount": 61,
        "unpackedSize": 428211,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJbV8fqCRA9TVsSAnZWagAAnoIP/1To+AafY0yCf0JJVhk5\ndj95TdWAiQFeZRV2odmSEV7ju34BfnrOxjgBmf/x05WJ6FMemcss84FKV/2m\nrCWrI1cxeg+yi72o2sNd98wsdp4chkLAzSuL3Jis53IkF+ZY87nyxHVTKtKu\noxeTpUWcCLAfIxEo5xuUIu16YlDTMg5Yze9/eOkgIXfIOHtSjotfWpHU+Jae\ngO9usZDS4/DZs4e9uYcB/UxAOfXPQm0wuG5aSFqpTrlfRXfJ2rWlNKRrdNOq\nGzbzg0RH//HDOmn3d27fjdKYwrgujTACQWu/5yUNhIhoImF1R1X1wPAoBOGj\nDvfE4hWJdHZT5fmsT5QwzCXFXjN9dbL+JRbmlLLdiEgoTWmZpQh/ezNGJBri\nbx8XRIYNBXJ+AhpQhv2IKKi2wM4fHM+nPk/rWd0U8pXe+CQzThoW0PqWp34N\nIaYQ4BrItyi2iLumQauUv/+iNyOwpp3z7ITG4fSe5M6mcsY6aGX1liyoMdhG\nuhZ22sjn+UJCct2L8P/+rC8MiH2TAVS8v20yt5emt11XkFAqNVkiJAkz6EQG\n5ZLU4sSBoz2ByYCyu2YD3TF7gPe5JO3GUR5kKwAWJBiAswWaKlxRGmdgHDYT\nAWgXUXpc2dSi9TMbpHcQK2prTb2uz2wZZslNlfis6wvXu5RQ6Xq420kStBkH\nKnA9\r\n=hEaE\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIBSo+nHArn5GQ6kZNHt1+Nn063EQp7BYd7mp5F/lNpbYAiEAj3xRLADiagO4RvD8Pxp/Q4ApL39rc83uaxbnqAgfRwo="
          }
        ]
      },
      "maintainers": [
        {
          "email": "ben@benjamn.com",
          "name": "benjamn"
        },
        {
          "email": "james@meteor.com",
          "name": "jbaxleyiii"
        },
        {
          "email": "npm@meteor.com",
          "name": "mdg"
        },
        {
          "email": "peggyrayzis@gmail.com",
          "name": "peggyrayzis"
        }
      ],
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/apollo-cache-inmemory_1.2.6-alpha.4_1532479465951_0.5538567162738168"
      },
      "_hasShrinkwrap": false
    },
    "1.2.6-alpha.5": {
      "name": "apollo-cache-inmemory",
      "version": "1.2.6-alpha.5",
      "description": "Core abstract of Caching layer for Apollo Client",
      "author": {
        "name": "James Baxley",
        "email": "james@meteor.com"
      },
      "contributors": [
        {
          "name": "James Baxley",
          "email": "james@meteor.com"
        },
        {
          "name": "Jonas Helfer",
          "email": "jonas@helfer.email"
        },
        {
          "name": "Sashko Stubailo",
          "email": "sashko@stubailo.com"
        },
        {
          "name": "James Burgess",
          "email": "jamesmillerburgess@gmail.com"
        },
        {
          "name": "Bazyli Brzóska",
          "email": "bazyli.brzoska@gmail.com"
        }
      ],
      "license": "MIT",
      "main": "./lib/bundle.umd.js",
      "module": "./lib/index.js",
      "jsnext:main": "./lib/index.js",
      "typings": "./lib/index.d.ts",
      "sideEffects": false,
      "repository": {
        "type": "git",
        "url": "git+https://github.com/apollographql/apollo-client.git"
      },
      "bugs": {
        "url": "https://github.com/apollographql/apollo-client/issues"
      },
      "homepage": "https://github.com/apollographql/apollo-client#readme",
      "scripts": {
        "coverage": "jest --coverage",
        "test": "jest",
        "lint": "tslint --type-check -p tsconfig.json src/*.ts",
        "prebuild": "npm run clean",
        "build": "tsc -p .",
        "postbuild": "npm run bundle",
        "bundle": "rollup -c rollup.config.js",
        "watch": "tsc -w -p .",
        "clean": "rimraf coverage/* && rimraf lib/*",
        "prepublishOnly": "npm run build",
        "build:browser": "browserify ./lib/bundle.umd.js --i apollo-cache --i apollo-utilities --i graphql -o=./lib/bundle.js && npm run minify:browser",
        "minify:browser": "uglifyjs -c -m -o ./lib/bundle.min.js -- ./lib/bundle.js",
        "filesize": "npm run build:browser"
      },
      "dependencies": {
        "apollo-cache": "^1.1.13-alpha.5",
        "apollo-utilities": "^1.0.17-alpha.5",
        "graphql-anywhere": "^4.1.15-alpha.5"
      },
      "peerDependencies": {
        "graphql": "0.11.7 || ^0.12.0 || ^0.13.0"
      },
      "devDependencies": {
        "@types/graphql": "0.12.7",
        "@types/jest": "22.2.3",
        "@types/lodash": "4.14.112",
        "browserify": "15.2.0",
        "graphql": "0.13.2",
        "graphql-tag": "2.9.2",
        "jest": "23.0.0",
        "lodash": "4.17.10",
        "rimraf": "2.6.2",
        "rollup": "0.62.0",
        "ts-jest": "20.0.14",
        "tslint": "5.11.0",
        "typescript": "2.9.2",
        "uglifyjs": "2.4.11"
      },
      "jest": {
        "transform": {
          ".(ts|tsx)": "<rootDir>/node_modules/ts-jest/preprocessor.js"
        },
        "testRegex": "(/__tests__/.*|\\.(test|spec))\\.(ts|tsx|js)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "json"
        ]
      },
      "readme": "---\ntitle: InMemoryCache\ndescription: An explanation of `apollo-cache-inmemory`\n---\n\n`apollo-cache-inmemory` is the recommended cache implementation for Apollo Client 2.0. `InMemoryCache` is a normalized data store that supports all of Apollo Client 1.0's features without the dependency on Redux.\n\nIn some instances, you may need to manipulate the cache directly, such as updating the store after a mutation. We'll cover some common use cases [here](#recipes).\n\n<h2 id=\"installation\">Installation</h2>\n\n```\nnpm install apollo-cache-inmemory --save\n```\n\nAfter installing the package, you'll want to initialize the cache constructor. Then, you can pass in your newly created cache to ApolloClient.\n\n```js\nimport { InMemoryCache } from 'apollo-cache-inmemory';\nimport { HttpLink } from 'apollo-link-http';\nimport ApolloClient from 'apollo-client';\n\nconst cache = new InMemoryCache();\n\nconst client = new ApolloClient({\n  link: new HttpLink(),\n  cache\n});\n```\n\n<h2 id=\"configuration\">Configuration</h2>\n\nThe `InMemoryCache` constructor takes an optional config object with properties to customize your cache:\n\n- addTypename: A boolean to determine whether to add __typename to the document (default: `true`)\n- dataIdFromObject: A function that takes a data object and returns a unique identifier to be used when normalizing the data in the store. Learn more about how to customize `dataIdFromObject` in the [Normalization](#normalization) section.\n- fragmentMatcher: By default, the `InMemoryCache` uses a heuristic fragment matcher. If you are using fragments on unions and interfaces, you will need to use an `IntrospectionFragmentMatcher`. For more information, please read [our guide to setting up fragment matching for unions & interfaces](https://www.apollographql.com/docs/react/advanced/fragments.html#fragment-matcher).\n\n<h2 id=\"normalization\">Normalization</h2>\n\nThe `InMemoryCache` normalizes your data before saving it to the store by splitting the result into individual objects, creating a unique identifier for each object, and storing those objects in a flattened data structure. By default, `InMemoryCache` will attempt to use the commonly found primary keys of `id` and `_id` for the unique identifier if they exist along with `__typename` on an object.\n\nIf `id` and `_id` are not specified, or if `__typename` is not specified, `InMemoryCache` will fall back to the path to the object in the query, such as `ROOT_QUERY.allPeople.0` for the first record returned on the `allPeople` root query.\n\nThis \"getter\" behavior for unique identifiers can be configured manually via the `dataIdFromObject` option passed to the `InMemoryCache` constructor, so you can pick which field is used if some of your data follows unorthodox primary key conventions.\n\nFor example, if you wanted to key off of the `key` field for all of your data, you could configure `dataIdFromObject` like so:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => object.key\n});\n```\n\nThis also allows you to use different unique identifiers for different data types by keying off of the `__typename` property attached to every object typed by GraphQL.  For example:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => {\n    switch (object.__typename) {\n      case 'foo': return object.key; // use `key` as the primary key\n      case 'bar': return object.blah; // use `blah` as the priamry key\n      default: return object.id || object._id; // fall back to `id` and `_id` for all other types\n    }\n  }\n});\n```\n\n<h2 id=\"direct\">Direct Cache Access</h2>\n\nTo interact directly with your cache, you can use the Apollo Client class methods readQuery, readFragment, writeQuery, and writeFragment. These methods are available to us via the [`DataProxy` interface](http://dev.apollodata.com/core/apollo-client-api.html#DataProxy). Accessing these methods will vary slightly based on your view layer implementation. If you are using React, you can wrap your component in the `withApollo` higher order component, which will give you access to `this.props.client`. From there, you can use the methods to control your data.\n\nAny code demonstration in the following sections will assume that we have already initialized an instance of  `ApolloClient` and that we have imported the `gql` tag from `graphql-tag`.\n\n<h3 id=\"readquery\">readQuery</h3>\n\nThe `readQuery` method is very similar to the [`query` method on `ApolloClient`][] except that `readQuery` will _never_ make a request to your GraphQL server. The `query` method, on the other hand, may send a request to your server if the appropriate data is not in your cache whereas `readQuery` will throw an error if the data is not in your cache. `readQuery` will _always_ read from the cache. You can use `readQuery` by giving it a GraphQL query like so:\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo {\n      todo(id: 5) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n});\n```\n\nIf all of the data needed to fulfill this read is in Apollo Client’s normalized data cache then a data object will be returned in the shape of the query you wanted to read. If not all of the data needed to fulfill this read is in Apollo Client’s cache then an error will be thrown instead, so make sure to only read data that you know you have!\n\nYou can also pass variables into `readQuery`.\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo($id: Int!) {\n      todo(id: $id) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n  variables: {\n    id: 5,\n  },\n});\n```\n\n<h3 id=\"readfragment\">readFragment</h3>\n\nThis method allows you great flexibility around the data in your cache. Whereas `readQuery` only allowed you to read data from your root query type, `readFragment` allows you to read data from _any node you have queried_. This is incredibly powerful. You use this method as follows:\n\n```js\nconst todo = client.readFragment({\n  id: ..., // `id` is any id that could be returned by `dataIdFromObject`.\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\nThe first argument is the id of the data you want to read from the cache. That id must be a value that was returned by the `dataIdFromObject` function you defined when initializing `ApolloClient`. So for example if you initialized `ApolloClient` like so:\n\n```js\nconst client = new ApolloClient({\n  ...,\n  dataIdFromObject: object => object.id,\n});\n```\n\n…and you requested a todo before with an id of `5`, then you can read that todo out of your cache with the following:\n\n```js\nconst todo = client.readFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\n> **Note:** Most people add a `__typename` to the id in `dataIdFromObject`. If you do this then don’t forget to add the `__typename` when you are reading a fragment as well. So for example your id may be `Todo_5` and not just `5`.\n\nIf a todo with that id does not exist in the cache you will get `null` back. If a todo of that id does exist in the cache, but that todo does not have the `text` field then an error will be thrown.\n\nThe beauty of `readFragment` is that the todo could have come from anywhere! The todo could have been selected as a singleton (`{ todo(id: 5) { ... } }`), the todo could have come from a list of todos (`{ todos { ... } }`), or the todo could have come from a mutation (`mutation { createTodo { ... } }`). As long as at some point your GraphQL server gave you a todo with the provided id and fields `id`, `text`, and `completed` you can read it from the cache at any part of your code.\n\n<h3 id=\"writequery-and-writefragment\">writeQuery` and `writeFragment</h3>\n\nNot only can you read arbitrary data from the Apollo Client cache, but you can also write any data that you would like to the cache. The methods you use to do this are `writeQuery` and `writeFragment`. They will allow you to change data in your local cache, but it is important to remember that *they will not change any data on your server*. If you reload your environment then changes made with `writeQuery` and `writeFragment` will disappear.\n\nThese methods have the same signature as their `readQuery` and `readFragment` counterparts except they also require an additional `data` variable. So for example, if you wanted to update the `completed` flag locally for your todo with id `'5'` you could execute the following:\n\n```js\nclient.writeFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      completed\n    }\n  `,\n  data: {\n    completed: true,\n  },\n});\n```\n\nAny subscriber to the Apollo Client store will instantly see this update and render new UI accordingly.\n\n> **Note:** Again, remember that using `writeQuery` or `writeFragment` only changes data *locally*. If you reload your environment then changes made with these methods will no longer exist.\n\nOr if you wanted to add a new todo to a list fetched from the server, you could use `readQuery` and `writeQuery` together.\n\n```js\nconst query = gql`\n  query MyTodoAppQuery {\n    todos {\n      id\n      text\n      completed\n    }\n  }\n`;\n\nconst data = client.readQuery({ query });\n\nconst myNewTodo = {\n  id: '6',\n  text: 'Start using Apollo Client.',\n  completed: false,\n};\n\nclient.writeQuery({\n  query,\n  data: {\n    todos: [...data.todos, myNewTodo],\n  },\n});\n```\n\n<h2 id=\"recipes\">Recipes</h2>\n\nHere are some common situations where you would need to access the cache directly. If you're manipulating the cache in an interesting way and would like your example to be featured, please send in a pull request!\n\n<h3 id=\"server\">Server side rendering</h3>\n\nFirst, you will need to initialize an `InMemoryCache` on the server and create an instance of `ApolloClient`. In the initial serialized HTML payload from the server, you should include a script tag that extracts the data from the cache.\n\n```js\n`<script>\n  window.__APOLLO_STATE__=${JSON.stringify(cache.extract())}\n</script>`\n```\n\nOn the client, you can rehydrate the cache using the initial data passed from the server:\n\n```js\ncache: new Cache().restore(window.__APOLLO_STATE__)\n```\n\nIf you would like to learn more about server side rendering, please check our our more in depth guide [here].\n<!---\nTODO (PEGGY): Add link to SSR\n-->\n\n<h3 id=\"server\">Updating the cache after a mutation</h3>\n\nBeing able to read and write to the Apollo cache from anywhere in your application gives you a lot of power over your data. However, there is one place where we most often want to update our cached data: after a mutation. As such, Apollo Client has optimized the experience for updating your cache with the read and write methods after a mutation with the `update` function. Let us say that we have the following GraphQL mutation:\n\n```graphql\nmutation TodoCreateMutation($text: String!) {\n  createTodo(text: $text) {\n    id\n    text\n    completed\n  }\n}\n```\n\nWe may also have the following GraphQL query:\n\n```graphql\nquery TodoAppQuery {\n  todos {\n    id\n    text\n    completed\n  }\n}\n```\n\nAt the end of our mutation we want our query to include the new todo like we had sent our `TodoAppQuery` a second time after the mutation finished without actually sending the query. To do this we can use the `update` function provided as an option of the `client.mutate` method. To update your cache with the mutation just write code that looks like:\n\n```js\n// We assume that the GraphQL operations `TodoCreateMutation` and\n// `TodoAppQuery` have already been defined using the `gql` tag.\n\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    // Read the data from our cache for this query.\n    const data = proxy.readQuery({ query: TodoAppQuery });\n\n    // Add our todo from the mutation to the end.\n    data.todos.push(createTodo);\n\n    // Write our data back to the cache.\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nThe first `proxy` argument is an instance of [`DataProxy`][] has the same four methods that we just learned exist on the Apollo Client: `readQuery`, `readFragment`, `writeQuery`, and `writeFragment`. The reason we call them on a `proxy` object here instead of on our `client` instance is that we can easily apply optimistic updates (which we will demonstrate in a bit). The `proxy` object also provides an isolated transaction which shields you from any other mutations going on at the same time, and the `proxy` object also batches writes together until the very end.\n\nIf you provide an `optimisticResponse` option to the mutation then the `update` function will be run twice. Once immediately after you call `client.mutate` with the data from `optimisticResponse`. After the mutation successfully executes against the server the changes made in the first call to `update` will be rolled back and `update` will be called with the *actual* data returned by the mutation and not just the optimistic response.\n\nPutting it all together:\n\n```js\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  optimisticResponse: {\n    id: -1, // -1 is a temporary id for the optimistic response.\n    text,\n    completed: false,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    const data = proxy.readQuery({ query: TodoAppQuery });\n    data.todos.push(createTodo);\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nAs you can see the `update` function on `client.mutate` provides extra change management functionality specific to the use case of a mutation while still providing you the powerful data control APIs that are available on `client`.\n\nThe `update` function is not a good place for side-effects as it may be called multiple times. Also, you may not call any of the methods on `proxy` asynchronously.\n\n",
      "readmeFilename": "README.md",
      "_id": "apollo-cache-inmemory@1.2.6-alpha.5",
      "_npmVersion": "6.1.0",
      "_nodeVersion": "10.6.0",
      "_npmUser": {
        "name": "mdg",
        "email": "npm@meteor.com"
      },
      "dist": {
        "integrity": "sha512-xHJBtHAco5uJ706sZ6SnwKfqKnBrmuuXhaswWOZqHgm50KJ18M3oTzbZi8F8Vh6OtXDbVuGXj3xfFNXcy169vQ==",
        "shasum": "ac42f78027c12838ecea1246815b402c8fa3c653",
        "tarball": "https://registry.npmjs.org/apollo-cache-inmemory/-/apollo-cache-inmemory-1.2.6-alpha.5.tgz",
        "fileCount": 61,
        "unpackedSize": 428211,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJbV/8wCRA9TVsSAnZWagAAd84QAKIIai8C+wYvr9F3t1T4\nMIn190e1zoMdtwGXqpau7FIRBhvuxrHPt2y77lDPKCfBMy39Aw9eTL5VoNI1\nu6iyA54TqNGvlOdc0vbHzy2zcPR5nOQQvjjmrov5w3r9b0IP22MjwAR8Waud\n4id3aiRVB8QB1CqiJrgdq03Ex0LqTnmzhMEhPhHZ0BFaQuidQzK+JY9Un9KG\nv4T3ny99sKlVE/vjF6cRmMHlp/bSDdDBzbWn7hZhONXok5f2WfVJ4gGhkXVX\nU214Wmr/Be1nOKwlV3UhODy4iqQc8cnldf2zYHtbvvGtO7eK02eoxps/eb4d\nZZcELUvYHMXQ6ZPUEZ/m7dgGmFBj7jIr/c2THKz971BWoePjEA6Jt4CAAgzl\nfb7H5H+A+A/rul97osGiiGvb/jzfssZ3igyV50Mz0bbbLEG4GCc70j1m+YIm\n539rHhKfsI6mKx8gISJJ6sDbTGj1YuyfEBzvrocvNrSW0cJQ9VwHJ85/DZNm\nQI8tSbFCWIZ1v+sEGfuhGaFkilR0AdiEA9kineXoNxkDdVXEMdXPBMlP4sqY\nqE7EeHjoK/+RXsi5Mja4Q7r9kEvmfx2A/CiUN4m6y7dTqjejnH7pJsDE6gqS\neenxID+e4AwNE7z2/MutHgXKiRMimViy8G1dJTU3OWrMPBO8ejNCl8QR/7cg\nHDF+\r\n=r4fb\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIQDLk3inO59sUvUxwc5zuPXVZOtO4YxGnvXqN2csmiIBQAIgToYl/1GpybswIncnaBVKDFI8XT5BgmUahuxzNsfdxL8="
          }
        ]
      },
      "maintainers": [
        {
          "email": "ben@benjamn.com",
          "name": "benjamn"
        },
        {
          "email": "james@meteor.com",
          "name": "jbaxleyiii"
        },
        {
          "email": "npm@meteor.com",
          "name": "mdg"
        },
        {
          "email": "peggyrayzis@gmail.com",
          "name": "peggyrayzis"
        }
      ],
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/apollo-cache-inmemory_1.2.6-alpha.5_1532493615941_0.33257361771308913"
      },
      "_hasShrinkwrap": false
    },
    "1.2.6-alpha.6": {
      "name": "apollo-cache-inmemory",
      "version": "1.2.6-alpha.6",
      "description": "Core abstract of Caching layer for Apollo Client",
      "author": {
        "name": "James Baxley",
        "email": "james@meteor.com"
      },
      "contributors": [
        {
          "name": "James Baxley",
          "email": "james@meteor.com"
        },
        {
          "name": "Jonas Helfer",
          "email": "jonas@helfer.email"
        },
        {
          "name": "Sashko Stubailo",
          "email": "sashko@stubailo.com"
        },
        {
          "name": "James Burgess",
          "email": "jamesmillerburgess@gmail.com"
        },
        {
          "name": "Bazyli Brzóska",
          "email": "bazyli.brzoska@gmail.com"
        }
      ],
      "license": "MIT",
      "main": "./lib/bundle.umd.js",
      "module": "./lib/index.js",
      "jsnext:main": "./lib/index.js",
      "typings": "./lib/index.d.ts",
      "sideEffects": false,
      "repository": {
        "type": "git",
        "url": "git+https://github.com/apollographql/apollo-client.git"
      },
      "bugs": {
        "url": "https://github.com/apollographql/apollo-client/issues"
      },
      "homepage": "https://github.com/apollographql/apollo-client#readme",
      "scripts": {
        "coverage": "jest --coverage",
        "test": "jest",
        "lint": "tslint --type-check -p tsconfig.json src/*.ts",
        "prebuild": "npm run clean",
        "build": "tsc -p .",
        "postbuild": "npm run bundle",
        "bundle": "rollup -c rollup.config.js",
        "watch": "tsc -w -p .",
        "clean": "rimraf coverage/* && rimraf lib/*",
        "prepublishOnly": "npm run build",
        "build:browser": "browserify ./lib/bundle.umd.js --i apollo-cache --i apollo-utilities --i graphql -o=./lib/bundle.js && npm run minify:browser",
        "minify:browser": "uglifyjs -c -m -o ./lib/bundle.min.js -- ./lib/bundle.js",
        "filesize": "npm run build:browser"
      },
      "dependencies": {
        "apollo-cache": "^1.1.13-alpha.6",
        "apollo-utilities": "^1.0.17-alpha.4",
        "graphql-anywhere": "^4.1.15-alpha.4"
      },
      "peerDependencies": {
        "graphql": "0.11.7 || ^0.12.0 || ^0.13.0"
      },
      "devDependencies": {
        "@types/graphql": "0.12.7",
        "@types/jest": "22.2.3",
        "@types/lodash": "4.14.112",
        "browserify": "15.2.0",
        "graphql": "0.13.2",
        "graphql-tag": "2.9.2",
        "jest": "23.0.0",
        "lodash": "4.17.10",
        "rimraf": "2.6.2",
        "rollup": "0.62.0",
        "ts-jest": "20.0.14",
        "tslint": "5.11.0",
        "typescript": "2.9.2",
        "uglifyjs": "2.4.11"
      },
      "jest": {
        "transform": {
          ".(ts|tsx)": "<rootDir>/node_modules/ts-jest/preprocessor.js"
        },
        "testRegex": "(/__tests__/.*|\\.(test|spec))\\.(ts|tsx|js)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "json"
        ]
      },
      "readme": "---\ntitle: InMemoryCache\ndescription: An explanation of `apollo-cache-inmemory`\n---\n\n`apollo-cache-inmemory` is the recommended cache implementation for Apollo Client 2.0. `InMemoryCache` is a normalized data store that supports all of Apollo Client 1.0's features without the dependency on Redux.\n\nIn some instances, you may need to manipulate the cache directly, such as updating the store after a mutation. We'll cover some common use cases [here](#recipes).\n\n<h2 id=\"installation\">Installation</h2>\n\n```\nnpm install apollo-cache-inmemory --save\n```\n\nAfter installing the package, you'll want to initialize the cache constructor. Then, you can pass in your newly created cache to ApolloClient.\n\n```js\nimport { InMemoryCache } from 'apollo-cache-inmemory';\nimport { HttpLink } from 'apollo-link-http';\nimport ApolloClient from 'apollo-client';\n\nconst cache = new InMemoryCache();\n\nconst client = new ApolloClient({\n  link: new HttpLink(),\n  cache\n});\n```\n\n<h2 id=\"configuration\">Configuration</h2>\n\nThe `InMemoryCache` constructor takes an optional config object with properties to customize your cache:\n\n- addTypename: A boolean to determine whether to add __typename to the document (default: `true`)\n- dataIdFromObject: A function that takes a data object and returns a unique identifier to be used when normalizing the data in the store. Learn more about how to customize `dataIdFromObject` in the [Normalization](#normalization) section.\n- fragmentMatcher: By default, the `InMemoryCache` uses a heuristic fragment matcher. If you are using fragments on unions and interfaces, you will need to use an `IntrospectionFragmentMatcher`. For more information, please read [our guide to setting up fragment matching for unions & interfaces](https://www.apollographql.com/docs/react/advanced/fragments.html#fragment-matcher).\n\n<h2 id=\"normalization\">Normalization</h2>\n\nThe `InMemoryCache` normalizes your data before saving it to the store by splitting the result into individual objects, creating a unique identifier for each object, and storing those objects in a flattened data structure. By default, `InMemoryCache` will attempt to use the commonly found primary keys of `id` and `_id` for the unique identifier if they exist along with `__typename` on an object.\n\nIf `id` and `_id` are not specified, or if `__typename` is not specified, `InMemoryCache` will fall back to the path to the object in the query, such as `ROOT_QUERY.allPeople.0` for the first record returned on the `allPeople` root query.\n\nThis \"getter\" behavior for unique identifiers can be configured manually via the `dataIdFromObject` option passed to the `InMemoryCache` constructor, so you can pick which field is used if some of your data follows unorthodox primary key conventions.\n\nFor example, if you wanted to key off of the `key` field for all of your data, you could configure `dataIdFromObject` like so:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => object.key\n});\n```\n\nThis also allows you to use different unique identifiers for different data types by keying off of the `__typename` property attached to every object typed by GraphQL.  For example:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => {\n    switch (object.__typename) {\n      case 'foo': return object.key; // use `key` as the primary key\n      case 'bar': return object.blah; // use `blah` as the priamry key\n      default: return object.id || object._id; // fall back to `id` and `_id` for all other types\n    }\n  }\n});\n```\n\n<h2 id=\"direct\">Direct Cache Access</h2>\n\nTo interact directly with your cache, you can use the Apollo Client class methods readQuery, readFragment, writeQuery, and writeFragment. These methods are available to us via the [`DataProxy` interface](http://dev.apollodata.com/core/apollo-client-api.html#DataProxy). Accessing these methods will vary slightly based on your view layer implementation. If you are using React, you can wrap your component in the `withApollo` higher order component, which will give you access to `this.props.client`. From there, you can use the methods to control your data.\n\nAny code demonstration in the following sections will assume that we have already initialized an instance of  `ApolloClient` and that we have imported the `gql` tag from `graphql-tag`.\n\n<h3 id=\"readquery\">readQuery</h3>\n\nThe `readQuery` method is very similar to the [`query` method on `ApolloClient`][] except that `readQuery` will _never_ make a request to your GraphQL server. The `query` method, on the other hand, may send a request to your server if the appropriate data is not in your cache whereas `readQuery` will throw an error if the data is not in your cache. `readQuery` will _always_ read from the cache. You can use `readQuery` by giving it a GraphQL query like so:\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo {\n      todo(id: 5) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n});\n```\n\nIf all of the data needed to fulfill this read is in Apollo Client’s normalized data cache then a data object will be returned in the shape of the query you wanted to read. If not all of the data needed to fulfill this read is in Apollo Client’s cache then an error will be thrown instead, so make sure to only read data that you know you have!\n\nYou can also pass variables into `readQuery`.\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo($id: Int!) {\n      todo(id: $id) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n  variables: {\n    id: 5,\n  },\n});\n```\n\n<h3 id=\"readfragment\">readFragment</h3>\n\nThis method allows you great flexibility around the data in your cache. Whereas `readQuery` only allowed you to read data from your root query type, `readFragment` allows you to read data from _any node you have queried_. This is incredibly powerful. You use this method as follows:\n\n```js\nconst todo = client.readFragment({\n  id: ..., // `id` is any id that could be returned by `dataIdFromObject`.\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\nThe first argument is the id of the data you want to read from the cache. That id must be a value that was returned by the `dataIdFromObject` function you defined when initializing `ApolloClient`. So for example if you initialized `ApolloClient` like so:\n\n```js\nconst client = new ApolloClient({\n  ...,\n  dataIdFromObject: object => object.id,\n});\n```\n\n…and you requested a todo before with an id of `5`, then you can read that todo out of your cache with the following:\n\n```js\nconst todo = client.readFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\n> **Note:** Most people add a `__typename` to the id in `dataIdFromObject`. If you do this then don’t forget to add the `__typename` when you are reading a fragment as well. So for example your id may be `Todo_5` and not just `5`.\n\nIf a todo with that id does not exist in the cache you will get `null` back. If a todo of that id does exist in the cache, but that todo does not have the `text` field then an error will be thrown.\n\nThe beauty of `readFragment` is that the todo could have come from anywhere! The todo could have been selected as a singleton (`{ todo(id: 5) { ... } }`), the todo could have come from a list of todos (`{ todos { ... } }`), or the todo could have come from a mutation (`mutation { createTodo { ... } }`). As long as at some point your GraphQL server gave you a todo with the provided id and fields `id`, `text`, and `completed` you can read it from the cache at any part of your code.\n\n<h3 id=\"writequery-and-writefragment\">writeQuery` and `writeFragment</h3>\n\nNot only can you read arbitrary data from the Apollo Client cache, but you can also write any data that you would like to the cache. The methods you use to do this are `writeQuery` and `writeFragment`. They will allow you to change data in your local cache, but it is important to remember that *they will not change any data on your server*. If you reload your environment then changes made with `writeQuery` and `writeFragment` will disappear.\n\nThese methods have the same signature as their `readQuery` and `readFragment` counterparts except they also require an additional `data` variable. So for example, if you wanted to update the `completed` flag locally for your todo with id `'5'` you could execute the following:\n\n```js\nclient.writeFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      completed\n    }\n  `,\n  data: {\n    completed: true,\n  },\n});\n```\n\nAny subscriber to the Apollo Client store will instantly see this update and render new UI accordingly.\n\n> **Note:** Again, remember that using `writeQuery` or `writeFragment` only changes data *locally*. If you reload your environment then changes made with these methods will no longer exist.\n\nOr if you wanted to add a new todo to a list fetched from the server, you could use `readQuery` and `writeQuery` together.\n\n```js\nconst query = gql`\n  query MyTodoAppQuery {\n    todos {\n      id\n      text\n      completed\n    }\n  }\n`;\n\nconst data = client.readQuery({ query });\n\nconst myNewTodo = {\n  id: '6',\n  text: 'Start using Apollo Client.',\n  completed: false,\n};\n\nclient.writeQuery({\n  query,\n  data: {\n    todos: [...data.todos, myNewTodo],\n  },\n});\n```\n\n<h2 id=\"recipes\">Recipes</h2>\n\nHere are some common situations where you would need to access the cache directly. If you're manipulating the cache in an interesting way and would like your example to be featured, please send in a pull request!\n\n<h3 id=\"server\">Server side rendering</h3>\n\nFirst, you will need to initialize an `InMemoryCache` on the server and create an instance of `ApolloClient`. In the initial serialized HTML payload from the server, you should include a script tag that extracts the data from the cache.\n\n```js\n`<script>\n  window.__APOLLO_STATE__=${JSON.stringify(cache.extract())}\n</script>`\n```\n\nOn the client, you can rehydrate the cache using the initial data passed from the server:\n\n```js\ncache: new Cache().restore(window.__APOLLO_STATE__)\n```\n\nIf you would like to learn more about server side rendering, please check our our more in depth guide [here].\n<!---\nTODO (PEGGY): Add link to SSR\n-->\n\n<h3 id=\"server\">Updating the cache after a mutation</h3>\n\nBeing able to read and write to the Apollo cache from anywhere in your application gives you a lot of power over your data. However, there is one place where we most often want to update our cached data: after a mutation. As such, Apollo Client has optimized the experience for updating your cache with the read and write methods after a mutation with the `update` function. Let us say that we have the following GraphQL mutation:\n\n```graphql\nmutation TodoCreateMutation($text: String!) {\n  createTodo(text: $text) {\n    id\n    text\n    completed\n  }\n}\n```\n\nWe may also have the following GraphQL query:\n\n```graphql\nquery TodoAppQuery {\n  todos {\n    id\n    text\n    completed\n  }\n}\n```\n\nAt the end of our mutation we want our query to include the new todo like we had sent our `TodoAppQuery` a second time after the mutation finished without actually sending the query. To do this we can use the `update` function provided as an option of the `client.mutate` method. To update your cache with the mutation just write code that looks like:\n\n```js\n// We assume that the GraphQL operations `TodoCreateMutation` and\n// `TodoAppQuery` have already been defined using the `gql` tag.\n\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    // Read the data from our cache for this query.\n    const data = proxy.readQuery({ query: TodoAppQuery });\n\n    // Add our todo from the mutation to the end.\n    data.todos.push(createTodo);\n\n    // Write our data back to the cache.\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nThe first `proxy` argument is an instance of [`DataProxy`][] has the same four methods that we just learned exist on the Apollo Client: `readQuery`, `readFragment`, `writeQuery`, and `writeFragment`. The reason we call them on a `proxy` object here instead of on our `client` instance is that we can easily apply optimistic updates (which we will demonstrate in a bit). The `proxy` object also provides an isolated transaction which shields you from any other mutations going on at the same time, and the `proxy` object also batches writes together until the very end.\n\nIf you provide an `optimisticResponse` option to the mutation then the `update` function will be run twice. Once immediately after you call `client.mutate` with the data from `optimisticResponse`. After the mutation successfully executes against the server the changes made in the first call to `update` will be rolled back and `update` will be called with the *actual* data returned by the mutation and not just the optimistic response.\n\nPutting it all together:\n\n```js\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  optimisticResponse: {\n    id: -1, // -1 is a temporary id for the optimistic response.\n    text,\n    completed: false,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    const data = proxy.readQuery({ query: TodoAppQuery });\n    data.todos.push(createTodo);\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nAs you can see the `update` function on `client.mutate` provides extra change management functionality specific to the use case of a mutation while still providing you the powerful data control APIs that are available on `client`.\n\nThe `update` function is not a good place for side-effects as it may be called multiple times. Also, you may not call any of the methods on `proxy` asynchronously.\n\n",
      "readmeFilename": "README.md",
      "_id": "apollo-cache-inmemory@1.2.6-alpha.6",
      "_npmVersion": "6.1.0",
      "_nodeVersion": "10.6.0",
      "_npmUser": {
        "name": "mdg",
        "email": "npm@meteor.com"
      },
      "dist": {
        "integrity": "sha512-re7Xzb5+J57IeouBxuFospN7pqt7vBhIBffMv+7mzrG1QL8WI0IXht2DZUXKdvJQHr2zgwo86Ra7iURQxwwYdA==",
        "shasum": "f4d6b6076ee2addd1d5672ca877b1add7e3007d6",
        "tarball": "https://registry.npmjs.org/apollo-cache-inmemory/-/apollo-cache-inmemory-1.2.6-alpha.6.tgz",
        "fileCount": 61,
        "unpackedSize": 428211,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJbWAcNCRA9TVsSAnZWagAAIUoP/0NlVAeAZAXzU200yCV8\nZWw0T1UZY7jvKJX5oFRF1j3TUA6GI/6mrbbHdgu54Q2s7GQbP/fx6K1rSvv9\ni9BnVf3YSMmHwFC3Rs2uFF8PxV+A/X1/wzrx0E9ar42cuukYgQ/eHMvvmPZY\nlmRJRJ+TbR9AQ265nBe+qEVxAkWk7s8sII4dxSZdGUKWJX+qOYt3w65TJpch\nfXOhBvgeK9egY1ZUiHd2QFbP/jLQbFS0AV24yULgtSUrGGc5nB9+9lDeoKZw\nvtLU47q1AFBVg4WGwjtTQ+8Xgi99+XuFsULIk097QMzCMcBhdvFIeshd60cu\nSWb2WTdW8zslW9XBbTKk2PsPN6x/Qhok8JeHKauqmS5IJplDfyZXaa1Y1xjT\ng2DzAC2xrHwxk9L1LIseAYO8zQZJSekf0L6ZKHE84WE3Qsp7oEDda2pXIlIw\nVuhAxCh73rtpNJweJVh9dixUd+YRislo7YOlJ1/6SRFYYvDVXOcq25Pa13Xx\nzKQZHdVdcWIJuy0nawghD3ldU+XEs3wJQQPeyfX90Xa24IKdmCZhIjoKOoix\njbikCh1p9SSIf9IwXwJUAm+9Jdwu9bxXz5udPu5RA9CyEuYpBcXUEXioyhlP\nudOTWf+5tWA9I0D3+jFUn8UmpIAs+0HpQDWyE+NldG2iM7JHFe6fkdJAbzxl\nN/FL\r\n=z+XO\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIFvOwTCPWlJMu9TXkYANB+UxMbObKtZDD9sfcx1Jl16BAiEApnKAzGzkekgpJQw4gDnZyzMKJ+aYLKY1VegkdzdurJE="
          }
        ]
      },
      "maintainers": [
        {
          "email": "ben@benjamn.com",
          "name": "benjamn"
        },
        {
          "email": "james@meteor.com",
          "name": "jbaxleyiii"
        },
        {
          "email": "npm@meteor.com",
          "name": "mdg"
        },
        {
          "email": "peggyrayzis@gmail.com",
          "name": "peggyrayzis"
        }
      ],
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/apollo-cache-inmemory_1.2.6-alpha.6_1532495629501_0.6099669808173256"
      },
      "_hasShrinkwrap": false
    },
    "1.2.6-alpha.7": {
      "name": "apollo-cache-inmemory",
      "version": "1.2.6-alpha.7",
      "description": "Core abstract of Caching layer for Apollo Client",
      "author": {
        "name": "James Baxley",
        "email": "james@meteor.com"
      },
      "contributors": [
        {
          "name": "James Baxley",
          "email": "james@meteor.com"
        },
        {
          "name": "Jonas Helfer",
          "email": "jonas@helfer.email"
        },
        {
          "name": "Sashko Stubailo",
          "email": "sashko@stubailo.com"
        },
        {
          "name": "James Burgess",
          "email": "jamesmillerburgess@gmail.com"
        },
        {
          "name": "Bazyli Brzóska",
          "email": "bazyli.brzoska@gmail.com"
        }
      ],
      "license": "MIT",
      "main": "./lib/bundle.umd.js",
      "module": "./lib/index.js",
      "jsnext:main": "./lib/index.js",
      "typings": "./lib/index.d.ts",
      "sideEffects": false,
      "repository": {
        "type": "git",
        "url": "git+https://github.com/apollographql/apollo-client.git"
      },
      "bugs": {
        "url": "https://github.com/apollographql/apollo-client/issues"
      },
      "homepage": "https://github.com/apollographql/apollo-client#readme",
      "scripts": {
        "coverage": "jest --coverage",
        "test": "jest",
        "lint": "tslint --type-check -p tsconfig.json src/*.ts",
        "prebuild": "npm run clean",
        "build": "tsc -p .",
        "postbuild": "npm run bundle",
        "bundle": "rollup -c rollup.config.js",
        "watch": "tsc -w -p .",
        "clean": "rimraf coverage/* && rimraf lib/*",
        "prepublishOnly": "npm run build",
        "build:browser": "browserify ./lib/bundle.umd.js --i apollo-cache --i apollo-utilities --i graphql -o=./lib/bundle.js && npm run minify:browser",
        "minify:browser": "uglifyjs -c -m -o ./lib/bundle.min.js -- ./lib/bundle.js",
        "filesize": "npm run build:browser"
      },
      "dependencies": {
        "apollo-cache": "^1.1.13-alpha.7",
        "apollo-utilities": "^1.0.17-alpha.7",
        "graphql-anywhere": "^4.1.15-alpha.7"
      },
      "peerDependencies": {
        "graphql": "0.11.7 || ^0.12.0 || ^0.13.0"
      },
      "devDependencies": {
        "@types/graphql": "0.12.7",
        "@types/jest": "22.2.3",
        "@types/lodash": "4.14.112",
        "browserify": "15.2.0",
        "graphql": "0.13.2",
        "graphql-tag": "2.9.2",
        "jest": "23.0.0",
        "lodash": "4.17.10",
        "rimraf": "2.6.2",
        "rollup": "0.62.0",
        "ts-jest": "20.0.14",
        "tslint": "5.11.0",
        "typescript": "2.9.2",
        "uglifyjs": "2.4.11"
      },
      "jest": {
        "transform": {
          ".(ts|tsx)": "<rootDir>/node_modules/ts-jest/preprocessor.js"
        },
        "testRegex": "(/__tests__/.*|\\.(test|spec))\\.(ts|tsx|js)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "json"
        ]
      },
      "readme": "---\ntitle: InMemoryCache\ndescription: An explanation of `apollo-cache-inmemory`\n---\n\n`apollo-cache-inmemory` is the recommended cache implementation for Apollo Client 2.0. `InMemoryCache` is a normalized data store that supports all of Apollo Client 1.0's features without the dependency on Redux.\n\nIn some instances, you may need to manipulate the cache directly, such as updating the store after a mutation. We'll cover some common use cases [here](#recipes).\n\n<h2 id=\"installation\">Installation</h2>\n\n```\nnpm install apollo-cache-inmemory --save\n```\n\nAfter installing the package, you'll want to initialize the cache constructor. Then, you can pass in your newly created cache to ApolloClient.\n\n```js\nimport { InMemoryCache } from 'apollo-cache-inmemory';\nimport { HttpLink } from 'apollo-link-http';\nimport ApolloClient from 'apollo-client';\n\nconst cache = new InMemoryCache();\n\nconst client = new ApolloClient({\n  link: new HttpLink(),\n  cache\n});\n```\n\n<h2 id=\"configuration\">Configuration</h2>\n\nThe `InMemoryCache` constructor takes an optional config object with properties to customize your cache:\n\n- addTypename: A boolean to determine whether to add __typename to the document (default: `true`)\n- dataIdFromObject: A function that takes a data object and returns a unique identifier to be used when normalizing the data in the store. Learn more about how to customize `dataIdFromObject` in the [Normalization](#normalization) section.\n- fragmentMatcher: By default, the `InMemoryCache` uses a heuristic fragment matcher. If you are using fragments on unions and interfaces, you will need to use an `IntrospectionFragmentMatcher`. For more information, please read [our guide to setting up fragment matching for unions & interfaces](https://www.apollographql.com/docs/react/advanced/fragments.html#fragment-matcher).\n\n<h2 id=\"normalization\">Normalization</h2>\n\nThe `InMemoryCache` normalizes your data before saving it to the store by splitting the result into individual objects, creating a unique identifier for each object, and storing those objects in a flattened data structure. By default, `InMemoryCache` will attempt to use the commonly found primary keys of `id` and `_id` for the unique identifier if they exist along with `__typename` on an object.\n\nIf `id` and `_id` are not specified, or if `__typename` is not specified, `InMemoryCache` will fall back to the path to the object in the query, such as `ROOT_QUERY.allPeople.0` for the first record returned on the `allPeople` root query.\n\nThis \"getter\" behavior for unique identifiers can be configured manually via the `dataIdFromObject` option passed to the `InMemoryCache` constructor, so you can pick which field is used if some of your data follows unorthodox primary key conventions.\n\nFor example, if you wanted to key off of the `key` field for all of your data, you could configure `dataIdFromObject` like so:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => object.key\n});\n```\n\nThis also allows you to use different unique identifiers for different data types by keying off of the `__typename` property attached to every object typed by GraphQL.  For example:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => {\n    switch (object.__typename) {\n      case 'foo': return object.key; // use `key` as the primary key\n      case 'bar': return object.blah; // use `blah` as the priamry key\n      default: return object.id || object._id; // fall back to `id` and `_id` for all other types\n    }\n  }\n});\n```\n\n<h2 id=\"direct\">Direct Cache Access</h2>\n\nTo interact directly with your cache, you can use the Apollo Client class methods readQuery, readFragment, writeQuery, and writeFragment. These methods are available to us via the [`DataProxy` interface](http://dev.apollodata.com/core/apollo-client-api.html#DataProxy). Accessing these methods will vary slightly based on your view layer implementation. If you are using React, you can wrap your component in the `withApollo` higher order component, which will give you access to `this.props.client`. From there, you can use the methods to control your data.\n\nAny code demonstration in the following sections will assume that we have already initialized an instance of  `ApolloClient` and that we have imported the `gql` tag from `graphql-tag`.\n\n<h3 id=\"readquery\">readQuery</h3>\n\nThe `readQuery` method is very similar to the [`query` method on `ApolloClient`][] except that `readQuery` will _never_ make a request to your GraphQL server. The `query` method, on the other hand, may send a request to your server if the appropriate data is not in your cache whereas `readQuery` will throw an error if the data is not in your cache. `readQuery` will _always_ read from the cache. You can use `readQuery` by giving it a GraphQL query like so:\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo {\n      todo(id: 5) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n});\n```\n\nIf all of the data needed to fulfill this read is in Apollo Client’s normalized data cache then a data object will be returned in the shape of the query you wanted to read. If not all of the data needed to fulfill this read is in Apollo Client’s cache then an error will be thrown instead, so make sure to only read data that you know you have!\n\nYou can also pass variables into `readQuery`.\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo($id: Int!) {\n      todo(id: $id) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n  variables: {\n    id: 5,\n  },\n});\n```\n\n<h3 id=\"readfragment\">readFragment</h3>\n\nThis method allows you great flexibility around the data in your cache. Whereas `readQuery` only allowed you to read data from your root query type, `readFragment` allows you to read data from _any node you have queried_. This is incredibly powerful. You use this method as follows:\n\n```js\nconst todo = client.readFragment({\n  id: ..., // `id` is any id that could be returned by `dataIdFromObject`.\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\nThe first argument is the id of the data you want to read from the cache. That id must be a value that was returned by the `dataIdFromObject` function you defined when initializing `ApolloClient`. So for example if you initialized `ApolloClient` like so:\n\n```js\nconst client = new ApolloClient({\n  ...,\n  dataIdFromObject: object => object.id,\n});\n```\n\n…and you requested a todo before with an id of `5`, then you can read that todo out of your cache with the following:\n\n```js\nconst todo = client.readFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\n> **Note:** Most people add a `__typename` to the id in `dataIdFromObject`. If you do this then don’t forget to add the `__typename` when you are reading a fragment as well. So for example your id may be `Todo_5` and not just `5`.\n\nIf a todo with that id does not exist in the cache you will get `null` back. If a todo of that id does exist in the cache, but that todo does not have the `text` field then an error will be thrown.\n\nThe beauty of `readFragment` is that the todo could have come from anywhere! The todo could have been selected as a singleton (`{ todo(id: 5) { ... } }`), the todo could have come from a list of todos (`{ todos { ... } }`), or the todo could have come from a mutation (`mutation { createTodo { ... } }`). As long as at some point your GraphQL server gave you a todo with the provided id and fields `id`, `text`, and `completed` you can read it from the cache at any part of your code.\n\n<h3 id=\"writequery-and-writefragment\">writeQuery` and `writeFragment</h3>\n\nNot only can you read arbitrary data from the Apollo Client cache, but you can also write any data that you would like to the cache. The methods you use to do this are `writeQuery` and `writeFragment`. They will allow you to change data in your local cache, but it is important to remember that *they will not change any data on your server*. If you reload your environment then changes made with `writeQuery` and `writeFragment` will disappear.\n\nThese methods have the same signature as their `readQuery` and `readFragment` counterparts except they also require an additional `data` variable. So for example, if you wanted to update the `completed` flag locally for your todo with id `'5'` you could execute the following:\n\n```js\nclient.writeFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      completed\n    }\n  `,\n  data: {\n    completed: true,\n  },\n});\n```\n\nAny subscriber to the Apollo Client store will instantly see this update and render new UI accordingly.\n\n> **Note:** Again, remember that using `writeQuery` or `writeFragment` only changes data *locally*. If you reload your environment then changes made with these methods will no longer exist.\n\nOr if you wanted to add a new todo to a list fetched from the server, you could use `readQuery` and `writeQuery` together.\n\n```js\nconst query = gql`\n  query MyTodoAppQuery {\n    todos {\n      id\n      text\n      completed\n    }\n  }\n`;\n\nconst data = client.readQuery({ query });\n\nconst myNewTodo = {\n  id: '6',\n  text: 'Start using Apollo Client.',\n  completed: false,\n};\n\nclient.writeQuery({\n  query,\n  data: {\n    todos: [...data.todos, myNewTodo],\n  },\n});\n```\n\n<h2 id=\"recipes\">Recipes</h2>\n\nHere are some common situations where you would need to access the cache directly. If you're manipulating the cache in an interesting way and would like your example to be featured, please send in a pull request!\n\n<h3 id=\"server\">Server side rendering</h3>\n\nFirst, you will need to initialize an `InMemoryCache` on the server and create an instance of `ApolloClient`. In the initial serialized HTML payload from the server, you should include a script tag that extracts the data from the cache.\n\n```js\n`<script>\n  window.__APOLLO_STATE__=${JSON.stringify(cache.extract())}\n</script>`\n```\n\nOn the client, you can rehydrate the cache using the initial data passed from the server:\n\n```js\ncache: new Cache().restore(window.__APOLLO_STATE__)\n```\n\nIf you would like to learn more about server side rendering, please check our our more in depth guide [here].\n<!---\nTODO (PEGGY): Add link to SSR\n-->\n\n<h3 id=\"server\">Updating the cache after a mutation</h3>\n\nBeing able to read and write to the Apollo cache from anywhere in your application gives you a lot of power over your data. However, there is one place where we most often want to update our cached data: after a mutation. As such, Apollo Client has optimized the experience for updating your cache with the read and write methods after a mutation with the `update` function. Let us say that we have the following GraphQL mutation:\n\n```graphql\nmutation TodoCreateMutation($text: String!) {\n  createTodo(text: $text) {\n    id\n    text\n    completed\n  }\n}\n```\n\nWe may also have the following GraphQL query:\n\n```graphql\nquery TodoAppQuery {\n  todos {\n    id\n    text\n    completed\n  }\n}\n```\n\nAt the end of our mutation we want our query to include the new todo like we had sent our `TodoAppQuery` a second time after the mutation finished without actually sending the query. To do this we can use the `update` function provided as an option of the `client.mutate` method. To update your cache with the mutation just write code that looks like:\n\n```js\n// We assume that the GraphQL operations `TodoCreateMutation` and\n// `TodoAppQuery` have already been defined using the `gql` tag.\n\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    // Read the data from our cache for this query.\n    const data = proxy.readQuery({ query: TodoAppQuery });\n\n    // Add our todo from the mutation to the end.\n    data.todos.push(createTodo);\n\n    // Write our data back to the cache.\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nThe first `proxy` argument is an instance of [`DataProxy`][] has the same four methods that we just learned exist on the Apollo Client: `readQuery`, `readFragment`, `writeQuery`, and `writeFragment`. The reason we call them on a `proxy` object here instead of on our `client` instance is that we can easily apply optimistic updates (which we will demonstrate in a bit). The `proxy` object also provides an isolated transaction which shields you from any other mutations going on at the same time, and the `proxy` object also batches writes together until the very end.\n\nIf you provide an `optimisticResponse` option to the mutation then the `update` function will be run twice. Once immediately after you call `client.mutate` with the data from `optimisticResponse`. After the mutation successfully executes against the server the changes made in the first call to `update` will be rolled back and `update` will be called with the *actual* data returned by the mutation and not just the optimistic response.\n\nPutting it all together:\n\n```js\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  optimisticResponse: {\n    id: -1, // -1 is a temporary id for the optimistic response.\n    text,\n    completed: false,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    const data = proxy.readQuery({ query: TodoAppQuery });\n    data.todos.push(createTodo);\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nAs you can see the `update` function on `client.mutate` provides extra change management functionality specific to the use case of a mutation while still providing you the powerful data control APIs that are available on `client`.\n\nThe `update` function is not a good place for side-effects as it may be called multiple times. Also, you may not call any of the methods on `proxy` asynchronously.\n\n",
      "readmeFilename": "README.md",
      "_id": "apollo-cache-inmemory@1.2.6-alpha.7",
      "_npmVersion": "6.1.0",
      "_nodeVersion": "10.6.0",
      "_npmUser": {
        "name": "mdg",
        "email": "npm@meteor.com"
      },
      "dist": {
        "integrity": "sha512-zCnhOs/5uuB6CD78vOAH1YgEvQPPWyL9xakJOh0R9lErTkayKOqM+1eVOSYqrv6TSjr1NLLmS26JgW4krYnnkA==",
        "shasum": "04136d0c6a91698f2d3f27223e77b5389bf37a6f",
        "tarball": "https://registry.npmjs.org/apollo-cache-inmemory/-/apollo-cache-inmemory-1.2.6-alpha.7.tgz",
        "fileCount": 61,
        "unpackedSize": 428211,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJbWAooCRA9TVsSAnZWagAAmUkQAJUqAHSBeZRLm7co17Fn\nRdHs/v2TTDu49/lvC7pBrEqynOm3Fk0EUwFvi6SorqERTBEYJk12UD3J6EVZ\nCvJWwg2vvqzurYM6k9ilyikoVJtTAao4f87GO1s5YzwTDRMU+AdXGIBrrcUV\ntdFl9wxyHo8oXQFzHTfZd7fYQA2bf8WuVJn3dpW/7qh5raSlAw2+qvUGTGvv\n91+bQwlcq+sM/8HkVF9aUU82DcFqbTxRsDEy6J3RyyPmC1fpnJR1TV/sRBED\nXNYyhhnaqtrxPwqhC1kjs8gH/61oXjK1PZigfHjZQcpYhlKPmvgC6+gtzNg4\nQWJUW7F1tPtqp1lnX8Z5lZNboQnZeOoyIhAyqxhAWLQhXM6NS/MYeZAhY3jh\nGOuJu4hEcq+xi3OBs4VbuRreyuEKZQaV1oLs4e3divip+h7CiDdOfBrj5MiK\nvBN0Jegav9kuKZacUinDatqzZfRwgkJ5RpazjGsQVS9Juf0QM62M+qwGAyul\nDUruc+BPrG2Hqg/Z4FgnE+Yb5JcunASCtdtvtX5UJZXTjs0Kraoq95jQV3Mx\nqGvfA16+AkcOXA/6uk/4JFtvFMI6iVR2wswevSIULBpCzMoXDP1Lp6rbdbYV\nx1+87y9LMdII2UKx5BNGNHrzkBiObdb1MLt2lOYTFDEa2YkU4Znqc/l8nm/K\nWX7Y\r\n=JqBr\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIAm3OLbya9dmRcWdladssL+13tsrgocfXat3z1tW9/aGAiEAvnImwzwTvQ/0fexJza63Rh9KuuWmMfpjGZewlHl04Zw="
          }
        ]
      },
      "maintainers": [
        {
          "email": "ben@benjamn.com",
          "name": "benjamn"
        },
        {
          "email": "james@meteor.com",
          "name": "jbaxleyiii"
        },
        {
          "email": "npm@meteor.com",
          "name": "mdg"
        },
        {
          "email": "peggyrayzis@gmail.com",
          "name": "peggyrayzis"
        }
      ],
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/apollo-cache-inmemory_1.2.6-alpha.7_1532496424359_0.9141703223466158"
      },
      "_hasShrinkwrap": false
    },
    "1.2.6-alpha.8": {
      "name": "apollo-cache-inmemory",
      "version": "1.2.6-alpha.8",
      "description": "Core abstract of Caching layer for Apollo Client",
      "author": {
        "name": "James Baxley",
        "email": "james@meteor.com"
      },
      "contributors": [
        {
          "name": "James Baxley",
          "email": "james@meteor.com"
        },
        {
          "name": "Jonas Helfer",
          "email": "jonas@helfer.email"
        },
        {
          "name": "Sashko Stubailo",
          "email": "sashko@stubailo.com"
        },
        {
          "name": "James Burgess",
          "email": "jamesmillerburgess@gmail.com"
        },
        {
          "name": "Bazyli Brzóska",
          "email": "bazyli.brzoska@gmail.com"
        }
      ],
      "license": "MIT",
      "main": "./lib/bundle.umd.js",
      "module": "./lib/index.js",
      "jsnext:main": "./lib/index.js",
      "typings": "./lib/index.d.ts",
      "sideEffects": false,
      "repository": {
        "type": "git",
        "url": "git+https://github.com/apollographql/apollo-client.git"
      },
      "bugs": {
        "url": "https://github.com/apollographql/apollo-client/issues"
      },
      "homepage": "https://github.com/apollographql/apollo-client#readme",
      "scripts": {
        "coverage": "jest --coverage",
        "test": "jest",
        "lint": "tslint --type-check -p tsconfig.json src/*.ts",
        "prebuild": "npm run clean",
        "build": "tsc -p .",
        "postbuild": "npm run bundle",
        "bundle": "rollup -c rollup.config.js",
        "watch": "tsc -w -p .",
        "clean": "rimraf coverage/* && rimraf lib/*",
        "prepublishOnly": "npm run build",
        "build:browser": "browserify ./lib/bundle.umd.js --i apollo-cache --i apollo-utilities --i graphql -o=./lib/bundle.js && npm run minify:browser",
        "minify:browser": "uglifyjs -c -m -o ./lib/bundle.min.js -- ./lib/bundle.js",
        "filesize": "npm run build:browser"
      },
      "dependencies": {
        "apollo-cache": "^1.1.13-alpha.8",
        "apollo-utilities": "^1.0.17-alpha.8",
        "graphql-anywhere": "^4.1.15-alpha.8"
      },
      "peerDependencies": {
        "graphql": "0.11.7 || ^0.12.0 || ^0.13.0"
      },
      "devDependencies": {
        "@types/graphql": "0.12.7",
        "@types/jest": "22.2.3",
        "@types/lodash": "4.14.112",
        "browserify": "15.2.0",
        "graphql": "0.13.2",
        "graphql-tag": "2.9.2",
        "jest": "23.0.0",
        "lodash": "4.17.10",
        "rimraf": "2.6.2",
        "rollup": "0.62.0",
        "ts-jest": "20.0.14",
        "tslint": "5.11.0",
        "typescript": "2.9.2",
        "uglifyjs": "2.4.11"
      },
      "jest": {
        "transform": {
          ".(ts|tsx)": "<rootDir>/node_modules/ts-jest/preprocessor.js"
        },
        "testRegex": "(/__tests__/.*|\\.(test|spec))\\.(ts|tsx|js)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "json"
        ]
      },
      "readme": "---\ntitle: InMemoryCache\ndescription: An explanation of `apollo-cache-inmemory`\n---\n\n`apollo-cache-inmemory` is the recommended cache implementation for Apollo Client 2.0. `InMemoryCache` is a normalized data store that supports all of Apollo Client 1.0's features without the dependency on Redux.\n\nIn some instances, you may need to manipulate the cache directly, such as updating the store after a mutation. We'll cover some common use cases [here](#recipes).\n\n<h2 id=\"installation\">Installation</h2>\n\n```\nnpm install apollo-cache-inmemory --save\n```\n\nAfter installing the package, you'll want to initialize the cache constructor. Then, you can pass in your newly created cache to ApolloClient.\n\n```js\nimport { InMemoryCache } from 'apollo-cache-inmemory';\nimport { HttpLink } from 'apollo-link-http';\nimport ApolloClient from 'apollo-client';\n\nconst cache = new InMemoryCache();\n\nconst client = new ApolloClient({\n  link: new HttpLink(),\n  cache\n});\n```\n\n<h2 id=\"configuration\">Configuration</h2>\n\nThe `InMemoryCache` constructor takes an optional config object with properties to customize your cache:\n\n- addTypename: A boolean to determine whether to add __typename to the document (default: `true`)\n- dataIdFromObject: A function that takes a data object and returns a unique identifier to be used when normalizing the data in the store. Learn more about how to customize `dataIdFromObject` in the [Normalization](#normalization) section.\n- fragmentMatcher: By default, the `InMemoryCache` uses a heuristic fragment matcher. If you are using fragments on unions and interfaces, you will need to use an `IntrospectionFragmentMatcher`. For more information, please read [our guide to setting up fragment matching for unions & interfaces](https://www.apollographql.com/docs/react/advanced/fragments.html#fragment-matcher).\n\n<h2 id=\"normalization\">Normalization</h2>\n\nThe `InMemoryCache` normalizes your data before saving it to the store by splitting the result into individual objects, creating a unique identifier for each object, and storing those objects in a flattened data structure. By default, `InMemoryCache` will attempt to use the commonly found primary keys of `id` and `_id` for the unique identifier if they exist along with `__typename` on an object.\n\nIf `id` and `_id` are not specified, or if `__typename` is not specified, `InMemoryCache` will fall back to the path to the object in the query, such as `ROOT_QUERY.allPeople.0` for the first record returned on the `allPeople` root query.\n\nThis \"getter\" behavior for unique identifiers can be configured manually via the `dataIdFromObject` option passed to the `InMemoryCache` constructor, so you can pick which field is used if some of your data follows unorthodox primary key conventions.\n\nFor example, if you wanted to key off of the `key` field for all of your data, you could configure `dataIdFromObject` like so:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => object.key\n});\n```\n\nThis also allows you to use different unique identifiers for different data types by keying off of the `__typename` property attached to every object typed by GraphQL.  For example:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => {\n    switch (object.__typename) {\n      case 'foo': return object.key; // use `key` as the primary key\n      case 'bar': return object.blah; // use `blah` as the priamry key\n      default: return object.id || object._id; // fall back to `id` and `_id` for all other types\n    }\n  }\n});\n```\n\n<h2 id=\"direct\">Direct Cache Access</h2>\n\nTo interact directly with your cache, you can use the Apollo Client class methods readQuery, readFragment, writeQuery, and writeFragment. These methods are available to us via the [`DataProxy` interface](http://dev.apollodata.com/core/apollo-client-api.html#DataProxy). Accessing these methods will vary slightly based on your view layer implementation. If you are using React, you can wrap your component in the `withApollo` higher order component, which will give you access to `this.props.client`. From there, you can use the methods to control your data.\n\nAny code demonstration in the following sections will assume that we have already initialized an instance of  `ApolloClient` and that we have imported the `gql` tag from `graphql-tag`.\n\n<h3 id=\"readquery\">readQuery</h3>\n\nThe `readQuery` method is very similar to the [`query` method on `ApolloClient`][] except that `readQuery` will _never_ make a request to your GraphQL server. The `query` method, on the other hand, may send a request to your server if the appropriate data is not in your cache whereas `readQuery` will throw an error if the data is not in your cache. `readQuery` will _always_ read from the cache. You can use `readQuery` by giving it a GraphQL query like so:\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo {\n      todo(id: 5) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n});\n```\n\nIf all of the data needed to fulfill this read is in Apollo Client’s normalized data cache then a data object will be returned in the shape of the query you wanted to read. If not all of the data needed to fulfill this read is in Apollo Client’s cache then an error will be thrown instead, so make sure to only read data that you know you have!\n\nYou can also pass variables into `readQuery`.\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo($id: Int!) {\n      todo(id: $id) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n  variables: {\n    id: 5,\n  },\n});\n```\n\n<h3 id=\"readfragment\">readFragment</h3>\n\nThis method allows you great flexibility around the data in your cache. Whereas `readQuery` only allowed you to read data from your root query type, `readFragment` allows you to read data from _any node you have queried_. This is incredibly powerful. You use this method as follows:\n\n```js\nconst todo = client.readFragment({\n  id: ..., // `id` is any id that could be returned by `dataIdFromObject`.\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\nThe first argument is the id of the data you want to read from the cache. That id must be a value that was returned by the `dataIdFromObject` function you defined when initializing `ApolloClient`. So for example if you initialized `ApolloClient` like so:\n\n```js\nconst client = new ApolloClient({\n  ...,\n  dataIdFromObject: object => object.id,\n});\n```\n\n…and you requested a todo before with an id of `5`, then you can read that todo out of your cache with the following:\n\n```js\nconst todo = client.readFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\n> **Note:** Most people add a `__typename` to the id in `dataIdFromObject`. If you do this then don’t forget to add the `__typename` when you are reading a fragment as well. So for example your id may be `Todo_5` and not just `5`.\n\nIf a todo with that id does not exist in the cache you will get `null` back. If a todo of that id does exist in the cache, but that todo does not have the `text` field then an error will be thrown.\n\nThe beauty of `readFragment` is that the todo could have come from anywhere! The todo could have been selected as a singleton (`{ todo(id: 5) { ... } }`), the todo could have come from a list of todos (`{ todos { ... } }`), or the todo could have come from a mutation (`mutation { createTodo { ... } }`). As long as at some point your GraphQL server gave you a todo with the provided id and fields `id`, `text`, and `completed` you can read it from the cache at any part of your code.\n\n<h3 id=\"writequery-and-writefragment\">writeQuery` and `writeFragment</h3>\n\nNot only can you read arbitrary data from the Apollo Client cache, but you can also write any data that you would like to the cache. The methods you use to do this are `writeQuery` and `writeFragment`. They will allow you to change data in your local cache, but it is important to remember that *they will not change any data on your server*. If you reload your environment then changes made with `writeQuery` and `writeFragment` will disappear.\n\nThese methods have the same signature as their `readQuery` and `readFragment` counterparts except they also require an additional `data` variable. So for example, if you wanted to update the `completed` flag locally for your todo with id `'5'` you could execute the following:\n\n```js\nclient.writeFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      completed\n    }\n  `,\n  data: {\n    completed: true,\n  },\n});\n```\n\nAny subscriber to the Apollo Client store will instantly see this update and render new UI accordingly.\n\n> **Note:** Again, remember that using `writeQuery` or `writeFragment` only changes data *locally*. If you reload your environment then changes made with these methods will no longer exist.\n\nOr if you wanted to add a new todo to a list fetched from the server, you could use `readQuery` and `writeQuery` together.\n\n```js\nconst query = gql`\n  query MyTodoAppQuery {\n    todos {\n      id\n      text\n      completed\n    }\n  }\n`;\n\nconst data = client.readQuery({ query });\n\nconst myNewTodo = {\n  id: '6',\n  text: 'Start using Apollo Client.',\n  completed: false,\n};\n\nclient.writeQuery({\n  query,\n  data: {\n    todos: [...data.todos, myNewTodo],\n  },\n});\n```\n\n<h2 id=\"recipes\">Recipes</h2>\n\nHere are some common situations where you would need to access the cache directly. If you're manipulating the cache in an interesting way and would like your example to be featured, please send in a pull request!\n\n<h3 id=\"server\">Server side rendering</h3>\n\nFirst, you will need to initialize an `InMemoryCache` on the server and create an instance of `ApolloClient`. In the initial serialized HTML payload from the server, you should include a script tag that extracts the data from the cache.\n\n```js\n`<script>\n  window.__APOLLO_STATE__=${JSON.stringify(cache.extract())}\n</script>`\n```\n\nOn the client, you can rehydrate the cache using the initial data passed from the server:\n\n```js\ncache: new Cache().restore(window.__APOLLO_STATE__)\n```\n\nIf you would like to learn more about server side rendering, please check our our more in depth guide [here].\n<!---\nTODO (PEGGY): Add link to SSR\n-->\n\n<h3 id=\"server\">Updating the cache after a mutation</h3>\n\nBeing able to read and write to the Apollo cache from anywhere in your application gives you a lot of power over your data. However, there is one place where we most often want to update our cached data: after a mutation. As such, Apollo Client has optimized the experience for updating your cache with the read and write methods after a mutation with the `update` function. Let us say that we have the following GraphQL mutation:\n\n```graphql\nmutation TodoCreateMutation($text: String!) {\n  createTodo(text: $text) {\n    id\n    text\n    completed\n  }\n}\n```\n\nWe may also have the following GraphQL query:\n\n```graphql\nquery TodoAppQuery {\n  todos {\n    id\n    text\n    completed\n  }\n}\n```\n\nAt the end of our mutation we want our query to include the new todo like we had sent our `TodoAppQuery` a second time after the mutation finished without actually sending the query. To do this we can use the `update` function provided as an option of the `client.mutate` method. To update your cache with the mutation just write code that looks like:\n\n```js\n// We assume that the GraphQL operations `TodoCreateMutation` and\n// `TodoAppQuery` have already been defined using the `gql` tag.\n\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    // Read the data from our cache for this query.\n    const data = proxy.readQuery({ query: TodoAppQuery });\n\n    // Add our todo from the mutation to the end.\n    data.todos.push(createTodo);\n\n    // Write our data back to the cache.\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nThe first `proxy` argument is an instance of [`DataProxy`][] has the same four methods that we just learned exist on the Apollo Client: `readQuery`, `readFragment`, `writeQuery`, and `writeFragment`. The reason we call them on a `proxy` object here instead of on our `client` instance is that we can easily apply optimistic updates (which we will demonstrate in a bit). The `proxy` object also provides an isolated transaction which shields you from any other mutations going on at the same time, and the `proxy` object also batches writes together until the very end.\n\nIf you provide an `optimisticResponse` option to the mutation then the `update` function will be run twice. Once immediately after you call `client.mutate` with the data from `optimisticResponse`. After the mutation successfully executes against the server the changes made in the first call to `update` will be rolled back and `update` will be called with the *actual* data returned by the mutation and not just the optimistic response.\n\nPutting it all together:\n\n```js\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  optimisticResponse: {\n    id: -1, // -1 is a temporary id for the optimistic response.\n    text,\n    completed: false,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    const data = proxy.readQuery({ query: TodoAppQuery });\n    data.todos.push(createTodo);\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nAs you can see the `update` function on `client.mutate` provides extra change management functionality specific to the use case of a mutation while still providing you the powerful data control APIs that are available on `client`.\n\nThe `update` function is not a good place for side-effects as it may be called multiple times. Also, you may not call any of the methods on `proxy` asynchronously.\n\n",
      "readmeFilename": "README.md",
      "_id": "apollo-cache-inmemory@1.2.6-alpha.8",
      "_npmVersion": "6.2.0",
      "_nodeVersion": "10.6.0",
      "_npmUser": {
        "name": "mdg",
        "email": "npm@meteor.com"
      },
      "dist": {
        "integrity": "sha512-y6RTOs45KD37R+QxFDecD5ybSq9hgFztV+/2diVBeWSDpkmsYnWacyj/B5gLRKcysz9jfGAj6iROPO0fjYigNQ==",
        "shasum": "f29e777e8b66b1efed09938ee5dd2f9e6c64fdea",
        "tarball": "https://registry.npmjs.org/apollo-cache-inmemory/-/apollo-cache-inmemory-1.2.6-alpha.8.tgz",
        "fileCount": 61,
        "unpackedSize": 428211,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJbWL6bCRA9TVsSAnZWagAAOZMP/R0H3sv7xCEjd7zYcp77\njFeEfnidrBSsAV0JNG4iRoLTOeXY/VFctQOKbVrFGSeTyVQVe4kV9GDgauD0\nP2DY1OZTA32F16G/WhuPRXDHgze5Dw/NdlxKy8u7CJUCMQF/U1MSKDvP5pRW\nZYvQldwZ2hwslTbyYjPiX5bwQuemlGNc6IkO/c9oPR2DoEy8crIL8xX+959n\nZ/D/yaZw4IbmqWKk4k87dFEnxfANvCHjr4JHseq7F/UA2EdQqH3LDJ7SsUdY\nNGk+yvhexhm0ZiAoCq4NErQ0arr1mDXGnbL/D/D/a7AXeA+NdxeiAKq6prQI\nPe7ItMPqLk7sAxSgURoZCfu+hv/hIuTkUbKn06AvViTJ4sKt+6cer2nib5t2\n9g5ZqfxJUF+e9XErNFQdGDIvQDIR90vruY9+yoe9Hb3cnDqJeK46wXDOuLSk\nBk8ZWHPiW5pdUp5vBFzVrpfVKr1Dh7LHs88DDeI5Z33t5gCblH8V40jxc5VN\n9QT/K8SEwSIl2uqBEkWplhnjB257GdEjY6eHBa2tYbOGSsV2u6z0KygTrmWD\nCVokHxB1fCXLDN5OMbMp+/7vfRsrh6F0SYfwsWI0c3CX14Vyc9OwBnWdzNWf\ny71yZV1ktHfxLA30YamCtSObuDJaozFkrhGpK4xAQX7gZFCebLlUQXcEoIP3\n1GSG\r\n=MlHO\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIQCPps6VZEmpcYcgXnrsH9IUhYm6pczH51M5VSiWXogHHAIgYpTTPsr5O/mfDqzrrIfhr4HvgHqF1RfFKMCADavLmcE="
          }
        ]
      },
      "maintainers": [
        {
          "email": "ben@benjamn.com",
          "name": "benjamn"
        },
        {
          "email": "james@meteor.com",
          "name": "jbaxleyiii"
        },
        {
          "email": "npm@meteor.com",
          "name": "mdg"
        },
        {
          "email": "peggyrayzis@gmail.com",
          "name": "peggyrayzis"
        }
      ],
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/apollo-cache-inmemory_1.2.6-alpha.8_1532542619112_0.3247348783657962"
      },
      "_hasShrinkwrap": false
    },
    "1.2.6-alpha.9": {
      "name": "apollo-cache-inmemory",
      "version": "1.2.6-alpha.9",
      "description": "Core abstract of Caching layer for Apollo Client",
      "author": {
        "name": "James Baxley",
        "email": "james@meteor.com"
      },
      "contributors": [
        {
          "name": "James Baxley",
          "email": "james@meteor.com"
        },
        {
          "name": "Jonas Helfer",
          "email": "jonas@helfer.email"
        },
        {
          "name": "Sashko Stubailo",
          "email": "sashko@stubailo.com"
        },
        {
          "name": "James Burgess",
          "email": "jamesmillerburgess@gmail.com"
        },
        {
          "name": "Bazyli Brzóska",
          "email": "bazyli.brzoska@gmail.com"
        }
      ],
      "license": "MIT",
      "main": "./lib/bundle.umd.js",
      "module": "./lib/index.js",
      "jsnext:main": "./lib/index.js",
      "typings": "./lib/index.d.ts",
      "sideEffects": false,
      "repository": {
        "type": "git",
        "url": "git+https://github.com/apollographql/apollo-client.git"
      },
      "bugs": {
        "url": "https://github.com/apollographql/apollo-client/issues"
      },
      "homepage": "https://github.com/apollographql/apollo-client#readme",
      "scripts": {
        "coverage": "jest --coverage",
        "test": "jest",
        "lint": "tslint --type-check -p tsconfig.json src/*.ts",
        "prebuild": "npm run clean",
        "build": "tsc -p .",
        "postbuild": "npm run bundle",
        "bundle": "rollup -c rollup.config.js",
        "watch": "tsc -w -p .",
        "clean": "rimraf coverage/* && rimraf lib/*",
        "prepublishOnly": "npm run build",
        "build:browser": "browserify ./lib/bundle.umd.js --i apollo-cache --i apollo-utilities --i graphql -o=./lib/bundle.js && npm run minify:browser",
        "minify:browser": "uglifyjs -c -m -o ./lib/bundle.min.js -- ./lib/bundle.js",
        "filesize": "npm run build:browser"
      },
      "dependencies": {
        "apollo-cache": "^1.1.13-alpha.9",
        "apollo-utilities": "^1.0.17-alpha.9",
        "graphql-anywhere": "^4.1.15-alpha.9"
      },
      "peerDependencies": {
        "graphql": "0.11.7 || ^0.12.0 || ^0.13.0"
      },
      "devDependencies": {
        "@types/graphql": "0.12.7",
        "@types/jest": "22.2.3",
        "@types/lodash": "4.14.112",
        "browserify": "15.2.0",
        "graphql": "0.13.2",
        "graphql-tag": "2.9.2",
        "jest": "23.0.0",
        "lodash": "4.17.10",
        "rimraf": "2.6.2",
        "rollup": "0.62.0",
        "ts-jest": "20.0.14",
        "tslint": "5.11.0",
        "typescript": "2.9.2",
        "uglifyjs": "2.4.11"
      },
      "jest": {
        "transform": {
          ".(ts|tsx)": "<rootDir>/node_modules/ts-jest/preprocessor.js"
        },
        "testRegex": "(/__tests__/.*|\\.(test|spec))\\.(ts|tsx|js)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "json"
        ]
      },
      "readme": "---\ntitle: InMemoryCache\ndescription: An explanation of `apollo-cache-inmemory`\n---\n\n`apollo-cache-inmemory` is the recommended cache implementation for Apollo Client 2.0. `InMemoryCache` is a normalized data store that supports all of Apollo Client 1.0's features without the dependency on Redux.\n\nIn some instances, you may need to manipulate the cache directly, such as updating the store after a mutation. We'll cover some common use cases [here](#recipes).\n\n<h2 id=\"installation\">Installation</h2>\n\n```\nnpm install apollo-cache-inmemory --save\n```\n\nAfter installing the package, you'll want to initialize the cache constructor. Then, you can pass in your newly created cache to ApolloClient.\n\n```js\nimport { InMemoryCache } from 'apollo-cache-inmemory';\nimport { HttpLink } from 'apollo-link-http';\nimport ApolloClient from 'apollo-client';\n\nconst cache = new InMemoryCache();\n\nconst client = new ApolloClient({\n  link: new HttpLink(),\n  cache\n});\n```\n\n<h2 id=\"configuration\">Configuration</h2>\n\nThe `InMemoryCache` constructor takes an optional config object with properties to customize your cache:\n\n- addTypename: A boolean to determine whether to add __typename to the document (default: `true`)\n- dataIdFromObject: A function that takes a data object and returns a unique identifier to be used when normalizing the data in the store. Learn more about how to customize `dataIdFromObject` in the [Normalization](#normalization) section.\n- fragmentMatcher: By default, the `InMemoryCache` uses a heuristic fragment matcher. If you are using fragments on unions and interfaces, you will need to use an `IntrospectionFragmentMatcher`. For more information, please read [our guide to setting up fragment matching for unions & interfaces](https://www.apollographql.com/docs/react/advanced/fragments.html#fragment-matcher).\n\n<h2 id=\"normalization\">Normalization</h2>\n\nThe `InMemoryCache` normalizes your data before saving it to the store by splitting the result into individual objects, creating a unique identifier for each object, and storing those objects in a flattened data structure. By default, `InMemoryCache` will attempt to use the commonly found primary keys of `id` and `_id` for the unique identifier if they exist along with `__typename` on an object.\n\nIf `id` and `_id` are not specified, or if `__typename` is not specified, `InMemoryCache` will fall back to the path to the object in the query, such as `ROOT_QUERY.allPeople.0` for the first record returned on the `allPeople` root query.\n\nThis \"getter\" behavior for unique identifiers can be configured manually via the `dataIdFromObject` option passed to the `InMemoryCache` constructor, so you can pick which field is used if some of your data follows unorthodox primary key conventions.\n\nFor example, if you wanted to key off of the `key` field for all of your data, you could configure `dataIdFromObject` like so:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => object.key\n});\n```\n\nThis also allows you to use different unique identifiers for different data types by keying off of the `__typename` property attached to every object typed by GraphQL.  For example:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => {\n    switch (object.__typename) {\n      case 'foo': return object.key; // use `key` as the primary key\n      case 'bar': return object.blah; // use `blah` as the priamry key\n      default: return object.id || object._id; // fall back to `id` and `_id` for all other types\n    }\n  }\n});\n```\n\n<h2 id=\"direct\">Direct Cache Access</h2>\n\nTo interact directly with your cache, you can use the Apollo Client class methods readQuery, readFragment, writeQuery, and writeFragment. These methods are available to us via the [`DataProxy` interface](http://dev.apollodata.com/core/apollo-client-api.html#DataProxy). Accessing these methods will vary slightly based on your view layer implementation. If you are using React, you can wrap your component in the `withApollo` higher order component, which will give you access to `this.props.client`. From there, you can use the methods to control your data.\n\nAny code demonstration in the following sections will assume that we have already initialized an instance of  `ApolloClient` and that we have imported the `gql` tag from `graphql-tag`.\n\n<h3 id=\"readquery\">readQuery</h3>\n\nThe `readQuery` method is very similar to the [`query` method on `ApolloClient`][] except that `readQuery` will _never_ make a request to your GraphQL server. The `query` method, on the other hand, may send a request to your server if the appropriate data is not in your cache whereas `readQuery` will throw an error if the data is not in your cache. `readQuery` will _always_ read from the cache. You can use `readQuery` by giving it a GraphQL query like so:\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo {\n      todo(id: 5) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n});\n```\n\nIf all of the data needed to fulfill this read is in Apollo Client’s normalized data cache then a data object will be returned in the shape of the query you wanted to read. If not all of the data needed to fulfill this read is in Apollo Client’s cache then an error will be thrown instead, so make sure to only read data that you know you have!\n\nYou can also pass variables into `readQuery`.\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo($id: Int!) {\n      todo(id: $id) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n  variables: {\n    id: 5,\n  },\n});\n```\n\n<h3 id=\"readfragment\">readFragment</h3>\n\nThis method allows you great flexibility around the data in your cache. Whereas `readQuery` only allowed you to read data from your root query type, `readFragment` allows you to read data from _any node you have queried_. This is incredibly powerful. You use this method as follows:\n\n```js\nconst todo = client.readFragment({\n  id: ..., // `id` is any id that could be returned by `dataIdFromObject`.\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\nThe first argument is the id of the data you want to read from the cache. That id must be a value that was returned by the `dataIdFromObject` function you defined when initializing `ApolloClient`. So for example if you initialized `ApolloClient` like so:\n\n```js\nconst client = new ApolloClient({\n  ...,\n  dataIdFromObject: object => object.id,\n});\n```\n\n…and you requested a todo before with an id of `5`, then you can read that todo out of your cache with the following:\n\n```js\nconst todo = client.readFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\n> **Note:** Most people add a `__typename` to the id in `dataIdFromObject`. If you do this then don’t forget to add the `__typename` when you are reading a fragment as well. So for example your id may be `Todo_5` and not just `5`.\n\nIf a todo with that id does not exist in the cache you will get `null` back. If a todo of that id does exist in the cache, but that todo does not have the `text` field then an error will be thrown.\n\nThe beauty of `readFragment` is that the todo could have come from anywhere! The todo could have been selected as a singleton (`{ todo(id: 5) { ... } }`), the todo could have come from a list of todos (`{ todos { ... } }`), or the todo could have come from a mutation (`mutation { createTodo { ... } }`). As long as at some point your GraphQL server gave you a todo with the provided id and fields `id`, `text`, and `completed` you can read it from the cache at any part of your code.\n\n<h3 id=\"writequery-and-writefragment\">writeQuery` and `writeFragment</h3>\n\nNot only can you read arbitrary data from the Apollo Client cache, but you can also write any data that you would like to the cache. The methods you use to do this are `writeQuery` and `writeFragment`. They will allow you to change data in your local cache, but it is important to remember that *they will not change any data on your server*. If you reload your environment then changes made with `writeQuery` and `writeFragment` will disappear.\n\nThese methods have the same signature as their `readQuery` and `readFragment` counterparts except they also require an additional `data` variable. So for example, if you wanted to update the `completed` flag locally for your todo with id `'5'` you could execute the following:\n\n```js\nclient.writeFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      completed\n    }\n  `,\n  data: {\n    completed: true,\n  },\n});\n```\n\nAny subscriber to the Apollo Client store will instantly see this update and render new UI accordingly.\n\n> **Note:** Again, remember that using `writeQuery` or `writeFragment` only changes data *locally*. If you reload your environment then changes made with these methods will no longer exist.\n\nOr if you wanted to add a new todo to a list fetched from the server, you could use `readQuery` and `writeQuery` together.\n\n```js\nconst query = gql`\n  query MyTodoAppQuery {\n    todos {\n      id\n      text\n      completed\n    }\n  }\n`;\n\nconst data = client.readQuery({ query });\n\nconst myNewTodo = {\n  id: '6',\n  text: 'Start using Apollo Client.',\n  completed: false,\n};\n\nclient.writeQuery({\n  query,\n  data: {\n    todos: [...data.todos, myNewTodo],\n  },\n});\n```\n\n<h2 id=\"recipes\">Recipes</h2>\n\nHere are some common situations where you would need to access the cache directly. If you're manipulating the cache in an interesting way and would like your example to be featured, please send in a pull request!\n\n<h3 id=\"server\">Server side rendering</h3>\n\nFirst, you will need to initialize an `InMemoryCache` on the server and create an instance of `ApolloClient`. In the initial serialized HTML payload from the server, you should include a script tag that extracts the data from the cache.\n\n```js\n`<script>\n  window.__APOLLO_STATE__=${JSON.stringify(cache.extract())}\n</script>`\n```\n\nOn the client, you can rehydrate the cache using the initial data passed from the server:\n\n```js\ncache: new Cache().restore(window.__APOLLO_STATE__)\n```\n\nIf you would like to learn more about server side rendering, please check our our more in depth guide [here].\n<!---\nTODO (PEGGY): Add link to SSR\n-->\n\n<h3 id=\"server\">Updating the cache after a mutation</h3>\n\nBeing able to read and write to the Apollo cache from anywhere in your application gives you a lot of power over your data. However, there is one place where we most often want to update our cached data: after a mutation. As such, Apollo Client has optimized the experience for updating your cache with the read and write methods after a mutation with the `update` function. Let us say that we have the following GraphQL mutation:\n\n```graphql\nmutation TodoCreateMutation($text: String!) {\n  createTodo(text: $text) {\n    id\n    text\n    completed\n  }\n}\n```\n\nWe may also have the following GraphQL query:\n\n```graphql\nquery TodoAppQuery {\n  todos {\n    id\n    text\n    completed\n  }\n}\n```\n\nAt the end of our mutation we want our query to include the new todo like we had sent our `TodoAppQuery` a second time after the mutation finished without actually sending the query. To do this we can use the `update` function provided as an option of the `client.mutate` method. To update your cache with the mutation just write code that looks like:\n\n```js\n// We assume that the GraphQL operations `TodoCreateMutation` and\n// `TodoAppQuery` have already been defined using the `gql` tag.\n\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    // Read the data from our cache for this query.\n    const data = proxy.readQuery({ query: TodoAppQuery });\n\n    // Add our todo from the mutation to the end.\n    data.todos.push(createTodo);\n\n    // Write our data back to the cache.\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nThe first `proxy` argument is an instance of [`DataProxy`][] has the same four methods that we just learned exist on the Apollo Client: `readQuery`, `readFragment`, `writeQuery`, and `writeFragment`. The reason we call them on a `proxy` object here instead of on our `client` instance is that we can easily apply optimistic updates (which we will demonstrate in a bit). The `proxy` object also provides an isolated transaction which shields you from any other mutations going on at the same time, and the `proxy` object also batches writes together until the very end.\n\nIf you provide an `optimisticResponse` option to the mutation then the `update` function will be run twice. Once immediately after you call `client.mutate` with the data from `optimisticResponse`. After the mutation successfully executes against the server the changes made in the first call to `update` will be rolled back and `update` will be called with the *actual* data returned by the mutation and not just the optimistic response.\n\nPutting it all together:\n\n```js\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  optimisticResponse: {\n    id: -1, // -1 is a temporary id for the optimistic response.\n    text,\n    completed: false,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    const data = proxy.readQuery({ query: TodoAppQuery });\n    data.todos.push(createTodo);\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nAs you can see the `update` function on `client.mutate` provides extra change management functionality specific to the use case of a mutation while still providing you the powerful data control APIs that are available on `client`.\n\nThe `update` function is not a good place for side-effects as it may be called multiple times. Also, you may not call any of the methods on `proxy` asynchronously.\n\n",
      "readmeFilename": "README.md",
      "_id": "apollo-cache-inmemory@1.2.6-alpha.9",
      "_npmVersion": "6.2.0",
      "_nodeVersion": "10.6.0",
      "_npmUser": {
        "name": "mdg",
        "email": "npm@meteor.com"
      },
      "dist": {
        "integrity": "sha512-zBT8WVfc/lb8SiiKUmL5QIrap6x73ga2ofV5EYl3Zm2bVHUW/DNtLc76hk9KgnDNSPWwoWFqvLCl5cdUCyAbFw==",
        "shasum": "f65064c106b5ba05ad01aa84b55472e15041e35e",
        "tarball": "https://registry.npmjs.org/apollo-cache-inmemory/-/apollo-cache-inmemory-1.2.6-alpha.9.tgz",
        "fileCount": 61,
        "unpackedSize": 428211,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJbWMZtCRA9TVsSAnZWagAAoUkP/0Q0hzC4H21W3f0pgFUI\n7bP6p2rP+LMcm6cRlCtsFi3hzZ0ALvChqlZmP4/fLmi+9MfFb8LVWZTuFc6s\nt+ui8PuGq6OQTqf7AaUr57Wd5suJPqzF9uYtkeQ15CzguXpqj+bzMQ6gbcq4\n8ZB81D3ZzZdEZlRF0xTWoT5h8+Kjylsy08H5DXH+9BFLab8DEuQn04IlOt2l\nyn0x3u2jSqUmTTIuG7wP3zuVAl6l7beMzjpfiJPa7mTxWnWf+EDP5WZsg0SS\nKiQ/NLW92uM4528B/pUX+KwIavH9ewijsYf7dQXKpbFpm138KeZoJrGZi2su\n2pU0QRnv/bftsLmAW1j//PWP7Dw0Dpo1i6yNIPm3mSljjJIY22zuXJ8fTOPL\nhoXVhgQ2bE4XESLZryGXgZ4otd5pbKDsnhu0dGS4y96R3xyHXta4HNqsAZM4\nTLjTzC6xFZYoeXJGsO2amE7bPlLDofIEI222nMKy4kk/XjwJarimx5/+xAoA\nhcO/EK3JjKERGu/qOBtm5YQ/R51LPG3DtCK1tH8rST+jHxqcM/ULnpQse4cj\nS5OBosswOMXQgIFeWbaSLv438eKPMvKGTI6VGmzKPCQ7vzOLIGUAhOG7PG3D\nu+3MXCgC/ucavSq++gdrsHrJkZ5q/tDFsj3GqnZyLvR516I1OFzXr79wWCE6\ngOUn\r\n=xBsa\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEYCIQD+lsPKJhv+Lgo84C5xt10rchdScwqXJDLHBaTb3PHypgIhAPRKUVOFYAqLYQItAtXAmuev3AvovKw6IEFrkj4dpVz/"
          }
        ]
      },
      "maintainers": [
        {
          "email": "ben@benjamn.com",
          "name": "benjamn"
        },
        {
          "email": "james@meteor.com",
          "name": "jbaxleyiii"
        },
        {
          "email": "npm@meteor.com",
          "name": "mdg"
        },
        {
          "email": "peggyrayzis@gmail.com",
          "name": "peggyrayzis"
        }
      ],
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/apollo-cache-inmemory_1.2.6-alpha.9_1532544621717_0.4113208527935732"
      },
      "_hasShrinkwrap": false
    },
    "1.2.6-alpha.10": {
      "name": "apollo-cache-inmemory",
      "version": "1.2.6-alpha.10",
      "description": "Core abstract of Caching layer for Apollo Client",
      "author": {
        "name": "James Baxley",
        "email": "james@meteor.com"
      },
      "contributors": [
        {
          "name": "James Baxley",
          "email": "james@meteor.com"
        },
        {
          "name": "Jonas Helfer",
          "email": "jonas@helfer.email"
        },
        {
          "name": "Sashko Stubailo",
          "email": "sashko@stubailo.com"
        },
        {
          "name": "James Burgess",
          "email": "jamesmillerburgess@gmail.com"
        },
        {
          "name": "Bazyli Brzóska",
          "email": "bazyli.brzoska@gmail.com"
        }
      ],
      "license": "MIT",
      "main": "./lib/bundle.umd.js",
      "module": "./lib/index.js",
      "jsnext:main": "./lib/index.js",
      "typings": "./lib/index.d.ts",
      "sideEffects": false,
      "repository": {
        "type": "git",
        "url": "git+https://github.com/apollographql/apollo-client.git"
      },
      "bugs": {
        "url": "https://github.com/apollographql/apollo-client/issues"
      },
      "homepage": "https://github.com/apollographql/apollo-client#readme",
      "scripts": {
        "coverage": "jest --coverage",
        "test": "jest",
        "lint": "tslint --type-check -p tsconfig.json src/*.ts",
        "prebuild": "npm run clean",
        "build": "tsc -p .",
        "postbuild": "npm run bundle",
        "bundle": "rollup -c rollup.config.js",
        "watch": "tsc -w -p .",
        "clean": "rimraf coverage/* && rimraf lib/*",
        "prepublishOnly": "npm run build",
        "build:browser": "browserify ./lib/bundle.umd.js --i apollo-cache --i apollo-utilities --i graphql -o=./lib/bundle.js && npm run minify:browser",
        "minify:browser": "uglifyjs -c -m -o ./lib/bundle.min.js -- ./lib/bundle.js",
        "filesize": "npm run build:browser"
      },
      "dependencies": {
        "apollo-cache": "1.1.13-alpha.10",
        "apollo-utilities": "1.0.17-alpha.10",
        "graphql-anywhere": "4.1.15-alpha.10"
      },
      "peerDependencies": {
        "graphql": "0.11.7 || ^0.12.0 || ^0.13.0"
      },
      "devDependencies": {
        "@types/graphql": "0.12.7",
        "@types/jest": "22.2.3",
        "@types/lodash": "4.14.112",
        "browserify": "15.2.0",
        "graphql": "0.13.2",
        "graphql-tag": "2.9.2",
        "jest": "23.0.0",
        "lodash": "4.17.10",
        "rimraf": "2.6.2",
        "rollup": "0.62.0",
        "ts-jest": "20.0.14",
        "tslint": "5.11.0",
        "typescript": "2.9.2",
        "uglifyjs": "2.4.11"
      },
      "jest": {
        "transform": {
          ".(ts|tsx)": "<rootDir>/node_modules/ts-jest/preprocessor.js"
        },
        "testRegex": "(/__tests__/.*|\\.(test|spec))\\.(ts|tsx|js)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "json"
        ]
      },
      "readme": "---\ntitle: InMemoryCache\ndescription: An explanation of `apollo-cache-inmemory`\n---\n\n`apollo-cache-inmemory` is the recommended cache implementation for Apollo Client 2.0. `InMemoryCache` is a normalized data store that supports all of Apollo Client 1.0's features without the dependency on Redux.\n\nIn some instances, you may need to manipulate the cache directly, such as updating the store after a mutation. We'll cover some common use cases [here](#recipes).\n\n<h2 id=\"installation\">Installation</h2>\n\n```\nnpm install apollo-cache-inmemory --save\n```\n\nAfter installing the package, you'll want to initialize the cache constructor. Then, you can pass in your newly created cache to ApolloClient.\n\n```js\nimport { InMemoryCache } from 'apollo-cache-inmemory';\nimport { HttpLink } from 'apollo-link-http';\nimport ApolloClient from 'apollo-client';\n\nconst cache = new InMemoryCache();\n\nconst client = new ApolloClient({\n  link: new HttpLink(),\n  cache\n});\n```\n\n<h2 id=\"configuration\">Configuration</h2>\n\nThe `InMemoryCache` constructor takes an optional config object with properties to customize your cache:\n\n- addTypename: A boolean to determine whether to add __typename to the document (default: `true`)\n- dataIdFromObject: A function that takes a data object and returns a unique identifier to be used when normalizing the data in the store. Learn more about how to customize `dataIdFromObject` in the [Normalization](#normalization) section.\n- fragmentMatcher: By default, the `InMemoryCache` uses a heuristic fragment matcher. If you are using fragments on unions and interfaces, you will need to use an `IntrospectionFragmentMatcher`. For more information, please read [our guide to setting up fragment matching for unions & interfaces](https://www.apollographql.com/docs/react/advanced/fragments.html#fragment-matcher).\n\n<h2 id=\"normalization\">Normalization</h2>\n\nThe `InMemoryCache` normalizes your data before saving it to the store by splitting the result into individual objects, creating a unique identifier for each object, and storing those objects in a flattened data structure. By default, `InMemoryCache` will attempt to use the commonly found primary keys of `id` and `_id` for the unique identifier if they exist along with `__typename` on an object.\n\nIf `id` and `_id` are not specified, or if `__typename` is not specified, `InMemoryCache` will fall back to the path to the object in the query, such as `ROOT_QUERY.allPeople.0` for the first record returned on the `allPeople` root query.\n\nThis \"getter\" behavior for unique identifiers can be configured manually via the `dataIdFromObject` option passed to the `InMemoryCache` constructor, so you can pick which field is used if some of your data follows unorthodox primary key conventions.\n\nFor example, if you wanted to key off of the `key` field for all of your data, you could configure `dataIdFromObject` like so:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => object.key\n});\n```\n\nThis also allows you to use different unique identifiers for different data types by keying off of the `__typename` property attached to every object typed by GraphQL.  For example:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => {\n    switch (object.__typename) {\n      case 'foo': return object.key; // use `key` as the primary key\n      case 'bar': return object.blah; // use `blah` as the priamry key\n      default: return object.id || object._id; // fall back to `id` and `_id` for all other types\n    }\n  }\n});\n```\n\n<h2 id=\"direct\">Direct Cache Access</h2>\n\nTo interact directly with your cache, you can use the Apollo Client class methods readQuery, readFragment, writeQuery, and writeFragment. These methods are available to us via the [`DataProxy` interface](http://dev.apollodata.com/core/apollo-client-api.html#DataProxy). Accessing these methods will vary slightly based on your view layer implementation. If you are using React, you can wrap your component in the `withApollo` higher order component, which will give you access to `this.props.client`. From there, you can use the methods to control your data.\n\nAny code demonstration in the following sections will assume that we have already initialized an instance of  `ApolloClient` and that we have imported the `gql` tag from `graphql-tag`.\n\n<h3 id=\"readquery\">readQuery</h3>\n\nThe `readQuery` method is very similar to the [`query` method on `ApolloClient`][] except that `readQuery` will _never_ make a request to your GraphQL server. The `query` method, on the other hand, may send a request to your server if the appropriate data is not in your cache whereas `readQuery` will throw an error if the data is not in your cache. `readQuery` will _always_ read from the cache. You can use `readQuery` by giving it a GraphQL query like so:\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo {\n      todo(id: 5) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n});\n```\n\nIf all of the data needed to fulfill this read is in Apollo Client’s normalized data cache then a data object will be returned in the shape of the query you wanted to read. If not all of the data needed to fulfill this read is in Apollo Client’s cache then an error will be thrown instead, so make sure to only read data that you know you have!\n\nYou can also pass variables into `readQuery`.\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo($id: Int!) {\n      todo(id: $id) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n  variables: {\n    id: 5,\n  },\n});\n```\n\n<h3 id=\"readfragment\">readFragment</h3>\n\nThis method allows you great flexibility around the data in your cache. Whereas `readQuery` only allowed you to read data from your root query type, `readFragment` allows you to read data from _any node you have queried_. This is incredibly powerful. You use this method as follows:\n\n```js\nconst todo = client.readFragment({\n  id: ..., // `id` is any id that could be returned by `dataIdFromObject`.\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\nThe first argument is the id of the data you want to read from the cache. That id must be a value that was returned by the `dataIdFromObject` function you defined when initializing `ApolloClient`. So for example if you initialized `ApolloClient` like so:\n\n```js\nconst client = new ApolloClient({\n  ...,\n  dataIdFromObject: object => object.id,\n});\n```\n\n…and you requested a todo before with an id of `5`, then you can read that todo out of your cache with the following:\n\n```js\nconst todo = client.readFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\n> **Note:** Most people add a `__typename` to the id in `dataIdFromObject`. If you do this then don’t forget to add the `__typename` when you are reading a fragment as well. So for example your id may be `Todo_5` and not just `5`.\n\nIf a todo with that id does not exist in the cache you will get `null` back. If a todo of that id does exist in the cache, but that todo does not have the `text` field then an error will be thrown.\n\nThe beauty of `readFragment` is that the todo could have come from anywhere! The todo could have been selected as a singleton (`{ todo(id: 5) { ... } }`), the todo could have come from a list of todos (`{ todos { ... } }`), or the todo could have come from a mutation (`mutation { createTodo { ... } }`). As long as at some point your GraphQL server gave you a todo with the provided id and fields `id`, `text`, and `completed` you can read it from the cache at any part of your code.\n\n<h3 id=\"writequery-and-writefragment\">writeQuery` and `writeFragment</h3>\n\nNot only can you read arbitrary data from the Apollo Client cache, but you can also write any data that you would like to the cache. The methods you use to do this are `writeQuery` and `writeFragment`. They will allow you to change data in your local cache, but it is important to remember that *they will not change any data on your server*. If you reload your environment then changes made with `writeQuery` and `writeFragment` will disappear.\n\nThese methods have the same signature as their `readQuery` and `readFragment` counterparts except they also require an additional `data` variable. So for example, if you wanted to update the `completed` flag locally for your todo with id `'5'` you could execute the following:\n\n```js\nclient.writeFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      completed\n    }\n  `,\n  data: {\n    completed: true,\n  },\n});\n```\n\nAny subscriber to the Apollo Client store will instantly see this update and render new UI accordingly.\n\n> **Note:** Again, remember that using `writeQuery` or `writeFragment` only changes data *locally*. If you reload your environment then changes made with these methods will no longer exist.\n\nOr if you wanted to add a new todo to a list fetched from the server, you could use `readQuery` and `writeQuery` together.\n\n```js\nconst query = gql`\n  query MyTodoAppQuery {\n    todos {\n      id\n      text\n      completed\n    }\n  }\n`;\n\nconst data = client.readQuery({ query });\n\nconst myNewTodo = {\n  id: '6',\n  text: 'Start using Apollo Client.',\n  completed: false,\n};\n\nclient.writeQuery({\n  query,\n  data: {\n    todos: [...data.todos, myNewTodo],\n  },\n});\n```\n\n<h2 id=\"recipes\">Recipes</h2>\n\nHere are some common situations where you would need to access the cache directly. If you're manipulating the cache in an interesting way and would like your example to be featured, please send in a pull request!\n\n<h3 id=\"server\">Server side rendering</h3>\n\nFirst, you will need to initialize an `InMemoryCache` on the server and create an instance of `ApolloClient`. In the initial serialized HTML payload from the server, you should include a script tag that extracts the data from the cache.\n\n```js\n`<script>\n  window.__APOLLO_STATE__=${JSON.stringify(cache.extract())}\n</script>`\n```\n\nOn the client, you can rehydrate the cache using the initial data passed from the server:\n\n```js\ncache: new Cache().restore(window.__APOLLO_STATE__)\n```\n\nIf you would like to learn more about server side rendering, please check our our more in depth guide [here].\n<!---\nTODO (PEGGY): Add link to SSR\n-->\n\n<h3 id=\"server\">Updating the cache after a mutation</h3>\n\nBeing able to read and write to the Apollo cache from anywhere in your application gives you a lot of power over your data. However, there is one place where we most often want to update our cached data: after a mutation. As such, Apollo Client has optimized the experience for updating your cache with the read and write methods after a mutation with the `update` function. Let us say that we have the following GraphQL mutation:\n\n```graphql\nmutation TodoCreateMutation($text: String!) {\n  createTodo(text: $text) {\n    id\n    text\n    completed\n  }\n}\n```\n\nWe may also have the following GraphQL query:\n\n```graphql\nquery TodoAppQuery {\n  todos {\n    id\n    text\n    completed\n  }\n}\n```\n\nAt the end of our mutation we want our query to include the new todo like we had sent our `TodoAppQuery` a second time after the mutation finished without actually sending the query. To do this we can use the `update` function provided as an option of the `client.mutate` method. To update your cache with the mutation just write code that looks like:\n\n```js\n// We assume that the GraphQL operations `TodoCreateMutation` and\n// `TodoAppQuery` have already been defined using the `gql` tag.\n\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    // Read the data from our cache for this query.\n    const data = proxy.readQuery({ query: TodoAppQuery });\n\n    // Add our todo from the mutation to the end.\n    data.todos.push(createTodo);\n\n    // Write our data back to the cache.\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nThe first `proxy` argument is an instance of [`DataProxy`][] has the same four methods that we just learned exist on the Apollo Client: `readQuery`, `readFragment`, `writeQuery`, and `writeFragment`. The reason we call them on a `proxy` object here instead of on our `client` instance is that we can easily apply optimistic updates (which we will demonstrate in a bit). The `proxy` object also provides an isolated transaction which shields you from any other mutations going on at the same time, and the `proxy` object also batches writes together until the very end.\n\nIf you provide an `optimisticResponse` option to the mutation then the `update` function will be run twice. Once immediately after you call `client.mutate` with the data from `optimisticResponse`. After the mutation successfully executes against the server the changes made in the first call to `update` will be rolled back and `update` will be called with the *actual* data returned by the mutation and not just the optimistic response.\n\nPutting it all together:\n\n```js\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  optimisticResponse: {\n    id: -1, // -1 is a temporary id for the optimistic response.\n    text,\n    completed: false,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    const data = proxy.readQuery({ query: TodoAppQuery });\n    data.todos.push(createTodo);\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nAs you can see the `update` function on `client.mutate` provides extra change management functionality specific to the use case of a mutation while still providing you the powerful data control APIs that are available on `client`.\n\nThe `update` function is not a good place for side-effects as it may be called multiple times. Also, you may not call any of the methods on `proxy` asynchronously.\n\n",
      "readmeFilename": "README.md",
      "_id": "apollo-cache-inmemory@1.2.6-alpha.10",
      "_npmVersion": "6.2.0",
      "_nodeVersion": "10.6.0",
      "_npmUser": {
        "name": "mdg",
        "email": "npm@meteor.com"
      },
      "dist": {
        "integrity": "sha512-LkZO+zXgV6vPejPQ1eHAC08XZz61kimpUgcg4xPOwiyPumbfCa/BPVZG6iy1D/NAmiCOP6Iu3UK8LcpT0kZzNw==",
        "shasum": "f35c8c6579c1d39075caffc578db623f700f3675",
        "tarball": "https://registry.npmjs.org/apollo-cache-inmemory/-/apollo-cache-inmemory-1.2.6-alpha.10.tgz",
        "fileCount": 61,
        "unpackedSize": 428212,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJbWMqbCRA9TVsSAnZWagAAOtoP/2W4KeP83710YbhkBZu8\nYdCEhGYG2IvIo0tb3U4BOZskPlWo9Cv7WKfQgzkkjGJjB7pJUgga9fNu0DrD\nNfMOkS1f9wLtPkqXfoWEpTu/lgfWAR0fbtTcQTP/S1s3pbONe5m0J0Wr7QLc\nThosoCPQWdnR3sTfTVncVAgUzhZXr6MTWggkj1IY7hCYlr1ZjJAFFBz+cT5P\nJgA/5V2LcdjPrlKK0PC8bqIqfwCjU9ty6SFjo0rrResi5fQsV3gQdzeYTZwy\n/wXAVrYdqKp8/FNMuozauwpfbyP+3cYLfhTum3mP0BfKAu0V/IWPp2VYpOt1\nWiwmmqJygH+lvntiI6wOhnSideNxXqzhXmtaj2YJW+awoTfkubpMSmxSTThe\noIE+AczAdkvg3jONGAx6AEFqFs9u/iGg+HqL9Y0h7nvsYLitnkk0Qzf7iG0C\nFWDxEC4iAiI/BP6XMQhFp+m/lNEv01QKvMhUPwDDu+1qwSwPepl8T/AsK7KK\nEDoxam4eVxMblCkYx3R/188Dj5bFV+GAprA8lt5FYQsFmZwlwLun3++0pWVw\ngWJ3VCQjEZzv5Dg+1T+zMXkdVr1RDNMh1HLqPqhIiYEZ1VQBUZj4RsXS3xpV\nLvKkDF5dSGj8ZBl9OIJ/yjFJOUgezSnEyl8GXUalkOKECFCjIPHI7aOeS/Tv\nc5jp\r\n=7KEK\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIQD83S+BS4N2mTHfcev9ig6N1xYCR+ybnMv1d2iV9rrQZgIgD7Oto7jMsVhJ6dDIDz32xP/+n66Zbm2PPo/hAs3Pvvw="
          }
        ]
      },
      "maintainers": [
        {
          "email": "ben@benjamn.com",
          "name": "benjamn"
        },
        {
          "email": "james@meteor.com",
          "name": "jbaxleyiii"
        },
        {
          "email": "npm@meteor.com",
          "name": "mdg"
        },
        {
          "email": "peggyrayzis@gmail.com",
          "name": "peggyrayzis"
        }
      ],
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/apollo-cache-inmemory_1.2.6-alpha.10_1532545691780_0.665012173700557"
      },
      "_hasShrinkwrap": false
    },
    "1.2.6-alpha.12": {
      "name": "apollo-cache-inmemory",
      "version": "1.2.6-alpha.12",
      "description": "Core abstract of Caching layer for Apollo Client",
      "author": {
        "name": "James Baxley",
        "email": "james@meteor.com"
      },
      "contributors": [
        {
          "name": "James Baxley",
          "email": "james@meteor.com"
        },
        {
          "name": "Jonas Helfer",
          "email": "jonas@helfer.email"
        },
        {
          "name": "Sashko Stubailo",
          "email": "sashko@stubailo.com"
        },
        {
          "name": "James Burgess",
          "email": "jamesmillerburgess@gmail.com"
        },
        {
          "name": "Bazyli Brzóska",
          "email": "bazyli.brzoska@gmail.com"
        }
      ],
      "license": "MIT",
      "main": "./lib/bundle.umd.js",
      "module": "./lib/index.js",
      "jsnext:main": "./lib/index.js",
      "typings": "./lib/index.d.ts",
      "sideEffects": false,
      "repository": {
        "type": "git",
        "url": "git+https://github.com/apollographql/apollo-client.git"
      },
      "bugs": {
        "url": "https://github.com/apollographql/apollo-client/issues"
      },
      "homepage": "https://github.com/apollographql/apollo-client#readme",
      "scripts": {
        "coverage": "jest --coverage",
        "test": "jest",
        "lint": "tslint --type-check -p tsconfig.json src/*.ts",
        "prebuild": "npm run clean",
        "build": "tsc -p .",
        "postbuild": "npm run bundle",
        "bundle": "rollup -c rollup.config.js",
        "watch": "tsc -w -p .",
        "clean": "rimraf coverage/* && rimraf lib/*",
        "prepublishOnly": "npm run build",
        "build:browser": "browserify ./lib/bundle.umd.js --i apollo-cache --i apollo-utilities --i graphql -o=./lib/bundle.js && npm run minify:browser",
        "minify:browser": "uglifyjs -c -m -o ./lib/bundle.min.js -- ./lib/bundle.js",
        "filesize": "npm run build:browser"
      },
      "dependencies": {
        "apollo-cache": "1.1.13-alpha.12",
        "apollo-utilities": "1.0.17-alpha.12",
        "graphql-anywhere": "4.1.15-alpha.12"
      },
      "peerDependencies": {
        "graphql": "0.11.7 || ^0.12.0 || ^0.13.0"
      },
      "devDependencies": {
        "@types/graphql": "0.12.7",
        "@types/jest": "22.2.3",
        "@types/lodash": "4.14.112",
        "browserify": "15.2.0",
        "graphql": "0.13.2",
        "graphql-tag": "2.9.2",
        "jest": "23.0.0",
        "lodash": "4.17.10",
        "rimraf": "2.6.2",
        "rollup": "0.62.0",
        "ts-jest": "20.0.14",
        "tslint": "5.11.0",
        "typescript": "2.9.2",
        "uglifyjs": "2.4.11"
      },
      "jest": {
        "transform": {
          ".(ts|tsx)": "<rootDir>/node_modules/ts-jest/preprocessor.js"
        },
        "testRegex": "(/__tests__/.*|\\.(test|spec))\\.(ts|tsx|js)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "json"
        ]
      },
      "readme": "---\ntitle: InMemoryCache\ndescription: An explanation of `apollo-cache-inmemory`\n---\n\n`apollo-cache-inmemory` is the recommended cache implementation for Apollo Client 2.0. `InMemoryCache` is a normalized data store that supports all of Apollo Client 1.0's features without the dependency on Redux.\n\nIn some instances, you may need to manipulate the cache directly, such as updating the store after a mutation. We'll cover some common use cases [here](#recipes).\n\n<h2 id=\"installation\">Installation</h2>\n\n```\nnpm install apollo-cache-inmemory --save\n```\n\nAfter installing the package, you'll want to initialize the cache constructor. Then, you can pass in your newly created cache to ApolloClient.\n\n```js\nimport { InMemoryCache } from 'apollo-cache-inmemory';\nimport { HttpLink } from 'apollo-link-http';\nimport ApolloClient from 'apollo-client';\n\nconst cache = new InMemoryCache();\n\nconst client = new ApolloClient({\n  link: new HttpLink(),\n  cache\n});\n```\n\n<h2 id=\"configuration\">Configuration</h2>\n\nThe `InMemoryCache` constructor takes an optional config object with properties to customize your cache:\n\n- addTypename: A boolean to determine whether to add __typename to the document (default: `true`)\n- dataIdFromObject: A function that takes a data object and returns a unique identifier to be used when normalizing the data in the store. Learn more about how to customize `dataIdFromObject` in the [Normalization](#normalization) section.\n- fragmentMatcher: By default, the `InMemoryCache` uses a heuristic fragment matcher. If you are using fragments on unions and interfaces, you will need to use an `IntrospectionFragmentMatcher`. For more information, please read [our guide to setting up fragment matching for unions & interfaces](https://www.apollographql.com/docs/react/advanced/fragments.html#fragment-matcher).\n\n<h2 id=\"normalization\">Normalization</h2>\n\nThe `InMemoryCache` normalizes your data before saving it to the store by splitting the result into individual objects, creating a unique identifier for each object, and storing those objects in a flattened data structure. By default, `InMemoryCache` will attempt to use the commonly found primary keys of `id` and `_id` for the unique identifier if they exist along with `__typename` on an object.\n\nIf `id` and `_id` are not specified, or if `__typename` is not specified, `InMemoryCache` will fall back to the path to the object in the query, such as `ROOT_QUERY.allPeople.0` for the first record returned on the `allPeople` root query.\n\nThis \"getter\" behavior for unique identifiers can be configured manually via the `dataIdFromObject` option passed to the `InMemoryCache` constructor, so you can pick which field is used if some of your data follows unorthodox primary key conventions.\n\nFor example, if you wanted to key off of the `key` field for all of your data, you could configure `dataIdFromObject` like so:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => object.key\n});\n```\n\nThis also allows you to use different unique identifiers for different data types by keying off of the `__typename` property attached to every object typed by GraphQL.  For example:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => {\n    switch (object.__typename) {\n      case 'foo': return object.key; // use `key` as the primary key\n      case 'bar': return object.blah; // use `blah` as the priamry key\n      default: return object.id || object._id; // fall back to `id` and `_id` for all other types\n    }\n  }\n});\n```\n\n<h2 id=\"direct\">Direct Cache Access</h2>\n\nTo interact directly with your cache, you can use the Apollo Client class methods readQuery, readFragment, writeQuery, and writeFragment. These methods are available to us via the [`DataProxy` interface](http://dev.apollodata.com/core/apollo-client-api.html#DataProxy). Accessing these methods will vary slightly based on your view layer implementation. If you are using React, you can wrap your component in the `withApollo` higher order component, which will give you access to `this.props.client`. From there, you can use the methods to control your data.\n\nAny code demonstration in the following sections will assume that we have already initialized an instance of  `ApolloClient` and that we have imported the `gql` tag from `graphql-tag`.\n\n<h3 id=\"readquery\">readQuery</h3>\n\nThe `readQuery` method is very similar to the [`query` method on `ApolloClient`][] except that `readQuery` will _never_ make a request to your GraphQL server. The `query` method, on the other hand, may send a request to your server if the appropriate data is not in your cache whereas `readQuery` will throw an error if the data is not in your cache. `readQuery` will _always_ read from the cache. You can use `readQuery` by giving it a GraphQL query like so:\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo {\n      todo(id: 5) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n});\n```\n\nIf all of the data needed to fulfill this read is in Apollo Client’s normalized data cache then a data object will be returned in the shape of the query you wanted to read. If not all of the data needed to fulfill this read is in Apollo Client’s cache then an error will be thrown instead, so make sure to only read data that you know you have!\n\nYou can also pass variables into `readQuery`.\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo($id: Int!) {\n      todo(id: $id) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n  variables: {\n    id: 5,\n  },\n});\n```\n\n<h3 id=\"readfragment\">readFragment</h3>\n\nThis method allows you great flexibility around the data in your cache. Whereas `readQuery` only allowed you to read data from your root query type, `readFragment` allows you to read data from _any node you have queried_. This is incredibly powerful. You use this method as follows:\n\n```js\nconst todo = client.readFragment({\n  id: ..., // `id` is any id that could be returned by `dataIdFromObject`.\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\nThe first argument is the id of the data you want to read from the cache. That id must be a value that was returned by the `dataIdFromObject` function you defined when initializing `ApolloClient`. So for example if you initialized `ApolloClient` like so:\n\n```js\nconst client = new ApolloClient({\n  ...,\n  dataIdFromObject: object => object.id,\n});\n```\n\n…and you requested a todo before with an id of `5`, then you can read that todo out of your cache with the following:\n\n```js\nconst todo = client.readFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\n> **Note:** Most people add a `__typename` to the id in `dataIdFromObject`. If you do this then don’t forget to add the `__typename` when you are reading a fragment as well. So for example your id may be `Todo_5` and not just `5`.\n\nIf a todo with that id does not exist in the cache you will get `null` back. If a todo of that id does exist in the cache, but that todo does not have the `text` field then an error will be thrown.\n\nThe beauty of `readFragment` is that the todo could have come from anywhere! The todo could have been selected as a singleton (`{ todo(id: 5) { ... } }`), the todo could have come from a list of todos (`{ todos { ... } }`), or the todo could have come from a mutation (`mutation { createTodo { ... } }`). As long as at some point your GraphQL server gave you a todo with the provided id and fields `id`, `text`, and `completed` you can read it from the cache at any part of your code.\n\n<h3 id=\"writequery-and-writefragment\">writeQuery` and `writeFragment</h3>\n\nNot only can you read arbitrary data from the Apollo Client cache, but you can also write any data that you would like to the cache. The methods you use to do this are `writeQuery` and `writeFragment`. They will allow you to change data in your local cache, but it is important to remember that *they will not change any data on your server*. If you reload your environment then changes made with `writeQuery` and `writeFragment` will disappear.\n\nThese methods have the same signature as their `readQuery` and `readFragment` counterparts except they also require an additional `data` variable. So for example, if you wanted to update the `completed` flag locally for your todo with id `'5'` you could execute the following:\n\n```js\nclient.writeFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      completed\n    }\n  `,\n  data: {\n    completed: true,\n  },\n});\n```\n\nAny subscriber to the Apollo Client store will instantly see this update and render new UI accordingly.\n\n> **Note:** Again, remember that using `writeQuery` or `writeFragment` only changes data *locally*. If you reload your environment then changes made with these methods will no longer exist.\n\nOr if you wanted to add a new todo to a list fetched from the server, you could use `readQuery` and `writeQuery` together.\n\n```js\nconst query = gql`\n  query MyTodoAppQuery {\n    todos {\n      id\n      text\n      completed\n    }\n  }\n`;\n\nconst data = client.readQuery({ query });\n\nconst myNewTodo = {\n  id: '6',\n  text: 'Start using Apollo Client.',\n  completed: false,\n};\n\nclient.writeQuery({\n  query,\n  data: {\n    todos: [...data.todos, myNewTodo],\n  },\n});\n```\n\n<h2 id=\"recipes\">Recipes</h2>\n\nHere are some common situations where you would need to access the cache directly. If you're manipulating the cache in an interesting way and would like your example to be featured, please send in a pull request!\n\n<h3 id=\"server\">Server side rendering</h3>\n\nFirst, you will need to initialize an `InMemoryCache` on the server and create an instance of `ApolloClient`. In the initial serialized HTML payload from the server, you should include a script tag that extracts the data from the cache.\n\n```js\n`<script>\n  window.__APOLLO_STATE__=${JSON.stringify(cache.extract())}\n</script>`\n```\n\nOn the client, you can rehydrate the cache using the initial data passed from the server:\n\n```js\ncache: new Cache().restore(window.__APOLLO_STATE__)\n```\n\nIf you would like to learn more about server side rendering, please check our our more in depth guide [here].\n<!---\nTODO (PEGGY): Add link to SSR\n-->\n\n<h3 id=\"server\">Updating the cache after a mutation</h3>\n\nBeing able to read and write to the Apollo cache from anywhere in your application gives you a lot of power over your data. However, there is one place where we most often want to update our cached data: after a mutation. As such, Apollo Client has optimized the experience for updating your cache with the read and write methods after a mutation with the `update` function. Let us say that we have the following GraphQL mutation:\n\n```graphql\nmutation TodoCreateMutation($text: String!) {\n  createTodo(text: $text) {\n    id\n    text\n    completed\n  }\n}\n```\n\nWe may also have the following GraphQL query:\n\n```graphql\nquery TodoAppQuery {\n  todos {\n    id\n    text\n    completed\n  }\n}\n```\n\nAt the end of our mutation we want our query to include the new todo like we had sent our `TodoAppQuery` a second time after the mutation finished without actually sending the query. To do this we can use the `update` function provided as an option of the `client.mutate` method. To update your cache with the mutation just write code that looks like:\n\n```js\n// We assume that the GraphQL operations `TodoCreateMutation` and\n// `TodoAppQuery` have already been defined using the `gql` tag.\n\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    // Read the data from our cache for this query.\n    const data = proxy.readQuery({ query: TodoAppQuery });\n\n    // Add our todo from the mutation to the end.\n    data.todos.push(createTodo);\n\n    // Write our data back to the cache.\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nThe first `proxy` argument is an instance of [`DataProxy`][] has the same four methods that we just learned exist on the Apollo Client: `readQuery`, `readFragment`, `writeQuery`, and `writeFragment`. The reason we call them on a `proxy` object here instead of on our `client` instance is that we can easily apply optimistic updates (which we will demonstrate in a bit). The `proxy` object also provides an isolated transaction which shields you from any other mutations going on at the same time, and the `proxy` object also batches writes together until the very end.\n\nIf you provide an `optimisticResponse` option to the mutation then the `update` function will be run twice. Once immediately after you call `client.mutate` with the data from `optimisticResponse`. After the mutation successfully executes against the server the changes made in the first call to `update` will be rolled back and `update` will be called with the *actual* data returned by the mutation and not just the optimistic response.\n\nPutting it all together:\n\n```js\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  optimisticResponse: {\n    id: -1, // -1 is a temporary id for the optimistic response.\n    text,\n    completed: false,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    const data = proxy.readQuery({ query: TodoAppQuery });\n    data.todos.push(createTodo);\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nAs you can see the `update` function on `client.mutate` provides extra change management functionality specific to the use case of a mutation while still providing you the powerful data control APIs that are available on `client`.\n\nThe `update` function is not a good place for side-effects as it may be called multiple times. Also, you may not call any of the methods on `proxy` asynchronously.\n\n",
      "readmeFilename": "README.md",
      "_id": "apollo-cache-inmemory@1.2.6-alpha.12",
      "_npmVersion": "6.2.0",
      "_nodeVersion": "10.6.0",
      "_npmUser": {
        "name": "mdg",
        "email": "npm@meteor.com"
      },
      "dist": {
        "integrity": "sha512-TKFggCbkQb0BmEsT1HnuGQvb9yWxEp+zpgPCJVFa9q73WbFHWa00sUu/XFQ9XVKsAHT1PFvwpWJQysOlcG2uFA==",
        "shasum": "473dd7e2b516aa900e8a3c01b58529486aec5dc1",
        "tarball": "https://registry.npmjs.org/apollo-cache-inmemory/-/apollo-cache-inmemory-1.2.6-alpha.12.tgz",
        "fileCount": 61,
        "unpackedSize": 428212,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJbWnQhCRA9TVsSAnZWagAA4p8P/0Hkwj8w/9piJlhA+Qqy\nzn4xkrixNxG6bWweibce3NOSHR5UWXlzYiX8FN9w5Mh+kdyc18RiXClc8uaI\nwA0tfUKrHlOH5oQFnqcIJmEXoii6JGnyiwb/fJ1OsbRC3UAGvtZpX4oKiHbK\nvKeCFOCYROJHPiNeORnT6WH06JZXtCjcxAsvhu9B8AB6jhHw4B3uYtYguY2r\norZkEZaVEXN0Jh+ZYv9XAxO4/AfUfA+jIaDTCGs9WA+kecYor3R8nUdv9cur\n8JXq9By0gjTU1OLY9Z3jbidmHWTNWuF9lK2iGSIZosSOpLqnGAsAYhi+Sa49\nzH8419Q4mdOO6kTX7JQrceGEcP57UDW7vZKjC303kRQpGTqaJXTVVq8oSnG1\nbbd9Wr+z6fOqmJWTtiRshhQkT8Lnzqqb6iO0r+aHmh+57w9XhLaJre7eBs6c\nP4lFoZIUSsetIclM2JTE9GpI61ZkZOKmfWSSKY3XGNwLmTrr2cwqkU17Qr7/\nQQb09V2w+hHgHQoE1mSsrk92k1QM8Wc0n/yQHYabwpvOxXIIOFG8IHtjoDpW\nHjmCvVToEf/sFxAEMqX8fu2NnwWLhwWfpzXtek9dftNl/EfjiQyFoWtb695O\nS+VLtIXvgubQhoPnU4n8Btn12+97zGGypHcqJ0v4lW/GDTBASUb7Lu868+Sd\n1e9Y\r\n=Zd9X\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEYCIQD4GsMpEhsFiOz/G19NkHscRSHmG/IRc7o4wLstCUncMQIhAORVaJ6mqWk7/Lf0zJDexFPs7thLrN4+3DNuIoTfPg/T"
          }
        ]
      },
      "maintainers": [
        {
          "email": "ben@benjamn.com",
          "name": "benjamn"
        },
        {
          "email": "james@meteor.com",
          "name": "jbaxleyiii"
        },
        {
          "email": "npm@meteor.com",
          "name": "mdg"
        },
        {
          "email": "peggyrayzis@gmail.com",
          "name": "peggyrayzis"
        }
      ],
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/apollo-cache-inmemory_1.2.6-alpha.12_1532654625389_0.5929844111121569"
      },
      "_hasShrinkwrap": false
    },
    "1.3.0-beta.6": {
      "name": "apollo-cache-inmemory",
      "version": "1.3.0-beta.6",
      "description": "Core abstract of Caching layer for Apollo Client",
      "author": {
        "name": "James Baxley",
        "email": "james@meteor.com"
      },
      "contributors": [
        {
          "name": "James Baxley",
          "email": "james@meteor.com"
        },
        {
          "name": "Jonas Helfer",
          "email": "jonas@helfer.email"
        },
        {
          "name": "Sashko Stubailo",
          "email": "sashko@stubailo.com"
        },
        {
          "name": "James Burgess",
          "email": "jamesmillerburgess@gmail.com"
        },
        {
          "name": "Bazyli Brzóska",
          "email": "bazyli.brzoska@gmail.com"
        }
      ],
      "license": "MIT",
      "main": "./lib/bundle.umd.js",
      "module": "./lib/index.js",
      "jsnext:main": "./lib/index.js",
      "typings": "./lib/index.d.ts",
      "sideEffects": false,
      "repository": {
        "type": "git",
        "url": "git+https://github.com/apollographql/apollo-client.git"
      },
      "bugs": {
        "url": "https://github.com/apollographql/apollo-client/issues"
      },
      "homepage": "https://github.com/apollographql/apollo-client#readme",
      "scripts": {
        "coverage": "jest --coverage",
        "test": "jest",
        "lint": "tslint --type-check -p tsconfig.json src/*.ts",
        "prebuild": "npm run clean",
        "build": "tsc -p .",
        "postbuild": "npm run bundle",
        "bundle": "rollup -c rollup.config.js",
        "watch": "tsc -w -p .",
        "clean": "rimraf coverage/* && rimraf lib/*",
        "prepublishOnly": "npm run build",
        "build:browser": "browserify ./lib/bundle.umd.js --i apollo-cache --i apollo-utilities --i graphql -o=./lib/bundle.js && npm run minify:browser",
        "minify:browser": "uglifyjs -c -m -o ./lib/bundle.min.js -- ./lib/bundle.js",
        "filesize": "npm run build:browser"
      },
      "dependencies": {
        "apollo-cache": "^1.1.13",
        "apollo-utilities": "^1.0.17",
        "optimism": "^0.6.5"
      },
      "peerDependencies": {
        "graphql": "0.11.7 || ^0.12.0 || ^0.13.0"
      },
      "devDependencies": {
        "@types/graphql": "0.12.7",
        "@types/jest": "22.2.3",
        "@types/lodash": "4.14.113",
        "browserify": "15.2.0",
        "graphql": "0.13.2",
        "graphql-tag": "2.9.2",
        "jest": "23.0.0",
        "lodash": "4.17.10",
        "rimraf": "2.6.2",
        "rollup": "0.63.4",
        "ts-jest": "20.0.14",
        "tslint": "5.11.0",
        "typescript": "2.9.2",
        "uglifyjs": "2.4.11"
      },
      "jest": {
        "transform": {
          ".(ts|tsx)": "<rootDir>/node_modules/ts-jest/preprocessor.js"
        },
        "testRegex": "(/__tests__/.*|\\.(test|spec))\\.(ts|tsx|js)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "json"
        ],
        "testURL": "http://localhost"
      },
      "_id": "apollo-cache-inmemory@1.3.0-beta.6",
      "_npmVersion": "6.2.0",
      "_nodeVersion": "8.11.3",
      "_npmUser": {
        "name": "benjamn",
        "email": "ben@benjamn.com"
      },
      "dist": {
        "integrity": "sha512-mKKn5iugSmqooPObAkikgwi56R/oK0Ik9gmyE1+GjyANbcMWiL1XHNNePpaAauW3w/XQmZDNdhGbG9j+juXx8g==",
        "shasum": "5767741216e441b05b6966c99cd4e3f2cb67c09b",
        "tarball": "https://registry.npmjs.org/apollo-cache-inmemory/-/apollo-cache-inmemory-1.3.0-beta.6.tgz",
        "fileCount": 69,
        "unpackedSize": 464280,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJbW39ACRA9TVsSAnZWagAA7YcQAJXMyBnuFMFP5hAhnk1S\nFvwNMKMSnQho3mZdzdSgLBHc17QBycOX3Cdgowx2oAB9So0cncy4LRz04LKd\nPofyCS2tMkbuPAidn3pyvYA0w6pLh4NltEs5hoL96v+K+TAALaUXhM2XFVmV\nonJf95h4Iqv7es09rLeCkS/QX1/RXHi/z4ku6OO4yaW6jqWSkGsBcNcgjZD9\nEoqpKW6TT0h9dOLSwtLmm9e+PzRqxEsuBiufMJWXKDNee0TDld1RpLVhPTUe\nLUoOtYNVcVYJ1m6bGLqfFlSft+WC5srMbQbcTqY3HpRuo6Ah7AhY6Llt5JHA\nonlf1THkqV6ECqgSUBoxmy1pvnhKDjMJBTQgdqofImlkFN3n52rA43DKIGhL\nv5LzyW/nr+VckxgG333tMZbBX1/N+/IiCeOLpA41MGfxwpt2dH6DM5485Y0D\ngBaZAxM4sgt8S0sdL7QoecWjXqXIZEszNJmtHb8JouVD5eMXWBw8aLpofnNe\nsKuGfnbG49fMV+tx0engUHpaGMNG9wXvgiiYLFuDBQJX3ghJjI5uBArutMhn\nF83VuNWrXtxcMCPBUxEMsvoQ3JFQL1uG4xlRcEnYZxkV69s83mJgvQVcIwH3\ngePEIIuUYisPBsihDS3SByJLXNlXUjWgybRq58Dqnsu5R0pgoTgo0KmJKl4y\n3jqJ\r\n=rmoc\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEYCIQDzMJfRfCGxg/g1Rbyyo5HNFI5mjHa0mvrGcvvlmDurlwIhAIrsoUW96wtlUXQ3jJsVpMCUf61LPEHmMutDq6jEE1Qk"
          }
        ]
      },
      "maintainers": [
        {
          "email": "ben@benjamn.com",
          "name": "benjamn"
        },
        {
          "email": "james@meteor.com",
          "name": "jbaxleyiii"
        },
        {
          "email": "npm@meteor.com",
          "name": "mdg"
        },
        {
          "email": "peggyrayzis@gmail.com",
          "name": "peggyrayzis"
        }
      ],
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/apollo-cache-inmemory_1.3.0-beta.6_1532723008182_0.6589664036421383"
      },
      "_hasShrinkwrap": false
    },
    "1.2.6-alpha.13": {
      "name": "apollo-cache-inmemory",
      "version": "1.2.6-alpha.13",
      "description": "Core abstract of Caching layer for Apollo Client",
      "author": {
        "name": "James Baxley",
        "email": "james@meteor.com"
      },
      "contributors": [
        {
          "name": "James Baxley",
          "email": "james@meteor.com"
        },
        {
          "name": "Jonas Helfer",
          "email": "jonas@helfer.email"
        },
        {
          "name": "Sashko Stubailo",
          "email": "sashko@stubailo.com"
        },
        {
          "name": "James Burgess",
          "email": "jamesmillerburgess@gmail.com"
        },
        {
          "name": "Bazyli Brzóska",
          "email": "bazyli.brzoska@gmail.com"
        }
      ],
      "license": "MIT",
      "main": "./lib/bundle.umd.js",
      "module": "./lib/index.js",
      "jsnext:main": "./lib/index.js",
      "typings": "./lib/index.d.ts",
      "sideEffects": false,
      "repository": {
        "type": "git",
        "url": "git+https://github.com/apollographql/apollo-client.git"
      },
      "bugs": {
        "url": "https://github.com/apollographql/apollo-client/issues"
      },
      "homepage": "https://github.com/apollographql/apollo-client#readme",
      "scripts": {
        "coverage": "jest --coverage",
        "test": "jest",
        "lint": "tslint --type-check -p tsconfig.json src/*.ts",
        "prebuild": "npm run clean",
        "build": "tsc -p .",
        "postbuild": "npm run bundle",
        "bundle": "rollup -c rollup.config.js",
        "watch": "tsc -w -p .",
        "clean": "rimraf coverage/* && rimraf lib/*",
        "prepublishOnly": "npm run build",
        "build:browser": "browserify ./lib/bundle.umd.js --i apollo-cache --i apollo-utilities --i graphql -o=./lib/bundle.js && npm run minify:browser",
        "minify:browser": "uglifyjs -c -m -o ./lib/bundle.min.js -- ./lib/bundle.js",
        "filesize": "npm run build:browser"
      },
      "dependencies": {
        "apollo-cache": "1.1.13-alpha.13",
        "apollo-utilities": "1.0.17-alpha.13",
        "graphql-anywhere": "4.1.15-alpha.13"
      },
      "peerDependencies": {
        "graphql": "0.11.7 || ^0.12.0 || ^0.13.0"
      },
      "devDependencies": {
        "@types/graphql": "0.12.7",
        "@types/jest": "22.2.3",
        "@types/lodash": "4.14.112",
        "browserify": "15.2.0",
        "graphql": "0.13.2",
        "graphql-tag": "2.9.2",
        "jest": "23.0.0",
        "lodash": "4.17.10",
        "rimraf": "2.6.2",
        "rollup": "0.63.4",
        "ts-jest": "20.0.14",
        "tslint": "5.11.0",
        "typescript": "2.9.2",
        "uglifyjs": "2.4.11"
      },
      "jest": {
        "transform": {
          ".(ts|tsx)": "<rootDir>/node_modules/ts-jest/preprocessor.js"
        },
        "testRegex": "(/__tests__/.*|\\.(test|spec))\\.(ts|tsx|js)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "json"
        ]
      },
      "readme": "---\ntitle: InMemoryCache\ndescription: An explanation of `apollo-cache-inmemory`\n---\n\n`apollo-cache-inmemory` is the recommended cache implementation for Apollo Client 2.0. `InMemoryCache` is a normalized data store that supports all of Apollo Client 1.0's features without the dependency on Redux.\n\nIn some instances, you may need to manipulate the cache directly, such as updating the store after a mutation. We'll cover some common use cases [here](#recipes).\n\n<h2 id=\"installation\">Installation</h2>\n\n```\nnpm install apollo-cache-inmemory --save\n```\n\nAfter installing the package, you'll want to initialize the cache constructor. Then, you can pass in your newly created cache to ApolloClient.\n\n```js\nimport { InMemoryCache } from 'apollo-cache-inmemory';\nimport { HttpLink } from 'apollo-link-http';\nimport ApolloClient from 'apollo-client';\n\nconst cache = new InMemoryCache();\n\nconst client = new ApolloClient({\n  link: new HttpLink(),\n  cache\n});\n```\n\n<h2 id=\"configuration\">Configuration</h2>\n\nThe `InMemoryCache` constructor takes an optional config object with properties to customize your cache:\n\n- addTypename: A boolean to determine whether to add __typename to the document (default: `true`)\n- dataIdFromObject: A function that takes a data object and returns a unique identifier to be used when normalizing the data in the store. Learn more about how to customize `dataIdFromObject` in the [Normalization](#normalization) section.\n- fragmentMatcher: By default, the `InMemoryCache` uses a heuristic fragment matcher. If you are using fragments on unions and interfaces, you will need to use an `IntrospectionFragmentMatcher`. For more information, please read [our guide to setting up fragment matching for unions & interfaces](https://www.apollographql.com/docs/react/advanced/fragments.html#fragment-matcher).\n\n<h2 id=\"normalization\">Normalization</h2>\n\nThe `InMemoryCache` normalizes your data before saving it to the store by splitting the result into individual objects, creating a unique identifier for each object, and storing those objects in a flattened data structure. By default, `InMemoryCache` will attempt to use the commonly found primary keys of `id` and `_id` for the unique identifier if they exist along with `__typename` on an object.\n\nIf `id` and `_id` are not specified, or if `__typename` is not specified, `InMemoryCache` will fall back to the path to the object in the query, such as `ROOT_QUERY.allPeople.0` for the first record returned on the `allPeople` root query.\n\nThis \"getter\" behavior for unique identifiers can be configured manually via the `dataIdFromObject` option passed to the `InMemoryCache` constructor, so you can pick which field is used if some of your data follows unorthodox primary key conventions.\n\nFor example, if you wanted to key off of the `key` field for all of your data, you could configure `dataIdFromObject` like so:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => object.key\n});\n```\n\nThis also allows you to use different unique identifiers for different data types by keying off of the `__typename` property attached to every object typed by GraphQL.  For example:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => {\n    switch (object.__typename) {\n      case 'foo': return object.key; // use `key` as the primary key\n      case 'bar': return object.blah; // use `blah` as the priamry key\n      default: return object.id || object._id; // fall back to `id` and `_id` for all other types\n    }\n  }\n});\n```\n\n<h2 id=\"direct\">Direct Cache Access</h2>\n\nTo interact directly with your cache, you can use the Apollo Client class methods readQuery, readFragment, writeQuery, and writeFragment. These methods are available to us via the [`DataProxy` interface](http://dev.apollodata.com/core/apollo-client-api.html#DataProxy). Accessing these methods will vary slightly based on your view layer implementation. If you are using React, you can wrap your component in the `withApollo` higher order component, which will give you access to `this.props.client`. From there, you can use the methods to control your data.\n\nAny code demonstration in the following sections will assume that we have already initialized an instance of  `ApolloClient` and that we have imported the `gql` tag from `graphql-tag`.\n\n<h3 id=\"readquery\">readQuery</h3>\n\nThe `readQuery` method is very similar to the [`query` method on `ApolloClient`][] except that `readQuery` will _never_ make a request to your GraphQL server. The `query` method, on the other hand, may send a request to your server if the appropriate data is not in your cache whereas `readQuery` will throw an error if the data is not in your cache. `readQuery` will _always_ read from the cache. You can use `readQuery` by giving it a GraphQL query like so:\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo {\n      todo(id: 5) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n});\n```\n\nIf all of the data needed to fulfill this read is in Apollo Client’s normalized data cache then a data object will be returned in the shape of the query you wanted to read. If not all of the data needed to fulfill this read is in Apollo Client’s cache then an error will be thrown instead, so make sure to only read data that you know you have!\n\nYou can also pass variables into `readQuery`.\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo($id: Int!) {\n      todo(id: $id) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n  variables: {\n    id: 5,\n  },\n});\n```\n\n<h3 id=\"readfragment\">readFragment</h3>\n\nThis method allows you great flexibility around the data in your cache. Whereas `readQuery` only allowed you to read data from your root query type, `readFragment` allows you to read data from _any node you have queried_. This is incredibly powerful. You use this method as follows:\n\n```js\nconst todo = client.readFragment({\n  id: ..., // `id` is any id that could be returned by `dataIdFromObject`.\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\nThe first argument is the id of the data you want to read from the cache. That id must be a value that was returned by the `dataIdFromObject` function you defined when initializing `ApolloClient`. So for example if you initialized `ApolloClient` like so:\n\n```js\nconst client = new ApolloClient({\n  ...,\n  dataIdFromObject: object => object.id,\n});\n```\n\n…and you requested a todo before with an id of `5`, then you can read that todo out of your cache with the following:\n\n```js\nconst todo = client.readFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\n> **Note:** Most people add a `__typename` to the id in `dataIdFromObject`. If you do this then don’t forget to add the `__typename` when you are reading a fragment as well. So for example your id may be `Todo_5` and not just `5`.\n\nIf a todo with that id does not exist in the cache you will get `null` back. If a todo of that id does exist in the cache, but that todo does not have the `text` field then an error will be thrown.\n\nThe beauty of `readFragment` is that the todo could have come from anywhere! The todo could have been selected as a singleton (`{ todo(id: 5) { ... } }`), the todo could have come from a list of todos (`{ todos { ... } }`), or the todo could have come from a mutation (`mutation { createTodo { ... } }`). As long as at some point your GraphQL server gave you a todo with the provided id and fields `id`, `text`, and `completed` you can read it from the cache at any part of your code.\n\n<h3 id=\"writequery-and-writefragment\">writeQuery` and `writeFragment</h3>\n\nNot only can you read arbitrary data from the Apollo Client cache, but you can also write any data that you would like to the cache. The methods you use to do this are `writeQuery` and `writeFragment`. They will allow you to change data in your local cache, but it is important to remember that *they will not change any data on your server*. If you reload your environment then changes made with `writeQuery` and `writeFragment` will disappear.\n\nThese methods have the same signature as their `readQuery` and `readFragment` counterparts except they also require an additional `data` variable. So for example, if you wanted to update the `completed` flag locally for your todo with id `'5'` you could execute the following:\n\n```js\nclient.writeFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      completed\n    }\n  `,\n  data: {\n    completed: true,\n  },\n});\n```\n\nAny subscriber to the Apollo Client store will instantly see this update and render new UI accordingly.\n\n> **Note:** Again, remember that using `writeQuery` or `writeFragment` only changes data *locally*. If you reload your environment then changes made with these methods will no longer exist.\n\nOr if you wanted to add a new todo to a list fetched from the server, you could use `readQuery` and `writeQuery` together.\n\n```js\nconst query = gql`\n  query MyTodoAppQuery {\n    todos {\n      id\n      text\n      completed\n    }\n  }\n`;\n\nconst data = client.readQuery({ query });\n\nconst myNewTodo = {\n  id: '6',\n  text: 'Start using Apollo Client.',\n  completed: false,\n};\n\nclient.writeQuery({\n  query,\n  data: {\n    todos: [...data.todos, myNewTodo],\n  },\n});\n```\n\n<h2 id=\"recipes\">Recipes</h2>\n\nHere are some common situations where you would need to access the cache directly. If you're manipulating the cache in an interesting way and would like your example to be featured, please send in a pull request!\n\n<h3 id=\"server\">Server side rendering</h3>\n\nFirst, you will need to initialize an `InMemoryCache` on the server and create an instance of `ApolloClient`. In the initial serialized HTML payload from the server, you should include a script tag that extracts the data from the cache.\n\n```js\n`<script>\n  window.__APOLLO_STATE__=${JSON.stringify(cache.extract())}\n</script>`\n```\n\nOn the client, you can rehydrate the cache using the initial data passed from the server:\n\n```js\ncache: new Cache().restore(window.__APOLLO_STATE__)\n```\n\nIf you would like to learn more about server side rendering, please check our our more in depth guide [here].\n<!---\nTODO (PEGGY): Add link to SSR\n-->\n\n<h3 id=\"server\">Updating the cache after a mutation</h3>\n\nBeing able to read and write to the Apollo cache from anywhere in your application gives you a lot of power over your data. However, there is one place where we most often want to update our cached data: after a mutation. As such, Apollo Client has optimized the experience for updating your cache with the read and write methods after a mutation with the `update` function. Let us say that we have the following GraphQL mutation:\n\n```graphql\nmutation TodoCreateMutation($text: String!) {\n  createTodo(text: $text) {\n    id\n    text\n    completed\n  }\n}\n```\n\nWe may also have the following GraphQL query:\n\n```graphql\nquery TodoAppQuery {\n  todos {\n    id\n    text\n    completed\n  }\n}\n```\n\nAt the end of our mutation we want our query to include the new todo like we had sent our `TodoAppQuery` a second time after the mutation finished without actually sending the query. To do this we can use the `update` function provided as an option of the `client.mutate` method. To update your cache with the mutation just write code that looks like:\n\n```js\n// We assume that the GraphQL operations `TodoCreateMutation` and\n// `TodoAppQuery` have already been defined using the `gql` tag.\n\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    // Read the data from our cache for this query.\n    const data = proxy.readQuery({ query: TodoAppQuery });\n\n    // Add our todo from the mutation to the end.\n    data.todos.push(createTodo);\n\n    // Write our data back to the cache.\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nThe first `proxy` argument is an instance of [`DataProxy`][] has the same four methods that we just learned exist on the Apollo Client: `readQuery`, `readFragment`, `writeQuery`, and `writeFragment`. The reason we call them on a `proxy` object here instead of on our `client` instance is that we can easily apply optimistic updates (which we will demonstrate in a bit). The `proxy` object also provides an isolated transaction which shields you from any other mutations going on at the same time, and the `proxy` object also batches writes together until the very end.\n\nIf you provide an `optimisticResponse` option to the mutation then the `update` function will be run twice. Once immediately after you call `client.mutate` with the data from `optimisticResponse`. After the mutation successfully executes against the server the changes made in the first call to `update` will be rolled back and `update` will be called with the *actual* data returned by the mutation and not just the optimistic response.\n\nPutting it all together:\n\n```js\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  optimisticResponse: {\n    id: -1, // -1 is a temporary id for the optimistic response.\n    text,\n    completed: false,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    const data = proxy.readQuery({ query: TodoAppQuery });\n    data.todos.push(createTodo);\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nAs you can see the `update` function on `client.mutate` provides extra change management functionality specific to the use case of a mutation while still providing you the powerful data control APIs that are available on `client`.\n\nThe `update` function is not a good place for side-effects as it may be called multiple times. Also, you may not call any of the methods on `proxy` asynchronously.\n\n",
      "readmeFilename": "README.md",
      "_id": "apollo-cache-inmemory@1.2.6-alpha.13",
      "_npmVersion": "6.2.0",
      "_nodeVersion": "10.6.0",
      "_npmUser": {
        "name": "mdg",
        "email": "npm@meteor.com"
      },
      "dist": {
        "integrity": "sha512-C/b+qyLsPIN8VghyKxTtt9LBonB5STv0C1/oTSpBLI2kqxioDaWoqvrK3GEujTXsELcYNIwoXlKXLVbwyODA/g==",
        "shasum": "4e451a467a2c26e4068782424c917899b37b045c",
        "tarball": "https://registry.npmjs.org/apollo-cache-inmemory/-/apollo-cache-inmemory-1.2.6-alpha.13.tgz",
        "fileCount": 61,
        "unpackedSize": 429645,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJbYBhuCRA9TVsSAnZWagAA96kP/1ZQofc9Hn4AayVnc/0b\npjmzhz1PTXYhz7jzAYaL693/MGu8lvGS3jPnORLNq/oqofmxy6oDeM6ZsN0G\num399q+O85caLLswR7IfcS2Kb+2GivD23bZ2RFviQRjOdjjTskzSCCoOErYx\n6QgH9I+2NDnYE4FPwBHveC3IL2jrAmzzaFC9hI3AESYueTrYNYbeAqWOnqNb\nJxMr6OBZxt4cp2gbo+YTQE1fcxVrRllEnpWLlRC9oEOC2aWIwoK+KLXBsdHu\ncSn1LJglSWztTM7kpJS7PHQ8Lpsg45219xSMltq1Oa4Tjiph04r+ya7S4nWh\nBzET3Rf+hrFFsUHPqVE221nZNB4P/NpqdyRBM2fC0SWT+SURxWtx/0R2gUzF\nADWmH3L3tK18Fua7/qtI4EAwj8qm5k6U2E52d5taKVm/oSFZZm38wuXoASJu\nhHx0W6FnC4ZxnRSr07r766i/pKVBTcEiCKQkgSNrjqWcxzAZ0O56JmOPNMN5\nuD2+Z4pxogGPIg6IJK3VArXG8rUZ6GxN9vguyD5pvSe5tYNvIIRY1x1OsVu4\n1Uzexxn9H/3jQIXnH2zx8Ph3YvaEy0WmsMDesunhzAOsQTSyYYrxUFfMwGsC\nHvdt8zIYBS2+9ne3NGpRuxVhOar420yoT1bGQSOHzpWXuIsOgxrZNiK+wgDV\nMVSY\r\n=jwqe\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIBqB4U+wiE+FzCahIGTG6J0vywKzGW8pDui2Px2MxggRAiEAmw0ONVaX6bk4to9Et10xC25zDqZsy80I/UdF+AoArak="
          }
        ]
      },
      "maintainers": [
        {
          "email": "ben@benjamn.com",
          "name": "benjamn"
        },
        {
          "email": "james@meteor.com",
          "name": "jbaxleyiii"
        },
        {
          "email": "npm@meteor.com",
          "name": "mdg"
        },
        {
          "email": "peggyrayzis@gmail.com",
          "name": "peggyrayzis"
        }
      ],
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/apollo-cache-inmemory_1.2.6-alpha.13_1533024365918_0.6378123251292687"
      },
      "_hasShrinkwrap": false
    },
    "1.3.0-beta.7": {
      "name": "apollo-cache-inmemory",
      "version": "1.3.0-beta.7",
      "description": "Core abstract of Caching layer for Apollo Client",
      "author": {
        "name": "James Baxley",
        "email": "james@meteor.com"
      },
      "contributors": [
        {
          "name": "James Baxley",
          "email": "james@meteor.com"
        },
        {
          "name": "Jonas Helfer",
          "email": "jonas@helfer.email"
        },
        {
          "name": "Sashko Stubailo",
          "email": "sashko@stubailo.com"
        },
        {
          "name": "James Burgess",
          "email": "jamesmillerburgess@gmail.com"
        },
        {
          "name": "Bazyli Brzóska",
          "email": "bazyli.brzoska@gmail.com"
        }
      ],
      "license": "MIT",
      "main": "./lib/bundle.umd.js",
      "module": "./lib/index.js",
      "jsnext:main": "./lib/index.js",
      "typings": "./lib/index.d.ts",
      "sideEffects": false,
      "repository": {
        "type": "git",
        "url": "git+https://github.com/apollographql/apollo-client.git"
      },
      "bugs": {
        "url": "https://github.com/apollographql/apollo-client/issues"
      },
      "homepage": "https://github.com/apollographql/apollo-client#readme",
      "scripts": {
        "coverage": "jest --coverage",
        "test": "jest",
        "lint": "tslint --type-check -p tsconfig.json src/*.ts",
        "prebuild": "npm run clean",
        "build": "tsc -p .",
        "postbuild": "npm run bundle",
        "bundle": "rollup -c rollup.config.js",
        "watch": "tsc -w -p .",
        "clean": "rimraf coverage/* && rimraf lib/*",
        "prepublishOnly": "npm run build",
        "build:browser": "browserify ./lib/bundle.umd.js --i apollo-cache --i apollo-utilities --i graphql -o=./lib/bundle.js && npm run minify:browser",
        "minify:browser": "uglifyjs -c -m -o ./lib/bundle.min.js -- ./lib/bundle.js",
        "filesize": "npm run build:browser"
      },
      "dependencies": {
        "apollo-cache": "^1.1.13",
        "apollo-utilities": "^1.0.17",
        "optimism": "^0.6.5"
      },
      "peerDependencies": {
        "graphql": "0.11.7 || ^0.12.0 || ^0.13.0"
      },
      "devDependencies": {
        "@types/graphql": "0.12.7",
        "@types/jest": "22.2.3",
        "@types/lodash": "4.14.115",
        "browserify": "15.2.0",
        "graphql": "0.13.2",
        "graphql-tag": "2.9.2",
        "jest": "23.0.0",
        "lodash": "4.17.10",
        "rimraf": "2.6.2",
        "rollup": "0.63.5",
        "ts-jest": "20.0.14",
        "tslint": "5.11.0",
        "typescript": "2.9.2",
        "uglify-js": "^3.4.6"
      },
      "jest": {
        "transform": {
          ".(ts|tsx)": "<rootDir>/node_modules/ts-jest/preprocessor.js"
        },
        "testRegex": "(/__tests__/.*|\\.(test|spec))\\.(ts|tsx|js)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "json"
        ],
        "testURL": "http://localhost"
      },
      "readme": "---\ntitle: InMemoryCache\ndescription: An explanation of `apollo-cache-inmemory`\n---\n\n`apollo-cache-inmemory` is the recommended cache implementation for Apollo Client 2.0. `InMemoryCache` is a normalized data store that supports all of Apollo Client 1.0's features without the dependency on Redux.\n\nIn some instances, you may need to manipulate the cache directly, such as updating the store after a mutation. We'll cover some common use cases [here](#recipes).\n\n<h2 id=\"installation\">Installation</h2>\n\n```\nnpm install apollo-cache-inmemory --save\n```\n\nAfter installing the package, you'll want to initialize the cache constructor. Then, you can pass in your newly created cache to ApolloClient.\n\n```js\nimport { InMemoryCache } from 'apollo-cache-inmemory';\nimport { HttpLink } from 'apollo-link-http';\nimport ApolloClient from 'apollo-client';\n\nconst cache = new InMemoryCache();\n\nconst client = new ApolloClient({\n  link: new HttpLink(),\n  cache\n});\n```\n\n<h2 id=\"configuration\">Configuration</h2>\n\nThe `InMemoryCache` constructor takes an optional config object with properties to customize your cache:\n\n- addTypename: A boolean to determine whether to add __typename to the document (default: `true`)\n- dataIdFromObject: A function that takes a data object and returns a unique identifier to be used when normalizing the data in the store. Learn more about how to customize `dataIdFromObject` in the [Normalization](#normalization) section.\n- fragmentMatcher: By default, the `InMemoryCache` uses a heuristic fragment matcher. If you are using fragments on unions and interfaces, you will need to use an `IntrospectionFragmentMatcher`. For more information, please read [our guide to setting up fragment matching for unions & interfaces](https://www.apollographql.com/docs/react/advanced/fragments.html#fragment-matcher).\n\n<h2 id=\"normalization\">Normalization</h2>\n\nThe `InMemoryCache` normalizes your data before saving it to the store by splitting the result into individual objects, creating a unique identifier for each object, and storing those objects in a flattened data structure. By default, `InMemoryCache` will attempt to use the commonly found primary keys of `id` and `_id` for the unique identifier if they exist along with `__typename` on an object.\n\nIf `id` and `_id` are not specified, or if `__typename` is not specified, `InMemoryCache` will fall back to the path to the object in the query, such as `ROOT_QUERY.allPeople.0` for the first record returned on the `allPeople` root query.\n\nThis \"getter\" behavior for unique identifiers can be configured manually via the `dataIdFromObject` option passed to the `InMemoryCache` constructor, so you can pick which field is used if some of your data follows unorthodox primary key conventions.\n\nFor example, if you wanted to key off of the `key` field for all of your data, you could configure `dataIdFromObject` like so:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => object.key\n});\n```\n\nThis also allows you to use different unique identifiers for different data types by keying off of the `__typename` property attached to every object typed by GraphQL.  For example:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => {\n    switch (object.__typename) {\n      case 'foo': return object.key; // use `key` as the primary key\n      case 'bar': return object.blah; // use `blah` as the priamry key\n      default: return object.id || object._id; // fall back to `id` and `_id` for all other types\n    }\n  }\n});\n```\n\n<h2 id=\"direct\">Direct Cache Access</h2>\n\nTo interact directly with your cache, you can use the Apollo Client class methods readQuery, readFragment, writeQuery, and writeFragment. These methods are available to us via the [`DataProxy` interface](https://github.com/apollographql/apollo-client/blob/master/packages/apollo-cache/src/types/DataProxy.ts). Accessing these methods will vary slightly based on your view layer implementation. If you are using React, you can wrap your component in the `withApollo` higher order component, which will give you access to `this.props.client`. From there, you can use the methods to control your data.\n\nAny code demonstration in the following sections will assume that we have already initialized an instance of  `ApolloClient` and that we have imported the `gql` tag from `graphql-tag`.\n\n<h3 id=\"readquery\">readQuery</h3>\n\nThe `readQuery` method is very similar to the [`query` method on `ApolloClient`][] except that `readQuery` will _never_ make a request to your GraphQL server. The `query` method, on the other hand, may send a request to your server if the appropriate data is not in your cache whereas `readQuery` will throw an error if the data is not in your cache. `readQuery` will _always_ read from the cache. You can use `readQuery` by giving it a GraphQL query like so:\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo {\n      todo(id: 5) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n});\n```\n\nIf all of the data needed to fulfill this read is in Apollo Client’s normalized data cache then a data object will be returned in the shape of the query you wanted to read. If not all of the data needed to fulfill this read is in Apollo Client’s cache then an error will be thrown instead, so make sure to only read data that you know you have!\n\nYou can also pass variables into `readQuery`.\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo($id: Int!) {\n      todo(id: $id) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n  variables: {\n    id: 5,\n  },\n});\n```\n\n<h3 id=\"readfragment\">readFragment</h3>\n\nThis method allows you great flexibility around the data in your cache. Whereas `readQuery` only allowed you to read data from your root query type, `readFragment` allows you to read data from _any node you have queried_. This is incredibly powerful. You use this method as follows:\n\n```js\nconst todo = client.readFragment({\n  id: ..., // `id` is any id that could be returned by `dataIdFromObject`.\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\nThe first argument is the id of the data you want to read from the cache. That id must be a value that was returned by the `dataIdFromObject` function you defined when initializing `ApolloClient`. So for example if you initialized `ApolloClient` like so:\n\n```js\nconst client = new ApolloClient({\n  ...,\n  dataIdFromObject: object => object.id,\n});\n```\n\n…and you requested a todo before with an id of `5`, then you can read that todo out of your cache with the following:\n\n```js\nconst todo = client.readFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\n> **Note:** Most people add a `__typename` to the id in `dataIdFromObject`. If you do this then don’t forget to add the `__typename` when you are reading a fragment as well. So for example your id may be `Todo_5` and not just `5`.\n\nIf a todo with that id does not exist in the cache you will get `null` back. If a todo of that id does exist in the cache, but that todo does not have the `text` field then an error will be thrown.\n\nThe beauty of `readFragment` is that the todo could have come from anywhere! The todo could have been selected as a singleton (`{ todo(id: 5) { ... } }`), the todo could have come from a list of todos (`{ todos { ... } }`), or the todo could have come from a mutation (`mutation { createTodo { ... } }`). As long as at some point your GraphQL server gave you a todo with the provided id and fields `id`, `text`, and `completed` you can read it from the cache at any part of your code.\n\n<h3 id=\"writequery-and-writefragment\">writeQuery` and `writeFragment</h3>\n\nNot only can you read arbitrary data from the Apollo Client cache, but you can also write any data that you would like to the cache. The methods you use to do this are `writeQuery` and `writeFragment`. They will allow you to change data in your local cache, but it is important to remember that *they will not change any data on your server*. If you reload your environment then changes made with `writeQuery` and `writeFragment` will disappear.\n\nThese methods have the same signature as their `readQuery` and `readFragment` counterparts except they also require an additional `data` variable. So for example, if you wanted to update the `completed` flag locally for your todo with id `'5'` you could execute the following:\n\n```js\nclient.writeFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      completed\n    }\n  `,\n  data: {\n    completed: true,\n  },\n});\n```\n\nAny subscriber to the Apollo Client store will instantly see this update and render new UI accordingly.\n\n> **Note:** Again, remember that using `writeQuery` or `writeFragment` only changes data *locally*. If you reload your environment then changes made with these methods will no longer exist.\n\nOr if you wanted to add a new todo to a list fetched from the server, you could use `readQuery` and `writeQuery` together.\n\n```js\nconst query = gql`\n  query MyTodoAppQuery {\n    todos {\n      id\n      text\n      completed\n    }\n  }\n`;\n\nconst data = client.readQuery({ query });\n\nconst myNewTodo = {\n  id: '6',\n  text: 'Start using Apollo Client.',\n  completed: false,\n};\n\nclient.writeQuery({\n  query,\n  data: {\n    todos: [...data.todos, myNewTodo],\n  },\n});\n```\n\n<h2 id=\"recipes\">Recipes</h2>\n\nHere are some common situations where you would need to access the cache directly. If you're manipulating the cache in an interesting way and would like your example to be featured, please send in a pull request!\n\n<h3 id=\"server\">Server side rendering</h3>\n\nFirst, you will need to initialize an `InMemoryCache` on the server and create an instance of `ApolloClient`. In the initial serialized HTML payload from the server, you should include a script tag that extracts the data from the cache.\n\n```js\n`<script>\n  window.__APOLLO_STATE__=${JSON.stringify(cache.extract())}\n</script>`\n```\n\nOn the client, you can rehydrate the cache using the initial data passed from the server:\n\n```js\ncache: new Cache().restore(window.__APOLLO_STATE__)\n```\n\nIf you would like to learn more about server side rendering, please check our our more in depth guide [here].\n<!---\nTODO (PEGGY): Add link to SSR\n-->\n\n<h3 id=\"server\">Updating the cache after a mutation</h3>\n\nBeing able to read and write to the Apollo cache from anywhere in your application gives you a lot of power over your data. However, there is one place where we most often want to update our cached data: after a mutation. As such, Apollo Client has optimized the experience for updating your cache with the read and write methods after a mutation with the `update` function. Let us say that we have the following GraphQL mutation:\n\n```graphql\nmutation TodoCreateMutation($text: String!) {\n  createTodo(text: $text) {\n    id\n    text\n    completed\n  }\n}\n```\n\nWe may also have the following GraphQL query:\n\n```graphql\nquery TodoAppQuery {\n  todos {\n    id\n    text\n    completed\n  }\n}\n```\n\nAt the end of our mutation we want our query to include the new todo like we had sent our `TodoAppQuery` a second time after the mutation finished without actually sending the query. To do this we can use the `update` function provided as an option of the `client.mutate` method. To update your cache with the mutation just write code that looks like:\n\n```js\n// We assume that the GraphQL operations `TodoCreateMutation` and\n// `TodoAppQuery` have already been defined using the `gql` tag.\n\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    // Read the data from our cache for this query.\n    const data = proxy.readQuery({ query: TodoAppQuery });\n\n    // Add our todo from the mutation to the end.\n    data.todos.push(createTodo);\n\n    // Write our data back to the cache.\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nThe first `proxy` argument is an instance of [`DataProxy`][] has the same four methods that we just learned exist on the Apollo Client: `readQuery`, `readFragment`, `writeQuery`, and `writeFragment`. The reason we call them on a `proxy` object here instead of on our `client` instance is that we can easily apply optimistic updates (which we will demonstrate in a bit). The `proxy` object also provides an isolated transaction which shields you from any other mutations going on at the same time, and the `proxy` object also batches writes together until the very end.\n\nIf you provide an `optimisticResponse` option to the mutation then the `update` function will be run twice. Once immediately after you call `client.mutate` with the data from `optimisticResponse`. After the mutation successfully executes against the server the changes made in the first call to `update` will be rolled back and `update` will be called with the *actual* data returned by the mutation and not just the optimistic response.\n\nPutting it all together:\n\n```js\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  optimisticResponse: {\n    id: -1, // -1 is a temporary id for the optimistic response.\n    text,\n    completed: false,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    const data = proxy.readQuery({ query: TodoAppQuery });\n    data.todos.push(createTodo);\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nAs you can see the `update` function on `client.mutate` provides extra change management functionality specific to the use case of a mutation while still providing you the powerful data control APIs that are available on `client`.\n\nThe `update` function is not a good place for side-effects as it may be called multiple times. Also, you may not call any of the methods on `proxy` asynchronously.\n\n",
      "readmeFilename": "README.md",
      "_id": "apollo-cache-inmemory@1.3.0-beta.7",
      "_npmVersion": "6.3.0",
      "_nodeVersion": "8.11.3",
      "_npmUser": {
        "name": "benjamn",
        "email": "ben@benjamn.com"
      },
      "dist": {
        "integrity": "sha512-N61kl4P49EaHjwF0w/sy4k+r/9QohOPdU7EKngZZaoaMWrMEjBQMSaXotkETsYmktwaRn4hP4t601BB3MX6fSg==",
        "shasum": "30ee7b9bd77dd39580cbf661db689973d4c4cbd8",
        "tarball": "https://registry.npmjs.org/apollo-cache-inmemory/-/apollo-cache-inmemory-1.3.0-beta.7.tgz",
        "fileCount": 69,
        "unpackedSize": 468896,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJbaiwPCRA9TVsSAnZWagAA4fkP/j5T2+qWngggSSmAbKkA\nFUcp9u1pvx1XVuay96MQphc6VSOoZ+RUbBcaCzuAJRCVuZoPG0PuPb/DZta3\n49qvcd0wds/nU2yVzArrRDL9iUUj8UaSrVcJdtv+qLLaEREFsRsWLdwpCqJ9\nZ0M+pN6M4/+OY2DfZfLKdzLrhXo2ois0eiKm/l9nDaPe3EbpgN+EGrDkX6uT\nub4s/hCJOnapn1pho8YqqxzMX2+9xygimwy2XW8nsThHNV5Nq9BhNMH+gHbg\nxNhQwEfSQQGTpnTlbpiQNDYIdwcgKNwnmkyoornbD0O5c5K4U5si4xbNKhfO\n8luIEU8Cgfp9gGOFToeQz2k9rXEi+FbKMG2ZWX8d9AoYcTOtmocKKsWoyJGa\nOIaVmx5GQMT2RiQNa9va63D1j+2hEfNSUVCth8i66rcMLYZ3Gg5GzUFBE36Z\nafjXCktpMrJ1vq8XjkiPL7f6AiXII+8NfZcn47zQHVW66ev1t41dVu7cvYKq\nCKnCdFi4ZXOb69ajRqqDJ6i+04kte+yLZwGaDURLKFdkN0P4hkz1wxIh9D1l\nGlULzZx8YZ/u25d6bAd1XG7tSFRwWmxgj+U7xWeidr+9Jk4uIspjR/hf/Knv\nUEb1TJRsq8i+vKvmUeLT16GFU5XP550XI556sOY1jFkM/IwKqCHIzreNw4hc\nuA+C\r\n=743b\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIGMo2/RNgLqqnsaOsWrHcObFkRmkId4bSTm+9J2GbkglAiEA5rki5SXnh3lz0jZHzfroUiYzWGF2ZmaRTzxftLCO7I0="
          }
        ]
      },
      "maintainers": [
        {
          "email": "ben@benjamn.com",
          "name": "benjamn"
        },
        {
          "email": "james@meteor.com",
          "name": "jbaxleyiii"
        },
        {
          "email": "npm@meteor.com",
          "name": "mdg"
        },
        {
          "email": "peggyrayzis@gmail.com",
          "name": "peggyrayzis"
        }
      ],
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/apollo-cache-inmemory_1.3.0-beta.7_1533684751487_0.08814679015823357"
      },
      "_hasShrinkwrap": false
    },
    "1.2.6-alpha.14": {
      "name": "apollo-cache-inmemory",
      "version": "1.2.6-alpha.14",
      "description": "Core abstract of Caching layer for Apollo Client",
      "author": {
        "name": "James Baxley",
        "email": "james@meteor.com"
      },
      "contributors": [
        {
          "name": "James Baxley",
          "email": "james@meteor.com"
        },
        {
          "name": "Jonas Helfer",
          "email": "jonas@helfer.email"
        },
        {
          "name": "Sashko Stubailo",
          "email": "sashko@stubailo.com"
        },
        {
          "name": "James Burgess",
          "email": "jamesmillerburgess@gmail.com"
        },
        {
          "name": "Bazyli Brzóska",
          "email": "bazyli.brzoska@gmail.com"
        }
      ],
      "license": "MIT",
      "main": "./lib/bundle.umd.js",
      "module": "./lib/index.js",
      "jsnext:main": "./lib/index.js",
      "typings": "./lib/index.d.ts",
      "sideEffects": false,
      "repository": {
        "type": "git",
        "url": "git+https://github.com/apollographql/apollo-client.git"
      },
      "bugs": {
        "url": "https://github.com/apollographql/apollo-client/issues"
      },
      "homepage": "https://github.com/apollographql/apollo-client#readme",
      "scripts": {
        "coverage": "jest --coverage",
        "test": "jest",
        "lint": "tslint --type-check -p tsconfig.json src/*.ts",
        "prebuild": "npm run clean",
        "build": "tsc -p .",
        "postbuild": "npm run bundle",
        "bundle": "rollup -c rollup.config.js",
        "watch": "tsc -w -p .",
        "clean": "rimraf coverage/* && rimraf lib/*",
        "prepublishOnly": "npm run build",
        "build:browser": "browserify ./lib/bundle.umd.js --i apollo-cache --i apollo-utilities --i graphql -o=./lib/bundle.js && npm run minify:browser",
        "minify:browser": "uglifyjs -c -m -o ./lib/bundle.min.js -- ./lib/bundle.js",
        "filesize": "npm run build:browser"
      },
      "dependencies": {
        "apollo-cache": "1.1.13-alpha.14",
        "apollo-utilities": "1.0.17-alpha.14",
        "graphql-anywhere": "4.1.15-alpha.14"
      },
      "peerDependencies": {
        "graphql": "0.11.7 || ^0.12.0 || ^0.13.0"
      },
      "devDependencies": {
        "@types/graphql": "0.12.7",
        "@types/jest": "22.2.3",
        "@types/lodash": "4.14.116",
        "browserify": "15.2.0",
        "graphql": "0.13.2",
        "graphql-tag": "2.9.2",
        "jest": "23.0.0",
        "lodash": "4.17.10",
        "rimraf": "2.6.2",
        "rollup": "0.63.5",
        "ts-jest": "20.0.14",
        "tslint": "5.11.0",
        "typescript": "2.9.2",
        "uglify-js": "^3.4.6"
      },
      "jest": {
        "transform": {
          ".(ts|tsx)": "<rootDir>/node_modules/ts-jest/preprocessor.js"
        },
        "testRegex": "(/__tests__/.*|\\.(test|spec))\\.(ts|tsx|js)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "json"
        ],
        "testURL": "http://localhost"
      },
      "readme": "---\ntitle: InMemoryCache\ndescription: An explanation of `apollo-cache-inmemory`\n---\n\n`apollo-cache-inmemory` is the recommended cache implementation for Apollo Client 2.0. `InMemoryCache` is a normalized data store that supports all of Apollo Client 1.0's features without the dependency on Redux.\n\nIn some instances, you may need to manipulate the cache directly, such as updating the store after a mutation. We'll cover some common use cases [here](#recipes).\n\n<h2 id=\"installation\">Installation</h2>\n\n```\nnpm install apollo-cache-inmemory --save\n```\n\nAfter installing the package, you'll want to initialize the cache constructor. Then, you can pass in your newly created cache to ApolloClient.\n\n```js\nimport { InMemoryCache } from 'apollo-cache-inmemory';\nimport { HttpLink } from 'apollo-link-http';\nimport ApolloClient from 'apollo-client';\n\nconst cache = new InMemoryCache();\n\nconst client = new ApolloClient({\n  link: new HttpLink(),\n  cache\n});\n```\n\n<h2 id=\"configuration\">Configuration</h2>\n\nThe `InMemoryCache` constructor takes an optional config object with properties to customize your cache:\n\n- addTypename: A boolean to determine whether to add __typename to the document (default: `true`)\n- dataIdFromObject: A function that takes a data object and returns a unique identifier to be used when normalizing the data in the store. Learn more about how to customize `dataIdFromObject` in the [Normalization](#normalization) section.\n- fragmentMatcher: By default, the `InMemoryCache` uses a heuristic fragment matcher. If you are using fragments on unions and interfaces, you will need to use an `IntrospectionFragmentMatcher`. For more information, please read [our guide to setting up fragment matching for unions & interfaces](https://www.apollographql.com/docs/react/advanced/fragments.html#fragment-matcher).\n\n<h2 id=\"normalization\">Normalization</h2>\n\nThe `InMemoryCache` normalizes your data before saving it to the store by splitting the result into individual objects, creating a unique identifier for each object, and storing those objects in a flattened data structure. By default, `InMemoryCache` will attempt to use the commonly found primary keys of `id` and `_id` for the unique identifier if they exist along with `__typename` on an object.\n\nIf `id` and `_id` are not specified, or if `__typename` is not specified, `InMemoryCache` will fall back to the path to the object in the query, such as `ROOT_QUERY.allPeople.0` for the first record returned on the `allPeople` root query.\n\nThis \"getter\" behavior for unique identifiers can be configured manually via the `dataIdFromObject` option passed to the `InMemoryCache` constructor, so you can pick which field is used if some of your data follows unorthodox primary key conventions.\n\nFor example, if you wanted to key off of the `key` field for all of your data, you could configure `dataIdFromObject` like so:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => object.key\n});\n```\n\nThis also allows you to use different unique identifiers for different data types by keying off of the `__typename` property attached to every object typed by GraphQL.  For example:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => {\n    switch (object.__typename) {\n      case 'foo': return object.key; // use `key` as the primary key\n      case 'bar': return object.blah; // use `blah` as the priamry key\n      default: return object.id || object._id; // fall back to `id` and `_id` for all other types\n    }\n  }\n});\n```\n\n<h2 id=\"direct\">Direct Cache Access</h2>\n\nTo interact directly with your cache, you can use the Apollo Client class methods readQuery, readFragment, writeQuery, and writeFragment. These methods are available to us via the [`DataProxy` interface](https://github.com/apollographql/apollo-client/blob/master/packages/apollo-cache/src/types/DataProxy.ts). Accessing these methods will vary slightly based on your view layer implementation. If you are using React, you can wrap your component in the `withApollo` higher order component, which will give you access to `this.props.client`. From there, you can use the methods to control your data.\n\nAny code demonstration in the following sections will assume that we have already initialized an instance of  `ApolloClient` and that we have imported the `gql` tag from `graphql-tag`.\n\n<h3 id=\"readquery\">readQuery</h3>\n\nThe `readQuery` method is very similar to the [`query` method on `ApolloClient`][] except that `readQuery` will _never_ make a request to your GraphQL server. The `query` method, on the other hand, may send a request to your server if the appropriate data is not in your cache whereas `readQuery` will throw an error if the data is not in your cache. `readQuery` will _always_ read from the cache. You can use `readQuery` by giving it a GraphQL query like so:\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo {\n      todo(id: 5) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n});\n```\n\nIf all of the data needed to fulfill this read is in Apollo Client’s normalized data cache then a data object will be returned in the shape of the query you wanted to read. If not all of the data needed to fulfill this read is in Apollo Client’s cache then an error will be thrown instead, so make sure to only read data that you know you have!\n\nYou can also pass variables into `readQuery`.\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo($id: Int!) {\n      todo(id: $id) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n  variables: {\n    id: 5,\n  },\n});\n```\n\n<h3 id=\"readfragment\">readFragment</h3>\n\nThis method allows you great flexibility around the data in your cache. Whereas `readQuery` only allowed you to read data from your root query type, `readFragment` allows you to read data from _any node you have queried_. This is incredibly powerful. You use this method as follows:\n\n```js\nconst todo = client.readFragment({\n  id: ..., // `id` is any id that could be returned by `dataIdFromObject`.\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\nThe first argument is the id of the data you want to read from the cache. That id must be a value that was returned by the `dataIdFromObject` function you defined when initializing `ApolloClient`. So for example if you initialized `ApolloClient` like so:\n\n```js\nconst client = new ApolloClient({\n  ...,\n  dataIdFromObject: object => object.id,\n});\n```\n\n…and you requested a todo before with an id of `5`, then you can read that todo out of your cache with the following:\n\n```js\nconst todo = client.readFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\n> **Note:** Most people add a `__typename` to the id in `dataIdFromObject`. If you do this then don’t forget to add the `__typename` when you are reading a fragment as well. So for example your id may be `Todo_5` and not just `5`.\n\nIf a todo with that id does not exist in the cache you will get `null` back. If a todo of that id does exist in the cache, but that todo does not have the `text` field then an error will be thrown.\n\nThe beauty of `readFragment` is that the todo could have come from anywhere! The todo could have been selected as a singleton (`{ todo(id: 5) { ... } }`), the todo could have come from a list of todos (`{ todos { ... } }`), or the todo could have come from a mutation (`mutation { createTodo { ... } }`). As long as at some point your GraphQL server gave you a todo with the provided id and fields `id`, `text`, and `completed` you can read it from the cache at any part of your code.\n\n<h3 id=\"writequery-and-writefragment\">writeQuery` and `writeFragment</h3>\n\nNot only can you read arbitrary data from the Apollo Client cache, but you can also write any data that you would like to the cache. The methods you use to do this are `writeQuery` and `writeFragment`. They will allow you to change data in your local cache, but it is important to remember that *they will not change any data on your server*. If you reload your environment then changes made with `writeQuery` and `writeFragment` will disappear.\n\nThese methods have the same signature as their `readQuery` and `readFragment` counterparts except they also require an additional `data` variable. So for example, if you wanted to update the `completed` flag locally for your todo with id `'5'` you could execute the following:\n\n```js\nclient.writeFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      completed\n    }\n  `,\n  data: {\n    completed: true,\n  },\n});\n```\n\nAny subscriber to the Apollo Client store will instantly see this update and render new UI accordingly.\n\n> **Note:** Again, remember that using `writeQuery` or `writeFragment` only changes data *locally*. If you reload your environment then changes made with these methods will no longer exist.\n\nOr if you wanted to add a new todo to a list fetched from the server, you could use `readQuery` and `writeQuery` together.\n\n```js\nconst query = gql`\n  query MyTodoAppQuery {\n    todos {\n      id\n      text\n      completed\n    }\n  }\n`;\n\nconst data = client.readQuery({ query });\n\nconst myNewTodo = {\n  id: '6',\n  text: 'Start using Apollo Client.',\n  completed: false,\n};\n\nclient.writeQuery({\n  query,\n  data: {\n    todos: [...data.todos, myNewTodo],\n  },\n});\n```\n\n<h2 id=\"recipes\">Recipes</h2>\n\nHere are some common situations where you would need to access the cache directly. If you're manipulating the cache in an interesting way and would like your example to be featured, please send in a pull request!\n\n<h3 id=\"server\">Server side rendering</h3>\n\nFirst, you will need to initialize an `InMemoryCache` on the server and create an instance of `ApolloClient`. In the initial serialized HTML payload from the server, you should include a script tag that extracts the data from the cache.\n\n```js\n`<script>\n  window.__APOLLO_STATE__=${JSON.stringify(cache.extract())}\n</script>`\n```\n\nOn the client, you can rehydrate the cache using the initial data passed from the server:\n\n```js\ncache: new Cache().restore(window.__APOLLO_STATE__)\n```\n\nIf you would like to learn more about server side rendering, please check our our more in depth guide [here].\n<!---\nTODO (PEGGY): Add link to SSR\n-->\n\n<h3 id=\"server\">Updating the cache after a mutation</h3>\n\nBeing able to read and write to the Apollo cache from anywhere in your application gives you a lot of power over your data. However, there is one place where we most often want to update our cached data: after a mutation. As such, Apollo Client has optimized the experience for updating your cache with the read and write methods after a mutation with the `update` function. Let us say that we have the following GraphQL mutation:\n\n```graphql\nmutation TodoCreateMutation($text: String!) {\n  createTodo(text: $text) {\n    id\n    text\n    completed\n  }\n}\n```\n\nWe may also have the following GraphQL query:\n\n```graphql\nquery TodoAppQuery {\n  todos {\n    id\n    text\n    completed\n  }\n}\n```\n\nAt the end of our mutation we want our query to include the new todo like we had sent our `TodoAppQuery` a second time after the mutation finished without actually sending the query. To do this we can use the `update` function provided as an option of the `client.mutate` method. To update your cache with the mutation just write code that looks like:\n\n```js\n// We assume that the GraphQL operations `TodoCreateMutation` and\n// `TodoAppQuery` have already been defined using the `gql` tag.\n\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    // Read the data from our cache for this query.\n    const data = proxy.readQuery({ query: TodoAppQuery });\n\n    // Add our todo from the mutation to the end.\n    data.todos.push(createTodo);\n\n    // Write our data back to the cache.\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nThe first `proxy` argument is an instance of [`DataProxy`][] has the same four methods that we just learned exist on the Apollo Client: `readQuery`, `readFragment`, `writeQuery`, and `writeFragment`. The reason we call them on a `proxy` object here instead of on our `client` instance is that we can easily apply optimistic updates (which we will demonstrate in a bit). The `proxy` object also provides an isolated transaction which shields you from any other mutations going on at the same time, and the `proxy` object also batches writes together until the very end.\n\nIf you provide an `optimisticResponse` option to the mutation then the `update` function will be run twice. Once immediately after you call `client.mutate` with the data from `optimisticResponse`. After the mutation successfully executes against the server the changes made in the first call to `update` will be rolled back and `update` will be called with the *actual* data returned by the mutation and not just the optimistic response.\n\nPutting it all together:\n\n```js\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  optimisticResponse: {\n    id: -1, // -1 is a temporary id for the optimistic response.\n    text,\n    completed: false,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    const data = proxy.readQuery({ query: TodoAppQuery });\n    data.todos.push(createTodo);\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nAs you can see the `update` function on `client.mutate` provides extra change management functionality specific to the use case of a mutation while still providing you the powerful data control APIs that are available on `client`.\n\nThe `update` function is not a good place for side-effects as it may be called multiple times. Also, you may not call any of the methods on `proxy` asynchronously.\n\n",
      "readmeFilename": "README.md",
      "_id": "apollo-cache-inmemory@1.2.6-alpha.14",
      "_npmVersion": "6.2.0",
      "_nodeVersion": "10.6.0",
      "_npmUser": {
        "name": "mdg",
        "email": "npm@meteor.com"
      },
      "dist": {
        "integrity": "sha512-jYiOxfTSRVYMrt8ssl0parQJ/AQvIP3rfEz9DS3yZ+OYCoLQIbwFvrH0Y2slnCtWDBp//MkGcvPZf/Q215Mcgw==",
        "shasum": "a61590463c8f04fb1e8340f8544f7a47d15fb9a6",
        "tarball": "https://registry.npmjs.org/apollo-cache-inmemory/-/apollo-cache-inmemory-1.2.6-alpha.14.tgz",
        "fileCount": 61,
        "unpackedSize": 429133,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJbalMSCRA9TVsSAnZWagAAjz4QAJB8kgYcm13lGYmciwGS\n+xLW0Pcs8EQxbGUKJZfnOyGr8H/1P5nzNsgDxnwK8jY2C8u+9iKVWxQpjuKI\nLl+WXaP+2e5aR0Is27X08tTQcVZGP8AbdMphqVCYvvQ9836x7v7MQGn2NSXV\nxcczo44AgFn1zIuXCvY3vk2Ubd4XwBIk0tKwVvO0AyWqRSr0r5Eulvk8el69\nIJhjH2hn6q9v/HnLSU920Sq3jbqhYY+bntp3kgHW0My32HGJS1IV21Xi21Xt\noWlYNXc60gdZ0Enrzpz+bfi/LNDlIn0rXz8xiAOT2o0k8NqH6cxewG76O06X\n2W5c4zqpsNKqrsoRh5V8V9K32HcgBis7mmWRO9Qpl6QbPWAsVUZGexSSbviS\nzfNC3SUVlZqouxVB1mVI6iK17DYjeAIGYenaMeqIGCOEdGvsFuk7xwOOfMb+\nh7WnFZt5qdeCFta695hPHIlM3Wa/Z71L2kLfyKUayh6jPyxeb0R05Qo5M/lT\nkDWZ0a6yb6+iy379HAvvmw0ziTlgW3oh+UWP/lKgv/+8x3nxQ0C+ZHWk7izy\nxsM8qSpOMxmUSaevyyUfX0rrs7RsuqB4a3QnlmKMgb+1UYmhYRMVXFI3VJ89\nz3NBJonYIsLUoM6zGIw6K1emtX9gGt7/QaKUEy0NWV8mWteqmgWk4JohpqL8\nwRBD\r\n=Umj0\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEYCIQCDtEaKcTaqxXEQyXWP1f0o4VVoXpXhBNAraf8QDJ6sugIhAKpUlkg0LdYkV+fdrKdRvtYlHB+WIl+eeTuoU6O9KGZn"
          }
        ]
      },
      "maintainers": [
        {
          "email": "ben@benjamn.com",
          "name": "benjamn"
        },
        {
          "email": "james@meteor.com",
          "name": "jbaxleyiii"
        },
        {
          "email": "npm@meteor.com",
          "name": "mdg"
        },
        {
          "email": "peggyrayzis@gmail.com",
          "name": "peggyrayzis"
        }
      ],
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/apollo-cache-inmemory_1.2.6-alpha.14_1533694738176_0.38076673397401595"
      },
      "_hasShrinkwrap": false
    },
    "1.2.7": {
      "name": "apollo-cache-inmemory",
      "version": "1.2.7",
      "description": "Core abstract of Caching layer for Apollo Client",
      "author": {
        "name": "James Baxley",
        "email": "james@meteor.com"
      },
      "contributors": [
        {
          "name": "James Baxley",
          "email": "james@meteor.com"
        },
        {
          "name": "Jonas Helfer",
          "email": "jonas@helfer.email"
        },
        {
          "name": "Sashko Stubailo",
          "email": "sashko@stubailo.com"
        },
        {
          "name": "James Burgess",
          "email": "jamesmillerburgess@gmail.com"
        },
        {
          "name": "Bazyli Brzóska",
          "email": "bazyli.brzoska@gmail.com"
        }
      ],
      "license": "MIT",
      "main": "./lib/bundle.umd.js",
      "module": "./lib/index.js",
      "jsnext:main": "./lib/index.js",
      "typings": "./lib/index.d.ts",
      "sideEffects": false,
      "repository": {
        "type": "git",
        "url": "git+https://github.com/apollographql/apollo-client.git"
      },
      "bugs": {
        "url": "https://github.com/apollographql/apollo-client/issues"
      },
      "homepage": "https://github.com/apollographql/apollo-client#readme",
      "scripts": {
        "coverage": "jest --coverage",
        "test": "jest",
        "lint": "tslint --type-check -p tsconfig.json src/*.ts",
        "prebuild": "npm run clean",
        "build": "tsc -p .",
        "postbuild": "npm run bundle",
        "bundle": "rollup -c rollup.config.js",
        "watch": "tsc -w -p .",
        "clean": "rimraf coverage/* && rimraf lib/*",
        "prepublishOnly": "npm run build",
        "build:browser": "browserify ./lib/bundle.umd.js --i apollo-cache --i apollo-utilities --i graphql -o=./lib/bundle.js && npm run minify:browser",
        "minify:browser": "uglifyjs -c -m -o ./lib/bundle.min.js -- ./lib/bundle.js",
        "filesize": "npm run build:browser"
      },
      "dependencies": {
        "apollo-cache": "^1.1.14",
        "apollo-utilities": "^1.0.18",
        "graphql-anywhere": "^4.1.16"
      },
      "peerDependencies": {
        "graphql": "0.11.7 || ^0.12.0 || ^0.13.0"
      },
      "devDependencies": {
        "@types/graphql": "0.12.7",
        "@types/jest": "22.2.3",
        "@types/lodash": "4.14.116",
        "browserify": "15.2.0",
        "graphql": "0.13.2",
        "graphql-tag": "2.9.2",
        "jest": "23.0.0",
        "lodash": "4.17.10",
        "rimraf": "2.6.2",
        "rollup": "0.64.1",
        "ts-jest": "20.0.14",
        "tslint": "5.11.0",
        "typescript": "2.9.2",
        "uglify-js": "^3.4.6"
      },
      "jest": {
        "transform": {
          ".(ts|tsx)": "<rootDir>/node_modules/ts-jest/preprocessor.js"
        },
        "testRegex": "(/__tests__/.*|\\.(test|spec))\\.(ts|tsx|js)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "json"
        ],
        "testURL": "http://localhost"
      },
      "_id": "apollo-cache-inmemory@1.2.7",
      "_npmVersion": "5.6.0",
      "_nodeVersion": "8.11.2",
      "_npmUser": {
        "name": "mdg",
        "email": "npm@meteor.com"
      },
      "dist": {
        "integrity": "sha512-ikL3hWsd1DejiZSAuiGnX6TG3cKAZmkMTZZfNZggp9vcTa47kfPqms/pX0F4iajCJP/p7/AllhbpsQ3zVMOZGg==",
        "shasum": "80517c4b5e910022ab8d318f47d9364f99db8541",
        "tarball": "https://registry.npmjs.org/apollo-cache-inmemory/-/apollo-cache-inmemory-1.2.7.tgz",
        "fileCount": 61,
        "unpackedSize": 429110,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJbbC83CRA9TVsSAnZWagAA5XYP/1XONIJ76PbypL7CAWFq\nTGYOtw9PtQ1J0jdvf/RUlsRr1/WG2d0vQ6cNol+2QfJazGXW/gDjI8TONEDR\nAYAH7TlppfJ4pft5Kp/ZOTl9zfPgv7/kG/htO1i7VNLvqok2zIe1RRoe2ciO\nECCoVr8s8w6zAMyfiTnKQBieIxR3co+FSnEWcU+ucBRuwZ3h5Sx+qathBb5k\nnVRlttOtPeFKGYZD5aXgFEIfohyNV6qbPmSrDDeMU8OG/9udzpqBWvykqCWS\nkfvUkK8XkG68CbPBk+WD5iYNSBVVg4Al1/mhF4nuqycYJ+W2y4RlnyKdgGO+\nGgdC8W41hB3M7JvLNalHb4udsGIjC6weGEdWtLhkU+wp3NexNfnpgYPJJ0Kk\nMOL6+NPA6NWSgwwnyCBa7BvSQCAa382YxqjMHI9o1LdnLoTMZQtDa2OvXfRO\nR2+4EeLUJ5dVHOMb8pMcYdd2G4uFalfRS0gtzi0dsxu0EMD2JIgr4UaBoA/b\nfEzgRYSwTKM+x5ecqRM48tmjlO9XpxmRtL3NMVxDvjqv6yj2vrh1vmqTUMRh\np7alpPQvVTH7rAVagufXPJShlyLq47lBnqVvDIwt3jBRDGcHsdBYh/h5MWYC\nPjkPUx3K+3iOMT+wOT6XYZ7dqEFjjtC9ppnMmrgxg0A516Jma35raMDB+JZW\nlkMg\r\n=0kLK\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEYCIQDIEiUmN5c/dyc2aWDiBqr+WcreFe7b1QB9IkWAK7Ox4wIhAL/Ga+AeshgIJDrm3KR/CkI2W2iqTUHqEOSGYhuh4aAD"
          }
        ]
      },
      "maintainers": [
        {
          "email": "ben@benjamn.com",
          "name": "benjamn"
        },
        {
          "email": "james@meteor.com",
          "name": "jbaxleyiii"
        },
        {
          "email": "npm@meteor.com",
          "name": "mdg"
        },
        {
          "email": "peggyrayzis@gmail.com",
          "name": "peggyrayzis"
        }
      ],
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/apollo-cache-inmemory_1.2.7_1533816630270_0.08668146778217078"
      },
      "_hasShrinkwrap": false
    },
    "1.2.8": {
      "name": "apollo-cache-inmemory",
      "version": "1.2.8",
      "description": "Core abstract of Caching layer for Apollo Client",
      "author": {
        "name": "James Baxley",
        "email": "james@meteor.com"
      },
      "contributors": [
        {
          "name": "James Baxley",
          "email": "james@meteor.com"
        },
        {
          "name": "Jonas Helfer",
          "email": "jonas@helfer.email"
        },
        {
          "name": "Sashko Stubailo",
          "email": "sashko@stubailo.com"
        },
        {
          "name": "James Burgess",
          "email": "jamesmillerburgess@gmail.com"
        },
        {
          "name": "Bazyli Brzóska",
          "email": "bazyli.brzoska@gmail.com"
        }
      ],
      "license": "MIT",
      "main": "./lib/bundle.umd.js",
      "module": "./lib/index.js",
      "jsnext:main": "./lib/index.js",
      "typings": "./lib/index.d.ts",
      "sideEffects": false,
      "repository": {
        "type": "git",
        "url": "git+https://github.com/apollographql/apollo-client.git"
      },
      "bugs": {
        "url": "https://github.com/apollographql/apollo-client/issues"
      },
      "homepage": "https://github.com/apollographql/apollo-client#readme",
      "scripts": {
        "coverage": "jest --coverage",
        "test": "jest",
        "lint": "tslint --type-check -p tsconfig.json src/*.ts",
        "prebuild": "npm run clean",
        "build": "tsc -p .",
        "postbuild": "npm run bundle",
        "bundle": "rollup -c rollup.config.js",
        "watch": "tsc -w -p .",
        "clean": "rimraf coverage/* && rimraf lib/*",
        "prepublishOnly": "npm run build",
        "build:browser": "browserify ./lib/bundle.umd.js --i apollo-cache --i apollo-utilities --i graphql -o=./lib/bundle.js && npm run minify:browser",
        "minify:browser": "uglifyjs -c -m -o ./lib/bundle.min.js -- ./lib/bundle.js",
        "filesize": "npm run build:browser"
      },
      "dependencies": {
        "apollo-cache": "^1.1.15",
        "apollo-utilities": "^1.0.19",
        "graphql-anywhere": "^4.1.17"
      },
      "peerDependencies": {
        "graphql": "0.11.7 || ^0.12.0 || ^0.13.0"
      },
      "devDependencies": {
        "@types/graphql": "0.12.7",
        "@types/jest": "23.3.1",
        "@types/lodash": "4.14.116",
        "browserify": "15.2.0",
        "graphql": "0.13.2",
        "graphql-tag": "2.9.2",
        "jest": "23.5.0",
        "lodash": "4.17.10",
        "rimraf": "2.6.2",
        "rollup": "0.64.1",
        "ts-jest": "23.1.3",
        "tslint": "5.11.0",
        "typescript": "3.0.1",
        "uglify-js": "3.4.7"
      },
      "jest": {
        "transform": {
          ".(ts|tsx)": "ts-jest"
        },
        "testRegex": "(/__tests__/.*|\\.(test|spec))\\.(ts|tsx|js)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "json"
        ],
        "testURL": "http://localhost"
      },
      "_id": "apollo-cache-inmemory@1.2.8",
      "_npmVersion": "5.6.0",
      "_nodeVersion": "8.11.2",
      "_npmUser": {
        "name": "mdg",
        "email": "npm@meteor.com"
      },
      "dist": {
        "integrity": "sha512-IlzG/A8NzSGn+7R05UJO/YdOlygA06V+qlTKrmMVPLrX2usaN7b9G65LHDePaVLM4GrOctFKJ9bfdeubNZcAVQ==",
        "shasum": "98be86fe7023dffd8ec86675c631a2b73e8c8308",
        "tarball": "https://registry.npmjs.org/apollo-cache-inmemory/-/apollo-cache-inmemory-1.2.8.tgz",
        "fileCount": 58,
        "unpackedSize": 428884,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJbdtUZCRA9TVsSAnZWagAAAKMP/1Wz5Du1Z4yoM4/UC3kG\nbvYz9z/fPKaed0f1ZFWMUX0sXEHBQtZZJPleooFEOwDyxitH4EwoD15QOXgw\n0NM6eTlcUmtvCvT+MrxiAP81bzZDF52xR2j8e5aK3x6jFTZ4Xnosc9X1jrmt\n9coriY/a4pKcbz0w4GDeLpbZz0eJiy48AHWhDjMu/pQ+nLQFk+AvgTOR4Prz\n98BQz6YCGw5Eua8D5XQPJMRtAl5Vdp08JyIDx9LT6WBNWgG9wGEf5yIZoOG0\nzGEJcm8E75Ba2uPu1dvSIMs8EuREHWpfocxomiwN/lEc6gO9DCXlvYaNjNJT\niHZ0HR33cvLgDVTknMaNJDns5tFfGBE8Xtj7lE/urSoI06uz2g81fcVd1jCY\n7T5LINW+XEdPnv+ujH3iCpjv2+J+maCsDLUiQVC3NYOpMjjX3Bcd6TCItP8S\nNZnAFkPhnbecI1h1gUqEQXOmd2sCGwdON8lndkFNEHok0QPW9V37a8Mtwvf0\n/KJML+iFFYXADIcF9k28Dq4K8fhzu9NpbAdzS95gcipUnFKI6bYq7m8eqet2\nZxxYA5yWJv/fsgAiE6h9pieh6hTfoR9X9695jabYFI6fL7Z8q+fOA5z9vJQ0\nqgBxscvehga8oZOZkYJOmpOwaYuf3QG3aH+MT668KFT7f0LSZecurLIZHj59\nNbf/\r\n=sOm4\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIQD0hnB88EZvaUbitVi/ePqchzDJfMCknBeXU2KjgIlSqwIgcmujb17lLimUEq7j5TPlwczr70LAZgmgqcIMxKWY0Ws="
          }
        ]
      },
      "maintainers": [
        {
          "email": "ben@benjamn.com",
          "name": "benjamn"
        },
        {
          "email": "james@meteor.com",
          "name": "jbaxleyiii"
        },
        {
          "email": "npm@meteor.com",
          "name": "mdg"
        },
        {
          "email": "peggyrayzis@gmail.com",
          "name": "peggyrayzis"
        }
      ],
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/apollo-cache-inmemory_1.2.8_1534514456803_0.7368981058372459"
      },
      "_hasShrinkwrap": false
    },
    "1.3.0-verify.1": {
      "name": "apollo-cache-inmemory",
      "version": "1.3.0-verify.1",
      "description": "Core abstract of Caching layer for Apollo Client",
      "author": {
        "name": "James Baxley",
        "email": "james@meteor.com"
      },
      "contributors": [
        {
          "name": "James Baxley",
          "email": "james@meteor.com"
        },
        {
          "name": "Jonas Helfer",
          "email": "jonas@helfer.email"
        },
        {
          "name": "Sashko Stubailo",
          "email": "sashko@stubailo.com"
        },
        {
          "name": "James Burgess",
          "email": "jamesmillerburgess@gmail.com"
        },
        {
          "name": "Bazyli Brzóska",
          "email": "bazyli.brzoska@gmail.com"
        }
      ],
      "license": "MIT",
      "main": "./lib/bundle.umd.js",
      "module": "./lib/index.js",
      "jsnext:main": "./lib/index.js",
      "typings": "./lib/index.d.ts",
      "sideEffects": false,
      "repository": {
        "type": "git",
        "url": "git+https://github.com/apollographql/apollo-client.git"
      },
      "bugs": {
        "url": "https://github.com/apollographql/apollo-client/issues"
      },
      "homepage": "https://github.com/apollographql/apollo-client#readme",
      "scripts": {
        "prepare": "npm run lint && npm run build",
        "coverage": "jest --coverage",
        "test": "jest",
        "lint": "tslint -c \"../../config/tslint.json\" -p tsconfig.json src/*.ts",
        "prebuild": "npm run clean",
        "build": "tsc -p .",
        "postbuild": "npm run bundle",
        "bundle": "../../node_modules/rollup/bin/rollup -c rollup.config.js",
        "watch": "tsc -w -p .",
        "clean": "rm -rf coverage/* && rm -rf lib/*",
        "prepublishOnly": "npm run build",
        "minify": "../../node_modules/uglify-js/bin/uglifyjs -c -m -o ./lib/bundle.min.js -- ./lib/bundle.umd.js",
        "filesize": "npm run minify"
      },
      "dependencies": {
        "apollo-cache": "^1.2.0-verify.1",
        "apollo-utilities": "^1.1.0-verify.1",
        "graphql-anywhere": "^4.2.0-verify.1"
      },
      "peerDependencies": {
        "graphql": "0.11.7 || ^0.12.0 || ^0.13.0"
      },
      "jest": {
        "transform": {
          ".(ts|tsx)": "ts-jest"
        },
        "testRegex": "(/__tests__/.*|\\.(test|spec))\\.(ts|tsx|js)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "json"
        ],
        "testURL": "http://localhost"
      },
      "gitHead": "b37faabb6f20de0f5dddbeccbb1a5f3eb608ac68",
      "readme": "---\ntitle: InMemoryCache\ndescription: An explanation of `apollo-cache-inmemory`\n---\n\n`apollo-cache-inmemory` is the recommended cache implementation for Apollo Client 2.0. `InMemoryCache` is a normalized data store that supports all of Apollo Client 1.0's features without the dependency on Redux.\n\nIn some instances, you may need to manipulate the cache directly, such as updating the store after a mutation. We'll cover some common use cases [here](#recipes).\n\n<h2 id=\"installation\">Installation</h2>\n\n```\nnpm install apollo-cache-inmemory --save\n```\n\nAfter installing the package, you'll want to initialize the cache constructor. Then, you can pass in your newly created cache to ApolloClient.\n\n```js\nimport { InMemoryCache } from 'apollo-cache-inmemory';\nimport { HttpLink } from 'apollo-link-http';\nimport ApolloClient from 'apollo-client';\n\nconst cache = new InMemoryCache();\n\nconst client = new ApolloClient({\n  link: new HttpLink(),\n  cache\n});\n```\n\n<h2 id=\"configuration\">Configuration</h2>\n\nThe `InMemoryCache` constructor takes an optional config object with properties to customize your cache:\n\n- addTypename: A boolean to determine whether to add __typename to the document (default: `true`)\n- dataIdFromObject: A function that takes a data object and returns a unique identifier to be used when normalizing the data in the store. Learn more about how to customize `dataIdFromObject` in the [Normalization](#normalization) section.\n- fragmentMatcher: By default, the `InMemoryCache` uses a heuristic fragment matcher. If you are using fragments on unions and interfaces, you will need to use an `IntrospectionFragmentMatcher`. For more information, please read [our guide to setting up fragment matching for unions & interfaces](https://www.apollographql.com/docs/react/advanced/fragments.html#fragment-matcher).\n\n<h2 id=\"normalization\">Normalization</h2>\n\nThe `InMemoryCache` normalizes your data before saving it to the store by splitting the result into individual objects, creating a unique identifier for each object, and storing those objects in a flattened data structure. By default, `InMemoryCache` will attempt to use the commonly found primary keys of `id` and `_id` for the unique identifier if they exist along with `__typename` on an object.\n\nIf `id` and `_id` are not specified, or if `__typename` is not specified, `InMemoryCache` will fall back to the path to the object in the query, such as `ROOT_QUERY.allPeople.0` for the first record returned on the `allPeople` root query.\n\nThis \"getter\" behavior for unique identifiers can be configured manually via the `dataIdFromObject` option passed to the `InMemoryCache` constructor, so you can pick which field is used if some of your data follows unorthodox primary key conventions.\n\nFor example, if you wanted to key off of the `key` field for all of your data, you could configure `dataIdFromObject` like so:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => object.key\n});\n```\n\nThis also allows you to use different unique identifiers for different data types by keying off of the `__typename` property attached to every object typed by GraphQL.  For example:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => {\n    switch (object.__typename) {\n      case 'foo': return object.key; // use `key` as the primary key\n      case 'bar': return object.blah; // use `blah` as the priamry key\n      default: return object.id || object._id; // fall back to `id` and `_id` for all other types\n    }\n  }\n});\n```\n\n<h2 id=\"direct\">Direct Cache Access</h2>\n\nTo interact directly with your cache, you can use the Apollo Client class methods readQuery, readFragment, writeQuery, and writeFragment. These methods are available to us via the [`DataProxy` interface](https://github.com/apollographql/apollo-client/blob/master/packages/apollo-cache/src/types/DataProxy.ts). Accessing these methods will vary slightly based on your view layer implementation. If you are using React, you can wrap your component in the `withApollo` higher order component, which will give you access to `this.props.client`. From there, you can use the methods to control your data.\n\nAny code demonstration in the following sections will assume that we have already initialized an instance of  `ApolloClient` and that we have imported the `gql` tag from `graphql-tag`.\n\n<h3 id=\"readquery\">readQuery</h3>\n\nThe `readQuery` method is very similar to the [`query` method on `ApolloClient`][] except that `readQuery` will _never_ make a request to your GraphQL server. The `query` method, on the other hand, may send a request to your server if the appropriate data is not in your cache whereas `readQuery` will throw an error if the data is not in your cache. `readQuery` will _always_ read from the cache. You can use `readQuery` by giving it a GraphQL query like so:\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo {\n      todo(id: 5) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n});\n```\n\nIf all of the data needed to fulfill this read is in Apollo Client’s normalized data cache then a data object will be returned in the shape of the query you wanted to read. If not all of the data needed to fulfill this read is in Apollo Client’s cache then an error will be thrown instead, so make sure to only read data that you know you have!\n\nYou can also pass variables into `readQuery`.\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo($id: Int!) {\n      todo(id: $id) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n  variables: {\n    id: 5,\n  },\n});\n```\n\n<h3 id=\"readfragment\">readFragment</h3>\n\nThis method allows you great flexibility around the data in your cache. Whereas `readQuery` only allowed you to read data from your root query type, `readFragment` allows you to read data from _any node you have queried_. This is incredibly powerful. You use this method as follows:\n\n```js\nconst todo = client.readFragment({\n  id: ..., // `id` is any id that could be returned by `dataIdFromObject`.\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\nThe first argument is the id of the data you want to read from the cache. That id must be a value that was returned by the `dataIdFromObject` function you defined when initializing `ApolloClient`. So for example if you initialized `ApolloClient` like so:\n\n```js\nconst client = new ApolloClient({\n  ...,\n  dataIdFromObject: object => object.id,\n});\n```\n\n…and you requested a todo before with an id of `5`, then you can read that todo out of your cache with the following:\n\n```js\nconst todo = client.readFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\n> **Note:** Most people add a `__typename` to the id in `dataIdFromObject`. If you do this then don’t forget to add the `__typename` when you are reading a fragment as well. So for example your id may be `Todo_5` and not just `5`.\n\nIf a todo with that id does not exist in the cache you will get `null` back. If a todo of that id does exist in the cache, but that todo does not have the `text` field then an error will be thrown.\n\nThe beauty of `readFragment` is that the todo could have come from anywhere! The todo could have been selected as a singleton (`{ todo(id: 5) { ... } }`), the todo could have come from a list of todos (`{ todos { ... } }`), or the todo could have come from a mutation (`mutation { createTodo { ... } }`). As long as at some point your GraphQL server gave you a todo with the provided id and fields `id`, `text`, and `completed` you can read it from the cache at any part of your code.\n\n<h3 id=\"writequery-and-writefragment\">writeQuery` and `writeFragment</h3>\n\nNot only can you read arbitrary data from the Apollo Client cache, but you can also write any data that you would like to the cache. The methods you use to do this are `writeQuery` and `writeFragment`. They will allow you to change data in your local cache, but it is important to remember that *they will not change any data on your server*. If you reload your environment then changes made with `writeQuery` and `writeFragment` will disappear.\n\nThese methods have the same signature as their `readQuery` and `readFragment` counterparts except they also require an additional `data` variable. So for example, if you wanted to update the `completed` flag locally for your todo with id `'5'` you could execute the following:\n\n```js\nclient.writeFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      completed\n    }\n  `,\n  data: {\n    completed: true,\n  },\n});\n```\n\nAny subscriber to the Apollo Client store will instantly see this update and render new UI accordingly.\n\n> **Note:** Again, remember that using `writeQuery` or `writeFragment` only changes data *locally*. If you reload your environment then changes made with these methods will no longer exist.\n\nOr if you wanted to add a new todo to a list fetched from the server, you could use `readQuery` and `writeQuery` together.\n\n```js\nconst query = gql`\n  query MyTodoAppQuery {\n    todos {\n      id\n      text\n      completed\n    }\n  }\n`;\n\nconst data = client.readQuery({ query });\n\nconst myNewTodo = {\n  id: '6',\n  text: 'Start using Apollo Client.',\n  completed: false,\n};\n\nclient.writeQuery({\n  query,\n  data: {\n    todos: [...data.todos, myNewTodo],\n  },\n});\n```\n\n<h2 id=\"recipes\">Recipes</h2>\n\nHere are some common situations where you would need to access the cache directly. If you're manipulating the cache in an interesting way and would like your example to be featured, please send in a pull request!\n\n<h3 id=\"server\">Server side rendering</h3>\n\nFirst, you will need to initialize an `InMemoryCache` on the server and create an instance of `ApolloClient`. In the initial serialized HTML payload from the server, you should include a script tag that extracts the data from the cache.\n\n```js\n`<script>\n  window.__APOLLO_STATE__=${JSON.stringify(cache.extract())}\n</script>`\n```\n\nOn the client, you can rehydrate the cache using the initial data passed from the server:\n\n```js\ncache: new Cache().restore(window.__APOLLO_STATE__)\n```\n\nIf you would like to learn more about server side rendering, please check our our more in depth guide [here].\n<!---\nTODO (PEGGY): Add link to SSR\n-->\n\n<h3 id=\"server\">Updating the cache after a mutation</h3>\n\nBeing able to read and write to the Apollo cache from anywhere in your application gives you a lot of power over your data. However, there is one place where we most often want to update our cached data: after a mutation. As such, Apollo Client has optimized the experience for updating your cache with the read and write methods after a mutation with the `update` function. Let us say that we have the following GraphQL mutation:\n\n```graphql\nmutation TodoCreateMutation($text: String!) {\n  createTodo(text: $text) {\n    id\n    text\n    completed\n  }\n}\n```\n\nWe may also have the following GraphQL query:\n\n```graphql\nquery TodoAppQuery {\n  todos {\n    id\n    text\n    completed\n  }\n}\n```\n\nAt the end of our mutation we want our query to include the new todo like we had sent our `TodoAppQuery` a second time after the mutation finished without actually sending the query. To do this we can use the `update` function provided as an option of the `client.mutate` method. To update your cache with the mutation just write code that looks like:\n\n```js\n// We assume that the GraphQL operations `TodoCreateMutation` and\n// `TodoAppQuery` have already been defined using the `gql` tag.\n\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    // Read the data from our cache for this query.\n    const data = proxy.readQuery({ query: TodoAppQuery });\n\n    // Add our todo from the mutation to the end.\n    data.todos.push(createTodo);\n\n    // Write our data back to the cache.\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nThe first `proxy` argument is an instance of [`DataProxy`][] has the same four methods that we just learned exist on the Apollo Client: `readQuery`, `readFragment`, `writeQuery`, and `writeFragment`. The reason we call them on a `proxy` object here instead of on our `client` instance is that we can easily apply optimistic updates (which we will demonstrate in a bit). The `proxy` object also provides an isolated transaction which shields you from any other mutations going on at the same time, and the `proxy` object also batches writes together until the very end.\n\nIf you provide an `optimisticResponse` option to the mutation then the `update` function will be run twice. Once immediately after you call `client.mutate` with the data from `optimisticResponse`. After the mutation successfully executes against the server the changes made in the first call to `update` will be rolled back and `update` will be called with the *actual* data returned by the mutation and not just the optimistic response.\n\nPutting it all together:\n\n```js\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  optimisticResponse: {\n    id: -1, // -1 is a temporary id for the optimistic response.\n    text,\n    completed: false,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    const data = proxy.readQuery({ query: TodoAppQuery });\n    data.todos.push(createTodo);\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nAs you can see the `update` function on `client.mutate` provides extra change management functionality specific to the use case of a mutation while still providing you the powerful data control APIs that are available on `client`.\n\nThe `update` function is not a good place for side-effects as it may be called multiple times. Also, you may not call any of the methods on `proxy` asynchronously.\n\n",
      "readmeFilename": "README.md",
      "_id": "apollo-cache-inmemory@1.3.0-verify.1",
      "_npmVersion": "5.6.0",
      "_nodeVersion": "8.11.2",
      "_npmUser": {
        "name": "mdg",
        "email": "npm@meteor.com"
      },
      "dist": {
        "integrity": "sha512-nirGLuNZgeIZI0ms/7CbFJwCrfcfs/8STvrMDL6uUQv6S4hq+VkPI5zoSE0LZogvCQFYQwN+j8ZbPEs3QYZXjQ==",
        "shasum": "2c6fbc07ebddd387419f6733fa7edd1afac80c2d",
        "tarball": "https://registry.npmjs.org/apollo-cache-inmemory/-/apollo-cache-inmemory-1.3.0-verify.1.tgz",
        "fileCount": 69,
        "unpackedSize": 410910,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJbdvr/CRA9TVsSAnZWagAADroP/izQbjxsDLw+HO4+pn1G\n27uBqwJOCJk3o+EcT53nXpag6rDKYEJzKZvj9LZ3dl3t4+kCVmByiApSKvcn\n7CfgCHZ91OwpruTGJyXTx6TZxZI5qbxEIbYRvq5EAQUlhokmi/RC9I9diWBy\nIgIiX2AWk9JTyPkGuv3WcGblnT1njc/oOYIwBNu9YV9rjBS8bc1gaffHZ9qk\nIKh3AeTjQqguwfMIYmU21K5kpaQHzTW4Zxew8dHeDtUYQydGrezJcl1Rp5d2\nwQwEEYxynpGQPjKBgvKCamIAAjMTpI4yIvH18mPX141rlBu3sh2ojBzcjN40\nDJLEoV54NpeCLTMUTBWjQiRdA0kmvTd0O4DOJavGuKHJXbnXelIV1YKxt0eZ\nECjSB0czlGYgadFYsxumjQGDS070/32exfVOordj/E2czwbYXWPabGNN/F/0\n4QUwzaYaYqIgNADLSXgq6gJjrbZREp+hhY1ikIFj5+WxOyHhaf8uCp/p3B8o\ndC4K3YODnpJSsYUfLmmXfm3Xj+g8TWLUNSDGf0PasLcJoz8HqlxWJciQqqku\n91PNQqOO1VXXjitOnCrNIMjg6a0o9MlLaSHMOuxaOcWuolPoVioAytlcxiS7\nSQvApIASXh2GIKF0CXADaij64l6rAEDqIR52OBWH6u5S7r24BWc9bjmKy5j6\nG25n\r\n=3KOl\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIQDnUuNS/PtopSUWBRDySqHaCSNzZvg6CTuO/k6R1X6jKQIgQp66L5KFWdPn8njYZRbMMokO+/Jp0xpspfVDiZKc1MU="
          }
        ]
      },
      "maintainers": [
        {
          "email": "ben@benjamn.com",
          "name": "benjamn"
        },
        {
          "email": "james@meteor.com",
          "name": "jbaxleyiii"
        },
        {
          "email": "npm@meteor.com",
          "name": "mdg"
        },
        {
          "email": "peggyrayzis@gmail.com",
          "name": "peggyrayzis"
        }
      ],
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/apollo-cache-inmemory_1.3.0-verify.1_1534524159036_0.14339514682334498"
      },
      "_hasShrinkwrap": false
    },
    "1.3.0-verify.2": {
      "name": "apollo-cache-inmemory",
      "version": "1.3.0-verify.2",
      "description": "Core abstract of Caching layer for Apollo Client",
      "author": {
        "name": "James Baxley",
        "email": "james@meteor.com"
      },
      "contributors": [
        {
          "name": "James Baxley",
          "email": "james@meteor.com"
        },
        {
          "name": "Jonas Helfer",
          "email": "jonas@helfer.email"
        },
        {
          "name": "Sashko Stubailo",
          "email": "sashko@stubailo.com"
        },
        {
          "name": "James Burgess",
          "email": "jamesmillerburgess@gmail.com"
        },
        {
          "name": "Bazyli Brzóska",
          "email": "bazyli.brzoska@gmail.com"
        }
      ],
      "license": "MIT",
      "main": "./lib/bundle.umd.js",
      "module": "./lib/index.js",
      "jsnext:main": "./lib/index.js",
      "typings": "./lib/index.d.ts",
      "sideEffects": false,
      "repository": {
        "type": "git",
        "url": "git+https://github.com/apollographql/apollo-client.git"
      },
      "bugs": {
        "url": "https://github.com/apollographql/apollo-client/issues"
      },
      "homepage": "https://github.com/apollographql/apollo-client#readme",
      "scripts": {
        "prepare": "npm run lint && npm run build",
        "coverage": "jest --coverage",
        "test": "jest",
        "lint": "tslint -c \"../../config/tslint.json\" -p tsconfig.json src/*.ts",
        "prebuild": "npm run clean",
        "build": "tsc -p .",
        "postbuild": "npm run bundle",
        "bundle": "../../node_modules/rollup/bin/rollup -c rollup.config.js",
        "watch": "tsc -w -p .",
        "clean": "rm -rf coverage/* && rm -rf lib/*",
        "prepublishOnly": "npm run build",
        "minify": "../../node_modules/uglify-js/bin/uglifyjs -c -m -o ./lib/bundle.min.js -- ./lib/bundle.umd.js",
        "filesize": "npm run minify"
      },
      "dependencies": {
        "apollo-cache": "^1.2.0-verify.2",
        "apollo-utilities": "^1.1.0-verify.2",
        "graphql-anywhere": "^4.2.0-verify.2"
      },
      "peerDependencies": {
        "graphql": "0.11.7 || ^0.12.0 || ^0.13.0"
      },
      "jest": {
        "transform": {
          ".(ts|tsx)": "ts-jest"
        },
        "testRegex": "(/__tests__/.*|\\.(test|spec))\\.(ts|tsx|js)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "json"
        ],
        "testURL": "http://localhost"
      },
      "gitHead": "797a82a8b1e3aad73c479ef70dc255282780948d",
      "readme": "---\ntitle: InMemoryCache\ndescription: An explanation of `apollo-cache-inmemory`\n---\n\n`apollo-cache-inmemory` is the recommended cache implementation for Apollo Client 2.0. `InMemoryCache` is a normalized data store that supports all of Apollo Client 1.0's features without the dependency on Redux.\n\nIn some instances, you may need to manipulate the cache directly, such as updating the store after a mutation. We'll cover some common use cases [here](#recipes).\n\n<h2 id=\"installation\">Installation</h2>\n\n```\nnpm install apollo-cache-inmemory --save\n```\n\nAfter installing the package, you'll want to initialize the cache constructor. Then, you can pass in your newly created cache to ApolloClient.\n\n```js\nimport { InMemoryCache } from 'apollo-cache-inmemory';\nimport { HttpLink } from 'apollo-link-http';\nimport ApolloClient from 'apollo-client';\n\nconst cache = new InMemoryCache();\n\nconst client = new ApolloClient({\n  link: new HttpLink(),\n  cache\n});\n```\n\n<h2 id=\"configuration\">Configuration</h2>\n\nThe `InMemoryCache` constructor takes an optional config object with properties to customize your cache:\n\n- addTypename: A boolean to determine whether to add __typename to the document (default: `true`)\n- dataIdFromObject: A function that takes a data object and returns a unique identifier to be used when normalizing the data in the store. Learn more about how to customize `dataIdFromObject` in the [Normalization](#normalization) section.\n- fragmentMatcher: By default, the `InMemoryCache` uses a heuristic fragment matcher. If you are using fragments on unions and interfaces, you will need to use an `IntrospectionFragmentMatcher`. For more information, please read [our guide to setting up fragment matching for unions & interfaces](https://www.apollographql.com/docs/react/advanced/fragments.html#fragment-matcher).\n\n<h2 id=\"normalization\">Normalization</h2>\n\nThe `InMemoryCache` normalizes your data before saving it to the store by splitting the result into individual objects, creating a unique identifier for each object, and storing those objects in a flattened data structure. By default, `InMemoryCache` will attempt to use the commonly found primary keys of `id` and `_id` for the unique identifier if they exist along with `__typename` on an object.\n\nIf `id` and `_id` are not specified, or if `__typename` is not specified, `InMemoryCache` will fall back to the path to the object in the query, such as `ROOT_QUERY.allPeople.0` for the first record returned on the `allPeople` root query.\n\nThis \"getter\" behavior for unique identifiers can be configured manually via the `dataIdFromObject` option passed to the `InMemoryCache` constructor, so you can pick which field is used if some of your data follows unorthodox primary key conventions.\n\nFor example, if you wanted to key off of the `key` field for all of your data, you could configure `dataIdFromObject` like so:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => object.key\n});\n```\n\nThis also allows you to use different unique identifiers for different data types by keying off of the `__typename` property attached to every object typed by GraphQL.  For example:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => {\n    switch (object.__typename) {\n      case 'foo': return object.key; // use `key` as the primary key\n      case 'bar': return object.blah; // use `blah` as the priamry key\n      default: return object.id || object._id; // fall back to `id` and `_id` for all other types\n    }\n  }\n});\n```\n\n<h2 id=\"direct\">Direct Cache Access</h2>\n\nTo interact directly with your cache, you can use the Apollo Client class methods readQuery, readFragment, writeQuery, and writeFragment. These methods are available to us via the [`DataProxy` interface](https://github.com/apollographql/apollo-client/blob/master/packages/apollo-cache/src/types/DataProxy.ts). Accessing these methods will vary slightly based on your view layer implementation. If you are using React, you can wrap your component in the `withApollo` higher order component, which will give you access to `this.props.client`. From there, you can use the methods to control your data.\n\nAny code demonstration in the following sections will assume that we have already initialized an instance of  `ApolloClient` and that we have imported the `gql` tag from `graphql-tag`.\n\n<h3 id=\"readquery\">readQuery</h3>\n\nThe `readQuery` method is very similar to the [`query` method on `ApolloClient`][] except that `readQuery` will _never_ make a request to your GraphQL server. The `query` method, on the other hand, may send a request to your server if the appropriate data is not in your cache whereas `readQuery` will throw an error if the data is not in your cache. `readQuery` will _always_ read from the cache. You can use `readQuery` by giving it a GraphQL query like so:\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo {\n      todo(id: 5) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n});\n```\n\nIf all of the data needed to fulfill this read is in Apollo Client’s normalized data cache then a data object will be returned in the shape of the query you wanted to read. If not all of the data needed to fulfill this read is in Apollo Client’s cache then an error will be thrown instead, so make sure to only read data that you know you have!\n\nYou can also pass variables into `readQuery`.\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo($id: Int!) {\n      todo(id: $id) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n  variables: {\n    id: 5,\n  },\n});\n```\n\n<h3 id=\"readfragment\">readFragment</h3>\n\nThis method allows you great flexibility around the data in your cache. Whereas `readQuery` only allowed you to read data from your root query type, `readFragment` allows you to read data from _any node you have queried_. This is incredibly powerful. You use this method as follows:\n\n```js\nconst todo = client.readFragment({\n  id: ..., // `id` is any id that could be returned by `dataIdFromObject`.\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\nThe first argument is the id of the data you want to read from the cache. That id must be a value that was returned by the `dataIdFromObject` function you defined when initializing `ApolloClient`. So for example if you initialized `ApolloClient` like so:\n\n```js\nconst client = new ApolloClient({\n  ...,\n  dataIdFromObject: object => object.id,\n});\n```\n\n…and you requested a todo before with an id of `5`, then you can read that todo out of your cache with the following:\n\n```js\nconst todo = client.readFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\n> **Note:** Most people add a `__typename` to the id in `dataIdFromObject`. If you do this then don’t forget to add the `__typename` when you are reading a fragment as well. So for example your id may be `Todo_5` and not just `5`.\n\nIf a todo with that id does not exist in the cache you will get `null` back. If a todo of that id does exist in the cache, but that todo does not have the `text` field then an error will be thrown.\n\nThe beauty of `readFragment` is that the todo could have come from anywhere! The todo could have been selected as a singleton (`{ todo(id: 5) { ... } }`), the todo could have come from a list of todos (`{ todos { ... } }`), or the todo could have come from a mutation (`mutation { createTodo { ... } }`). As long as at some point your GraphQL server gave you a todo with the provided id and fields `id`, `text`, and `completed` you can read it from the cache at any part of your code.\n\n<h3 id=\"writequery-and-writefragment\">writeQuery` and `writeFragment</h3>\n\nNot only can you read arbitrary data from the Apollo Client cache, but you can also write any data that you would like to the cache. The methods you use to do this are `writeQuery` and `writeFragment`. They will allow you to change data in your local cache, but it is important to remember that *they will not change any data on your server*. If you reload your environment then changes made with `writeQuery` and `writeFragment` will disappear.\n\nThese methods have the same signature as their `readQuery` and `readFragment` counterparts except they also require an additional `data` variable. So for example, if you wanted to update the `completed` flag locally for your todo with id `'5'` you could execute the following:\n\n```js\nclient.writeFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      completed\n    }\n  `,\n  data: {\n    completed: true,\n  },\n});\n```\n\nAny subscriber to the Apollo Client store will instantly see this update and render new UI accordingly.\n\n> **Note:** Again, remember that using `writeQuery` or `writeFragment` only changes data *locally*. If you reload your environment then changes made with these methods will no longer exist.\n\nOr if you wanted to add a new todo to a list fetched from the server, you could use `readQuery` and `writeQuery` together.\n\n```js\nconst query = gql`\n  query MyTodoAppQuery {\n    todos {\n      id\n      text\n      completed\n    }\n  }\n`;\n\nconst data = client.readQuery({ query });\n\nconst myNewTodo = {\n  id: '6',\n  text: 'Start using Apollo Client.',\n  completed: false,\n};\n\nclient.writeQuery({\n  query,\n  data: {\n    todos: [...data.todos, myNewTodo],\n  },\n});\n```\n\n<h2 id=\"recipes\">Recipes</h2>\n\nHere are some common situations where you would need to access the cache directly. If you're manipulating the cache in an interesting way and would like your example to be featured, please send in a pull request!\n\n<h3 id=\"server\">Server side rendering</h3>\n\nFirst, you will need to initialize an `InMemoryCache` on the server and create an instance of `ApolloClient`. In the initial serialized HTML payload from the server, you should include a script tag that extracts the data from the cache.\n\n```js\n`<script>\n  window.__APOLLO_STATE__=${JSON.stringify(cache.extract())}\n</script>`\n```\n\nOn the client, you can rehydrate the cache using the initial data passed from the server:\n\n```js\ncache: new Cache().restore(window.__APOLLO_STATE__)\n```\n\nIf you would like to learn more about server side rendering, please check our our more in depth guide [here].\n<!---\nTODO (PEGGY): Add link to SSR\n-->\n\n<h3 id=\"server\">Updating the cache after a mutation</h3>\n\nBeing able to read and write to the Apollo cache from anywhere in your application gives you a lot of power over your data. However, there is one place where we most often want to update our cached data: after a mutation. As such, Apollo Client has optimized the experience for updating your cache with the read and write methods after a mutation with the `update` function. Let us say that we have the following GraphQL mutation:\n\n```graphql\nmutation TodoCreateMutation($text: String!) {\n  createTodo(text: $text) {\n    id\n    text\n    completed\n  }\n}\n```\n\nWe may also have the following GraphQL query:\n\n```graphql\nquery TodoAppQuery {\n  todos {\n    id\n    text\n    completed\n  }\n}\n```\n\nAt the end of our mutation we want our query to include the new todo like we had sent our `TodoAppQuery` a second time after the mutation finished without actually sending the query. To do this we can use the `update` function provided as an option of the `client.mutate` method. To update your cache with the mutation just write code that looks like:\n\n```js\n// We assume that the GraphQL operations `TodoCreateMutation` and\n// `TodoAppQuery` have already been defined using the `gql` tag.\n\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    // Read the data from our cache for this query.\n    const data = proxy.readQuery({ query: TodoAppQuery });\n\n    // Add our todo from the mutation to the end.\n    data.todos.push(createTodo);\n\n    // Write our data back to the cache.\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nThe first `proxy` argument is an instance of [`DataProxy`][] has the same four methods that we just learned exist on the Apollo Client: `readQuery`, `readFragment`, `writeQuery`, and `writeFragment`. The reason we call them on a `proxy` object here instead of on our `client` instance is that we can easily apply optimistic updates (which we will demonstrate in a bit). The `proxy` object also provides an isolated transaction which shields you from any other mutations going on at the same time, and the `proxy` object also batches writes together until the very end.\n\nIf you provide an `optimisticResponse` option to the mutation then the `update` function will be run twice. Once immediately after you call `client.mutate` with the data from `optimisticResponse`. After the mutation successfully executes against the server the changes made in the first call to `update` will be rolled back and `update` will be called with the *actual* data returned by the mutation and not just the optimistic response.\n\nPutting it all together:\n\n```js\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  optimisticResponse: {\n    id: -1, // -1 is a temporary id for the optimistic response.\n    text,\n    completed: false,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    const data = proxy.readQuery({ query: TodoAppQuery });\n    data.todos.push(createTodo);\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nAs you can see the `update` function on `client.mutate` provides extra change management functionality specific to the use case of a mutation while still providing you the powerful data control APIs that are available on `client`.\n\nThe `update` function is not a good place for side-effects as it may be called multiple times. Also, you may not call any of the methods on `proxy` asynchronously.\n\n",
      "readmeFilename": "README.md",
      "_id": "apollo-cache-inmemory@1.3.0-verify.2",
      "_npmVersion": "5.6.0",
      "_nodeVersion": "8.11.2",
      "_npmUser": {
        "name": "mdg",
        "email": "npm@meteor.com"
      },
      "dist": {
        "integrity": "sha512-VYYY61pgQeLfTJcdQFJ44MzMMk84JUEK6S3nQ/m2Le+miBJHtdTbAcOojeKsQ1DNwAGWTRwXgvoswWZXMmxtjw==",
        "shasum": "dfd00bd4f9f32cd7f0593f25527c36486aded0e3",
        "tarball": "https://registry.npmjs.org/apollo-cache-inmemory/-/apollo-cache-inmemory-1.3.0-verify.2.tgz",
        "fileCount": 69,
        "unpackedSize": 410910,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJbdwFcCRA9TVsSAnZWagAA340QAIA5IX+tYk2lhuSNHuy8\n9GCEbXpG212Fq+AutoUC7eae2RserPQQB+XmqpagqYp5jsrQbSCe2Z8YebNM\n51/Bwmtpucg/JoFliKphL3Lc8kIdXOOr1HALJQTwP1aowcI0ZPkfFCT2RxSE\nYUAxtmcRF2XUxy1BgwkwYpCbjVHiUJNZozTqvYz7Yjpg/qxw4y0QQ/g7vQrG\nvrxBjM1ju0t6MFOK7nBzup/NXV0WOCbu5vvW/y8lpHZyKGqjveMZ5ZL2u6uR\nfkE/B6d1xSMLcw+O+odKTOGEdvVmYnypGCD/0mHozZmfe6isOEfeYpqOPu1G\nyPyrD5RLpx5JgIPwzJe9lLJU/Szrf8BUrgFdmOTBLDDfUpgf8fYLfsQ01kF6\nCi0uYE9ib86Qfk9z6XuyZfO980q8VcIl5Fb+XNewsN5PfNyuxhHaeknddgqM\n+z81JaEnAALrgJSP4BuSDL4sIxAn8wZqoOQSv3cU3UTEDhhWzcB8WdsdBPLp\nusrNmEpl70putui69f5esc1cRl73EkKWeqC1R9XbYRyfTLr0h4ZIgthmd64j\nVCeqZkuHzu1/gr7zMfzTTLoRbGAMq98kpab1tohZvYqnGY+KcikbG2cI199J\nJcL7AJQn8Kz+Ro+1AeRHOQGx0bxLdwAxQor4qG6EUDzFPb7RVqbcBiBHRicq\nspTA\r\n=nQK1\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEYCIQCXFT29LLjibpB7fdJnpr+WgHDrbHKtsZZoUwOZYJq3uQIhAPHl8tXJ1i1NM9/dS4JIdNLGxzJ8tU4/yKJYtFT/vtLY"
          }
        ]
      },
      "maintainers": [
        {
          "email": "ben@benjamn.com",
          "name": "benjamn"
        },
        {
          "email": "james@meteor.com",
          "name": "jbaxleyiii"
        },
        {
          "email": "npm@meteor.com",
          "name": "mdg"
        },
        {
          "email": "peggyrayzis@gmail.com",
          "name": "peggyrayzis"
        }
      ],
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/apollo-cache-inmemory_1.3.0-verify.2_1534525788433_0.8347379841261993"
      },
      "_hasShrinkwrap": false
    },
    "1.3.0-verify.3": {
      "name": "apollo-cache-inmemory",
      "version": "1.3.0-verify.3",
      "description": "Core abstract of Caching layer for Apollo Client",
      "author": {
        "name": "James Baxley",
        "email": "james@meteor.com"
      },
      "contributors": [
        {
          "name": "James Baxley",
          "email": "james@meteor.com"
        },
        {
          "name": "Jonas Helfer",
          "email": "jonas@helfer.email"
        },
        {
          "name": "Sashko Stubailo",
          "email": "sashko@stubailo.com"
        },
        {
          "name": "James Burgess",
          "email": "jamesmillerburgess@gmail.com"
        },
        {
          "name": "Bazyli Brzóska",
          "email": "bazyli.brzoska@gmail.com"
        }
      ],
      "license": "MIT",
      "main": "./lib/bundle.umd.js",
      "module": "./lib/index.js",
      "jsnext:main": "./lib/index.js",
      "typings": "./lib/index.d.ts",
      "sideEffects": false,
      "repository": {
        "type": "git",
        "url": "git+https://github.com/apollographql/apollo-client.git"
      },
      "bugs": {
        "url": "https://github.com/apollographql/apollo-client/issues"
      },
      "homepage": "https://github.com/apollographql/apollo-client#readme",
      "scripts": {
        "prepare": "npm run lint && npm run build",
        "coverage": "jest --coverage",
        "test": "jest",
        "lint": "tslint -c \"../../config/tslint.json\" -p tsconfig.json src/*.ts",
        "prebuild": "npm run clean",
        "build": "tsc -p .",
        "postbuild": "npm run bundle",
        "bundle": "../../node_modules/rollup/bin/rollup -c rollup.config.js",
        "watch": "tsc -w -p .",
        "clean": "rm -rf coverage/* && rm -rf lib/*",
        "prepublishOnly": "npm run build",
        "minify": "../../node_modules/uglify-js/bin/uglifyjs -c -m -o ./lib/bundle.min.js -- ./lib/bundle.umd.js",
        "filesize": "npm run minify"
      },
      "dependencies": {
        "apollo-cache": "^1.2.0-verify.3",
        "apollo-utilities": "^1.1.0-verify.3",
        "graphql-anywhere": "^4.2.0-verify.3"
      },
      "peerDependencies": {
        "graphql": "0.11.7 || ^0.12.0 || ^0.13.0"
      },
      "jest": {
        "transform": {
          ".(ts|tsx)": "ts-jest"
        },
        "testRegex": "(/__tests__/.*|\\.(test|spec))\\.(ts|tsx|js)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "json"
        ],
        "testURL": "http://localhost"
      },
      "gitHead": "4524d36d457da4ea34b8f28048a16b67bffa294c",
      "readme": "---\ntitle: InMemoryCache\ndescription: An explanation of `apollo-cache-inmemory`\n---\n\n`apollo-cache-inmemory` is the recommended cache implementation for Apollo Client 2.0. `InMemoryCache` is a normalized data store that supports all of Apollo Client 1.0's features without the dependency on Redux.\n\nIn some instances, you may need to manipulate the cache directly, such as updating the store after a mutation. We'll cover some common use cases [here](#recipes).\n\n<h2 id=\"installation\">Installation</h2>\n\n```\nnpm install apollo-cache-inmemory --save\n```\n\nAfter installing the package, you'll want to initialize the cache constructor. Then, you can pass in your newly created cache to ApolloClient.\n\n```js\nimport { InMemoryCache } from 'apollo-cache-inmemory';\nimport { HttpLink } from 'apollo-link-http';\nimport ApolloClient from 'apollo-client';\n\nconst cache = new InMemoryCache();\n\nconst client = new ApolloClient({\n  link: new HttpLink(),\n  cache\n});\n```\n\n<h2 id=\"configuration\">Configuration</h2>\n\nThe `InMemoryCache` constructor takes an optional config object with properties to customize your cache:\n\n- addTypename: A boolean to determine whether to add __typename to the document (default: `true`)\n- dataIdFromObject: A function that takes a data object and returns a unique identifier to be used when normalizing the data in the store. Learn more about how to customize `dataIdFromObject` in the [Normalization](#normalization) section.\n- fragmentMatcher: By default, the `InMemoryCache` uses a heuristic fragment matcher. If you are using fragments on unions and interfaces, you will need to use an `IntrospectionFragmentMatcher`. For more information, please read [our guide to setting up fragment matching for unions & interfaces](https://www.apollographql.com/docs/react/advanced/fragments.html#fragment-matcher).\n\n<h2 id=\"normalization\">Normalization</h2>\n\nThe `InMemoryCache` normalizes your data before saving it to the store by splitting the result into individual objects, creating a unique identifier for each object, and storing those objects in a flattened data structure. By default, `InMemoryCache` will attempt to use the commonly found primary keys of `id` and `_id` for the unique identifier if they exist along with `__typename` on an object.\n\nIf `id` and `_id` are not specified, or if `__typename` is not specified, `InMemoryCache` will fall back to the path to the object in the query, such as `ROOT_QUERY.allPeople.0` for the first record returned on the `allPeople` root query.\n\nThis \"getter\" behavior for unique identifiers can be configured manually via the `dataIdFromObject` option passed to the `InMemoryCache` constructor, so you can pick which field is used if some of your data follows unorthodox primary key conventions.\n\nFor example, if you wanted to key off of the `key` field for all of your data, you could configure `dataIdFromObject` like so:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => object.key\n});\n```\n\nThis also allows you to use different unique identifiers for different data types by keying off of the `__typename` property attached to every object typed by GraphQL.  For example:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => {\n    switch (object.__typename) {\n      case 'foo': return object.key; // use `key` as the primary key\n      case 'bar': return object.blah; // use `blah` as the priamry key\n      default: return object.id || object._id; // fall back to `id` and `_id` for all other types\n    }\n  }\n});\n```\n\n<h2 id=\"direct\">Direct Cache Access</h2>\n\nTo interact directly with your cache, you can use the Apollo Client class methods readQuery, readFragment, writeQuery, and writeFragment. These methods are available to us via the [`DataProxy` interface](https://github.com/apollographql/apollo-client/blob/master/packages/apollo-cache/src/types/DataProxy.ts). Accessing these methods will vary slightly based on your view layer implementation. If you are using React, you can wrap your component in the `withApollo` higher order component, which will give you access to `this.props.client`. From there, you can use the methods to control your data.\n\nAny code demonstration in the following sections will assume that we have already initialized an instance of  `ApolloClient` and that we have imported the `gql` tag from `graphql-tag`.\n\n<h3 id=\"readquery\">readQuery</h3>\n\nThe `readQuery` method is very similar to the [`query` method on `ApolloClient`][] except that `readQuery` will _never_ make a request to your GraphQL server. The `query` method, on the other hand, may send a request to your server if the appropriate data is not in your cache whereas `readQuery` will throw an error if the data is not in your cache. `readQuery` will _always_ read from the cache. You can use `readQuery` by giving it a GraphQL query like so:\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo {\n      todo(id: 5) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n});\n```\n\nIf all of the data needed to fulfill this read is in Apollo Client’s normalized data cache then a data object will be returned in the shape of the query you wanted to read. If not all of the data needed to fulfill this read is in Apollo Client’s cache then an error will be thrown instead, so make sure to only read data that you know you have!\n\nYou can also pass variables into `readQuery`.\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo($id: Int!) {\n      todo(id: $id) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n  variables: {\n    id: 5,\n  },\n});\n```\n\n<h3 id=\"readfragment\">readFragment</h3>\n\nThis method allows you great flexibility around the data in your cache. Whereas `readQuery` only allowed you to read data from your root query type, `readFragment` allows you to read data from _any node you have queried_. This is incredibly powerful. You use this method as follows:\n\n```js\nconst todo = client.readFragment({\n  id: ..., // `id` is any id that could be returned by `dataIdFromObject`.\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\nThe first argument is the id of the data you want to read from the cache. That id must be a value that was returned by the `dataIdFromObject` function you defined when initializing `ApolloClient`. So for example if you initialized `ApolloClient` like so:\n\n```js\nconst client = new ApolloClient({\n  ...,\n  dataIdFromObject: object => object.id,\n});\n```\n\n…and you requested a todo before with an id of `5`, then you can read that todo out of your cache with the following:\n\n```js\nconst todo = client.readFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\n> **Note:** Most people add a `__typename` to the id in `dataIdFromObject`. If you do this then don’t forget to add the `__typename` when you are reading a fragment as well. So for example your id may be `Todo_5` and not just `5`.\n\nIf a todo with that id does not exist in the cache you will get `null` back. If a todo of that id does exist in the cache, but that todo does not have the `text` field then an error will be thrown.\n\nThe beauty of `readFragment` is that the todo could have come from anywhere! The todo could have been selected as a singleton (`{ todo(id: 5) { ... } }`), the todo could have come from a list of todos (`{ todos { ... } }`), or the todo could have come from a mutation (`mutation { createTodo { ... } }`). As long as at some point your GraphQL server gave you a todo with the provided id and fields `id`, `text`, and `completed` you can read it from the cache at any part of your code.\n\n<h3 id=\"writequery-and-writefragment\">writeQuery` and `writeFragment</h3>\n\nNot only can you read arbitrary data from the Apollo Client cache, but you can also write any data that you would like to the cache. The methods you use to do this are `writeQuery` and `writeFragment`. They will allow you to change data in your local cache, but it is important to remember that *they will not change any data on your server*. If you reload your environment then changes made with `writeQuery` and `writeFragment` will disappear.\n\nThese methods have the same signature as their `readQuery` and `readFragment` counterparts except they also require an additional `data` variable. So for example, if you wanted to update the `completed` flag locally for your todo with id `'5'` you could execute the following:\n\n```js\nclient.writeFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      completed\n    }\n  `,\n  data: {\n    completed: true,\n  },\n});\n```\n\nAny subscriber to the Apollo Client store will instantly see this update and render new UI accordingly.\n\n> **Note:** Again, remember that using `writeQuery` or `writeFragment` only changes data *locally*. If you reload your environment then changes made with these methods will no longer exist.\n\nOr if you wanted to add a new todo to a list fetched from the server, you could use `readQuery` and `writeQuery` together.\n\n```js\nconst query = gql`\n  query MyTodoAppQuery {\n    todos {\n      id\n      text\n      completed\n    }\n  }\n`;\n\nconst data = client.readQuery({ query });\n\nconst myNewTodo = {\n  id: '6',\n  text: 'Start using Apollo Client.',\n  completed: false,\n};\n\nclient.writeQuery({\n  query,\n  data: {\n    todos: [...data.todos, myNewTodo],\n  },\n});\n```\n\n<h2 id=\"recipes\">Recipes</h2>\n\nHere are some common situations where you would need to access the cache directly. If you're manipulating the cache in an interesting way and would like your example to be featured, please send in a pull request!\n\n<h3 id=\"server\">Server side rendering</h3>\n\nFirst, you will need to initialize an `InMemoryCache` on the server and create an instance of `ApolloClient`. In the initial serialized HTML payload from the server, you should include a script tag that extracts the data from the cache.\n\n```js\n`<script>\n  window.__APOLLO_STATE__=${JSON.stringify(cache.extract())}\n</script>`\n```\n\nOn the client, you can rehydrate the cache using the initial data passed from the server:\n\n```js\ncache: new Cache().restore(window.__APOLLO_STATE__)\n```\n\nIf you would like to learn more about server side rendering, please check our our more in depth guide [here].\n<!---\nTODO (PEGGY): Add link to SSR\n-->\n\n<h3 id=\"server\">Updating the cache after a mutation</h3>\n\nBeing able to read and write to the Apollo cache from anywhere in your application gives you a lot of power over your data. However, there is one place where we most often want to update our cached data: after a mutation. As such, Apollo Client has optimized the experience for updating your cache with the read and write methods after a mutation with the `update` function. Let us say that we have the following GraphQL mutation:\n\n```graphql\nmutation TodoCreateMutation($text: String!) {\n  createTodo(text: $text) {\n    id\n    text\n    completed\n  }\n}\n```\n\nWe may also have the following GraphQL query:\n\n```graphql\nquery TodoAppQuery {\n  todos {\n    id\n    text\n    completed\n  }\n}\n```\n\nAt the end of our mutation we want our query to include the new todo like we had sent our `TodoAppQuery` a second time after the mutation finished without actually sending the query. To do this we can use the `update` function provided as an option of the `client.mutate` method. To update your cache with the mutation just write code that looks like:\n\n```js\n// We assume that the GraphQL operations `TodoCreateMutation` and\n// `TodoAppQuery` have already been defined using the `gql` tag.\n\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    // Read the data from our cache for this query.\n    const data = proxy.readQuery({ query: TodoAppQuery });\n\n    // Add our todo from the mutation to the end.\n    data.todos.push(createTodo);\n\n    // Write our data back to the cache.\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nThe first `proxy` argument is an instance of [`DataProxy`][] has the same four methods that we just learned exist on the Apollo Client: `readQuery`, `readFragment`, `writeQuery`, and `writeFragment`. The reason we call them on a `proxy` object here instead of on our `client` instance is that we can easily apply optimistic updates (which we will demonstrate in a bit). The `proxy` object also provides an isolated transaction which shields you from any other mutations going on at the same time, and the `proxy` object also batches writes together until the very end.\n\nIf you provide an `optimisticResponse` option to the mutation then the `update` function will be run twice. Once immediately after you call `client.mutate` with the data from `optimisticResponse`. After the mutation successfully executes against the server the changes made in the first call to `update` will be rolled back and `update` will be called with the *actual* data returned by the mutation and not just the optimistic response.\n\nPutting it all together:\n\n```js\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  optimisticResponse: {\n    id: -1, // -1 is a temporary id for the optimistic response.\n    text,\n    completed: false,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    const data = proxy.readQuery({ query: TodoAppQuery });\n    data.todos.push(createTodo);\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nAs you can see the `update` function on `client.mutate` provides extra change management functionality specific to the use case of a mutation while still providing you the powerful data control APIs that are available on `client`.\n\nThe `update` function is not a good place for side-effects as it may be called multiple times. Also, you may not call any of the methods on `proxy` asynchronously.\n\n",
      "readmeFilename": "README.md",
      "_id": "apollo-cache-inmemory@1.3.0-verify.3",
      "_npmVersion": "5.6.0",
      "_nodeVersion": "8.11.2",
      "_npmUser": {
        "name": "mdg",
        "email": "npm@meteor.com"
      },
      "dist": {
        "integrity": "sha512-mQv5L88JMkwQP44Qct2vFB6onNf508V5AQuzyar8uQYq7EQowNsgZ9ojj/HRu5xgR4CbiVgqzT7ZjCtDluFSmg==",
        "shasum": "923f6739b9f09d5dd626287dd7e7c9ceccd72bd7",
        "tarball": "https://registry.npmjs.org/apollo-cache-inmemory/-/apollo-cache-inmemory-1.3.0-verify.3.tgz",
        "fileCount": 69,
        "unpackedSize": 410910,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJbdw/NCRA9TVsSAnZWagAAB5MP/Rv9wt2J37g8x/WoYlP/\npo75ZmHaWvLBIwwpon4UclzceI+7QUAaoPPQ2Dxy6/LxXzMLMq/rMBxtcgq6\n7GCisXbXdbQ7T6J8L4NzkmCLJuwQGNuRu7Mo8h9IyC+69FQHNXJQK2qLepH8\nIJ7ExQLWdKS+U1VVS7PMgcTWIWuZ3c5HAenUXNEo7sfTAvKAK7uAuFhXUmfc\nIckKwAoWdAhXciO8ju0Vtf57QthM4eDJuZdKYXe1hAhf1JYdoXUjw520K3R0\nsiqpoOA/kLSMqVd1zk+93Nvuzxzx9nQVSGlv/UjJsFZumwmW9NIlm5mLGwmn\nEBqDbYHuB8gOM42VcjIDxiwCB3MW19etwDMszXu2+GB0aLyCPa/JoUr3Hv/N\nZXQ6wCzTA5AJLwHfLPefagYJ8WCjB9gOIVbk87qfPpJj+HVbutixcvLbOMi0\n0wOkDM4bYqNTWYq5Np4e7EBF2MEEUervoPEBlCTFfqiLIIaToR144b+tq6aD\ng7VlAj6pX0dMImDbdaovSsDmhnzqa55OxGfT7/mXE2L0SDqcyAkANm6TQlrO\n6cecwAkjobFHhbWJt6axhYHOr9miLEOmHX72i086/NfcC//2BtLaj6zcdHbq\nMqUqqzMkbyUS3gYfliopj44u6UlMLu+4xaSCppK26AQPkqiYeJ+Xq/9cwfe7\nAe95\r\n=dlq8\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEYCIQCj3zR1doWwCShmsHe4l6yv2kh5bNCJ7PXl2WVmYlZAOgIhAP5VkszV7dXtj1+SsPTT+JVddR+vshuoJRjpAYfODj/b"
          }
        ]
      },
      "maintainers": [
        {
          "email": "ben@benjamn.com",
          "name": "benjamn"
        },
        {
          "email": "james@meteor.com",
          "name": "jbaxleyiii"
        },
        {
          "email": "npm@meteor.com",
          "name": "mdg"
        },
        {
          "email": "peggyrayzis@gmail.com",
          "name": "peggyrayzis"
        }
      ],
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/apollo-cache-inmemory_1.3.0-verify.3_1534529484602_0.7554790260663318"
      },
      "_hasShrinkwrap": false
    },
    "1.3.0-verify.4": {
      "name": "apollo-cache-inmemory",
      "version": "1.3.0-verify.4",
      "description": "Core abstract of Caching layer for Apollo Client",
      "author": {
        "name": "James Baxley",
        "email": "james@meteor.com"
      },
      "contributors": [
        {
          "name": "James Baxley",
          "email": "james@meteor.com"
        },
        {
          "name": "Jonas Helfer",
          "email": "jonas@helfer.email"
        },
        {
          "name": "Sashko Stubailo",
          "email": "sashko@stubailo.com"
        },
        {
          "name": "James Burgess",
          "email": "jamesmillerburgess@gmail.com"
        },
        {
          "name": "Bazyli Brzóska",
          "email": "bazyli.brzoska@gmail.com"
        }
      ],
      "license": "MIT",
      "main": "./lib/bundle.umd.js",
      "module": "./lib/index.js",
      "jsnext:main": "./lib/index.js",
      "typings": "./lib/index.d.ts",
      "sideEffects": false,
      "repository": {
        "type": "git",
        "url": "git+https://github.com/apollographql/apollo-client.git"
      },
      "bugs": {
        "url": "https://github.com/apollographql/apollo-client/issues"
      },
      "homepage": "https://github.com/apollographql/apollo-client#readme",
      "scripts": {
        "prepare": "npm run lint && npm run build",
        "coverage": "jest --coverage",
        "test": "jest",
        "lint": "tslint -c \"../../config/tslint.json\" -p tsconfig.json src/*.ts",
        "prebuild": "npm run clean",
        "build": "tsc -p .",
        "postbuild": "npm run bundle",
        "bundle": "../../node_modules/rollup/bin/rollup -c rollup.config.js",
        "watch": "tsc -w -p .",
        "clean": "rm -rf coverage/* && rm -rf lib/*",
        "prepublishOnly": "npm run build",
        "minify": "../../node_modules/uglify-js/bin/uglifyjs -c -m -o ./lib/bundle.min.js -- ./lib/bundle.umd.js",
        "filesize": "npm run minify"
      },
      "dependencies": {
        "apollo-cache": "^1.2.0-verify.4",
        "apollo-utilities": "^1.1.0-verify.4",
        "graphql-anywhere": "^4.2.0-verify.4"
      },
      "peerDependencies": {
        "graphql": "0.11.7 || ^0.12.0 || ^0.13.0"
      },
      "jest": {
        "transform": {
          ".(ts|tsx)": "ts-jest"
        },
        "testRegex": "(/__tests__/.*|\\.(test|spec))\\.(ts|tsx|js)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "json"
        ],
        "testURL": "http://localhost"
      },
      "gitHead": "aa5d083bdc328149e506b275c07d978b3b7fefd9",
      "readme": "---\ntitle: InMemoryCache\ndescription: An explanation of `apollo-cache-inmemory`\n---\n\n`apollo-cache-inmemory` is the recommended cache implementation for Apollo Client 2.0. `InMemoryCache` is a normalized data store that supports all of Apollo Client 1.0's features without the dependency on Redux.\n\nIn some instances, you may need to manipulate the cache directly, such as updating the store after a mutation. We'll cover some common use cases [here](#recipes).\n\n<h2 id=\"installation\">Installation</h2>\n\n```\nnpm install apollo-cache-inmemory --save\n```\n\nAfter installing the package, you'll want to initialize the cache constructor. Then, you can pass in your newly created cache to ApolloClient.\n\n```js\nimport { InMemoryCache } from 'apollo-cache-inmemory';\nimport { HttpLink } from 'apollo-link-http';\nimport ApolloClient from 'apollo-client';\n\nconst cache = new InMemoryCache();\n\nconst client = new ApolloClient({\n  link: new HttpLink(),\n  cache\n});\n```\n\n<h2 id=\"configuration\">Configuration</h2>\n\nThe `InMemoryCache` constructor takes an optional config object with properties to customize your cache:\n\n- addTypename: A boolean to determine whether to add __typename to the document (default: `true`)\n- dataIdFromObject: A function that takes a data object and returns a unique identifier to be used when normalizing the data in the store. Learn more about how to customize `dataIdFromObject` in the [Normalization](#normalization) section.\n- fragmentMatcher: By default, the `InMemoryCache` uses a heuristic fragment matcher. If you are using fragments on unions and interfaces, you will need to use an `IntrospectionFragmentMatcher`. For more information, please read [our guide to setting up fragment matching for unions & interfaces](https://www.apollographql.com/docs/react/advanced/fragments.html#fragment-matcher).\n\n<h2 id=\"normalization\">Normalization</h2>\n\nThe `InMemoryCache` normalizes your data before saving it to the store by splitting the result into individual objects, creating a unique identifier for each object, and storing those objects in a flattened data structure. By default, `InMemoryCache` will attempt to use the commonly found primary keys of `id` and `_id` for the unique identifier if they exist along with `__typename` on an object.\n\nIf `id` and `_id` are not specified, or if `__typename` is not specified, `InMemoryCache` will fall back to the path to the object in the query, such as `ROOT_QUERY.allPeople.0` for the first record returned on the `allPeople` root query.\n\nThis \"getter\" behavior for unique identifiers can be configured manually via the `dataIdFromObject` option passed to the `InMemoryCache` constructor, so you can pick which field is used if some of your data follows unorthodox primary key conventions.\n\nFor example, if you wanted to key off of the `key` field for all of your data, you could configure `dataIdFromObject` like so:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => object.key\n});\n```\n\nThis also allows you to use different unique identifiers for different data types by keying off of the `__typename` property attached to every object typed by GraphQL.  For example:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => {\n    switch (object.__typename) {\n      case 'foo': return object.key; // use `key` as the primary key\n      case 'bar': return object.blah; // use `blah` as the priamry key\n      default: return object.id || object._id; // fall back to `id` and `_id` for all other types\n    }\n  }\n});\n```\n\n<h2 id=\"direct\">Direct Cache Access</h2>\n\nTo interact directly with your cache, you can use the Apollo Client class methods readQuery, readFragment, writeQuery, and writeFragment. These methods are available to us via the [`DataProxy` interface](https://github.com/apollographql/apollo-client/blob/master/packages/apollo-cache/src/types/DataProxy.ts). Accessing these methods will vary slightly based on your view layer implementation. If you are using React, you can wrap your component in the `withApollo` higher order component, which will give you access to `this.props.client`. From there, you can use the methods to control your data.\n\nAny code demonstration in the following sections will assume that we have already initialized an instance of  `ApolloClient` and that we have imported the `gql` tag from `graphql-tag`.\n\n<h3 id=\"readquery\">readQuery</h3>\n\nThe `readQuery` method is very similar to the [`query` method on `ApolloClient`][] except that `readQuery` will _never_ make a request to your GraphQL server. The `query` method, on the other hand, may send a request to your server if the appropriate data is not in your cache whereas `readQuery` will throw an error if the data is not in your cache. `readQuery` will _always_ read from the cache. You can use `readQuery` by giving it a GraphQL query like so:\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo {\n      todo(id: 5) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n});\n```\n\nIf all of the data needed to fulfill this read is in Apollo Client’s normalized data cache then a data object will be returned in the shape of the query you wanted to read. If not all of the data needed to fulfill this read is in Apollo Client’s cache then an error will be thrown instead, so make sure to only read data that you know you have!\n\nYou can also pass variables into `readQuery`.\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo($id: Int!) {\n      todo(id: $id) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n  variables: {\n    id: 5,\n  },\n});\n```\n\n<h3 id=\"readfragment\">readFragment</h3>\n\nThis method allows you great flexibility around the data in your cache. Whereas `readQuery` only allowed you to read data from your root query type, `readFragment` allows you to read data from _any node you have queried_. This is incredibly powerful. You use this method as follows:\n\n```js\nconst todo = client.readFragment({\n  id: ..., // `id` is any id that could be returned by `dataIdFromObject`.\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\nThe first argument is the id of the data you want to read from the cache. That id must be a value that was returned by the `dataIdFromObject` function you defined when initializing `ApolloClient`. So for example if you initialized `ApolloClient` like so:\n\n```js\nconst client = new ApolloClient({\n  ...,\n  dataIdFromObject: object => object.id,\n});\n```\n\n…and you requested a todo before with an id of `5`, then you can read that todo out of your cache with the following:\n\n```js\nconst todo = client.readFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\n> **Note:** Most people add a `__typename` to the id in `dataIdFromObject`. If you do this then don’t forget to add the `__typename` when you are reading a fragment as well. So for example your id may be `Todo_5` and not just `5`.\n\nIf a todo with that id does not exist in the cache you will get `null` back. If a todo of that id does exist in the cache, but that todo does not have the `text` field then an error will be thrown.\n\nThe beauty of `readFragment` is that the todo could have come from anywhere! The todo could have been selected as a singleton (`{ todo(id: 5) { ... } }`), the todo could have come from a list of todos (`{ todos { ... } }`), or the todo could have come from a mutation (`mutation { createTodo { ... } }`). As long as at some point your GraphQL server gave you a todo with the provided id and fields `id`, `text`, and `completed` you can read it from the cache at any part of your code.\n\n<h3 id=\"writequery-and-writefragment\">writeQuery` and `writeFragment</h3>\n\nNot only can you read arbitrary data from the Apollo Client cache, but you can also write any data that you would like to the cache. The methods you use to do this are `writeQuery` and `writeFragment`. They will allow you to change data in your local cache, but it is important to remember that *they will not change any data on your server*. If you reload your environment then changes made with `writeQuery` and `writeFragment` will disappear.\n\nThese methods have the same signature as their `readQuery` and `readFragment` counterparts except they also require an additional `data` variable. So for example, if you wanted to update the `completed` flag locally for your todo with id `'5'` you could execute the following:\n\n```js\nclient.writeFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      completed\n    }\n  `,\n  data: {\n    completed: true,\n  },\n});\n```\n\nAny subscriber to the Apollo Client store will instantly see this update and render new UI accordingly.\n\n> **Note:** Again, remember that using `writeQuery` or `writeFragment` only changes data *locally*. If you reload your environment then changes made with these methods will no longer exist.\n\nOr if you wanted to add a new todo to a list fetched from the server, you could use `readQuery` and `writeQuery` together.\n\n```js\nconst query = gql`\n  query MyTodoAppQuery {\n    todos {\n      id\n      text\n      completed\n    }\n  }\n`;\n\nconst data = client.readQuery({ query });\n\nconst myNewTodo = {\n  id: '6',\n  text: 'Start using Apollo Client.',\n  completed: false,\n};\n\nclient.writeQuery({\n  query,\n  data: {\n    todos: [...data.todos, myNewTodo],\n  },\n});\n```\n\n<h2 id=\"recipes\">Recipes</h2>\n\nHere are some common situations where you would need to access the cache directly. If you're manipulating the cache in an interesting way and would like your example to be featured, please send in a pull request!\n\n<h3 id=\"server\">Server side rendering</h3>\n\nFirst, you will need to initialize an `InMemoryCache` on the server and create an instance of `ApolloClient`. In the initial serialized HTML payload from the server, you should include a script tag that extracts the data from the cache.\n\n```js\n`<script>\n  window.__APOLLO_STATE__=${JSON.stringify(cache.extract())}\n</script>`\n```\n\nOn the client, you can rehydrate the cache using the initial data passed from the server:\n\n```js\ncache: new Cache().restore(window.__APOLLO_STATE__)\n```\n\nIf you would like to learn more about server side rendering, please check our our more in depth guide [here].\n<!---\nTODO (PEGGY): Add link to SSR\n-->\n\n<h3 id=\"server\">Updating the cache after a mutation</h3>\n\nBeing able to read and write to the Apollo cache from anywhere in your application gives you a lot of power over your data. However, there is one place where we most often want to update our cached data: after a mutation. As such, Apollo Client has optimized the experience for updating your cache with the read and write methods after a mutation with the `update` function. Let us say that we have the following GraphQL mutation:\n\n```graphql\nmutation TodoCreateMutation($text: String!) {\n  createTodo(text: $text) {\n    id\n    text\n    completed\n  }\n}\n```\n\nWe may also have the following GraphQL query:\n\n```graphql\nquery TodoAppQuery {\n  todos {\n    id\n    text\n    completed\n  }\n}\n```\n\nAt the end of our mutation we want our query to include the new todo like we had sent our `TodoAppQuery` a second time after the mutation finished without actually sending the query. To do this we can use the `update` function provided as an option of the `client.mutate` method. To update your cache with the mutation just write code that looks like:\n\n```js\n// We assume that the GraphQL operations `TodoCreateMutation` and\n// `TodoAppQuery` have already been defined using the `gql` tag.\n\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    // Read the data from our cache for this query.\n    const data = proxy.readQuery({ query: TodoAppQuery });\n\n    // Add our todo from the mutation to the end.\n    data.todos.push(createTodo);\n\n    // Write our data back to the cache.\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nThe first `proxy` argument is an instance of [`DataProxy`][] has the same four methods that we just learned exist on the Apollo Client: `readQuery`, `readFragment`, `writeQuery`, and `writeFragment`. The reason we call them on a `proxy` object here instead of on our `client` instance is that we can easily apply optimistic updates (which we will demonstrate in a bit). The `proxy` object also provides an isolated transaction which shields you from any other mutations going on at the same time, and the `proxy` object also batches writes together until the very end.\n\nIf you provide an `optimisticResponse` option to the mutation then the `update` function will be run twice. Once immediately after you call `client.mutate` with the data from `optimisticResponse`. After the mutation successfully executes against the server the changes made in the first call to `update` will be rolled back and `update` will be called with the *actual* data returned by the mutation and not just the optimistic response.\n\nPutting it all together:\n\n```js\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  optimisticResponse: {\n    id: -1, // -1 is a temporary id for the optimistic response.\n    text,\n    completed: false,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    const data = proxy.readQuery({ query: TodoAppQuery });\n    data.todos.push(createTodo);\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nAs you can see the `update` function on `client.mutate` provides extra change management functionality specific to the use case of a mutation while still providing you the powerful data control APIs that are available on `client`.\n\nThe `update` function is not a good place for side-effects as it may be called multiple times. Also, you may not call any of the methods on `proxy` asynchronously.\n\n",
      "readmeFilename": "README.md",
      "_id": "apollo-cache-inmemory@1.3.0-verify.4",
      "_npmVersion": "5.6.0",
      "_nodeVersion": "8.11.2",
      "_npmUser": {
        "name": "mdg",
        "email": "npm@meteor.com"
      },
      "dist": {
        "integrity": "sha512-7iLig2CmpRkl4tOvhKFHTgqRANEKN4qtnVKI9RqSTzUq3AFclfC0vaxTeGGGZBJiIuqVR6+1aYr8egUNTwXWQQ==",
        "shasum": "d8a9631b301de98ebf47d3b935d39212b8498c66",
        "tarball": "https://registry.npmjs.org/apollo-cache-inmemory/-/apollo-cache-inmemory-1.3.0-verify.4.tgz",
        "fileCount": 69,
        "unpackedSize": 410910,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJbdxdeCRA9TVsSAnZWagAAOZIP/REsF4tNNd53UIgMDREO\ngvvHij/zQBy1/mnV1PTBhfFVQudhrD61D6i2iF8FnjOrJuo4iV7Rbrpow7Ov\nkbwF9LqumaRW5POhHlYp2TUkOCM/anXpO6N87zbq33AKIlgyLrDURKfKZn+d\nIgAq9+q3mopUMOhxUf/cedY/I7mTf2eEju6oIiU85qQcDFvAGD25l5uSsElO\nKN1ot2XXsnN0pu7zQbRRGxzLxAsMMpxEsetKjBCbh/raE7GXegQdpyZBGDLw\nXj4S5q9HZ8kbl7zAUhURp3eNy3/XnRjlyMaaDcQolSDEHbY1W5Sy3XTd2+tn\n4mSMN7Sc13WheL1TgVe7QoRRqbyoutPwc7BM+1liJwa2k3OC2NQvELIYUUDI\n8grp6Sp17ywWPanGk/+Eo1+/UigljyNpTgLgrLDecFlvpj0sjrMEjfdqkqxL\n/Yqf2LzQuj21okyRMIDZcrvhcOukzahywsiCed8cu9l2ONo1OAA9arUmAk1F\nnyBlezImB9S7GXqzVuDGIwo0ccJ/1gTgAjEuE5bqVMwYOBR3s9KNw44aMP1z\nWAGbgn1CsiX7wVeVHlbaua5BFUgAnBXeMHRHbeE2MFLF8KpYFRu1f3PyZCxC\nFw2Wf/CEtPS1DAVE3XFBXPQz+Fdt0kCHkYsFsGvNgwdAo4E+7WrAMnyvk5gn\nBI3c\r\n=UPoA\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIQCdoHpb118p9IXrdK3LVYCBfR0oB6fqTrS733bg+dsKTAIgYF4f/TjbU3twHLffjRQFV402MW8p73J+vA0hvEErsSo="
          }
        ]
      },
      "maintainers": [
        {
          "email": "ben@benjamn.com",
          "name": "benjamn"
        },
        {
          "email": "james@meteor.com",
          "name": "jbaxleyiii"
        },
        {
          "email": "npm@meteor.com",
          "name": "mdg"
        },
        {
          "email": "peggyrayzis@gmail.com",
          "name": "peggyrayzis"
        }
      ],
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/apollo-cache-inmemory_1.3.0-verify.4_1534531421433_0.648067741619043"
      },
      "_hasShrinkwrap": false
    },
    "1.2.9": {
      "name": "apollo-cache-inmemory",
      "version": "1.2.9",
      "description": "Core abstract of Caching layer for Apollo Client",
      "author": {
        "name": "James Baxley",
        "email": "james@meteor.com"
      },
      "contributors": [
        {
          "name": "James Baxley",
          "email": "james@meteor.com"
        },
        {
          "name": "Jonas Helfer",
          "email": "jonas@helfer.email"
        },
        {
          "name": "Sashko Stubailo",
          "email": "sashko@stubailo.com"
        },
        {
          "name": "James Burgess",
          "email": "jamesmillerburgess@gmail.com"
        },
        {
          "name": "Bazyli Brzóska",
          "email": "bazyli.brzoska@gmail.com"
        }
      ],
      "license": "MIT",
      "main": "./lib/bundle.umd.js",
      "module": "./lib/index.js",
      "jsnext:main": "./lib/index.js",
      "typings": "./lib/index.d.ts",
      "sideEffects": false,
      "repository": {
        "type": "git",
        "url": "git+https://github.com/apollographql/apollo-client.git"
      },
      "bugs": {
        "url": "https://github.com/apollographql/apollo-client/issues"
      },
      "homepage": "https://github.com/apollographql/apollo-client#readme",
      "scripts": {
        "prepare": "npm run lint && npm run build",
        "coverage": "jest --coverage",
        "test": "jest",
        "lint": "tslint -c \"../../config/tslint.json\" -p tsconfig.json src/*.ts",
        "prebuild": "npm run clean",
        "build": "tsc -p .",
        "postbuild": "npm run bundle",
        "bundle": "../../node_modules/rollup/bin/rollup -c rollup.config.js",
        "watch": "tsc -w -p .",
        "clean": "rm -rf coverage/* && rm -rf lib/*",
        "prepublishOnly": "npm run build",
        "minify": "../../node_modules/uglify-js/bin/uglifyjs -c -m -o ./lib/bundle.min.js -- ./lib/bundle.umd.js",
        "filesize": "npm run minify"
      },
      "dependencies": {
        "apollo-cache": "^1.1.16",
        "apollo-utilities": "^1.0.20",
        "graphql-anywhere": "^4.1.18"
      },
      "peerDependencies": {
        "graphql": "0.11.7 || ^0.12.0 || ^0.13.0"
      },
      "jest": {
        "transform": {
          ".(ts|tsx)": "ts-jest"
        },
        "testRegex": "(/__tests__/.*|\\.(test|spec))\\.(ts|tsx|js)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "json"
        ],
        "testURL": "http://localhost"
      },
      "gitHead": "40cccc16db43e190f341794f74e495bd8e390a82",
      "_id": "apollo-cache-inmemory@1.2.9",
      "_npmVersion": "5.6.0",
      "_nodeVersion": "8.11.2",
      "_npmUser": {
        "name": "mdg",
        "email": "npm@meteor.com"
      },
      "dist": {
        "integrity": "sha512-Z4m4NpT2eboM4qUww/46CsjOyITavxrKPBrsCugDlmwSzonqMLZmAyZEQgnYXCj8L5q5epnOuf0sqyYK/6sGIQ==",
        "shasum": "26e0c8c6a6c865bf9987d741114388cdbc3fae23",
        "tarball": "https://registry.npmjs.org/apollo-cache-inmemory/-/apollo-cache-inmemory-1.2.9.tgz",
        "fileCount": 69,
        "unpackedSize": 410877,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJbgtW1CRA9TVsSAnZWagAAsq0QAJ8uq2gFkaB0MCPbmiH1\nk9TtCph5JbKVs3afQGBEYFroFUkEoWKKbVyU6zD1WjJm4f3K5xGUm7mXW1ZE\nMyWDFuojCsosASX52exH4r0GoNPrsYlJjxoHG2KFzWrK1C1RF/EpjaED/51L\nM+lpUUjHeUc09RB3TV9tPxz2T/0rZYAsWrc9UKGAg6Yw0T9U2tgBrXbHDa4f\nhblvI2+3fs9F9RU5FK9pHlBrfOiMGorN6NWD8bFvW9QD8ZADMwKLNzy0cXZW\nzp94x2fje9ChfLr40M5D7Mz3a+hNWHDWJ6QWz5Vd+Lb1FcNq/giy7MxvI0Ak\nVHlBlJZesBEwtsPrIYMxdzhUr+Dp86bOcZuOMSP8a6y40P7IS7VmxKNTukx1\nmPvQDRkBkuRfDD0US1vmA8jLxGYLF9bkoqyILzkVOLRuyIbuORJYkCPxeeAX\nuUMxdEgNUl7ObZ8V+JGJ7GAq9nLWzDryy2PjqMJ22DT0XQeUMyAlFGYy2bgX\nk7M7qVHS+oApsachsA/+7QWpzsI3xxxfwULF3sN7rXdIdcKAd4G/s13ne1z9\nt7ZFs5Nrzzy6njJsP9zhfreF0xHhuXnNtGcI+iLAnBZA0lQKGy6xnBA1MgQj\nCYKxXM1ozDwpUvdnXRCiT5cXvh5JVtcSWQ4Mt5v1EzKdySwjQTtZC+sw+iXm\nuN7I\r\n=hxRy\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEQCICF9X50el2Gw8dVjJjQiO6b2ztmpBEIMkP7OOP5clfQxAiB2kui9nBtwCiXoaGvY6arFo1klyjGSocYcHO1tW+6cUg=="
          }
        ]
      },
      "maintainers": [
        {
          "email": "ben@benjamn.com",
          "name": "benjamn"
        },
        {
          "email": "james@meteor.com",
          "name": "jbaxleyiii"
        },
        {
          "email": "npm@meteor.com",
          "name": "mdg"
        },
        {
          "email": "peggyrayzis@gmail.com",
          "name": "peggyrayzis"
        }
      ],
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/apollo-cache-inmemory_1.2.9_1535301044239_0.18815014576805367"
      },
      "_hasShrinkwrap": false
    },
    "1.3.0-beta.8": {
      "name": "apollo-cache-inmemory",
      "version": "1.3.0-beta.8",
      "description": "Core abstract of Caching layer for Apollo Client",
      "author": {
        "name": "James Baxley",
        "email": "james@meteor.com"
      },
      "contributors": [
        {
          "name": "James Baxley",
          "email": "james@meteor.com"
        },
        {
          "name": "Jonas Helfer",
          "email": "jonas@helfer.email"
        },
        {
          "name": "Sashko Stubailo",
          "email": "sashko@stubailo.com"
        },
        {
          "name": "James Burgess",
          "email": "jamesmillerburgess@gmail.com"
        },
        {
          "name": "Bazyli Brzóska",
          "email": "bazyli.brzoska@gmail.com"
        }
      ],
      "license": "MIT",
      "main": "./lib/bundle.umd.js",
      "module": "./lib/index.js",
      "jsnext:main": "./lib/index.js",
      "typings": "./lib/index.d.ts",
      "sideEffects": false,
      "repository": {
        "type": "git",
        "url": "git+https://github.com/apollographql/apollo-client.git"
      },
      "bugs": {
        "url": "https://github.com/apollographql/apollo-client/issues"
      },
      "homepage": "https://github.com/apollographql/apollo-client#readme",
      "scripts": {
        "prepare": "npm run build",
        "coverage": "jest --coverage",
        "test": "jest",
        "lint": "tslint -c \"../../config/tslint.json\" -p tsconfig.json src/*.ts",
        "prebuild": "npm run clean",
        "build": "tsc -p .",
        "postbuild": "npm run bundle",
        "bundle": "../../node_modules/rollup/bin/rollup -c rollup.config.js",
        "watch": "tsc -w -p .",
        "clean": "rm -rf coverage/* && rm -rf lib/*",
        "prepublishOnly": "npm run build",
        "minify": "../../node_modules/uglify-js/bin/uglifyjs -c -m -o ./lib/bundle.min.js -- ./lib/bundle.umd.js",
        "filesize": "npm run minify"
      },
      "dependencies": {
        "apollo-cache": "file:../apollo-cache",
        "apollo-utilities": "file:../apollo-utilities",
        "optimism": "^0.6.5"
      },
      "peerDependencies": {
        "graphql": "0.11.7 || ^0.12.0 || ^0.13.0"
      },
      "jest": {
        "transform": {
          ".(ts|tsx)": "ts-jest"
        },
        "testRegex": "(/__tests__/.*|\\.(test|spec))\\.(ts|tsx|js)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "json"
        ],
        "testURL": "http://localhost"
      },
      "readme": "---\ntitle: InMemoryCache\ndescription: An explanation of `apollo-cache-inmemory`\n---\n\n`apollo-cache-inmemory` is the recommended cache implementation for Apollo Client 2.0. `InMemoryCache` is a normalized data store that supports all of Apollo Client 1.0's features without the dependency on Redux.\n\nIn some instances, you may need to manipulate the cache directly, such as updating the store after a mutation. We'll cover some common use cases [here](#recipes).\n\n<h2 id=\"installation\">Installation</h2>\n\n```\nnpm install apollo-cache-inmemory --save\n```\n\nAfter installing the package, you'll want to initialize the cache constructor. Then, you can pass in your newly created cache to ApolloClient.\n\n```js\nimport { InMemoryCache } from 'apollo-cache-inmemory';\nimport { HttpLink } from 'apollo-link-http';\nimport ApolloClient from 'apollo-client';\n\nconst cache = new InMemoryCache();\n\nconst client = new ApolloClient({\n  link: new HttpLink(),\n  cache\n});\n```\n\n<h2 id=\"configuration\">Configuration</h2>\n\nThe `InMemoryCache` constructor takes an optional config object with properties to customize your cache:\n\n- addTypename: A boolean to determine whether to add __typename to the document (default: `true`)\n- dataIdFromObject: A function that takes a data object and returns a unique identifier to be used when normalizing the data in the store. Learn more about how to customize `dataIdFromObject` in the [Normalization](#normalization) section.\n- fragmentMatcher: By default, the `InMemoryCache` uses a heuristic fragment matcher. If you are using fragments on unions and interfaces, you will need to use an `IntrospectionFragmentMatcher`. For more information, please read [our guide to setting up fragment matching for unions & interfaces](https://www.apollographql.com/docs/react/advanced/fragments.html#fragment-matcher).\n\n<h2 id=\"normalization\">Normalization</h2>\n\nThe `InMemoryCache` normalizes your data before saving it to the store by splitting the result into individual objects, creating a unique identifier for each object, and storing those objects in a flattened data structure. By default, `InMemoryCache` will attempt to use the commonly found primary keys of `id` and `_id` for the unique identifier if they exist along with `__typename` on an object.\n\nIf `id` and `_id` are not specified, or if `__typename` is not specified, `InMemoryCache` will fall back to the path to the object in the query, such as `ROOT_QUERY.allPeople.0` for the first record returned on the `allPeople` root query.\n\nThis \"getter\" behavior for unique identifiers can be configured manually via the `dataIdFromObject` option passed to the `InMemoryCache` constructor, so you can pick which field is used if some of your data follows unorthodox primary key conventions.\n\nFor example, if you wanted to key off of the `key` field for all of your data, you could configure `dataIdFromObject` like so:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => object.key\n});\n```\n\nThis also allows you to use different unique identifiers for different data types by keying off of the `__typename` property attached to every object typed by GraphQL.  For example:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => {\n    switch (object.__typename) {\n      case 'foo': return object.key; // use `key` as the primary key\n      case 'bar': return object.blah; // use `blah` as the priamry key\n      default: return object.id || object._id; // fall back to `id` and `_id` for all other types\n    }\n  }\n});\n```\n\n<h2 id=\"direct\">Direct Cache Access</h2>\n\nTo interact directly with your cache, you can use the Apollo Client class methods readQuery, readFragment, writeQuery, and writeFragment. These methods are available to us via the [`DataProxy` interface](https://github.com/apollographql/apollo-client/blob/master/packages/apollo-cache/src/types/DataProxy.ts). Accessing these methods will vary slightly based on your view layer implementation. If you are using React, you can wrap your component in the `withApollo` higher order component, which will give you access to `this.props.client`. From there, you can use the methods to control your data.\n\nAny code demonstration in the following sections will assume that we have already initialized an instance of  `ApolloClient` and that we have imported the `gql` tag from `graphql-tag`.\n\n<h3 id=\"readquery\">readQuery</h3>\n\nThe `readQuery` method is very similar to the [`query` method on `ApolloClient`][] except that `readQuery` will _never_ make a request to your GraphQL server. The `query` method, on the other hand, may send a request to your server if the appropriate data is not in your cache whereas `readQuery` will throw an error if the data is not in your cache. `readQuery` will _always_ read from the cache. You can use `readQuery` by giving it a GraphQL query like so:\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo {\n      todo(id: 5) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n});\n```\n\nIf all of the data needed to fulfill this read is in Apollo Client’s normalized data cache then a data object will be returned in the shape of the query you wanted to read. If not all of the data needed to fulfill this read is in Apollo Client’s cache then an error will be thrown instead, so make sure to only read data that you know you have!\n\nYou can also pass variables into `readQuery`.\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo($id: Int!) {\n      todo(id: $id) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n  variables: {\n    id: 5,\n  },\n});\n```\n\n<h3 id=\"readfragment\">readFragment</h3>\n\nThis method allows you great flexibility around the data in your cache. Whereas `readQuery` only allowed you to read data from your root query type, `readFragment` allows you to read data from _any node you have queried_. This is incredibly powerful. You use this method as follows:\n\n```js\nconst todo = client.readFragment({\n  id: ..., // `id` is any id that could be returned by `dataIdFromObject`.\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\nThe first argument is the id of the data you want to read from the cache. That id must be a value that was returned by the `dataIdFromObject` function you defined when initializing `ApolloClient`. So for example if you initialized `ApolloClient` like so:\n\n```js\nconst client = new ApolloClient({\n  ...,\n  dataIdFromObject: object => object.id,\n});\n```\n\n…and you requested a todo before with an id of `5`, then you can read that todo out of your cache with the following:\n\n```js\nconst todo = client.readFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\n> **Note:** Most people add a `__typename` to the id in `dataIdFromObject`. If you do this then don’t forget to add the `__typename` when you are reading a fragment as well. So for example your id may be `Todo_5` and not just `5`.\n\nIf a todo with that id does not exist in the cache you will get `null` back. If a todo of that id does exist in the cache, but that todo does not have the `text` field then an error will be thrown.\n\nThe beauty of `readFragment` is that the todo could have come from anywhere! The todo could have been selected as a singleton (`{ todo(id: 5) { ... } }`), the todo could have come from a list of todos (`{ todos { ... } }`), or the todo could have come from a mutation (`mutation { createTodo { ... } }`). As long as at some point your GraphQL server gave you a todo with the provided id and fields `id`, `text`, and `completed` you can read it from the cache at any part of your code.\n\n<h3 id=\"writequery-and-writefragment\">writeQuery` and `writeFragment</h3>\n\nNot only can you read arbitrary data from the Apollo Client cache, but you can also write any data that you would like to the cache. The methods you use to do this are `writeQuery` and `writeFragment`. They will allow you to change data in your local cache, but it is important to remember that *they will not change any data on your server*. If you reload your environment then changes made with `writeQuery` and `writeFragment` will disappear.\n\nThese methods have the same signature as their `readQuery` and `readFragment` counterparts except they also require an additional `data` variable. So for example, if you wanted to update the `completed` flag locally for your todo with id `'5'` you could execute the following:\n\n```js\nclient.writeFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      completed\n    }\n  `,\n  data: {\n    completed: true,\n  },\n});\n```\n\nAny subscriber to the Apollo Client store will instantly see this update and render new UI accordingly.\n\n> **Note:** Again, remember that using `writeQuery` or `writeFragment` only changes data *locally*. If you reload your environment then changes made with these methods will no longer exist.\n\nOr if you wanted to add a new todo to a list fetched from the server, you could use `readQuery` and `writeQuery` together.\n\n```js\nconst query = gql`\n  query MyTodoAppQuery {\n    todos {\n      id\n      text\n      completed\n    }\n  }\n`;\n\nconst data = client.readQuery({ query });\n\nconst myNewTodo = {\n  id: '6',\n  text: 'Start using Apollo Client.',\n  completed: false,\n};\n\nclient.writeQuery({\n  query,\n  data: {\n    todos: [...data.todos, myNewTodo],\n  },\n});\n```\n\n<h2 id=\"recipes\">Recipes</h2>\n\nHere are some common situations where you would need to access the cache directly. If you're manipulating the cache in an interesting way and would like your example to be featured, please send in a pull request!\n\n<h3 id=\"server\">Server side rendering</h3>\n\nFirst, you will need to initialize an `InMemoryCache` on the server and create an instance of `ApolloClient`. In the initial serialized HTML payload from the server, you should include a script tag that extracts the data from the cache.\n\n```js\n`<script>\n  window.__APOLLO_STATE__=${JSON.stringify(cache.extract())}\n</script>`\n```\n\nOn the client, you can rehydrate the cache using the initial data passed from the server:\n\n```js\ncache: new Cache().restore(window.__APOLLO_STATE__)\n```\n\nIf you would like to learn more about server side rendering, please check our our more in depth guide [here].\n<!---\nTODO (PEGGY): Add link to SSR\n-->\n\n<h3 id=\"server\">Updating the cache after a mutation</h3>\n\nBeing able to read and write to the Apollo cache from anywhere in your application gives you a lot of power over your data. However, there is one place where we most often want to update our cached data: after a mutation. As such, Apollo Client has optimized the experience for updating your cache with the read and write methods after a mutation with the `update` function. Let us say that we have the following GraphQL mutation:\n\n```graphql\nmutation TodoCreateMutation($text: String!) {\n  createTodo(text: $text) {\n    id\n    text\n    completed\n  }\n}\n```\n\nWe may also have the following GraphQL query:\n\n```graphql\nquery TodoAppQuery {\n  todos {\n    id\n    text\n    completed\n  }\n}\n```\n\nAt the end of our mutation we want our query to include the new todo like we had sent our `TodoAppQuery` a second time after the mutation finished without actually sending the query. To do this we can use the `update` function provided as an option of the `client.mutate` method. To update your cache with the mutation just write code that looks like:\n\n```js\n// We assume that the GraphQL operations `TodoCreateMutation` and\n// `TodoAppQuery` have already been defined using the `gql` tag.\n\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    // Read the data from our cache for this query.\n    const data = proxy.readQuery({ query: TodoAppQuery });\n\n    // Add our todo from the mutation to the end.\n    data.todos.push(createTodo);\n\n    // Write our data back to the cache.\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nThe first `proxy` argument is an instance of [`DataProxy`][] has the same four methods that we just learned exist on the Apollo Client: `readQuery`, `readFragment`, `writeQuery`, and `writeFragment`. The reason we call them on a `proxy` object here instead of on our `client` instance is that we can easily apply optimistic updates (which we will demonstrate in a bit). The `proxy` object also provides an isolated transaction which shields you from any other mutations going on at the same time, and the `proxy` object also batches writes together until the very end.\n\nIf you provide an `optimisticResponse` option to the mutation then the `update` function will be run twice. Once immediately after you call `client.mutate` with the data from `optimisticResponse`. After the mutation successfully executes against the server the changes made in the first call to `update` will be rolled back and `update` will be called with the *actual* data returned by the mutation and not just the optimistic response.\n\nPutting it all together:\n\n```js\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  optimisticResponse: {\n    id: -1, // -1 is a temporary id for the optimistic response.\n    text,\n    completed: false,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    const data = proxy.readQuery({ query: TodoAppQuery });\n    data.todos.push(createTodo);\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nAs you can see the `update` function on `client.mutate` provides extra change management functionality specific to the use case of a mutation while still providing you the powerful data control APIs that are available on `client`.\n\nThe `update` function is not a good place for side-effects as it may be called multiple times. Also, you may not call any of the methods on `proxy` asynchronously.\n\n",
      "readmeFilename": "README.md",
      "_id": "apollo-cache-inmemory@1.3.0-beta.8",
      "_npmVersion": "6.4.1",
      "_nodeVersion": "8.12.0",
      "_npmUser": {
        "name": "benjamn",
        "email": "ben@benjamn.com"
      },
      "dist": {
        "integrity": "sha512-uyzL285QLPgzrBM/DQBdiPgo+3IwxoTmsWuiAtYVQNPLobpWXUQI0hSID1aIX74MlNNylfmx2Z/dH/t2z6fL6g==",
        "shasum": "f3054647fdd6e6aec0d04c8d5c5c0393e2cad131",
        "tarball": "https://registry.npmjs.org/apollo-cache-inmemory/-/apollo-cache-inmemory-1.3.0-beta.8.tgz",
        "fileCount": 78,
        "unpackedSize": 454935,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJbmEXbCRA9TVsSAnZWagAA0MsQAIN1BlyLy6fwxMacPDxU\nfv3oq5m0ntLptCy3gMdbB6pVMabSmCDjAj+57YoOowHztsDmz2LLpPn/t+4M\nx5ibsz0z86elff1m+YKqQf0ep0N03mAmPgma6I2xJzbW8H9Eu/1QuWMYPMhA\nzN6kCpOrqkQHIjW9HglLbmmGRGICPinQoH/iwIxYylET69f3G8cs4fhjkiTJ\nrgfdlRvilQmXl5KGa+Ln4w5OfJ5Gbrci4dozMR7hbZxISaKCRELVrorQ82xu\nGLN7RJq8BEyBzD5KGnnMQbIOQZ+pTvZN1pv34N+7B098AWtaetKQxRMViGni\nMNxDDqqPSVjtSaCwEf6ZAkvEfAzBhgQbcGRmbQAevwoIqHoa3dLCkNMTBksS\n62SiEmguB4XLBFyvz1MBNP5EswWJU3tMAhAbTSTXM5+hQZlvw1HDxAjTAEVO\ne9GD+8L0rNGWy2SjDNRL7SnzPVGE23AYXehfNvdFDS9FFU7xU5duFncMV8GX\n4TrhZFuGJl8RIhdxKxk+f0l9hDsRvEwFmyRDkBbH6CEnpoJtuWSce8nbRVEz\n3PgiQm0IKigM4X5dtJCrxaWPx7NK97D/SiqGiWxuGSvL1/4pnGzGCIHXgaq7\nuWSQi7bXzW8mBsRfuZHBImcvShQSZeZtqfxjrTlMR+VxrWb3BqiN2Zw+fYEi\n+u51\r\n=t71N\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIB0g4saS4wDCwXzf/96i/CldzdVfpKgPIsInP/BLb+mrAiEAmOTTcD3iDZpVuhfkn4sixB/PkMmqV5h0BBMlFA22Q5o="
          }
        ]
      },
      "maintainers": [
        {
          "email": "ben@benjamn.com",
          "name": "benjamn"
        },
        {
          "email": "james@meteor.com",
          "name": "jbaxleyiii"
        },
        {
          "email": "npm@meteor.com",
          "name": "mdg"
        },
        {
          "email": "peggyrayzis@gmail.com",
          "name": "peggyrayzis"
        }
      ],
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/apollo-cache-inmemory_1.3.0-beta.8_1536706010473_0.8378567929247949"
      },
      "_hasShrinkwrap": false
    },
    "1.3.0-beta.9": {
      "name": "apollo-cache-inmemory",
      "version": "1.3.0-beta.9",
      "description": "Core abstract of Caching layer for Apollo Client",
      "author": {
        "name": "James Baxley",
        "email": "james@meteor.com"
      },
      "contributors": [
        {
          "name": "James Baxley",
          "email": "james@meteor.com"
        },
        {
          "name": "Jonas Helfer",
          "email": "jonas@helfer.email"
        },
        {
          "name": "Sashko Stubailo",
          "email": "sashko@stubailo.com"
        },
        {
          "name": "James Burgess",
          "email": "jamesmillerburgess@gmail.com"
        },
        {
          "name": "Bazyli Brzóska",
          "email": "bazyli.brzoska@gmail.com"
        }
      ],
      "license": "MIT",
      "main": "./lib/bundle.umd.js",
      "module": "./lib/index.js",
      "jsnext:main": "./lib/index.js",
      "typings": "./lib/index.d.ts",
      "sideEffects": false,
      "repository": {
        "type": "git",
        "url": "git+https://github.com/apollographql/apollo-client.git"
      },
      "bugs": {
        "url": "https://github.com/apollographql/apollo-client/issues"
      },
      "homepage": "https://github.com/apollographql/apollo-client#readme",
      "scripts": {
        "prepare": "npm run build",
        "coverage": "jest --coverage",
        "test": "jest",
        "lint": "tslint -c \"../../config/tslint.json\" -p tsconfig.json src/*.ts",
        "prebuild": "npm run clean",
        "build": "tsc -p .",
        "postbuild": "npm run bundle",
        "bundle": "../../node_modules/rollup/bin/rollup -c rollup.config.js",
        "watch": "tsc -w -p .",
        "clean": "rm -rf coverage/* && rm -rf lib/*",
        "prepublishOnly": "npm run build",
        "minify": "../../node_modules/uglify-js/bin/uglifyjs -c -m -o ./lib/bundle.min.js -- ./lib/bundle.umd.js",
        "filesize": "npm run minify"
      },
      "dependencies": {
        "apollo-cache": "^1.1.16",
        "apollo-utilities": "^1.0.20",
        "optimism": "^0.6.6"
      },
      "peerDependencies": {
        "graphql": "0.11.7 || ^0.12.0 || ^0.13.0"
      },
      "jest": {
        "transform": {
          ".(ts|tsx)": "ts-jest"
        },
        "testRegex": "(/__tests__/.*|\\.(test|spec))\\.(ts|tsx|js)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "json"
        ],
        "testURL": "http://localhost"
      },
      "readme": "---\ntitle: InMemoryCache\ndescription: An explanation of `apollo-cache-inmemory`\n---\n\n`apollo-cache-inmemory` is the recommended cache implementation for Apollo Client 2.0. `InMemoryCache` is a normalized data store that supports all of Apollo Client 1.0's features without the dependency on Redux.\n\nIn some instances, you may need to manipulate the cache directly, such as updating the store after a mutation. We'll cover some common use cases [here](#recipes).\n\n<h2 id=\"installation\">Installation</h2>\n\n```\nnpm install apollo-cache-inmemory --save\n```\n\nAfter installing the package, you'll want to initialize the cache constructor. Then, you can pass in your newly created cache to ApolloClient.\n\n```js\nimport { InMemoryCache } from 'apollo-cache-inmemory';\nimport { HttpLink } from 'apollo-link-http';\nimport ApolloClient from 'apollo-client';\n\nconst cache = new InMemoryCache();\n\nconst client = new ApolloClient({\n  link: new HttpLink(),\n  cache\n});\n```\n\n<h2 id=\"configuration\">Configuration</h2>\n\nThe `InMemoryCache` constructor takes an optional config object with properties to customize your cache:\n\n- addTypename: A boolean to determine whether to add __typename to the document (default: `true`)\n- dataIdFromObject: A function that takes a data object and returns a unique identifier to be used when normalizing the data in the store. Learn more about how to customize `dataIdFromObject` in the [Normalization](#normalization) section.\n- fragmentMatcher: By default, the `InMemoryCache` uses a heuristic fragment matcher. If you are using fragments on unions and interfaces, you will need to use an `IntrospectionFragmentMatcher`. For more information, please read [our guide to setting up fragment matching for unions & interfaces](https://www.apollographql.com/docs/react/advanced/fragments.html#fragment-matcher).\n\n<h2 id=\"normalization\">Normalization</h2>\n\nThe `InMemoryCache` normalizes your data before saving it to the store by splitting the result into individual objects, creating a unique identifier for each object, and storing those objects in a flattened data structure. By default, `InMemoryCache` will attempt to use the commonly found primary keys of `id` and `_id` for the unique identifier if they exist along with `__typename` on an object.\n\nIf `id` and `_id` are not specified, or if `__typename` is not specified, `InMemoryCache` will fall back to the path to the object in the query, such as `ROOT_QUERY.allPeople.0` for the first record returned on the `allPeople` root query.\n\nThis \"getter\" behavior for unique identifiers can be configured manually via the `dataIdFromObject` option passed to the `InMemoryCache` constructor, so you can pick which field is used if some of your data follows unorthodox primary key conventions.\n\nFor example, if you wanted to key off of the `key` field for all of your data, you could configure `dataIdFromObject` like so:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => object.key\n});\n```\n\nThis also allows you to use different unique identifiers for different data types by keying off of the `__typename` property attached to every object typed by GraphQL.  For example:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => {\n    switch (object.__typename) {\n      case 'foo': return object.key; // use `key` as the primary key\n      case 'bar': return object.blah; // use `blah` as the priamry key\n      default: return object.id || object._id; // fall back to `id` and `_id` for all other types\n    }\n  }\n});\n```\n\n<h2 id=\"direct\">Direct Cache Access</h2>\n\nTo interact directly with your cache, you can use the Apollo Client class methods readQuery, readFragment, writeQuery, and writeFragment. These methods are available to us via the [`DataProxy` interface](https://github.com/apollographql/apollo-client/blob/master/packages/apollo-cache/src/types/DataProxy.ts). Accessing these methods will vary slightly based on your view layer implementation. If you are using React, you can wrap your component in the `withApollo` higher order component, which will give you access to `this.props.client`. From there, you can use the methods to control your data.\n\nAny code demonstration in the following sections will assume that we have already initialized an instance of  `ApolloClient` and that we have imported the `gql` tag from `graphql-tag`.\n\n<h3 id=\"readquery\">readQuery</h3>\n\nThe `readQuery` method is very similar to the [`query` method on `ApolloClient`][] except that `readQuery` will _never_ make a request to your GraphQL server. The `query` method, on the other hand, may send a request to your server if the appropriate data is not in your cache whereas `readQuery` will throw an error if the data is not in your cache. `readQuery` will _always_ read from the cache. You can use `readQuery` by giving it a GraphQL query like so:\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo {\n      todo(id: 5) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n});\n```\n\nIf all of the data needed to fulfill this read is in Apollo Client’s normalized data cache then a data object will be returned in the shape of the query you wanted to read. If not all of the data needed to fulfill this read is in Apollo Client’s cache then an error will be thrown instead, so make sure to only read data that you know you have!\n\nYou can also pass variables into `readQuery`.\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo($id: Int!) {\n      todo(id: $id) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n  variables: {\n    id: 5,\n  },\n});\n```\n\n<h3 id=\"readfragment\">readFragment</h3>\n\nThis method allows you great flexibility around the data in your cache. Whereas `readQuery` only allowed you to read data from your root query type, `readFragment` allows you to read data from _any node you have queried_. This is incredibly powerful. You use this method as follows:\n\n```js\nconst todo = client.readFragment({\n  id: ..., // `id` is any id that could be returned by `dataIdFromObject`.\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\nThe first argument is the id of the data you want to read from the cache. That id must be a value that was returned by the `dataIdFromObject` function you defined when initializing `ApolloClient`. So for example if you initialized `ApolloClient` like so:\n\n```js\nconst client = new ApolloClient({\n  ...,\n  dataIdFromObject: object => object.id,\n});\n```\n\n…and you requested a todo before with an id of `5`, then you can read that todo out of your cache with the following:\n\n```js\nconst todo = client.readFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\n> **Note:** Most people add a `__typename` to the id in `dataIdFromObject`. If you do this then don’t forget to add the `__typename` when you are reading a fragment as well. So for example your id may be `Todo_5` and not just `5`.\n\nIf a todo with that id does not exist in the cache you will get `null` back. If a todo of that id does exist in the cache, but that todo does not have the `text` field then an error will be thrown.\n\nThe beauty of `readFragment` is that the todo could have come from anywhere! The todo could have been selected as a singleton (`{ todo(id: 5) { ... } }`), the todo could have come from a list of todos (`{ todos { ... } }`), or the todo could have come from a mutation (`mutation { createTodo { ... } }`). As long as at some point your GraphQL server gave you a todo with the provided id and fields `id`, `text`, and `completed` you can read it from the cache at any part of your code.\n\n<h3 id=\"writequery-and-writefragment\">writeQuery` and `writeFragment</h3>\n\nNot only can you read arbitrary data from the Apollo Client cache, but you can also write any data that you would like to the cache. The methods you use to do this are `writeQuery` and `writeFragment`. They will allow you to change data in your local cache, but it is important to remember that *they will not change any data on your server*. If you reload your environment then changes made with `writeQuery` and `writeFragment` will disappear.\n\nThese methods have the same signature as their `readQuery` and `readFragment` counterparts except they also require an additional `data` variable. So for example, if you wanted to update the `completed` flag locally for your todo with id `'5'` you could execute the following:\n\n```js\nclient.writeFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      completed\n    }\n  `,\n  data: {\n    completed: true,\n  },\n});\n```\n\nAny subscriber to the Apollo Client store will instantly see this update and render new UI accordingly.\n\n> **Note:** Again, remember that using `writeQuery` or `writeFragment` only changes data *locally*. If you reload your environment then changes made with these methods will no longer exist.\n\nOr if you wanted to add a new todo to a list fetched from the server, you could use `readQuery` and `writeQuery` together.\n\n```js\nconst query = gql`\n  query MyTodoAppQuery {\n    todos {\n      id\n      text\n      completed\n    }\n  }\n`;\n\nconst data = client.readQuery({ query });\n\nconst myNewTodo = {\n  id: '6',\n  text: 'Start using Apollo Client.',\n  completed: false,\n};\n\nclient.writeQuery({\n  query,\n  data: {\n    todos: [...data.todos, myNewTodo],\n  },\n});\n```\n\n<h2 id=\"recipes\">Recipes</h2>\n\nHere are some common situations where you would need to access the cache directly. If you're manipulating the cache in an interesting way and would like your example to be featured, please send in a pull request!\n\n<h3 id=\"server\">Server side rendering</h3>\n\nFirst, you will need to initialize an `InMemoryCache` on the server and create an instance of `ApolloClient`. In the initial serialized HTML payload from the server, you should include a script tag that extracts the data from the cache.\n\n```js\n`<script>\n  window.__APOLLO_STATE__=${JSON.stringify(cache.extract())}\n</script>`\n```\n\nOn the client, you can rehydrate the cache using the initial data passed from the server:\n\n```js\ncache: new Cache().restore(window.__APOLLO_STATE__)\n```\n\nIf you would like to learn more about server side rendering, please check our our more in depth guide [here].\n<!---\nTODO (PEGGY): Add link to SSR\n-->\n\n<h3 id=\"server\">Updating the cache after a mutation</h3>\n\nBeing able to read and write to the Apollo cache from anywhere in your application gives you a lot of power over your data. However, there is one place where we most often want to update our cached data: after a mutation. As such, Apollo Client has optimized the experience for updating your cache with the read and write methods after a mutation with the `update` function. Let us say that we have the following GraphQL mutation:\n\n```graphql\nmutation TodoCreateMutation($text: String!) {\n  createTodo(text: $text) {\n    id\n    text\n    completed\n  }\n}\n```\n\nWe may also have the following GraphQL query:\n\n```graphql\nquery TodoAppQuery {\n  todos {\n    id\n    text\n    completed\n  }\n}\n```\n\nAt the end of our mutation we want our query to include the new todo like we had sent our `TodoAppQuery` a second time after the mutation finished without actually sending the query. To do this we can use the `update` function provided as an option of the `client.mutate` method. To update your cache with the mutation just write code that looks like:\n\n```js\n// We assume that the GraphQL operations `TodoCreateMutation` and\n// `TodoAppQuery` have already been defined using the `gql` tag.\n\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    // Read the data from our cache for this query.\n    const data = proxy.readQuery({ query: TodoAppQuery });\n\n    // Add our todo from the mutation to the end.\n    data.todos.push(createTodo);\n\n    // Write our data back to the cache.\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nThe first `proxy` argument is an instance of [`DataProxy`][] has the same four methods that we just learned exist on the Apollo Client: `readQuery`, `readFragment`, `writeQuery`, and `writeFragment`. The reason we call them on a `proxy` object here instead of on our `client` instance is that we can easily apply optimistic updates (which we will demonstrate in a bit). The `proxy` object also provides an isolated transaction which shields you from any other mutations going on at the same time, and the `proxy` object also batches writes together until the very end.\n\nIf you provide an `optimisticResponse` option to the mutation then the `update` function will be run twice. Once immediately after you call `client.mutate` with the data from `optimisticResponse`. After the mutation successfully executes against the server the changes made in the first call to `update` will be rolled back and `update` will be called with the *actual* data returned by the mutation and not just the optimistic response.\n\nPutting it all together:\n\n```js\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  optimisticResponse: {\n    id: -1, // -1 is a temporary id for the optimistic response.\n    text,\n    completed: false,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    const data = proxy.readQuery({ query: TodoAppQuery });\n    data.todos.push(createTodo);\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nAs you can see the `update` function on `client.mutate` provides extra change management functionality specific to the use case of a mutation while still providing you the powerful data control APIs that are available on `client`.\n\nThe `update` function is not a good place for side-effects as it may be called multiple times. Also, you may not call any of the methods on `proxy` asynchronously.\n\n",
      "readmeFilename": "README.md",
      "_id": "apollo-cache-inmemory@1.3.0-beta.9",
      "_npmVersion": "6.4.1",
      "_nodeVersion": "8.12.0",
      "_npmUser": {
        "name": "benjamn",
        "email": "ben@benjamn.com"
      },
      "dist": {
        "integrity": "sha512-otE35Ogg2AWrIjU1LNQLYG4S9OPV6NMNTIbVdV4QEgoLfkj1sCjV8i7GNx6rbOTxmex9LWTDcj7MNxGqtSlmoA==",
        "shasum": "bd4223252547e44b001aeca3a61ff2dc3fa29626",
        "tarball": "https://registry.npmjs.org/apollo-cache-inmemory/-/apollo-cache-inmemory-1.3.0-beta.9.tgz",
        "fileCount": 78,
        "unpackedSize": 454905,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJbmEdCCRA9TVsSAnZWagAA7vAP/1S9ya4QHEWLF4wPaJ6/\nF/fxDqWbV9JLV8iKbhlvb1sCfInZt9aX5YjYDs8z1J28PcmoNspUChRIUAMX\n0QwHE9oDjefMAI3lZ4urQgoLc1QA1j1SAVEJSA7K/KYtTjzSPAk5GMLr7hPQ\nlfUgKm3gIFabCuRZMN31LsC76jjaZi/N+lnZ5VsJvjgZUt/nTkFzebjfkz3n\ntPtscm2zgoet3rXns+Hwp+9RN29yawYs7GJQZjzfLlCRnY+1/8J8H3npO4wN\nC7XIUYaVw1/A+b4lnHvnCK+WTtGC3K+H7jwLyzQRkRV4wKaif5TtnZ8zU3y9\n7444ZbqshCteQLHuMPGDsCCLd9sOU3X/OZ8zT+sALhs69wd1rGwfLaVlJ+1R\nQ5EDCkmibObYjK0cBv0jTfE0Q4CZfPLYZaTYpxNzynBOF49uBhawcIICcaz+\ngrLemiRaC0ltZUfvkUKEJhTiV7wP5sQIJltvWMvaDU0byuurW450l6Zhx3Xk\n4qm6l0Brt8Fr0Xbpmms5EocIpztFmiDdEWhPSCbAbqnh4WGimeOvl9tjQfEw\n8JIyAk6fca+WkIp+0w0cOoV9fQoTHV9fQK1oeschAv8MOFNt+d3eHLH6Zq0g\nVgjokX76PT+jKL064NpXMEKa6cj064FuKzOwRU8Tue6jDaGi17+ffepsk7YU\ngwht\r\n=I//B\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCICq31oabNCbEMefsLCcpe6xHL50pK0R+JgtHAWWYy/BbAiEA7JL4Yid4QJyuq3J9NIAAcZb/1rtK+CLwamu0VP9M4AI="
          }
        ]
      },
      "maintainers": [
        {
          "email": "ben@benjamn.com",
          "name": "benjamn"
        },
        {
          "email": "james@meteor.com",
          "name": "jbaxleyiii"
        },
        {
          "email": "npm@meteor.com",
          "name": "mdg"
        },
        {
          "email": "peggyrayzis@gmail.com",
          "name": "peggyrayzis"
        }
      ],
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/apollo-cache-inmemory_1.3.0-beta.9_1536706369629_0.4220239697864976"
      },
      "_hasShrinkwrap": false
    },
    "1.3.0-beta.10": {
      "name": "apollo-cache-inmemory",
      "version": "1.3.0-beta.10",
      "description": "Core abstract of Caching layer for Apollo Client",
      "author": {
        "name": "James Baxley",
        "email": "james@meteor.com"
      },
      "contributors": [
        {
          "name": "James Baxley",
          "email": "james@meteor.com"
        },
        {
          "name": "Jonas Helfer",
          "email": "jonas@helfer.email"
        },
        {
          "name": "Sashko Stubailo",
          "email": "sashko@stubailo.com"
        },
        {
          "name": "James Burgess",
          "email": "jamesmillerburgess@gmail.com"
        },
        {
          "name": "Bazyli Brzóska",
          "email": "bazyli.brzoska@gmail.com"
        }
      ],
      "license": "MIT",
      "main": "./lib/bundle.umd.js",
      "module": "./lib/index.js",
      "jsnext:main": "./lib/index.js",
      "typings": "./lib/index.d.ts",
      "sideEffects": false,
      "repository": {
        "type": "git",
        "url": "git+https://github.com/apollographql/apollo-client.git"
      },
      "bugs": {
        "url": "https://github.com/apollographql/apollo-client/issues"
      },
      "homepage": "https://github.com/apollographql/apollo-client#readme",
      "scripts": {
        "prepare": "npm run build",
        "coverage": "jest --coverage",
        "test": "jest",
        "lint": "tslint -c \"../../config/tslint.json\" -p tsconfig.json src/*.ts",
        "prebuild": "npm run clean",
        "build": "tsc -p .",
        "postbuild": "npm run bundle",
        "bundle": "../../node_modules/rollup/bin/rollup -c rollup.config.js",
        "watch": "tsc -w -p .",
        "clean": "rm -rf coverage/* && rm -rf lib/*",
        "prepublishOnly": "npm run build",
        "minify": "../../node_modules/uglify-js/bin/uglifyjs -c -m -o ./lib/bundle.min.js -- ./lib/bundle.umd.js",
        "filesize": "npm run minify"
      },
      "dependencies": {
        "apollo-cache": "^1.1.16",
        "apollo-utilities": "^1.0.20",
        "optimism": "^0.6.6"
      },
      "peerDependencies": {
        "graphql": "0.11.7 || ^0.12.0 || ^0.13.0"
      },
      "jest": {
        "transform": {
          ".(ts|tsx)": "ts-jest"
        },
        "testRegex": "(/__tests__/.*|\\.(test|spec))\\.(ts|tsx|js)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "json"
        ],
        "testURL": "http://localhost"
      },
      "readme": "---\ntitle: InMemoryCache\ndescription: An explanation of `apollo-cache-inmemory`\n---\n\n`apollo-cache-inmemory` is the recommended cache implementation for Apollo Client 2.0. `InMemoryCache` is a normalized data store that supports all of Apollo Client 1.0's features without the dependency on Redux.\n\nIn some instances, you may need to manipulate the cache directly, such as updating the store after a mutation. We'll cover some common use cases [here](#recipes).\n\n<h2 id=\"installation\">Installation</h2>\n\n```\nnpm install apollo-cache-inmemory --save\n```\n\nAfter installing the package, you'll want to initialize the cache constructor. Then, you can pass in your newly created cache to ApolloClient.\n\n```js\nimport { InMemoryCache } from 'apollo-cache-inmemory';\nimport { HttpLink } from 'apollo-link-http';\nimport ApolloClient from 'apollo-client';\n\nconst cache = new InMemoryCache();\n\nconst client = new ApolloClient({\n  link: new HttpLink(),\n  cache\n});\n```\n\n<h2 id=\"configuration\">Configuration</h2>\n\nThe `InMemoryCache` constructor takes an optional config object with properties to customize your cache:\n\n- addTypename: A boolean to determine whether to add __typename to the document (default: `true`)\n- dataIdFromObject: A function that takes a data object and returns a unique identifier to be used when normalizing the data in the store. Learn more about how to customize `dataIdFromObject` in the [Normalization](#normalization) section.\n- fragmentMatcher: By default, the `InMemoryCache` uses a heuristic fragment matcher. If you are using fragments on unions and interfaces, you will need to use an `IntrospectionFragmentMatcher`. For more information, please read [our guide to setting up fragment matching for unions & interfaces](https://www.apollographql.com/docs/react/advanced/fragments.html#fragment-matcher).\n\n<h2 id=\"normalization\">Normalization</h2>\n\nThe `InMemoryCache` normalizes your data before saving it to the store by splitting the result into individual objects, creating a unique identifier for each object, and storing those objects in a flattened data structure. By default, `InMemoryCache` will attempt to use the commonly found primary keys of `id` and `_id` for the unique identifier if they exist along with `__typename` on an object.\n\nIf `id` and `_id` are not specified, or if `__typename` is not specified, `InMemoryCache` will fall back to the path to the object in the query, such as `ROOT_QUERY.allPeople.0` for the first record returned on the `allPeople` root query.\n\nThis \"getter\" behavior for unique identifiers can be configured manually via the `dataIdFromObject` option passed to the `InMemoryCache` constructor, so you can pick which field is used if some of your data follows unorthodox primary key conventions.\n\nFor example, if you wanted to key off of the `key` field for all of your data, you could configure `dataIdFromObject` like so:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => object.key\n});\n```\n\nThis also allows you to use different unique identifiers for different data types by keying off of the `__typename` property attached to every object typed by GraphQL.  For example:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => {\n    switch (object.__typename) {\n      case 'foo': return object.key; // use `key` as the primary key\n      case 'bar': return object.blah; // use `blah` as the priamry key\n      default: return object.id || object._id; // fall back to `id` and `_id` for all other types\n    }\n  }\n});\n```\n\n<h2 id=\"direct\">Direct Cache Access</h2>\n\nTo interact directly with your cache, you can use the Apollo Client class methods readQuery, readFragment, writeQuery, and writeFragment. These methods are available to us via the [`DataProxy` interface](https://github.com/apollographql/apollo-client/blob/master/packages/apollo-cache/src/types/DataProxy.ts). Accessing these methods will vary slightly based on your view layer implementation. If you are using React, you can wrap your component in the `withApollo` higher order component, which will give you access to `this.props.client`. From there, you can use the methods to control your data.\n\nAny code demonstration in the following sections will assume that we have already initialized an instance of  `ApolloClient` and that we have imported the `gql` tag from `graphql-tag`.\n\n<h3 id=\"readquery\">readQuery</h3>\n\nThe `readQuery` method is very similar to the [`query` method on `ApolloClient`][] except that `readQuery` will _never_ make a request to your GraphQL server. The `query` method, on the other hand, may send a request to your server if the appropriate data is not in your cache whereas `readQuery` will throw an error if the data is not in your cache. `readQuery` will _always_ read from the cache. You can use `readQuery` by giving it a GraphQL query like so:\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo {\n      todo(id: 5) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n});\n```\n\nIf all of the data needed to fulfill this read is in Apollo Client’s normalized data cache then a data object will be returned in the shape of the query you wanted to read. If not all of the data needed to fulfill this read is in Apollo Client’s cache then an error will be thrown instead, so make sure to only read data that you know you have!\n\nYou can also pass variables into `readQuery`.\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo($id: Int!) {\n      todo(id: $id) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n  variables: {\n    id: 5,\n  },\n});\n```\n\n<h3 id=\"readfragment\">readFragment</h3>\n\nThis method allows you great flexibility around the data in your cache. Whereas `readQuery` only allowed you to read data from your root query type, `readFragment` allows you to read data from _any node you have queried_. This is incredibly powerful. You use this method as follows:\n\n```js\nconst todo = client.readFragment({\n  id: ..., // `id` is any id that could be returned by `dataIdFromObject`.\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\nThe first argument is the id of the data you want to read from the cache. That id must be a value that was returned by the `dataIdFromObject` function you defined when initializing `ApolloClient`. So for example if you initialized `ApolloClient` like so:\n\n```js\nconst client = new ApolloClient({\n  ...,\n  dataIdFromObject: object => object.id,\n});\n```\n\n…and you requested a todo before with an id of `5`, then you can read that todo out of your cache with the following:\n\n```js\nconst todo = client.readFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\n> **Note:** Most people add a `__typename` to the id in `dataIdFromObject`. If you do this then don’t forget to add the `__typename` when you are reading a fragment as well. So for example your id may be `Todo_5` and not just `5`.\n\nIf a todo with that id does not exist in the cache you will get `null` back. If a todo of that id does exist in the cache, but that todo does not have the `text` field then an error will be thrown.\n\nThe beauty of `readFragment` is that the todo could have come from anywhere! The todo could have been selected as a singleton (`{ todo(id: 5) { ... } }`), the todo could have come from a list of todos (`{ todos { ... } }`), or the todo could have come from a mutation (`mutation { createTodo { ... } }`). As long as at some point your GraphQL server gave you a todo with the provided id and fields `id`, `text`, and `completed` you can read it from the cache at any part of your code.\n\n<h3 id=\"writequery-and-writefragment\">writeQuery` and `writeFragment</h3>\n\nNot only can you read arbitrary data from the Apollo Client cache, but you can also write any data that you would like to the cache. The methods you use to do this are `writeQuery` and `writeFragment`. They will allow you to change data in your local cache, but it is important to remember that *they will not change any data on your server*. If you reload your environment then changes made with `writeQuery` and `writeFragment` will disappear.\n\nThese methods have the same signature as their `readQuery` and `readFragment` counterparts except they also require an additional `data` variable. So for example, if you wanted to update the `completed` flag locally for your todo with id `'5'` you could execute the following:\n\n```js\nclient.writeFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      completed\n    }\n  `,\n  data: {\n    completed: true,\n  },\n});\n```\n\nAny subscriber to the Apollo Client store will instantly see this update and render new UI accordingly.\n\n> **Note:** Again, remember that using `writeQuery` or `writeFragment` only changes data *locally*. If you reload your environment then changes made with these methods will no longer exist.\n\nOr if you wanted to add a new todo to a list fetched from the server, you could use `readQuery` and `writeQuery` together.\n\n```js\nconst query = gql`\n  query MyTodoAppQuery {\n    todos {\n      id\n      text\n      completed\n    }\n  }\n`;\n\nconst data = client.readQuery({ query });\n\nconst myNewTodo = {\n  id: '6',\n  text: 'Start using Apollo Client.',\n  completed: false,\n};\n\nclient.writeQuery({\n  query,\n  data: {\n    todos: [...data.todos, myNewTodo],\n  },\n});\n```\n\n<h2 id=\"recipes\">Recipes</h2>\n\nHere are some common situations where you would need to access the cache directly. If you're manipulating the cache in an interesting way and would like your example to be featured, please send in a pull request!\n\n<h3 id=\"server\">Server side rendering</h3>\n\nFirst, you will need to initialize an `InMemoryCache` on the server and create an instance of `ApolloClient`. In the initial serialized HTML payload from the server, you should include a script tag that extracts the data from the cache.\n\n```js\n`<script>\n  window.__APOLLO_STATE__=${JSON.stringify(cache.extract())}\n</script>`\n```\n\nOn the client, you can rehydrate the cache using the initial data passed from the server:\n\n```js\ncache: new Cache().restore(window.__APOLLO_STATE__)\n```\n\nIf you would like to learn more about server side rendering, please check our our more in depth guide [here].\n<!---\nTODO (PEGGY): Add link to SSR\n-->\n\n<h3 id=\"server\">Updating the cache after a mutation</h3>\n\nBeing able to read and write to the Apollo cache from anywhere in your application gives you a lot of power over your data. However, there is one place where we most often want to update our cached data: after a mutation. As such, Apollo Client has optimized the experience for updating your cache with the read and write methods after a mutation with the `update` function. Let us say that we have the following GraphQL mutation:\n\n```graphql\nmutation TodoCreateMutation($text: String!) {\n  createTodo(text: $text) {\n    id\n    text\n    completed\n  }\n}\n```\n\nWe may also have the following GraphQL query:\n\n```graphql\nquery TodoAppQuery {\n  todos {\n    id\n    text\n    completed\n  }\n}\n```\n\nAt the end of our mutation we want our query to include the new todo like we had sent our `TodoAppQuery` a second time after the mutation finished without actually sending the query. To do this we can use the `update` function provided as an option of the `client.mutate` method. To update your cache with the mutation just write code that looks like:\n\n```js\n// We assume that the GraphQL operations `TodoCreateMutation` and\n// `TodoAppQuery` have already been defined using the `gql` tag.\n\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    // Read the data from our cache for this query.\n    const data = proxy.readQuery({ query: TodoAppQuery });\n\n    // Add our todo from the mutation to the end.\n    data.todos.push(createTodo);\n\n    // Write our data back to the cache.\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nThe first `proxy` argument is an instance of [`DataProxy`][] has the same four methods that we just learned exist on the Apollo Client: `readQuery`, `readFragment`, `writeQuery`, and `writeFragment`. The reason we call them on a `proxy` object here instead of on our `client` instance is that we can easily apply optimistic updates (which we will demonstrate in a bit). The `proxy` object also provides an isolated transaction which shields you from any other mutations going on at the same time, and the `proxy` object also batches writes together until the very end.\n\nIf you provide an `optimisticResponse` option to the mutation then the `update` function will be run twice. Once immediately after you call `client.mutate` with the data from `optimisticResponse`. After the mutation successfully executes against the server the changes made in the first call to `update` will be rolled back and `update` will be called with the *actual* data returned by the mutation and not just the optimistic response.\n\nPutting it all together:\n\n```js\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  optimisticResponse: {\n    id: -1, // -1 is a temporary id for the optimistic response.\n    text,\n    completed: false,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    const data = proxy.readQuery({ query: TodoAppQuery });\n    data.todos.push(createTodo);\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nAs you can see the `update` function on `client.mutate` provides extra change management functionality specific to the use case of a mutation while still providing you the powerful data control APIs that are available on `client`.\n\nThe `update` function is not a good place for side-effects as it may be called multiple times. Also, you may not call any of the methods on `proxy` asynchronously.\n\n",
      "readmeFilename": "README.md",
      "_id": "apollo-cache-inmemory@1.3.0-beta.10",
      "_npmVersion": "6.4.1",
      "_nodeVersion": "8.12.0",
      "_npmUser": {
        "name": "benjamn",
        "email": "ben@benjamn.com"
      },
      "dist": {
        "integrity": "sha512-lBprYfGDNHzjPb7fMIsjjXLKtbPetcjeJ2TqfcRAvu0FjhA+NdhJQacCY9f6OViI323OXNbaNGslmNeTr1bhWg==",
        "shasum": "7bfe81ebf5205f280b5bceffde53cde99afabaec",
        "tarball": "https://registry.npmjs.org/apollo-cache-inmemory/-/apollo-cache-inmemory-1.3.0-beta.10.tgz",
        "fileCount": 78,
        "unpackedSize": 451060,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJbmF6qCRA9TVsSAnZWagAAUC0QAIXmXfKM58KkPJU6hJhA\nBHp8l1f6HZzmqgjHTxfRlDV9WoDGh3+M4DJZYi0cfxq4mSAuwk26pzlTJtq+\n8aozIBv2CkI10dtPILQ6rlPvFUoKDa52VJQ5wRpZFE595EmlNOA0uW7JhOl5\nmJgx4EY45bCFqXYc23rzWQ5/8cw7OmgHglGv4sMUz5V8EYcpVkmBskuC+h/H\n6INJg2v1WekpOoHh3V/MHB0yPYt4bn6wEPBmhUNbKNmc0N/Ca1PnFZBygq73\ndvNA/kO1bGT/G82Dos6Bn0hcvrdR9/KXTIyQ3n8i8J8TMAV1/kApX4Ii3ZLf\nAsidiTQoBaRftcvCNzoQtAtNzxUmd8fHWxcviMpsjsMOl4b7Dk719yok6LvP\nerAtibOw6Rpiv5T/vHTS6KQAb25nDFmyWXsIfzpUZWtr1etrhJERdAf5yTt6\nl5aXKlH2hYb/egPzzanwCRC4kHqU1C7jxfdO9lMXDsLK+sXv/F5cAyQAJ3iS\n4QwIUGsdbBbLl44vvaH0As8zsHNaXhtOBLe8C2hOtfrKTZ5CxD3EkfYJV37G\nbC8TSH26hZqMqaYLuO5npmknL0gcs66ncxQ0RBRDzNDvq4HsqbvmNPgNIOyi\naKjmr8+XhN1uQQElZxC4vMeCpJlrLg4uemkm3hL0Nvq8AUGANMOd3mWvTEd8\nJ5Qz\r\n=NgHP\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEQCIGUwH83bgA9LweTzXvzHMNsHh8Q5AmmgL2CX1rpAx8HuAiAl64qfcCM/1+QtN4Qdzbijc56N2zg8Bg25V7BNeneqiA=="
          }
        ]
      },
      "maintainers": [
        {
          "email": "ben@benjamn.com",
          "name": "benjamn"
        },
        {
          "email": "james@meteor.com",
          "name": "jbaxleyiii"
        },
        {
          "email": "npm@meteor.com",
          "name": "mdg"
        },
        {
          "email": "peggyrayzis@gmail.com",
          "name": "peggyrayzis"
        }
      ],
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/apollo-cache-inmemory_1.3.0-beta.10_1536712361446_0.75725846009453"
      },
      "_hasShrinkwrap": false
    },
    "1.2.10": {
      "name": "apollo-cache-inmemory",
      "version": "1.2.10",
      "description": "Core abstract of Caching layer for Apollo Client",
      "author": {
        "name": "James Baxley",
        "email": "james@meteor.com"
      },
      "contributors": [
        {
          "name": "James Baxley",
          "email": "james@meteor.com"
        },
        {
          "name": "Jonas Helfer",
          "email": "jonas@helfer.email"
        },
        {
          "name": "Sashko Stubailo",
          "email": "sashko@stubailo.com"
        },
        {
          "name": "James Burgess",
          "email": "jamesmillerburgess@gmail.com"
        },
        {
          "name": "Bazyli Brzóska",
          "email": "bazyli.brzoska@gmail.com"
        }
      ],
      "license": "MIT",
      "main": "./lib/bundle.umd.js",
      "module": "./lib/index.js",
      "jsnext:main": "./lib/index.js",
      "typings": "./lib/index.d.ts",
      "sideEffects": false,
      "repository": {
        "type": "git",
        "url": "git+https://github.com/apollographql/apollo-client.git"
      },
      "bugs": {
        "url": "https://github.com/apollographql/apollo-client/issues"
      },
      "homepage": "https://github.com/apollographql/apollo-client#readme",
      "scripts": {
        "prepare": "npm run lint && npm run build",
        "coverage": "jest --coverage",
        "test": "jest",
        "lint": "tslint -c \"../../config/tslint.json\" -p tsconfig.json src/*.ts",
        "prebuild": "npm run clean",
        "build": "tsc -p .",
        "postbuild": "npm run bundle",
        "bundle": "../../node_modules/rollup/bin/rollup -c rollup.config.js",
        "watch": "tsc -w -p .",
        "clean": "rm -rf coverage/* && rm -rf lib/*",
        "prepublishOnly": "npm run build",
        "minify": "../../node_modules/uglify-js/bin/uglifyjs -c -m -o ./lib/bundle.min.js -- ./lib/bundle.umd.js",
        "filesize": "npm run minify"
      },
      "dependencies": {
        "apollo-cache": "^1.1.17",
        "apollo-utilities": "^1.0.21",
        "graphql-anywhere": "^4.1.19"
      },
      "peerDependencies": {
        "graphql": "0.11.7 || ^0.12.0 || ^0.13.0"
      },
      "jest": {
        "transform": {
          ".(ts|tsx)": "ts-jest"
        },
        "testRegex": "(/__tests__/.*|\\.(test|spec))\\.(ts|tsx|js)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "json"
        ],
        "testURL": "http://localhost"
      },
      "gitHead": "6b8a3651d85c0b9eaa88385caf970905f497cf21",
      "_id": "apollo-cache-inmemory@1.2.10",
      "_npmVersion": "5.6.0",
      "_nodeVersion": "8.11.2",
      "_npmUser": {
        "name": "mdg",
        "email": "npm@meteor.com"
      },
      "dist": {
        "integrity": "sha512-eBusPFVtYIuo+PIfJdAwUCQ4cs7AJ4mB7sTdXxNQCXToYw8mzE6EfHnV37kdVfBXSaa82BzE2rb/YUq/duuamw==",
        "shasum": "362d6c36cfd815a309b966f71e5d2b6c770c7989",
        "tarball": "https://registry.npmjs.org/apollo-cache-inmemory/-/apollo-cache-inmemory-1.2.10.tgz",
        "fileCount": 69,
        "unpackedSize": 410878,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJbmN6MCRA9TVsSAnZWagAAvVAP/3n2pCsyZr0EKB5AEDcP\nwkSYQM25mj+BZ849ZHVUxFVZnbhz19ebQ31WD2HAxZ5TmKr4a9jKVLsALmLg\nOXitEHpZNbZMvRIeps1zLvoxqn693XZi1fnZVxy+m+J1FKEgRA6IK/B0nb3y\nRv7+TQSjdeWKWeWnq3Q/rzJ6sF5kPaJjZbQFXCMTdRBXdYB6ZYKV1Nw8yYWw\nsU7CiLo2RuZaJ9aMSGskQRejqVsZBFVsEU9uEqeu/1bx76+rRJQTQ4Qx1a7q\njfZ9sHUbkkrymDVSG1S93tGvFZ5hsgC2PKscoEURSBY8QGXfzbQkbQTleibY\nEqgPxNtExbf6SizMEEeGy7+9/Te94heAEdirlltEIeViqdE5rqdWLrOdedA4\nTEGKPM/YaYnlsPTxebl2T8k3ZAyCwMCUmNT2OA2pWRMEC1vv74moa3bIzSEK\n35X8KIAaXX3ZI/DEBkn+La0SxYeYTFuY0A7qWw/HNjHre1RiPdvY72JLwK96\nIG38+PiR+xgcZUQgPqYSaM1SPF/kIwtcnWMK+Sup3DZRlfFWrH7gCyi5EOw+\nyihZwFLftkptqLTBLxIH+dEdrSJSpBGuoptHPepGzNiXrmG3FMBy2G5ASFHs\nzpUgbKoybupyIu1ucf3iv3t8WtEzwd50w+g773K1M8vi0K1ZVTyfDq0lIdpi\ndTvP\r\n=itAV\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEYCIQDbMhSfJu0xC5iTi7lIhSZcBmyqFIZcjQFZZ/R9vo4BIwIhAKU6zkqgLMgqHHyw+JOYstyA0zjB6PKHt4DNbJmqH8/O"
          }
        ]
      },
      "maintainers": [
        {
          "email": "ben@benjamn.com",
          "name": "benjamn"
        },
        {
          "email": "james@meteor.com",
          "name": "jbaxleyiii"
        },
        {
          "email": "npm@meteor.com",
          "name": "mdg"
        },
        {
          "email": "peggyrayzis@gmail.com",
          "name": "peggyrayzis"
        }
      ],
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/apollo-cache-inmemory_1.2.10_1536745099838_0.006077108440161183"
      },
      "_hasShrinkwrap": false
    },
    "1.3.0-beta.11": {
      "name": "apollo-cache-inmemory",
      "version": "1.3.0-beta.11",
      "description": "Core abstract of Caching layer for Apollo Client",
      "author": {
        "name": "James Baxley",
        "email": "james@meteor.com"
      },
      "contributors": [
        {
          "name": "James Baxley",
          "email": "james@meteor.com"
        },
        {
          "name": "Jonas Helfer",
          "email": "jonas@helfer.email"
        },
        {
          "name": "Sashko Stubailo",
          "email": "sashko@stubailo.com"
        },
        {
          "name": "James Burgess",
          "email": "jamesmillerburgess@gmail.com"
        },
        {
          "name": "Bazyli Brzóska",
          "email": "bazyli.brzoska@gmail.com"
        }
      ],
      "license": "MIT",
      "main": "./lib/bundle.umd.js",
      "module": "./lib/index.js",
      "jsnext:main": "./lib/index.js",
      "typings": "./lib/index.d.ts",
      "sideEffects": false,
      "repository": {
        "type": "git",
        "url": "git+https://github.com/apollographql/apollo-client.git"
      },
      "bugs": {
        "url": "https://github.com/apollographql/apollo-client/issues"
      },
      "homepage": "https://github.com/apollographql/apollo-client#readme",
      "scripts": {
        "prepare": "npm run build",
        "coverage": "jest --coverage",
        "test": "jest",
        "lint": "tslint -c \"../../config/tslint.json\" -p tsconfig.json src/*.ts",
        "prebuild": "npm run clean",
        "build": "tsc -p .",
        "postbuild": "npm run bundle",
        "bundle": "../../node_modules/rollup/bin/rollup -c rollup.config.js",
        "watch": "tsc -w -p .",
        "clean": "rm -rf coverage/* && rm -rf lib/*",
        "prepublishOnly": "npm run build",
        "minify": "../../node_modules/uglify-js/bin/uglifyjs -c -m -o ./lib/bundle.min.js -- ./lib/bundle.umd.js",
        "filesize": "npm run minify"
      },
      "dependencies": {
        "apollo-cache": "^1.1.16",
        "apollo-utilities": "^1.0.20",
        "optimism": "^0.6.6"
      },
      "peerDependencies": {
        "graphql": "0.11.7 || ^0.12.0 || ^0.13.0"
      },
      "jest": {
        "transform": {
          ".(ts|tsx)": "ts-jest"
        },
        "testRegex": "(/__tests__/.*|\\.(test|spec))\\.(ts|tsx|js)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "json"
        ],
        "testURL": "http://localhost"
      },
      "readme": "---\ntitle: InMemoryCache\ndescription: An explanation of `apollo-cache-inmemory`\n---\n\n`apollo-cache-inmemory` is the recommended cache implementation for Apollo Client 2.0. `InMemoryCache` is a normalized data store that supports all of Apollo Client 1.0's features without the dependency on Redux.\n\nIn some instances, you may need to manipulate the cache directly, such as updating the store after a mutation. We'll cover some common use cases [here](#recipes).\n\n<h2 id=\"installation\">Installation</h2>\n\n```\nnpm install apollo-cache-inmemory --save\n```\n\nAfter installing the package, you'll want to initialize the cache constructor. Then, you can pass in your newly created cache to ApolloClient.\n\n```js\nimport { InMemoryCache } from 'apollo-cache-inmemory';\nimport { HttpLink } from 'apollo-link-http';\nimport ApolloClient from 'apollo-client';\n\nconst cache = new InMemoryCache();\n\nconst client = new ApolloClient({\n  link: new HttpLink(),\n  cache\n});\n```\n\n<h2 id=\"configuration\">Configuration</h2>\n\nThe `InMemoryCache` constructor takes an optional config object with properties to customize your cache:\n\n- addTypename: A boolean to determine whether to add __typename to the document (default: `true`)\n- dataIdFromObject: A function that takes a data object and returns a unique identifier to be used when normalizing the data in the store. Learn more about how to customize `dataIdFromObject` in the [Normalization](#normalization) section.\n- fragmentMatcher: By default, the `InMemoryCache` uses a heuristic fragment matcher. If you are using fragments on unions and interfaces, you will need to use an `IntrospectionFragmentMatcher`. For more information, please read [our guide to setting up fragment matching for unions & interfaces](https://www.apollographql.com/docs/react/advanced/fragments.html#fragment-matcher).\n\n<h2 id=\"normalization\">Normalization</h2>\n\nThe `InMemoryCache` normalizes your data before saving it to the store by splitting the result into individual objects, creating a unique identifier for each object, and storing those objects in a flattened data structure. By default, `InMemoryCache` will attempt to use the commonly found primary keys of `id` and `_id` for the unique identifier if they exist along with `__typename` on an object.\n\nIf `id` and `_id` are not specified, or if `__typename` is not specified, `InMemoryCache` will fall back to the path to the object in the query, such as `ROOT_QUERY.allPeople.0` for the first record returned on the `allPeople` root query.\n\nThis \"getter\" behavior for unique identifiers can be configured manually via the `dataIdFromObject` option passed to the `InMemoryCache` constructor, so you can pick which field is used if some of your data follows unorthodox primary key conventions.\n\nFor example, if you wanted to key off of the `key` field for all of your data, you could configure `dataIdFromObject` like so:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => object.key\n});\n```\n\nThis also allows you to use different unique identifiers for different data types by keying off of the `__typename` property attached to every object typed by GraphQL.  For example:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => {\n    switch (object.__typename) {\n      case 'foo': return object.key; // use `key` as the primary key\n      case 'bar': return object.blah; // use `blah` as the priamry key\n      default: return object.id || object._id; // fall back to `id` and `_id` for all other types\n    }\n  }\n});\n```\n\n<h2 id=\"direct\">Direct Cache Access</h2>\n\nTo interact directly with your cache, you can use the Apollo Client class methods readQuery, readFragment, writeQuery, and writeFragment. These methods are available to us via the [`DataProxy` interface](https://github.com/apollographql/apollo-client/blob/master/packages/apollo-cache/src/types/DataProxy.ts). Accessing these methods will vary slightly based on your view layer implementation. If you are using React, you can wrap your component in the `withApollo` higher order component, which will give you access to `this.props.client`. From there, you can use the methods to control your data.\n\nAny code demonstration in the following sections will assume that we have already initialized an instance of  `ApolloClient` and that we have imported the `gql` tag from `graphql-tag`.\n\n<h3 id=\"readquery\">readQuery</h3>\n\nThe `readQuery` method is very similar to the [`query` method on `ApolloClient`][] except that `readQuery` will _never_ make a request to your GraphQL server. The `query` method, on the other hand, may send a request to your server if the appropriate data is not in your cache whereas `readQuery` will throw an error if the data is not in your cache. `readQuery` will _always_ read from the cache. You can use `readQuery` by giving it a GraphQL query like so:\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo {\n      todo(id: 5) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n});\n```\n\nIf all of the data needed to fulfill this read is in Apollo Client’s normalized data cache then a data object will be returned in the shape of the query you wanted to read. If not all of the data needed to fulfill this read is in Apollo Client’s cache then an error will be thrown instead, so make sure to only read data that you know you have!\n\nYou can also pass variables into `readQuery`.\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo($id: Int!) {\n      todo(id: $id) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n  variables: {\n    id: 5,\n  },\n});\n```\n\n<h3 id=\"readfragment\">readFragment</h3>\n\nThis method allows you great flexibility around the data in your cache. Whereas `readQuery` only allowed you to read data from your root query type, `readFragment` allows you to read data from _any node you have queried_. This is incredibly powerful. You use this method as follows:\n\n```js\nconst todo = client.readFragment({\n  id: ..., // `id` is any id that could be returned by `dataIdFromObject`.\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\nThe first argument is the id of the data you want to read from the cache. That id must be a value that was returned by the `dataIdFromObject` function you defined when initializing `ApolloClient`. So for example if you initialized `ApolloClient` like so:\n\n```js\nconst client = new ApolloClient({\n  ...,\n  dataIdFromObject: object => object.id,\n});\n```\n\n…and you requested a todo before with an id of `5`, then you can read that todo out of your cache with the following:\n\n```js\nconst todo = client.readFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\n> **Note:** Most people add a `__typename` to the id in `dataIdFromObject`. If you do this then don’t forget to add the `__typename` when you are reading a fragment as well. So for example your id may be `Todo_5` and not just `5`.\n\nIf a todo with that id does not exist in the cache you will get `null` back. If a todo of that id does exist in the cache, but that todo does not have the `text` field then an error will be thrown.\n\nThe beauty of `readFragment` is that the todo could have come from anywhere! The todo could have been selected as a singleton (`{ todo(id: 5) { ... } }`), the todo could have come from a list of todos (`{ todos { ... } }`), or the todo could have come from a mutation (`mutation { createTodo { ... } }`). As long as at some point your GraphQL server gave you a todo with the provided id and fields `id`, `text`, and `completed` you can read it from the cache at any part of your code.\n\n<h3 id=\"writequery-and-writefragment\">writeQuery` and `writeFragment</h3>\n\nNot only can you read arbitrary data from the Apollo Client cache, but you can also write any data that you would like to the cache. The methods you use to do this are `writeQuery` and `writeFragment`. They will allow you to change data in your local cache, but it is important to remember that *they will not change any data on your server*. If you reload your environment then changes made with `writeQuery` and `writeFragment` will disappear.\n\nThese methods have the same signature as their `readQuery` and `readFragment` counterparts except they also require an additional `data` variable. So for example, if you wanted to update the `completed` flag locally for your todo with id `'5'` you could execute the following:\n\n```js\nclient.writeFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      completed\n    }\n  `,\n  data: {\n    completed: true,\n  },\n});\n```\n\nAny subscriber to the Apollo Client store will instantly see this update and render new UI accordingly.\n\n> **Note:** Again, remember that using `writeQuery` or `writeFragment` only changes data *locally*. If you reload your environment then changes made with these methods will no longer exist.\n\nOr if you wanted to add a new todo to a list fetched from the server, you could use `readQuery` and `writeQuery` together.\n\n```js\nconst query = gql`\n  query MyTodoAppQuery {\n    todos {\n      id\n      text\n      completed\n    }\n  }\n`;\n\nconst data = client.readQuery({ query });\n\nconst myNewTodo = {\n  id: '6',\n  text: 'Start using Apollo Client.',\n  completed: false,\n};\n\nclient.writeQuery({\n  query,\n  data: {\n    todos: [...data.todos, myNewTodo],\n  },\n});\n```\n\n<h2 id=\"recipes\">Recipes</h2>\n\nHere are some common situations where you would need to access the cache directly. If you're manipulating the cache in an interesting way and would like your example to be featured, please send in a pull request!\n\n<h3 id=\"server\">Server side rendering</h3>\n\nFirst, you will need to initialize an `InMemoryCache` on the server and create an instance of `ApolloClient`. In the initial serialized HTML payload from the server, you should include a script tag that extracts the data from the cache.\n\n```js\n`<script>\n  window.__APOLLO_STATE__=${JSON.stringify(cache.extract())}\n</script>`\n```\n\nOn the client, you can rehydrate the cache using the initial data passed from the server:\n\n```js\ncache: new Cache().restore(window.__APOLLO_STATE__)\n```\n\nIf you would like to learn more about server side rendering, please check our our more in depth guide [here].\n<!---\nTODO (PEGGY): Add link to SSR\n-->\n\n<h3 id=\"server\">Updating the cache after a mutation</h3>\n\nBeing able to read and write to the Apollo cache from anywhere in your application gives you a lot of power over your data. However, there is one place where we most often want to update our cached data: after a mutation. As such, Apollo Client has optimized the experience for updating your cache with the read and write methods after a mutation with the `update` function. Let us say that we have the following GraphQL mutation:\n\n```graphql\nmutation TodoCreateMutation($text: String!) {\n  createTodo(text: $text) {\n    id\n    text\n    completed\n  }\n}\n```\n\nWe may also have the following GraphQL query:\n\n```graphql\nquery TodoAppQuery {\n  todos {\n    id\n    text\n    completed\n  }\n}\n```\n\nAt the end of our mutation we want our query to include the new todo like we had sent our `TodoAppQuery` a second time after the mutation finished without actually sending the query. To do this we can use the `update` function provided as an option of the `client.mutate` method. To update your cache with the mutation just write code that looks like:\n\n```js\n// We assume that the GraphQL operations `TodoCreateMutation` and\n// `TodoAppQuery` have already been defined using the `gql` tag.\n\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    // Read the data from our cache for this query.\n    const data = proxy.readQuery({ query: TodoAppQuery });\n\n    // Add our todo from the mutation to the end.\n    data.todos.push(createTodo);\n\n    // Write our data back to the cache.\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nThe first `proxy` argument is an instance of [`DataProxy`][] has the same four methods that we just learned exist on the Apollo Client: `readQuery`, `readFragment`, `writeQuery`, and `writeFragment`. The reason we call them on a `proxy` object here instead of on our `client` instance is that we can easily apply optimistic updates (which we will demonstrate in a bit). The `proxy` object also provides an isolated transaction which shields you from any other mutations going on at the same time, and the `proxy` object also batches writes together until the very end.\n\nIf you provide an `optimisticResponse` option to the mutation then the `update` function will be run twice. Once immediately after you call `client.mutate` with the data from `optimisticResponse`. After the mutation successfully executes against the server the changes made in the first call to `update` will be rolled back and `update` will be called with the *actual* data returned by the mutation and not just the optimistic response.\n\nPutting it all together:\n\n```js\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  optimisticResponse: {\n    id: -1, // -1 is a temporary id for the optimistic response.\n    text,\n    completed: false,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    const data = proxy.readQuery({ query: TodoAppQuery });\n    data.todos.push(createTodo);\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nAs you can see the `update` function on `client.mutate` provides extra change management functionality specific to the use case of a mutation while still providing you the powerful data control APIs that are available on `client`.\n\nThe `update` function is not a good place for side-effects as it may be called multiple times. Also, you may not call any of the methods on `proxy` asynchronously.\n\n",
      "readmeFilename": "README.md",
      "_id": "apollo-cache-inmemory@1.3.0-beta.11",
      "_npmVersion": "6.4.1",
      "_nodeVersion": "8.11.4",
      "_npmUser": {
        "name": "benjamn",
        "email": "ben@benjamn.com"
      },
      "dist": {
        "integrity": "sha512-jv9l/RhulwgrHMwSq9xry4oYd3Y0bwffOuMBtlL80RpeHxti+paX+AyZQuftb6MaETOzoeOyboqNUJUf/Kvd8g==",
        "shasum": "a98e7bf65c37abf0e900c72bec3f676db08a4bce",
        "tarball": "https://registry.npmjs.org/apollo-cache-inmemory/-/apollo-cache-inmemory-1.3.0-beta.11.tgz",
        "fileCount": 78,
        "unpackedSize": 456588,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJbm/yNCRA9TVsSAnZWagAAWFMP/RhnlG4sbGxBmDBx96mn\nQkjCK6y1KhM0gEFIAo4Eg/DjXoyOqblG/AXS1JDnhpRuWPy4ZSS7MN5VtDv8\nvKTKDDmTqzRHWPISx+qI5eMAuuhB0g6MCv507kq1CEAKY7a5jSPwkWK3Mca4\n/O5qzVw/7A2KQnKoufex0kVvtFY2QsICU38SaaBs4hP0/EVCafriAJmtAbpt\np2QwjwAupvd/IAi0tzxjmoAlqI4UdRu3XZbM2hnL8HIkLwGyr507PIbwVe8O\n1TygQFR47naA3GCYa7e3/QNKkAAaVhrpZfNMDRX9oatBuQIQ+8vYL1Zoxbrp\nDiyqsdz5S7m+7YIDUcb53wjc0y/cjLf98HYaNryEEjC3rHpsSMetOKTzavZ7\n5MsLFVnIEuS6LSUjrAwGgWvuhxcVsaJAPUnxe3kEx1YI7lO9bOX7c3n+auIt\nf0ACx/4bFSbufe02oDkWFztYEvctQyroLQ0eSeRuf1DA94pmyvNMOaEpZOdO\nhj/C8yMNlC69R0NPxiNgZyNS0//R0F2gqQou1Lz0qNRE5X4Hgwa+jQgiOVQ8\n5q1sp7/LKYPwYKkhET6xOIcqkMrpwvxZRWq1RCqLgq89opUsAwXdsH2eZ+PJ\nrkkDOi3wNM1MbzWALINxQVM+r80BvqdFxvhUhTIeOE4g/ruXQbrUaEvuqmjw\n1V2e\r\n=SEj4\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCID/3ZBycUVubUEyaIzuyvslFi6xD1miKtfuYX+p41q3aAiEAkveqSGtqVqRtHMHF7jUuQbjwitxXKOe0qChEHkVGoZU="
          }
        ]
      },
      "maintainers": [
        {
          "email": "ben@benjamn.com",
          "name": "benjamn"
        },
        {
          "email": "james@meteor.com",
          "name": "jbaxleyiii"
        },
        {
          "email": "npm@meteor.com",
          "name": "mdg"
        },
        {
          "email": "peggyrayzis@gmail.com",
          "name": "peggyrayzis"
        }
      ],
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/apollo-cache-inmemory_1.3.0-beta.11_1536949388092_0.5574359552246657"
      },
      "_hasShrinkwrap": false
    },
    "1.3.0-beta.12": {
      "name": "apollo-cache-inmemory",
      "version": "1.3.0-beta.12",
      "description": "Core abstract of Caching layer for Apollo Client",
      "author": {
        "name": "James Baxley",
        "email": "james@meteor.com"
      },
      "contributors": [
        {
          "name": "James Baxley",
          "email": "james@meteor.com"
        },
        {
          "name": "Jonas Helfer",
          "email": "jonas@helfer.email"
        },
        {
          "name": "Sashko Stubailo",
          "email": "sashko@stubailo.com"
        },
        {
          "name": "James Burgess",
          "email": "jamesmillerburgess@gmail.com"
        },
        {
          "name": "Bazyli Brzóska",
          "email": "bazyli.brzoska@gmail.com"
        }
      ],
      "license": "MIT",
      "main": "./lib/bundle.umd.js",
      "module": "./lib/index.js",
      "jsnext:main": "./lib/index.js",
      "typings": "./lib/index.d.ts",
      "sideEffects": false,
      "repository": {
        "type": "git",
        "url": "git+https://github.com/apollographql/apollo-client.git"
      },
      "bugs": {
        "url": "https://github.com/apollographql/apollo-client/issues"
      },
      "homepage": "https://github.com/apollographql/apollo-client#readme",
      "scripts": {
        "prepare": "npm run build",
        "coverage": "jest --coverage",
        "test": "jest",
        "lint": "tslint -c \"../../config/tslint.json\" -p tsconfig.json src/*.ts",
        "prebuild": "npm run clean",
        "build": "tsc -p .",
        "postbuild": "npm run bundle",
        "bundle": "../../node_modules/rollup/bin/rollup -c rollup.config.js",
        "watch": "tsc -w -p .",
        "clean": "rm -rf coverage/* && rm -rf lib/*",
        "prepublishOnly": "npm run build",
        "minify": "../../node_modules/uglify-js/bin/uglifyjs -c -m -o ./lib/bundle.min.js -- ./lib/bundle.umd.js",
        "filesize": "npm run minify"
      },
      "dependencies": {
        "apollo-cache": "^1.1.16",
        "apollo-utilities": "^1.0.20",
        "optimism": "^0.6.6"
      },
      "peerDependencies": {
        "graphql": "0.11.7 || ^0.12.0 || ^0.13.0"
      },
      "jest": {
        "transform": {
          ".(ts|tsx)": "ts-jest"
        },
        "testRegex": "(/__tests__/.*|\\.(test|spec))\\.(ts|tsx|js)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "json"
        ],
        "testURL": "http://localhost"
      },
      "_id": "apollo-cache-inmemory@1.3.0-beta.12",
      "_npmVersion": "6.4.1",
      "_nodeVersion": "8.11.4",
      "_npmUser": {
        "name": "benjamn",
        "email": "ben@benjamn.com"
      },
      "dist": {
        "integrity": "sha512-xcr9/pd4L9kgiFvqkJAaBq76zBJcCzTehuTbIqHdkkw3+c+QixYu5dFWh3YYmvppjh2/Lm12Z82JU7K/cBmuZA==",
        "shasum": "8248d19a5a9a9e9eaaf64eb9cb0ce278bf06f8d3",
        "tarball": "https://registry.npmjs.org/apollo-cache-inmemory/-/apollo-cache-inmemory-1.3.0-beta.12.tgz",
        "fileCount": 78,
        "unpackedSize": 458520,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJbnAV9CRA9TVsSAnZWagAADyQP/0mg1bGpX3ojyfgV5Pj3\nYdMgIBe9s2+uWi2HdvgnLX+ytXt4JoFelXIUMBW/a5KQ00mmtQOeLeEW8tkx\n65qfCKNt5rCWThiZmyQQg3No4s2wew21oFk10UzxmHuvl22NTPWFYuZZzsxe\nNftzrSnRRQUZ0Q7c2icr1S0epG7KI4qyQL417+Ay3FelryvcS7+JacS8tWWw\nkHyHAIjUTGvxNg567/tPXIZ8rg4Seh2UBdSBxNx8QHxvRVWeTHlKoChLAbli\nEllOpnOgrEYaUD7WL95W7h8ah5S12NzhqXhAs55bH88uUAwZzvcordQXFSpm\nJppzOchTVKL+nxPHaVyocmmuVuiVLVWVysFin3fY6//cBg1A4EEdaJDDpQ9r\nyNGHt9BKk8/MU2I741rYrL0X+DJPGAmGIlHl+SCb5J4MWqruJD7dth6u9cQ0\no1TfxPNJHi2LqIFmU/P4LND6Wv7jPXEx08zslF92t9ePtus7LT6WoDL7gcVX\nWQJQe679+ydHbanexZ4Yhdlf7Cpv10iVnMZ1rvOWdPaoY8cN+W/8oZMQo/sL\nlX7XxhrnONdCSML98o4HUBnx7pvCXArIVx4rT/B99H67PrQrllGfKYqu601v\norA8N4yQfHqwNm1piqKECLEgQksMtFSY8jPI8UDtCJTwcaYehPs5eANEg2eO\n8/4V\r\n=oC5/\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEQCIAYDLQXkGcEtc1ZqhVdlFh1gV2HbR2T8qW0J87MWVgy9AiAwSC+QohiZEvrPJYIXzsuhGq/ynvg/OTRQyeXS6532dA=="
          }
        ]
      },
      "maintainers": [
        {
          "email": "ben@benjamn.com",
          "name": "benjamn"
        },
        {
          "email": "james@meteor.com",
          "name": "jbaxleyiii"
        },
        {
          "email": "npm@meteor.com",
          "name": "mdg"
        },
        {
          "email": "peggyrayzis@gmail.com",
          "name": "peggyrayzis"
        }
      ],
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/apollo-cache-inmemory_1.3.0-beta.12_1536951676419_0.5165689765594321"
      },
      "_hasShrinkwrap": false
    },
    "1.3.0-beta.13": {
      "name": "apollo-cache-inmemory",
      "version": "1.3.0-beta.13",
      "description": "Core abstract of Caching layer for Apollo Client",
      "author": {
        "name": "James Baxley",
        "email": "james@meteor.com"
      },
      "contributors": [
        {
          "name": "James Baxley",
          "email": "james@meteor.com"
        },
        {
          "name": "Jonas Helfer",
          "email": "jonas@helfer.email"
        },
        {
          "name": "Sashko Stubailo",
          "email": "sashko@stubailo.com"
        },
        {
          "name": "James Burgess",
          "email": "jamesmillerburgess@gmail.com"
        },
        {
          "name": "Bazyli Brzóska",
          "email": "bazyli.brzoska@gmail.com"
        }
      ],
      "license": "MIT",
      "main": "./lib/bundle.umd.js",
      "module": "./lib/index.js",
      "jsnext:main": "./lib/index.js",
      "typings": "./lib/index.d.ts",
      "sideEffects": false,
      "repository": {
        "type": "git",
        "url": "git+https://github.com/apollographql/apollo-client.git"
      },
      "bugs": {
        "url": "https://github.com/apollographql/apollo-client/issues"
      },
      "homepage": "https://github.com/apollographql/apollo-client#readme",
      "scripts": {
        "prepare": "npm run build",
        "coverage": "jest --coverage",
        "test": "jest",
        "lint": "tslint -c \"../../config/tslint.json\" -p tsconfig.json src/*.ts",
        "prebuild": "npm run clean",
        "build": "tsc -p .",
        "postbuild": "npm run bundle",
        "bundle": "../../node_modules/rollup/bin/rollup -c rollup.config.js",
        "watch": "tsc -w -p .",
        "clean": "rm -rf coverage/* && rm -rf lib/*",
        "prepublishOnly": "npm run build",
        "minify": "../../node_modules/uglify-js/bin/uglifyjs -c -m -o ./lib/bundle.min.js -- ./lib/bundle.umd.js",
        "filesize": "npm run minify"
      },
      "dependencies": {
        "apollo-cache": "^1.1.16",
        "apollo-utilities": "^1.0.20",
        "optimism": "^0.6.6"
      },
      "peerDependencies": {
        "graphql": "0.11.7 || ^0.12.0 || ^0.13.0"
      },
      "jest": {
        "transform": {
          ".(ts|tsx)": "ts-jest"
        },
        "testRegex": "(/__tests__/.*|\\.(test|spec))\\.(ts|tsx|js)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "json"
        ],
        "testURL": "http://localhost"
      },
      "readme": "---\ntitle: InMemoryCache\ndescription: An explanation of `apollo-cache-inmemory`\n---\n\n`apollo-cache-inmemory` is the recommended cache implementation for Apollo Client 2.0. `InMemoryCache` is a normalized data store that supports all of Apollo Client 1.0's features without the dependency on Redux.\n\nIn some instances, you may need to manipulate the cache directly, such as updating the store after a mutation. We'll cover some common use cases [here](#recipes).\n\n<h2 id=\"installation\">Installation</h2>\n\n```\nnpm install apollo-cache-inmemory --save\n```\n\nAfter installing the package, you'll want to initialize the cache constructor. Then, you can pass in your newly created cache to ApolloClient.\n\n```js\nimport { InMemoryCache } from 'apollo-cache-inmemory';\nimport { HttpLink } from 'apollo-link-http';\nimport ApolloClient from 'apollo-client';\n\nconst cache = new InMemoryCache();\n\nconst client = new ApolloClient({\n  link: new HttpLink(),\n  cache\n});\n```\n\n<h2 id=\"configuration\">Configuration</h2>\n\nThe `InMemoryCache` constructor takes an optional config object with properties to customize your cache:\n\n- addTypename: A boolean to determine whether to add __typename to the document (default: `true`)\n- dataIdFromObject: A function that takes a data object and returns a unique identifier to be used when normalizing the data in the store. Learn more about how to customize `dataIdFromObject` in the [Normalization](#normalization) section.\n- fragmentMatcher: By default, the `InMemoryCache` uses a heuristic fragment matcher. If you are using fragments on unions and interfaces, you will need to use an `IntrospectionFragmentMatcher`. For more information, please read [our guide to setting up fragment matching for unions & interfaces](https://www.apollographql.com/docs/react/advanced/fragments.html#fragment-matcher).\n\n<h2 id=\"normalization\">Normalization</h2>\n\nThe `InMemoryCache` normalizes your data before saving it to the store by splitting the result into individual objects, creating a unique identifier for each object, and storing those objects in a flattened data structure. By default, `InMemoryCache` will attempt to use the commonly found primary keys of `id` and `_id` for the unique identifier if they exist along with `__typename` on an object.\n\nIf `id` and `_id` are not specified, or if `__typename` is not specified, `InMemoryCache` will fall back to the path to the object in the query, such as `ROOT_QUERY.allPeople.0` for the first record returned on the `allPeople` root query.\n\nThis \"getter\" behavior for unique identifiers can be configured manually via the `dataIdFromObject` option passed to the `InMemoryCache` constructor, so you can pick which field is used if some of your data follows unorthodox primary key conventions.\n\nFor example, if you wanted to key off of the `key` field for all of your data, you could configure `dataIdFromObject` like so:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => object.key\n});\n```\n\nThis also allows you to use different unique identifiers for different data types by keying off of the `__typename` property attached to every object typed by GraphQL.  For example:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => {\n    switch (object.__typename) {\n      case 'foo': return object.key; // use `key` as the primary key\n      case 'bar': return object.blah; // use `blah` as the priamry key\n      default: return object.id || object._id; // fall back to `id` and `_id` for all other types\n    }\n  }\n});\n```\n\n<h2 id=\"direct\">Direct Cache Access</h2>\n\nTo interact directly with your cache, you can use the Apollo Client class methods readQuery, readFragment, writeQuery, and writeFragment. These methods are available to us via the [`DataProxy` interface](https://github.com/apollographql/apollo-client/blob/master/packages/apollo-cache/src/types/DataProxy.ts). Accessing these methods will vary slightly based on your view layer implementation. If you are using React, you can wrap your component in the `withApollo` higher order component, which will give you access to `this.props.client`. From there, you can use the methods to control your data.\n\nAny code demonstration in the following sections will assume that we have already initialized an instance of  `ApolloClient` and that we have imported the `gql` tag from `graphql-tag`.\n\n<h3 id=\"readquery\">readQuery</h3>\n\nThe `readQuery` method is very similar to the [`query` method on `ApolloClient`][] except that `readQuery` will _never_ make a request to your GraphQL server. The `query` method, on the other hand, may send a request to your server if the appropriate data is not in your cache whereas `readQuery` will throw an error if the data is not in your cache. `readQuery` will _always_ read from the cache. You can use `readQuery` by giving it a GraphQL query like so:\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo {\n      todo(id: 5) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n});\n```\n\nIf all of the data needed to fulfill this read is in Apollo Client’s normalized data cache then a data object will be returned in the shape of the query you wanted to read. If not all of the data needed to fulfill this read is in Apollo Client’s cache then an error will be thrown instead, so make sure to only read data that you know you have!\n\nYou can also pass variables into `readQuery`.\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo($id: Int!) {\n      todo(id: $id) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n  variables: {\n    id: 5,\n  },\n});\n```\n\n<h3 id=\"readfragment\">readFragment</h3>\n\nThis method allows you great flexibility around the data in your cache. Whereas `readQuery` only allowed you to read data from your root query type, `readFragment` allows you to read data from _any node you have queried_. This is incredibly powerful. You use this method as follows:\n\n```js\nconst todo = client.readFragment({\n  id: ..., // `id` is any id that could be returned by `dataIdFromObject`.\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\nThe first argument is the id of the data you want to read from the cache. That id must be a value that was returned by the `dataIdFromObject` function you defined when initializing `ApolloClient`. So for example if you initialized `ApolloClient` like so:\n\n```js\nconst client = new ApolloClient({\n  ...,\n  dataIdFromObject: object => object.id,\n});\n```\n\n…and you requested a todo before with an id of `5`, then you can read that todo out of your cache with the following:\n\n```js\nconst todo = client.readFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\n> **Note:** Most people add a `__typename` to the id in `dataIdFromObject`. If you do this then don’t forget to add the `__typename` when you are reading a fragment as well. So for example your id may be `Todo_5` and not just `5`.\n\nIf a todo with that id does not exist in the cache you will get `null` back. If a todo of that id does exist in the cache, but that todo does not have the `text` field then an error will be thrown.\n\nThe beauty of `readFragment` is that the todo could have come from anywhere! The todo could have been selected as a singleton (`{ todo(id: 5) { ... } }`), the todo could have come from a list of todos (`{ todos { ... } }`), or the todo could have come from a mutation (`mutation { createTodo { ... } }`). As long as at some point your GraphQL server gave you a todo with the provided id and fields `id`, `text`, and `completed` you can read it from the cache at any part of your code.\n\n<h3 id=\"writequery-and-writefragment\">writeQuery` and `writeFragment</h3>\n\nNot only can you read arbitrary data from the Apollo Client cache, but you can also write any data that you would like to the cache. The methods you use to do this are `writeQuery` and `writeFragment`. They will allow you to change data in your local cache, but it is important to remember that *they will not change any data on your server*. If you reload your environment then changes made with `writeQuery` and `writeFragment` will disappear.\n\nThese methods have the same signature as their `readQuery` and `readFragment` counterparts except they also require an additional `data` variable. So for example, if you wanted to update the `completed` flag locally for your todo with id `'5'` you could execute the following:\n\n```js\nclient.writeFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      completed\n    }\n  `,\n  data: {\n    completed: true,\n  },\n});\n```\n\nAny subscriber to the Apollo Client store will instantly see this update and render new UI accordingly.\n\n> **Note:** Again, remember that using `writeQuery` or `writeFragment` only changes data *locally*. If you reload your environment then changes made with these methods will no longer exist.\n\nOr if you wanted to add a new todo to a list fetched from the server, you could use `readQuery` and `writeQuery` together.\n\n```js\nconst query = gql`\n  query MyTodoAppQuery {\n    todos {\n      id\n      text\n      completed\n    }\n  }\n`;\n\nconst data = client.readQuery({ query });\n\nconst myNewTodo = {\n  id: '6',\n  text: 'Start using Apollo Client.',\n  completed: false,\n};\n\nclient.writeQuery({\n  query,\n  data: {\n    todos: [...data.todos, myNewTodo],\n  },\n});\n```\n\n<h2 id=\"recipes\">Recipes</h2>\n\nHere are some common situations where you would need to access the cache directly. If you're manipulating the cache in an interesting way and would like your example to be featured, please send in a pull request!\n\n<h3 id=\"server\">Server side rendering</h3>\n\nFirst, you will need to initialize an `InMemoryCache` on the server and create an instance of `ApolloClient`. In the initial serialized HTML payload from the server, you should include a script tag that extracts the data from the cache.\n\n```js\n`<script>\n  window.__APOLLO_STATE__=${JSON.stringify(cache.extract())}\n</script>`\n```\n\nOn the client, you can rehydrate the cache using the initial data passed from the server:\n\n```js\ncache: new Cache().restore(window.__APOLLO_STATE__)\n```\n\nIf you would like to learn more about server side rendering, please check our our more in depth guide [here].\n<!---\nTODO (PEGGY): Add link to SSR\n-->\n\n<h3 id=\"server\">Updating the cache after a mutation</h3>\n\nBeing able to read and write to the Apollo cache from anywhere in your application gives you a lot of power over your data. However, there is one place where we most often want to update our cached data: after a mutation. As such, Apollo Client has optimized the experience for updating your cache with the read and write methods after a mutation with the `update` function. Let us say that we have the following GraphQL mutation:\n\n```graphql\nmutation TodoCreateMutation($text: String!) {\n  createTodo(text: $text) {\n    id\n    text\n    completed\n  }\n}\n```\n\nWe may also have the following GraphQL query:\n\n```graphql\nquery TodoAppQuery {\n  todos {\n    id\n    text\n    completed\n  }\n}\n```\n\nAt the end of our mutation we want our query to include the new todo like we had sent our `TodoAppQuery` a second time after the mutation finished without actually sending the query. To do this we can use the `update` function provided as an option of the `client.mutate` method. To update your cache with the mutation just write code that looks like:\n\n```js\n// We assume that the GraphQL operations `TodoCreateMutation` and\n// `TodoAppQuery` have already been defined using the `gql` tag.\n\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    // Read the data from our cache for this query.\n    const data = proxy.readQuery({ query: TodoAppQuery });\n\n    // Add our todo from the mutation to the end.\n    data.todos.push(createTodo);\n\n    // Write our data back to the cache.\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nThe first `proxy` argument is an instance of [`DataProxy`][] has the same four methods that we just learned exist on the Apollo Client: `readQuery`, `readFragment`, `writeQuery`, and `writeFragment`. The reason we call them on a `proxy` object here instead of on our `client` instance is that we can easily apply optimistic updates (which we will demonstrate in a bit). The `proxy` object also provides an isolated transaction which shields you from any other mutations going on at the same time, and the `proxy` object also batches writes together until the very end.\n\nIf you provide an `optimisticResponse` option to the mutation then the `update` function will be run twice. Once immediately after you call `client.mutate` with the data from `optimisticResponse`. After the mutation successfully executes against the server the changes made in the first call to `update` will be rolled back and `update` will be called with the *actual* data returned by the mutation and not just the optimistic response.\n\nPutting it all together:\n\n```js\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  optimisticResponse: {\n    id: -1, // -1 is a temporary id for the optimistic response.\n    text,\n    completed: false,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    const data = proxy.readQuery({ query: TodoAppQuery });\n    data.todos.push(createTodo);\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nAs you can see the `update` function on `client.mutate` provides extra change management functionality specific to the use case of a mutation while still providing you the powerful data control APIs that are available on `client`.\n\nThe `update` function is not a good place for side-effects as it may be called multiple times. Also, you may not call any of the methods on `proxy` asynchronously.\n\n",
      "readmeFilename": "README.md",
      "_id": "apollo-cache-inmemory@1.3.0-beta.13",
      "_npmVersion": "6.4.1",
      "_nodeVersion": "8.11.4",
      "_npmUser": {
        "name": "benjamn",
        "email": "ben@benjamn.com"
      },
      "dist": {
        "integrity": "sha512-mgXdDIZ9D9gAe8hSYcVWGsmi9KVqMTtLMuVeMorzh8+ojEYvonVYpQ7xXHWj3vUMCnxGsYipsf35Ya9oUlmbCA==",
        "shasum": "4695daaf5eaa8016a918d9f71b938d2f172cd99e",
        "tarball": "https://registry.npmjs.org/apollo-cache-inmemory/-/apollo-cache-inmemory-1.3.0-beta.13.tgz",
        "fileCount": 78,
        "unpackedSize": 458496,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJbnAZkCRA9TVsSAnZWagAAJscQAJEkHmMeb8GQf0nhAF4K\n+4z8HoXiSRlMQRS7TARVpV2tbad5fDU0Iz1tNSzxSQBKUQcglhg1mpnzocIG\n8QRbm+n2jdtBXJ91xmMg8QfiN/rO60KOhMyg4ub4cUvdd1HD3lgp2AgGaKxr\nIQy9WTgsqX7gEwTE1j3IjkBgTzSANpcUvMk8KDExCYicg3C+kCP7zl0CHzWk\nsTBeR+Cz9joIe5fKc5E1wU2KG+ug33YRYA/uJ61q6ONrmmJrbOOE7q7GWQEP\ngyRJOKAfgI4px8f3go+YnEGY3z8rGlmD0Vx6CGBpmDvPH/Y1LByeSuLhs5cZ\nKIbujc3zVaGSJSYdV66uYUx4o7A/OQpWG/6fWQSt7VGtqiZDOXF8CXwBj13J\nnf1SSlKGaKn/3tbemhHtn6dw97N85bFafwIHpnN0SP1F3giHeYwAGvtqAuSI\nurG+SFQUdkDaGTVssvilXzZuCBZSG9kcxQP3im1opM+xqcoJGESCzL6Z9tBO\nKNdPk7PrC6hLhdNYsasoeyY6FtjWO5GHNs1p/ul/04SKPNhb1waAsQlEMUxI\nMv0U5ghg+Rg66mLYL2OGpS2PvubVDg1FgSnEYLLSaWRiQFo6oEjLAquMKGx1\nyD9Ke3dE1OsGNtNxFzAMvi/jWGoRXLUNah4kRMC+mucvULHVL2qVX8igLXBz\nKlDv\r\n=Qexa\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEYCIQCiugZnprbMiLcfqVA29Z8sPJkU4oLj0EUfzcrSlrHMEwIhANl3eA8c5oQDxcNNTKZWTeyIOwyoVkh/iM6JpQOJfYKv"
          }
        ]
      },
      "maintainers": [
        {
          "email": "ben@benjamn.com",
          "name": "benjamn"
        },
        {
          "email": "james@meteor.com",
          "name": "jbaxleyiii"
        },
        {
          "email": "npm@meteor.com",
          "name": "mdg"
        },
        {
          "email": "peggyrayzis@gmail.com",
          "name": "peggyrayzis"
        }
      ],
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/apollo-cache-inmemory_1.3.0-beta.13_1536951907619_0.3978965250260562"
      },
      "_hasShrinkwrap": false
    },
    "1.3.0-beta.14": {
      "name": "apollo-cache-inmemory",
      "version": "1.3.0-beta.14",
      "description": "Core abstract of Caching layer for Apollo Client",
      "author": {
        "name": "James Baxley",
        "email": "james@meteor.com"
      },
      "contributors": [
        {
          "name": "James Baxley",
          "email": "james@meteor.com"
        },
        {
          "name": "Jonas Helfer",
          "email": "jonas@helfer.email"
        },
        {
          "name": "Sashko Stubailo",
          "email": "sashko@stubailo.com"
        },
        {
          "name": "James Burgess",
          "email": "jamesmillerburgess@gmail.com"
        },
        {
          "name": "Bazyli Brzóska",
          "email": "bazyli.brzoska@gmail.com"
        }
      ],
      "license": "MIT",
      "main": "./lib/bundle.umd.js",
      "module": "./lib/index.js",
      "jsnext:main": "./lib/index.js",
      "typings": "./lib/index.d.ts",
      "sideEffects": false,
      "repository": {
        "type": "git",
        "url": "git+https://github.com/apollographql/apollo-client.git"
      },
      "bugs": {
        "url": "https://github.com/apollographql/apollo-client/issues"
      },
      "homepage": "https://github.com/apollographql/apollo-client#readme",
      "scripts": {
        "prepare": "npm run build",
        "coverage": "jest --coverage",
        "test": "jest",
        "lint": "tslint -c \"../../config/tslint.json\" -p tsconfig.json src/*.ts",
        "prebuild": "npm run clean",
        "build": "tsc -p .",
        "postbuild": "npm run bundle",
        "bundle": "../../node_modules/rollup/bin/rollup -c rollup.config.js",
        "watch": "tsc -w -p .",
        "clean": "rm -rf coverage/* && rm -rf lib/*",
        "prepublishOnly": "npm run build",
        "minify": "../../node_modules/uglify-js/bin/uglifyjs -c -m -o ./lib/bundle.min.js -- ./lib/bundle.umd.js",
        "filesize": "npm run minify"
      },
      "dependencies": {
        "apollo-cache": "^1.1.16",
        "apollo-utilities": "^1.0.20",
        "optimism": "^0.6.6"
      },
      "peerDependencies": {
        "graphql": "0.11.7 || ^0.12.0 || ^0.13.0"
      },
      "jest": {
        "transform": {
          ".(ts|tsx)": "ts-jest"
        },
        "testRegex": "(/__tests__/.*|\\.(test|spec))\\.(ts|tsx|js)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "json"
        ],
        "testURL": "http://localhost"
      },
      "readme": "---\ntitle: InMemoryCache\ndescription: An explanation of `apollo-cache-inmemory`\n---\n\n`apollo-cache-inmemory` is the recommended cache implementation for Apollo Client 2.0. `InMemoryCache` is a normalized data store that supports all of Apollo Client 1.0's features without the dependency on Redux.\n\nIn some instances, you may need to manipulate the cache directly, such as updating the store after a mutation. We'll cover some common use cases [here](#recipes).\n\n<h2 id=\"installation\">Installation</h2>\n\n```\nnpm install apollo-cache-inmemory --save\n```\n\nAfter installing the package, you'll want to initialize the cache constructor. Then, you can pass in your newly created cache to ApolloClient.\n\n```js\nimport { InMemoryCache } from 'apollo-cache-inmemory';\nimport { HttpLink } from 'apollo-link-http';\nimport ApolloClient from 'apollo-client';\n\nconst cache = new InMemoryCache();\n\nconst client = new ApolloClient({\n  link: new HttpLink(),\n  cache\n});\n```\n\n<h2 id=\"configuration\">Configuration</h2>\n\nThe `InMemoryCache` constructor takes an optional config object with properties to customize your cache:\n\n- addTypename: A boolean to determine whether to add __typename to the document (default: `true`)\n- dataIdFromObject: A function that takes a data object and returns a unique identifier to be used when normalizing the data in the store. Learn more about how to customize `dataIdFromObject` in the [Normalization](#normalization) section.\n- fragmentMatcher: By default, the `InMemoryCache` uses a heuristic fragment matcher. If you are using fragments on unions and interfaces, you will need to use an `IntrospectionFragmentMatcher`. For more information, please read [our guide to setting up fragment matching for unions & interfaces](https://www.apollographql.com/docs/react/advanced/fragments.html#fragment-matcher).\n\n<h2 id=\"normalization\">Normalization</h2>\n\nThe `InMemoryCache` normalizes your data before saving it to the store by splitting the result into individual objects, creating a unique identifier for each object, and storing those objects in a flattened data structure. By default, `InMemoryCache` will attempt to use the commonly found primary keys of `id` and `_id` for the unique identifier if they exist along with `__typename` on an object.\n\nIf `id` and `_id` are not specified, or if `__typename` is not specified, `InMemoryCache` will fall back to the path to the object in the query, such as `ROOT_QUERY.allPeople.0` for the first record returned on the `allPeople` root query.\n\nThis \"getter\" behavior for unique identifiers can be configured manually via the `dataIdFromObject` option passed to the `InMemoryCache` constructor, so you can pick which field is used if some of your data follows unorthodox primary key conventions.\n\nFor example, if you wanted to key off of the `key` field for all of your data, you could configure `dataIdFromObject` like so:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => object.key\n});\n```\n\nThis also allows you to use different unique identifiers for different data types by keying off of the `__typename` property attached to every object typed by GraphQL.  For example:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => {\n    switch (object.__typename) {\n      case 'foo': return object.key; // use `key` as the primary key\n      case 'bar': return object.blah; // use `blah` as the priamry key\n      default: return object.id || object._id; // fall back to `id` and `_id` for all other types\n    }\n  }\n});\n```\n\n<h2 id=\"direct\">Direct Cache Access</h2>\n\nTo interact directly with your cache, you can use the Apollo Client class methods readQuery, readFragment, writeQuery, and writeFragment. These methods are available to us via the [`DataProxy` interface](https://github.com/apollographql/apollo-client/blob/master/packages/apollo-cache/src/types/DataProxy.ts). Accessing these methods will vary slightly based on your view layer implementation. If you are using React, you can wrap your component in the `withApollo` higher order component, which will give you access to `this.props.client`. From there, you can use the methods to control your data.\n\nAny code demonstration in the following sections will assume that we have already initialized an instance of  `ApolloClient` and that we have imported the `gql` tag from `graphql-tag`.\n\n<h3 id=\"readquery\">readQuery</h3>\n\nThe `readQuery` method is very similar to the [`query` method on `ApolloClient`][] except that `readQuery` will _never_ make a request to your GraphQL server. The `query` method, on the other hand, may send a request to your server if the appropriate data is not in your cache whereas `readQuery` will throw an error if the data is not in your cache. `readQuery` will _always_ read from the cache. You can use `readQuery` by giving it a GraphQL query like so:\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo {\n      todo(id: 5) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n});\n```\n\nIf all of the data needed to fulfill this read is in Apollo Client’s normalized data cache then a data object will be returned in the shape of the query you wanted to read. If not all of the data needed to fulfill this read is in Apollo Client’s cache then an error will be thrown instead, so make sure to only read data that you know you have!\n\nYou can also pass variables into `readQuery`.\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo($id: Int!) {\n      todo(id: $id) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n  variables: {\n    id: 5,\n  },\n});\n```\n\n<h3 id=\"readfragment\">readFragment</h3>\n\nThis method allows you great flexibility around the data in your cache. Whereas `readQuery` only allowed you to read data from your root query type, `readFragment` allows you to read data from _any node you have queried_. This is incredibly powerful. You use this method as follows:\n\n```js\nconst todo = client.readFragment({\n  id: ..., // `id` is any id that could be returned by `dataIdFromObject`.\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\nThe first argument is the id of the data you want to read from the cache. That id must be a value that was returned by the `dataIdFromObject` function you defined when initializing `ApolloClient`. So for example if you initialized `ApolloClient` like so:\n\n```js\nconst client = new ApolloClient({\n  ...,\n  dataIdFromObject: object => object.id,\n});\n```\n\n…and you requested a todo before with an id of `5`, then you can read that todo out of your cache with the following:\n\n```js\nconst todo = client.readFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\n> **Note:** Most people add a `__typename` to the id in `dataIdFromObject`. If you do this then don’t forget to add the `__typename` when you are reading a fragment as well. So for example your id may be `Todo_5` and not just `5`.\n\nIf a todo with that id does not exist in the cache you will get `null` back. If a todo of that id does exist in the cache, but that todo does not have the `text` field then an error will be thrown.\n\nThe beauty of `readFragment` is that the todo could have come from anywhere! The todo could have been selected as a singleton (`{ todo(id: 5) { ... } }`), the todo could have come from a list of todos (`{ todos { ... } }`), or the todo could have come from a mutation (`mutation { createTodo { ... } }`). As long as at some point your GraphQL server gave you a todo with the provided id and fields `id`, `text`, and `completed` you can read it from the cache at any part of your code.\n\n<h3 id=\"writequery-and-writefragment\">writeQuery` and `writeFragment</h3>\n\nNot only can you read arbitrary data from the Apollo Client cache, but you can also write any data that you would like to the cache. The methods you use to do this are `writeQuery` and `writeFragment`. They will allow you to change data in your local cache, but it is important to remember that *they will not change any data on your server*. If you reload your environment then changes made with `writeQuery` and `writeFragment` will disappear.\n\nThese methods have the same signature as their `readQuery` and `readFragment` counterparts except they also require an additional `data` variable. So for example, if you wanted to update the `completed` flag locally for your todo with id `'5'` you could execute the following:\n\n```js\nclient.writeFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      completed\n    }\n  `,\n  data: {\n    completed: true,\n  },\n});\n```\n\nAny subscriber to the Apollo Client store will instantly see this update and render new UI accordingly.\n\n> **Note:** Again, remember that using `writeQuery` or `writeFragment` only changes data *locally*. If you reload your environment then changes made with these methods will no longer exist.\n\nOr if you wanted to add a new todo to a list fetched from the server, you could use `readQuery` and `writeQuery` together.\n\n```js\nconst query = gql`\n  query MyTodoAppQuery {\n    todos {\n      id\n      text\n      completed\n    }\n  }\n`;\n\nconst data = client.readQuery({ query });\n\nconst myNewTodo = {\n  id: '6',\n  text: 'Start using Apollo Client.',\n  completed: false,\n};\n\nclient.writeQuery({\n  query,\n  data: {\n    todos: [...data.todos, myNewTodo],\n  },\n});\n```\n\n<h2 id=\"recipes\">Recipes</h2>\n\nHere are some common situations where you would need to access the cache directly. If you're manipulating the cache in an interesting way and would like your example to be featured, please send in a pull request!\n\n<h3 id=\"server\">Server side rendering</h3>\n\nFirst, you will need to initialize an `InMemoryCache` on the server and create an instance of `ApolloClient`. In the initial serialized HTML payload from the server, you should include a script tag that extracts the data from the cache.\n\n```js\n`<script>\n  window.__APOLLO_STATE__=${JSON.stringify(cache.extract())}\n</script>`\n```\n\nOn the client, you can rehydrate the cache using the initial data passed from the server:\n\n```js\ncache: new Cache().restore(window.__APOLLO_STATE__)\n```\n\nIf you would like to learn more about server side rendering, please check our our more in depth guide [here].\n<!---\nTODO (PEGGY): Add link to SSR\n-->\n\n<h3 id=\"server\">Updating the cache after a mutation</h3>\n\nBeing able to read and write to the Apollo cache from anywhere in your application gives you a lot of power over your data. However, there is one place where we most often want to update our cached data: after a mutation. As such, Apollo Client has optimized the experience for updating your cache with the read and write methods after a mutation with the `update` function. Let us say that we have the following GraphQL mutation:\n\n```graphql\nmutation TodoCreateMutation($text: String!) {\n  createTodo(text: $text) {\n    id\n    text\n    completed\n  }\n}\n```\n\nWe may also have the following GraphQL query:\n\n```graphql\nquery TodoAppQuery {\n  todos {\n    id\n    text\n    completed\n  }\n}\n```\n\nAt the end of our mutation we want our query to include the new todo like we had sent our `TodoAppQuery` a second time after the mutation finished without actually sending the query. To do this we can use the `update` function provided as an option of the `client.mutate` method. To update your cache with the mutation just write code that looks like:\n\n```js\n// We assume that the GraphQL operations `TodoCreateMutation` and\n// `TodoAppQuery` have already been defined using the `gql` tag.\n\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    // Read the data from our cache for this query.\n    const data = proxy.readQuery({ query: TodoAppQuery });\n\n    // Add our todo from the mutation to the end.\n    data.todos.push(createTodo);\n\n    // Write our data back to the cache.\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nThe first `proxy` argument is an instance of [`DataProxy`][] has the same four methods that we just learned exist on the Apollo Client: `readQuery`, `readFragment`, `writeQuery`, and `writeFragment`. The reason we call them on a `proxy` object here instead of on our `client` instance is that we can easily apply optimistic updates (which we will demonstrate in a bit). The `proxy` object also provides an isolated transaction which shields you from any other mutations going on at the same time, and the `proxy` object also batches writes together until the very end.\n\nIf you provide an `optimisticResponse` option to the mutation then the `update` function will be run twice. Once immediately after you call `client.mutate` with the data from `optimisticResponse`. After the mutation successfully executes against the server the changes made in the first call to `update` will be rolled back and `update` will be called with the *actual* data returned by the mutation and not just the optimistic response.\n\nPutting it all together:\n\n```js\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  optimisticResponse: {\n    id: -1, // -1 is a temporary id for the optimistic response.\n    text,\n    completed: false,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    const data = proxy.readQuery({ query: TodoAppQuery });\n    data.todos.push(createTodo);\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nAs you can see the `update` function on `client.mutate` provides extra change management functionality specific to the use case of a mutation while still providing you the powerful data control APIs that are available on `client`.\n\nThe `update` function is not a good place for side-effects as it may be called multiple times. Also, you may not call any of the methods on `proxy` asynchronously.\n\n",
      "readmeFilename": "README.md",
      "_id": "apollo-cache-inmemory@1.3.0-beta.14",
      "_npmVersion": "6.4.1",
      "_nodeVersion": "8.11.4",
      "_npmUser": {
        "name": "benjamn",
        "email": "ben@benjamn.com"
      },
      "dist": {
        "integrity": "sha512-S20YO/gkLh47eElT7JnigOOP95bq5nhlHoNf68G6H99Zeu0DGd0f00L85Hc5ao3ONVuK7tS6Clczp/Eor3T61w==",
        "shasum": "9246eaf660ee8637923850e11dc6018e43dae6f9",
        "tarball": "https://registry.npmjs.org/apollo-cache-inmemory/-/apollo-cache-inmemory-1.3.0-beta.14.tgz",
        "fileCount": 78,
        "unpackedSize": 470205,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJbo6dRCRA9TVsSAnZWagAApM4P/3pGs2q1bQ37E45sqt3U\nO/74PgW0xKpDDmFGYcWfWZC8UXue18FLvW8kWi5EgkAzhtL0/LI0FK/ORKD3\nxgOVaTy+b0K5WAJDZZa9Y3esvbe3AiNjWoig9mAiBaRBO9ZdpAO6n519l01X\n3qAVPm+kK4PsCuaG2Zd9pbGL2uBVGSTRPVZUAcJSA7nSgZBbzfoCydljssVG\nLYNW4vRRGliWYMnmry+x1V5/P7i64hbqbqRyDOQtkYrpwcfJ6hdToSuSioX2\n0KBqdRDIn/r5NEdk+rlsmbn4Zs9ZkC+lw0fMjMdeQbHBufcyKk0avrVHw+6i\nTf0fv4kIhP266blBsD2u1dyLCTvUDX50KOzpY5Shp5eadm92d2volKZddfif\n+gn1UCROTv1Z7VxAt5VLsL01Ydko4ml4tIDztG4vLdVj/Db6ZqxmJqjzayo5\nfUl+hBE7PccWmVShLS8mN3WWj4jUcpqPjoeWuZx5S2UJzvprOtHkSwp1qtbP\nN6/fB8amKubikT6Q6X2fOE+gkdP1B7hDBQ5mVC0yHD3cTYzazGXLrSMUZrxb\n9VSM2fz9E8N08NY4IrDvqkHaVANPn7RSwq3TRkbk8q+wm5rNBa55Wde+7eUk\nbzyzTDHz/Em9yY3VGZ6v96VahCRKwq7nwO8PccV0CrVwy7zaKOxCsj3SvNbI\ndpIk\r\n=1ImQ\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEYCIQCD3uotYUoUpXqcvU/RPAYs00svkBG3xP+Mde559xdO2QIhAJxtIAiFUwBYY6fQIY3iEYLzeedYXGNMlWsM69g1oZZm"
          }
        ]
      },
      "maintainers": [
        {
          "email": "npm@apollographql.com",
          "name": "apollo-bot"
        },
        {
          "email": "ben@benjamn.com",
          "name": "benjamn"
        },
        {
          "email": "james@meteor.com",
          "name": "jbaxleyiii"
        },
        {
          "email": "peggyrayzis@gmail.com",
          "name": "peggyrayzis"
        }
      ],
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/apollo-cache-inmemory_1.3.0-beta.14_1537451856472_0.9978901214702043"
      },
      "_hasShrinkwrap": false
    },
    "1.3.0-beta.15": {
      "name": "apollo-cache-inmemory",
      "version": "1.3.0-beta.15",
      "description": "Core abstract of Caching layer for Apollo Client",
      "author": {
        "name": "James Baxley",
        "email": "james@meteor.com"
      },
      "contributors": [
        {
          "name": "James Baxley",
          "email": "james@meteor.com"
        },
        {
          "name": "Jonas Helfer",
          "email": "jonas@helfer.email"
        },
        {
          "name": "Sashko Stubailo",
          "email": "sashko@stubailo.com"
        },
        {
          "name": "James Burgess",
          "email": "jamesmillerburgess@gmail.com"
        },
        {
          "name": "Bazyli Brzóska",
          "email": "bazyli.brzoska@gmail.com"
        }
      ],
      "license": "MIT",
      "main": "./lib/bundle.umd.js",
      "module": "./lib/index.js",
      "jsnext:main": "./lib/index.js",
      "typings": "./lib/index.d.ts",
      "sideEffects": false,
      "repository": {
        "type": "git",
        "url": "git+https://github.com/apollographql/apollo-client.git"
      },
      "bugs": {
        "url": "https://github.com/apollographql/apollo-client/issues"
      },
      "homepage": "https://github.com/apollographql/apollo-client#readme",
      "scripts": {
        "prepare": "npm run build",
        "coverage": "jest --coverage",
        "test": "jest",
        "lint": "tslint -c \"../../config/tslint.json\" -p tsconfig.json src/*.ts",
        "prebuild": "npm run clean",
        "build": "tsc -p .",
        "postbuild": "npm run bundle",
        "bundle": "../../node_modules/rollup/bin/rollup -c rollup.config.js",
        "watch": "tsc -w -p .",
        "clean": "rm -rf coverage/* && rm -rf lib/*",
        "prepublishOnly": "npm run build",
        "minify": "../../node_modules/uglify-js/bin/uglifyjs -c -m -o ./lib/bundle.min.js -- ./lib/bundle.umd.js",
        "filesize": "npm run minify"
      },
      "dependencies": {
        "apollo-cache": "^1.1.16",
        "apollo-utilities": "^1.0.20",
        "optimism": "^0.6.6"
      },
      "peerDependencies": {
        "graphql": "0.11.7 || ^0.12.0 || ^0.13.0"
      },
      "jest": {
        "transform": {
          ".(ts|tsx)": "ts-jest"
        },
        "testRegex": "(/__tests__/.*|\\.(test|spec))\\.(ts|tsx|js)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "json"
        ],
        "testURL": "http://localhost"
      },
      "readme": "---\ntitle: InMemoryCache\ndescription: An explanation of `apollo-cache-inmemory`\n---\n\n`apollo-cache-inmemory` is the recommended cache implementation for Apollo Client 2.0. `InMemoryCache` is a normalized data store that supports all of Apollo Client 1.0's features without the dependency on Redux.\n\nIn some instances, you may need to manipulate the cache directly, such as updating the store after a mutation. We'll cover some common use cases [here](#recipes).\n\n<h2 id=\"installation\">Installation</h2>\n\n```\nnpm install apollo-cache-inmemory --save\n```\n\nAfter installing the package, you'll want to initialize the cache constructor. Then, you can pass in your newly created cache to ApolloClient.\n\n```js\nimport { InMemoryCache } from 'apollo-cache-inmemory';\nimport { HttpLink } from 'apollo-link-http';\nimport ApolloClient from 'apollo-client';\n\nconst cache = new InMemoryCache();\n\nconst client = new ApolloClient({\n  link: new HttpLink(),\n  cache\n});\n```\n\n<h2 id=\"configuration\">Configuration</h2>\n\nThe `InMemoryCache` constructor takes an optional config object with properties to customize your cache:\n\n- addTypename: A boolean to determine whether to add __typename to the document (default: `true`)\n- dataIdFromObject: A function that takes a data object and returns a unique identifier to be used when normalizing the data in the store. Learn more about how to customize `dataIdFromObject` in the [Normalization](#normalization) section.\n- fragmentMatcher: By default, the `InMemoryCache` uses a heuristic fragment matcher. If you are using fragments on unions and interfaces, you will need to use an `IntrospectionFragmentMatcher`. For more information, please read [our guide to setting up fragment matching for unions & interfaces](https://www.apollographql.com/docs/react/advanced/fragments.html#fragment-matcher).\n\n<h2 id=\"normalization\">Normalization</h2>\n\nThe `InMemoryCache` normalizes your data before saving it to the store by splitting the result into individual objects, creating a unique identifier for each object, and storing those objects in a flattened data structure. By default, `InMemoryCache` will attempt to use the commonly found primary keys of `id` and `_id` for the unique identifier if they exist along with `__typename` on an object.\n\nIf `id` and `_id` are not specified, or if `__typename` is not specified, `InMemoryCache` will fall back to the path to the object in the query, such as `ROOT_QUERY.allPeople.0` for the first record returned on the `allPeople` root query.\n\nThis \"getter\" behavior for unique identifiers can be configured manually via the `dataIdFromObject` option passed to the `InMemoryCache` constructor, so you can pick which field is used if some of your data follows unorthodox primary key conventions.\n\nFor example, if you wanted to key off of the `key` field for all of your data, you could configure `dataIdFromObject` like so:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => object.key\n});\n```\n\nThis also allows you to use different unique identifiers for different data types by keying off of the `__typename` property attached to every object typed by GraphQL.  For example:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => {\n    switch (object.__typename) {\n      case 'foo': return object.key; // use `key` as the primary key\n      case 'bar': return object.blah; // use `blah` as the priamry key\n      default: return object.id || object._id; // fall back to `id` and `_id` for all other types\n    }\n  }\n});\n```\n\n<h2 id=\"direct\">Direct Cache Access</h2>\n\nTo interact directly with your cache, you can use the Apollo Client class methods readQuery, readFragment, writeQuery, and writeFragment. These methods are available to us via the [`DataProxy` interface](https://github.com/apollographql/apollo-client/blob/master/packages/apollo-cache/src/types/DataProxy.ts). Accessing these methods will vary slightly based on your view layer implementation. If you are using React, you can wrap your component in the `withApollo` higher order component, which will give you access to `this.props.client`. From there, you can use the methods to control your data.\n\nAny code demonstration in the following sections will assume that we have already initialized an instance of  `ApolloClient` and that we have imported the `gql` tag from `graphql-tag`.\n\n<h3 id=\"readquery\">readQuery</h3>\n\nThe `readQuery` method is very similar to the [`query` method on `ApolloClient`][] except that `readQuery` will _never_ make a request to your GraphQL server. The `query` method, on the other hand, may send a request to your server if the appropriate data is not in your cache whereas `readQuery` will throw an error if the data is not in your cache. `readQuery` will _always_ read from the cache. You can use `readQuery` by giving it a GraphQL query like so:\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo {\n      todo(id: 5) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n});\n```\n\nIf all of the data needed to fulfill this read is in Apollo Client’s normalized data cache then a data object will be returned in the shape of the query you wanted to read. If not all of the data needed to fulfill this read is in Apollo Client’s cache then an error will be thrown instead, so make sure to only read data that you know you have!\n\nYou can also pass variables into `readQuery`.\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo($id: Int!) {\n      todo(id: $id) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n  variables: {\n    id: 5,\n  },\n});\n```\n\n<h3 id=\"readfragment\">readFragment</h3>\n\nThis method allows you great flexibility around the data in your cache. Whereas `readQuery` only allowed you to read data from your root query type, `readFragment` allows you to read data from _any node you have queried_. This is incredibly powerful. You use this method as follows:\n\n```js\nconst todo = client.readFragment({\n  id: ..., // `id` is any id that could be returned by `dataIdFromObject`.\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\nThe first argument is the id of the data you want to read from the cache. That id must be a value that was returned by the `dataIdFromObject` function you defined when initializing `ApolloClient`. So for example if you initialized `ApolloClient` like so:\n\n```js\nconst client = new ApolloClient({\n  ...,\n  dataIdFromObject: object => object.id,\n});\n```\n\n…and you requested a todo before with an id of `5`, then you can read that todo out of your cache with the following:\n\n```js\nconst todo = client.readFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\n> **Note:** Most people add a `__typename` to the id in `dataIdFromObject`. If you do this then don’t forget to add the `__typename` when you are reading a fragment as well. So for example your id may be `Todo_5` and not just `5`.\n\nIf a todo with that id does not exist in the cache you will get `null` back. If a todo of that id does exist in the cache, but that todo does not have the `text` field then an error will be thrown.\n\nThe beauty of `readFragment` is that the todo could have come from anywhere! The todo could have been selected as a singleton (`{ todo(id: 5) { ... } }`), the todo could have come from a list of todos (`{ todos { ... } }`), or the todo could have come from a mutation (`mutation { createTodo { ... } }`). As long as at some point your GraphQL server gave you a todo with the provided id and fields `id`, `text`, and `completed` you can read it from the cache at any part of your code.\n\n<h3 id=\"writequery-and-writefragment\">writeQuery` and `writeFragment</h3>\n\nNot only can you read arbitrary data from the Apollo Client cache, but you can also write any data that you would like to the cache. The methods you use to do this are `writeQuery` and `writeFragment`. They will allow you to change data in your local cache, but it is important to remember that *they will not change any data on your server*. If you reload your environment then changes made with `writeQuery` and `writeFragment` will disappear.\n\nThese methods have the same signature as their `readQuery` and `readFragment` counterparts except they also require an additional `data` variable. So for example, if you wanted to update the `completed` flag locally for your todo with id `'5'` you could execute the following:\n\n```js\nclient.writeFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      completed\n    }\n  `,\n  data: {\n    completed: true,\n  },\n});\n```\n\nAny subscriber to the Apollo Client store will instantly see this update and render new UI accordingly.\n\n> **Note:** Again, remember that using `writeQuery` or `writeFragment` only changes data *locally*. If you reload your environment then changes made with these methods will no longer exist.\n\nOr if you wanted to add a new todo to a list fetched from the server, you could use `readQuery` and `writeQuery` together.\n\n```js\nconst query = gql`\n  query MyTodoAppQuery {\n    todos {\n      id\n      text\n      completed\n    }\n  }\n`;\n\nconst data = client.readQuery({ query });\n\nconst myNewTodo = {\n  id: '6',\n  text: 'Start using Apollo Client.',\n  completed: false,\n};\n\nclient.writeQuery({\n  query,\n  data: {\n    todos: [...data.todos, myNewTodo],\n  },\n});\n```\n\n<h2 id=\"recipes\">Recipes</h2>\n\nHere are some common situations where you would need to access the cache directly. If you're manipulating the cache in an interesting way and would like your example to be featured, please send in a pull request!\n\n<h3 id=\"server\">Server side rendering</h3>\n\nFirst, you will need to initialize an `InMemoryCache` on the server and create an instance of `ApolloClient`. In the initial serialized HTML payload from the server, you should include a script tag that extracts the data from the cache.\n\n```js\n`<script>\n  window.__APOLLO_STATE__=${JSON.stringify(cache.extract())}\n</script>`\n```\n\nOn the client, you can rehydrate the cache using the initial data passed from the server:\n\n```js\ncache: new Cache().restore(window.__APOLLO_STATE__)\n```\n\nIf you would like to learn more about server side rendering, please check our our more in depth guide [here].\n<!---\nTODO (PEGGY): Add link to SSR\n-->\n\n<h3 id=\"server\">Updating the cache after a mutation</h3>\n\nBeing able to read and write to the Apollo cache from anywhere in your application gives you a lot of power over your data. However, there is one place where we most often want to update our cached data: after a mutation. As such, Apollo Client has optimized the experience for updating your cache with the read and write methods after a mutation with the `update` function. Let us say that we have the following GraphQL mutation:\n\n```graphql\nmutation TodoCreateMutation($text: String!) {\n  createTodo(text: $text) {\n    id\n    text\n    completed\n  }\n}\n```\n\nWe may also have the following GraphQL query:\n\n```graphql\nquery TodoAppQuery {\n  todos {\n    id\n    text\n    completed\n  }\n}\n```\n\nAt the end of our mutation we want our query to include the new todo like we had sent our `TodoAppQuery` a second time after the mutation finished without actually sending the query. To do this we can use the `update` function provided as an option of the `client.mutate` method. To update your cache with the mutation just write code that looks like:\n\n```js\n// We assume that the GraphQL operations `TodoCreateMutation` and\n// `TodoAppQuery` have already been defined using the `gql` tag.\n\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    // Read the data from our cache for this query.\n    const data = proxy.readQuery({ query: TodoAppQuery });\n\n    // Add our todo from the mutation to the end.\n    data.todos.push(createTodo);\n\n    // Write our data back to the cache.\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nThe first `proxy` argument is an instance of [`DataProxy`][] has the same four methods that we just learned exist on the Apollo Client: `readQuery`, `readFragment`, `writeQuery`, and `writeFragment`. The reason we call them on a `proxy` object here instead of on our `client` instance is that we can easily apply optimistic updates (which we will demonstrate in a bit). The `proxy` object also provides an isolated transaction which shields you from any other mutations going on at the same time, and the `proxy` object also batches writes together until the very end.\n\nIf you provide an `optimisticResponse` option to the mutation then the `update` function will be run twice. Once immediately after you call `client.mutate` with the data from `optimisticResponse`. After the mutation successfully executes against the server the changes made in the first call to `update` will be rolled back and `update` will be called with the *actual* data returned by the mutation and not just the optimistic response.\n\nPutting it all together:\n\n```js\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  optimisticResponse: {\n    id: -1, // -1 is a temporary id for the optimistic response.\n    text,\n    completed: false,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    const data = proxy.readQuery({ query: TodoAppQuery });\n    data.todos.push(createTodo);\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nAs you can see the `update` function on `client.mutate` provides extra change management functionality specific to the use case of a mutation while still providing you the powerful data control APIs that are available on `client`.\n\nThe `update` function is not a good place for side-effects as it may be called multiple times. Also, you may not call any of the methods on `proxy` asynchronously.\n\n",
      "readmeFilename": "README.md",
      "_id": "apollo-cache-inmemory@1.3.0-beta.15",
      "_npmVersion": "6.4.1",
      "_nodeVersion": "8.11.4",
      "_npmUser": {
        "name": "benjamn",
        "email": "ben@benjamn.com"
      },
      "dist": {
        "integrity": "sha512-62brpw6mT2jgeDhouTW/R/5MATR0PuE2TPSbbZ9oXxD7AvaLPcPgs16IHmbEWL0oiWNB6E5j26/xcGm9xxZG8Q==",
        "shasum": "f60b14e1064b54514a8464a4637ad1caee747138",
        "tarball": "https://registry.npmjs.org/apollo-cache-inmemory/-/apollo-cache-inmemory-1.3.0-beta.15.tgz",
        "fileCount": 83,
        "unpackedSize": 509199,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJbrPG4CRA9TVsSAnZWagAAKyMP/j60nWE/5i8vdVCBMjsC\nHTUXPd+Vo6psvAq4iFtX8AR26MaQICTp1kDAjBv8TPAxwxpoyAAjhMeK5uPU\ny0AWFeSbpSSRExNShgztuNGK+Lc9P+y+rrHDNTi6+e/WjBh1QaN5wySPl7Yg\nV1RLOehr1g2X7H6+akSwXo4dO7VXkidZx0+hAqNRBeQ9cqkGN7veYZfiggXn\nYJQT/b4BCrqCgmX/g+cYcK8GyqjJUZPUgOnlqzmDIA6IM38J0zvPdHieUJV8\nMuPHbO7SyKqwRCSSER0yh+LZLOJHvbEyA5ChF+7cscOtGyh78FQ+sNAUNAIo\n++co7YAy5b9xkuIs1xM5pWcDQ7Zw+qiVggcOfZ+0wEcR5vAUgmB/IDLlCV1m\nQS6c3XPu9YlHNvlMY/rJG/AcgLhPTkKRIydMGXG8YSB7ZePpdzSbhTSa9F9X\n1eIJWtQ8Px5vQGp45/eV6x6QTRO+VAG3iwBxhD6UF3b8cHjsZnTDkYWsUSKs\noqHaNg0VjmdNKXbfOeNrYaaDFxZqK8yu2i6fBPhltIG8BFmPy3kqta1TOyod\n/CsxlWl9BSEt6pmy5cVmyJq4DqUnkci3Jq8yx62z7ViKx4i8jLz2/aJvL6sE\neVUkQ+cODrhGb0gaOGL0BSglbRCTTAGazeSu3FLpqEX3nN5YDK+XI8fAabNY\nfN8T\r\n=Hr5i\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIAFKLxY5eWp4VNCdsmR3l6XK28eI5ujXWwy6m05Oc06QAiEAnmc2N3DPAtOaikcd84wvZ9M9jzmscLgZEyypW/dCKo8="
          }
        ]
      },
      "maintainers": [
        {
          "email": "npm@apollographql.com",
          "name": "apollo-bot"
        },
        {
          "email": "ben@benjamn.com",
          "name": "benjamn"
        },
        {
          "email": "james@meteor.com",
          "name": "jbaxleyiii"
        },
        {
          "email": "peggyrayzis@gmail.com",
          "name": "peggyrayzis"
        }
      ],
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/apollo-cache-inmemory_1.3.0-beta.15_1538060727176_0.5363682861822152"
      },
      "_hasShrinkwrap": false
    },
    "1.3.0": {
      "name": "apollo-cache-inmemory",
      "version": "1.3.0",
      "description": "Core abstract of Caching layer for Apollo Client",
      "author": {
        "name": "James Baxley",
        "email": "james@meteor.com"
      },
      "contributors": [
        {
          "name": "James Baxley",
          "email": "james@meteor.com"
        },
        {
          "name": "Jonas Helfer",
          "email": "jonas@helfer.email"
        },
        {
          "name": "Sashko Stubailo",
          "email": "sashko@stubailo.com"
        },
        {
          "name": "James Burgess",
          "email": "jamesmillerburgess@gmail.com"
        },
        {
          "name": "Bazyli Brzóska",
          "email": "bazyli.brzoska@gmail.com"
        }
      ],
      "license": "MIT",
      "main": "./lib/bundle.umd.js",
      "module": "./lib/index.js",
      "jsnext:main": "./lib/index.js",
      "typings": "./lib/index.d.ts",
      "sideEffects": false,
      "repository": {
        "type": "git",
        "url": "git+https://github.com/apollographql/apollo-client.git"
      },
      "bugs": {
        "url": "https://github.com/apollographql/apollo-client/issues"
      },
      "homepage": "https://github.com/apollographql/apollo-client#readme",
      "scripts": {
        "prepare": "npm run build",
        "coverage": "jest --coverage",
        "test": "jest",
        "lint": "tslint -c \"../../config/tslint.json\" -p tsconfig.json src/*.ts",
        "prebuild": "npm run clean",
        "build": "tsc -p .",
        "postbuild": "npm run bundle",
        "bundle": "../../node_modules/rollup/bin/rollup -c rollup.config.js",
        "watch": "tsc -w -p .",
        "clean": "rm -rf coverage/* && rm -rf lib/*",
        "prepublishOnly": "npm run build",
        "minify": "../../node_modules/uglify-js/bin/uglifyjs -c -m -o ./lib/bundle.min.js -- ./lib/bundle.umd.js",
        "filesize": "npm run minify"
      },
      "dependencies": {
        "apollo-cache": "^1.1.17",
        "apollo-utilities": "^1.0.21",
        "optimism": "^0.6.6"
      },
      "peerDependencies": {
        "graphql": "0.11.7 || ^0.12.0 || ^0.13.0"
      },
      "jest": {
        "transform": {
          ".(ts|tsx)": "ts-jest"
        },
        "testRegex": "(/__tests__/.*|\\.(test|spec))\\.(ts|tsx|js)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "json"
        ],
        "testURL": "http://localhost"
      },
      "_id": "apollo-cache-inmemory@1.3.0",
      "_npmVersion": "6.4.1",
      "_nodeVersion": "8.11.4",
      "_npmUser": {
        "name": "benjamn",
        "email": "ben@benjamn.com"
      },
      "dist": {
        "integrity": "sha512-7NXKkICo/JswTfTf7E3XAt5qcmt8xydUk86LbFrNiM9w3mHNIJnCJZdycuy34bx4DWsA+Bex4oYDB4H70v4maQ==",
        "shasum": "3bbadeea01a84c7d67f49872c87912a06f1678df",
        "tarball": "https://registry.npmjs.org/apollo-cache-inmemory/-/apollo-cache-inmemory-1.3.0.tgz",
        "fileCount": 83,
        "unpackedSize": 509191,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJbrllkCRA9TVsSAnZWagAAE5gP/jfdu10A0Z9o3NT9oxu8\nzLq87p7NKqMvrmoq3XhXLMndflNp49/UYjTkUbikoxkglph+HCMGXOfBmovr\nkN3fMVQSs4STjTwJv9W5HPHuLx0teGW0JjEzvx4zMlqppOvU2cM2kgvHy60X\n5bybZ4LDD25e1OSIgt0tPwmQK38onYHmmtbEbAa1wXPHsVUyqLDcMqmx07ih\n8AkE0AswnTzKoHyibvmC15ALbZL50cG3JrySSFev6Y4KL4n94G8sK/m8jn7w\nWIre73M3A6MArr44fkBXEUcf2uU2mcqcGCDWLM6DLafvCTPRTazO+d2Dc24h\ngepcURkjBINu0oo0l50GrD3aLHKG1OW/KHVAEPaevli+ESIaCsdFZOvh95Xw\nsGdeVg2CuF/yopu61ks/wwX1EBCyCOgVRsXCtXNj4inG4A9atE7FTiJkeiF1\nRKNM013BGLRpQWc5AfaLUC+RfMJSlsoYX4kqTc4DrertpS6DCNk9fWi70kCz\nK8KGLVAcSyBqjnkYIej5xkYtmJ5E2vbcUvgAuSIgCFMc5Y/iq89l6uYDUfj9\neKpz8VkmFtUstGeV4quaFylniR9NqlDLiJwu7HpbtxRHQ1ctLTNjTb3BEoiP\nMj68EUEotmlIiic9HiMqcEwUl5XxNdc69Y9uYeTK6s+1fJfTb66RPwWKxwI4\npLTF\r\n=v1Pm\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIBrhw0iMrnZP4mW+2h65NnS4tgnaTYrQ2QzFagefubtxAiEAqYhGc4o5xWsVA7W9V/5f88/u181ZZfkOPsYKd4FF85s="
          }
        ]
      },
      "maintainers": [
        {
          "email": "npm@apollographql.com",
          "name": "apollo-bot"
        },
        {
          "email": "ben@benjamn.com",
          "name": "benjamn"
        },
        {
          "email": "james@meteor.com",
          "name": "jbaxleyiii"
        },
        {
          "email": "peggyrayzis@gmail.com",
          "name": "peggyrayzis"
        }
      ],
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/apollo-cache-inmemory_1.3.0_1538152803785_0.23846439252801188"
      },
      "_hasShrinkwrap": false
    },
    "1.3.1": {
      "name": "apollo-cache-inmemory",
      "version": "1.3.1",
      "description": "Core abstract of Caching layer for Apollo Client",
      "author": {
        "name": "James Baxley",
        "email": "james@meteor.com"
      },
      "contributors": [
        {
          "name": "James Baxley",
          "email": "james@meteor.com"
        },
        {
          "name": "Jonas Helfer",
          "email": "jonas@helfer.email"
        },
        {
          "name": "Sashko Stubailo",
          "email": "sashko@stubailo.com"
        },
        {
          "name": "James Burgess",
          "email": "jamesmillerburgess@gmail.com"
        },
        {
          "name": "Bazyli Brzóska",
          "email": "bazyli.brzoska@gmail.com"
        }
      ],
      "license": "MIT",
      "main": "./lib/bundle.umd.js",
      "module": "./lib/index.js",
      "jsnext:main": "./lib/index.js",
      "typings": "./lib/index.d.ts",
      "sideEffects": false,
      "repository": {
        "type": "git",
        "url": "git+https://github.com/apollographql/apollo-client.git"
      },
      "bugs": {
        "url": "https://github.com/apollographql/apollo-client/issues"
      },
      "homepage": "https://github.com/apollographql/apollo-client#readme",
      "scripts": {
        "prepare": "npm run build",
        "coverage": "jest --coverage",
        "test": "jest",
        "lint": "tslint -c \"../../config/tslint.json\" -p tsconfig.json src/*.ts",
        "prebuild": "npm run clean",
        "build": "tsc -p .",
        "postbuild": "npm run bundle",
        "bundle": "../../node_modules/rollup/bin/rollup -c rollup.config.js",
        "watch": "tsc -w -p .",
        "clean": "rm -rf coverage/* && rm -rf lib/*",
        "prepublishOnly": "npm run build",
        "minify": "../../node_modules/uglify-js/bin/uglifyjs -c -m -o ./lib/bundle.min.js -- ./lib/bundle.umd.js",
        "filesize": "npm run minify"
      },
      "dependencies": {
        "apollo-cache": "file:../apollo-cache",
        "apollo-utilities": "file:../apollo-utilities",
        "optimism": "^0.6.6"
      },
      "peerDependencies": {
        "graphql": "0.11.7 || ^0.12.0 || ^0.13.0"
      },
      "jest": {
        "transform": {
          ".(ts|tsx)": "ts-jest"
        },
        "testRegex": "(/__tests__/.*|\\.(test|spec))\\.(ts|tsx|js)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "json"
        ],
        "testURL": "http://localhost"
      },
      "readme": "---\ntitle: InMemoryCache\ndescription: An explanation of `apollo-cache-inmemory`\n---\n\n`apollo-cache-inmemory` is the recommended cache implementation for Apollo Client 2.0. `InMemoryCache` is a normalized data store that supports all of Apollo Client 1.0's features without the dependency on Redux.\n\nIn some instances, you may need to manipulate the cache directly, such as updating the store after a mutation. We'll cover some common use cases [here](#recipes).\n\n<h2 id=\"installation\">Installation</h2>\n\n```\nnpm install apollo-cache-inmemory --save\n```\n\nAfter installing the package, you'll want to initialize the cache constructor. Then, you can pass in your newly created cache to ApolloClient.\n\n```js\nimport { InMemoryCache } from 'apollo-cache-inmemory';\nimport { HttpLink } from 'apollo-link-http';\nimport ApolloClient from 'apollo-client';\n\nconst cache = new InMemoryCache();\n\nconst client = new ApolloClient({\n  link: new HttpLink(),\n  cache\n});\n```\n\n<h2 id=\"configuration\">Configuration</h2>\n\nThe `InMemoryCache` constructor takes an optional config object with properties to customize your cache:\n\n- addTypename: A boolean to determine whether to add __typename to the document (default: `true`)\n- dataIdFromObject: A function that takes a data object and returns a unique identifier to be used when normalizing the data in the store. Learn more about how to customize `dataIdFromObject` in the [Normalization](#normalization) section.\n- fragmentMatcher: By default, the `InMemoryCache` uses a heuristic fragment matcher. If you are using fragments on unions and interfaces, you will need to use an `IntrospectionFragmentMatcher`. For more information, please read [our guide to setting up fragment matching for unions & interfaces](https://www.apollographql.com/docs/react/advanced/fragments.html#fragment-matcher).\n\n<h2 id=\"normalization\">Normalization</h2>\n\nThe `InMemoryCache` normalizes your data before saving it to the store by splitting the result into individual objects, creating a unique identifier for each object, and storing those objects in a flattened data structure. By default, `InMemoryCache` will attempt to use the commonly found primary keys of `id` and `_id` for the unique identifier if they exist along with `__typename` on an object.\n\nIf `id` and `_id` are not specified, or if `__typename` is not specified, `InMemoryCache` will fall back to the path to the object in the query, such as `ROOT_QUERY.allPeople.0` for the first record returned on the `allPeople` root query.\n\nThis \"getter\" behavior for unique identifiers can be configured manually via the `dataIdFromObject` option passed to the `InMemoryCache` constructor, so you can pick which field is used if some of your data follows unorthodox primary key conventions.\n\nFor example, if you wanted to key off of the `key` field for all of your data, you could configure `dataIdFromObject` like so:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => object.key\n});\n```\n\nThis also allows you to use different unique identifiers for different data types by keying off of the `__typename` property attached to every object typed by GraphQL.  For example:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => {\n    switch (object.__typename) {\n      case 'foo': return object.key; // use `key` as the primary key\n      case 'bar': return object.blah; // use `blah` as the priamry key\n      default: return object.id || object._id; // fall back to `id` and `_id` for all other types\n    }\n  }\n});\n```\n\n<h2 id=\"direct\">Direct Cache Access</h2>\n\nTo interact directly with your cache, you can use the Apollo Client class methods readQuery, readFragment, writeQuery, and writeFragment. These methods are available to us via the [`DataProxy` interface](https://github.com/apollographql/apollo-client/blob/master/packages/apollo-cache/src/types/DataProxy.ts). Accessing these methods will vary slightly based on your view layer implementation. If you are using React, you can wrap your component in the `withApollo` higher order component, which will give you access to `this.props.client`. From there, you can use the methods to control your data.\n\nAny code demonstration in the following sections will assume that we have already initialized an instance of  `ApolloClient` and that we have imported the `gql` tag from `graphql-tag`.\n\n<h3 id=\"readquery\">readQuery</h3>\n\nThe `readQuery` method is very similar to the [`query` method on `ApolloClient`][] except that `readQuery` will _never_ make a request to your GraphQL server. The `query` method, on the other hand, may send a request to your server if the appropriate data is not in your cache whereas `readQuery` will throw an error if the data is not in your cache. `readQuery` will _always_ read from the cache. You can use `readQuery` by giving it a GraphQL query like so:\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo {\n      todo(id: 5) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n});\n```\n\nIf all of the data needed to fulfill this read is in Apollo Client’s normalized data cache then a data object will be returned in the shape of the query you wanted to read. If not all of the data needed to fulfill this read is in Apollo Client’s cache then an error will be thrown instead, so make sure to only read data that you know you have!\n\nYou can also pass variables into `readQuery`.\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo($id: Int!) {\n      todo(id: $id) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n  variables: {\n    id: 5,\n  },\n});\n```\n\n<h3 id=\"readfragment\">readFragment</h3>\n\nThis method allows you great flexibility around the data in your cache. Whereas `readQuery` only allowed you to read data from your root query type, `readFragment` allows you to read data from _any node you have queried_. This is incredibly powerful. You use this method as follows:\n\n```js\nconst todo = client.readFragment({\n  id: ..., // `id` is any id that could be returned by `dataIdFromObject`.\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\nThe first argument is the id of the data you want to read from the cache. That id must be a value that was returned by the `dataIdFromObject` function you defined when initializing `ApolloClient`. So for example if you initialized `ApolloClient` like so:\n\n```js\nconst client = new ApolloClient({\n  ...,\n  dataIdFromObject: object => object.id,\n});\n```\n\n…and you requested a todo before with an id of `5`, then you can read that todo out of your cache with the following:\n\n```js\nconst todo = client.readFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\n> **Note:** Most people add a `__typename` to the id in `dataIdFromObject`. If you do this then don’t forget to add the `__typename` when you are reading a fragment as well. So for example your id may be `Todo_5` and not just `5`.\n\nIf a todo with that id does not exist in the cache you will get `null` back. If a todo of that id does exist in the cache, but that todo does not have the `text` field then an error will be thrown.\n\nThe beauty of `readFragment` is that the todo could have come from anywhere! The todo could have been selected as a singleton (`{ todo(id: 5) { ... } }`), the todo could have come from a list of todos (`{ todos { ... } }`), or the todo could have come from a mutation (`mutation { createTodo { ... } }`). As long as at some point your GraphQL server gave you a todo with the provided id and fields `id`, `text`, and `completed` you can read it from the cache at any part of your code.\n\n<h3 id=\"writequery-and-writefragment\">writeQuery` and `writeFragment</h3>\n\nNot only can you read arbitrary data from the Apollo Client cache, but you can also write any data that you would like to the cache. The methods you use to do this are `writeQuery` and `writeFragment`. They will allow you to change data in your local cache, but it is important to remember that *they will not change any data on your server*. If you reload your environment then changes made with `writeQuery` and `writeFragment` will disappear.\n\nThese methods have the same signature as their `readQuery` and `readFragment` counterparts except they also require an additional `data` variable. So for example, if you wanted to update the `completed` flag locally for your todo with id `'5'` you could execute the following:\n\n```js\nclient.writeFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      completed\n    }\n  `,\n  data: {\n    completed: true,\n  },\n});\n```\n\nAny subscriber to the Apollo Client store will instantly see this update and render new UI accordingly.\n\n> **Note:** Again, remember that using `writeQuery` or `writeFragment` only changes data *locally*. If you reload your environment then changes made with these methods will no longer exist.\n\nOr if you wanted to add a new todo to a list fetched from the server, you could use `readQuery` and `writeQuery` together.\n\n```js\nconst query = gql`\n  query MyTodoAppQuery {\n    todos {\n      id\n      text\n      completed\n    }\n  }\n`;\n\nconst data = client.readQuery({ query });\n\nconst myNewTodo = {\n  id: '6',\n  text: 'Start using Apollo Client.',\n  completed: false,\n};\n\nclient.writeQuery({\n  query,\n  data: {\n    todos: [...data.todos, myNewTodo],\n  },\n});\n```\n\n<h2 id=\"recipes\">Recipes</h2>\n\nHere are some common situations where you would need to access the cache directly. If you're manipulating the cache in an interesting way and would like your example to be featured, please send in a pull request!\n\n<h3 id=\"server\">Server side rendering</h3>\n\nFirst, you will need to initialize an `InMemoryCache` on the server and create an instance of `ApolloClient`. In the initial serialized HTML payload from the server, you should include a script tag that extracts the data from the cache.\n\n```js\n`<script>\n  window.__APOLLO_STATE__=${JSON.stringify(cache.extract())}\n</script>`\n```\n\nOn the client, you can rehydrate the cache using the initial data passed from the server:\n\n```js\ncache: new Cache().restore(window.__APOLLO_STATE__)\n```\n\nIf you would like to learn more about server side rendering, please check our our more in depth guide [here].\n<!---\nTODO (PEGGY): Add link to SSR\n-->\n\n<h3 id=\"server\">Updating the cache after a mutation</h3>\n\nBeing able to read and write to the Apollo cache from anywhere in your application gives you a lot of power over your data. However, there is one place where we most often want to update our cached data: after a mutation. As such, Apollo Client has optimized the experience for updating your cache with the read and write methods after a mutation with the `update` function. Let us say that we have the following GraphQL mutation:\n\n```graphql\nmutation TodoCreateMutation($text: String!) {\n  createTodo(text: $text) {\n    id\n    text\n    completed\n  }\n}\n```\n\nWe may also have the following GraphQL query:\n\n```graphql\nquery TodoAppQuery {\n  todos {\n    id\n    text\n    completed\n  }\n}\n```\n\nAt the end of our mutation we want our query to include the new todo like we had sent our `TodoAppQuery` a second time after the mutation finished without actually sending the query. To do this we can use the `update` function provided as an option of the `client.mutate` method. To update your cache with the mutation just write code that looks like:\n\n```js\n// We assume that the GraphQL operations `TodoCreateMutation` and\n// `TodoAppQuery` have already been defined using the `gql` tag.\n\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    // Read the data from our cache for this query.\n    const data = proxy.readQuery({ query: TodoAppQuery });\n\n    // Add our todo from the mutation to the end.\n    data.todos.push(createTodo);\n\n    // Write our data back to the cache.\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nThe first `proxy` argument is an instance of [`DataProxy`][] has the same four methods that we just learned exist on the Apollo Client: `readQuery`, `readFragment`, `writeQuery`, and `writeFragment`. The reason we call them on a `proxy` object here instead of on our `client` instance is that we can easily apply optimistic updates (which we will demonstrate in a bit). The `proxy` object also provides an isolated transaction which shields you from any other mutations going on at the same time, and the `proxy` object also batches writes together until the very end.\n\nIf you provide an `optimisticResponse` option to the mutation then the `update` function will be run twice. Once immediately after you call `client.mutate` with the data from `optimisticResponse`. After the mutation successfully executes against the server the changes made in the first call to `update` will be rolled back and `update` will be called with the *actual* data returned by the mutation and not just the optimistic response.\n\nPutting it all together:\n\n```js\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  optimisticResponse: {\n    id: -1, // -1 is a temporary id for the optimistic response.\n    text,\n    completed: false,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    const data = proxy.readQuery({ query: TodoAppQuery });\n    data.todos.push(createTodo);\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nAs you can see the `update` function on `client.mutate` provides extra change management functionality specific to the use case of a mutation while still providing you the powerful data control APIs that are available on `client`.\n\nThe `update` function is not a good place for side-effects as it may be called multiple times. Also, you may not call any of the methods on `proxy` asynchronously.\n\n",
      "readmeFilename": "README.md",
      "_id": "apollo-cache-inmemory@1.3.1",
      "_npmVersion": "6.4.1",
      "_nodeVersion": "8.11.4",
      "_npmUser": {
        "name": "benjamn",
        "email": "ben@benjamn.com"
      },
      "dist": {
        "integrity": "sha512-LXC3kkhWVWeAGUWNK9UWMVlT6VCLGW0BaBzPtuIf+5cOVoDz+LGdTbU3tLon7wf4YUd+6KWZuuLiJVpmziqvSg==",
        "shasum": "19ae382a2858738192cb21ecc9309eae2698e3f8",
        "tarball": "https://registry.npmjs.org/apollo-cache-inmemory/-/apollo-cache-inmemory-1.3.1.tgz",
        "fileCount": 83,
        "unpackedSize": 509694,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJbsktdCRA9TVsSAnZWagAAUMMP/1Zc/hx6tKlZWFKAP/sZ\nW0VFJhTjcRAyMRRMqitqJkm8khYpXOXoeNtpDLyK7XYebRorEuxDraSAtIXR\neANWXQ9CTFpjM/GbfQkdfPsJYkczlrLfKgPkrFevWOG0nfCHe77umRgP0BJ1\n0UARBEkom/zWf+xk9puFE1D9dAIv5u1z87HeyAbkHlO8spVM+uK9MWjG3l2q\nOVQ6tSmWDIZgKBqV9PIS50krHGbKh7OGdyvzwWuDbR+fE8hAhy5mgnF65FRK\nC3m2ugKGDrmbbBfrHEYaji/nJB1e5/QAp8YJDBe5kw534WNy0R5BdKIlOgRz\nS0i4tHS2TqOsSbqeJk/+sbdNfRXN+kPCvRA8VlHID2I+BQDNV47r42HWVXJb\niyVUFWXUDWa68aqhaGD9mGGzOr29w/Rt9Ru1+TMXAIpyhF85VGNqbc3t55KR\n+BqydzyyDB0s7lBCKpmJtM6D1OP986BpKOqFXKjzV80kN8kdtJYosPGG7X71\niSIlJmMnYfM31g52dPHP+Cb2e5SSfzaDFX56nr5i7qRSqeBbfEhSZXAHr6M4\n+x2XA4UXo750j+g7KSu9MtMytjmAOzETlUs3RXv4hUVyZ45kw5OF58xKhmUU\nRCVOoNTLvmqPcRqkHKLZ4x9wmUDdqDZWUJqszo9Huh2XdgrLD61IRIgBfi6K\nz2F2\r\n=g2zX\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIHeAESl9BpynbXkhtJujwwcVWgnv48S+fwOjfvIRjsU+AiEAwXUTQAn6wtfIrJ35nMh3mQVlARDaLGE6y3fk/OPcrk8="
          }
        ]
      },
      "maintainers": [
        {
          "email": "npm@apollographql.com",
          "name": "apollo-bot"
        },
        {
          "email": "ben@benjamn.com",
          "name": "benjamn"
        },
        {
          "email": "james@meteor.com",
          "name": "jbaxleyiii"
        },
        {
          "email": "peggyrayzis@gmail.com",
          "name": "peggyrayzis"
        }
      ],
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/apollo-cache-inmemory_1.3.1_1538411356170_0.9213100227619468"
      },
      "_hasShrinkwrap": false
    },
    "1.3.2": {
      "name": "apollo-cache-inmemory",
      "version": "1.3.2",
      "description": "Core abstract of Caching layer for Apollo Client",
      "author": {
        "name": "James Baxley",
        "email": "james@meteor.com"
      },
      "contributors": [
        {
          "name": "James Baxley",
          "email": "james@meteor.com"
        },
        {
          "name": "Jonas Helfer",
          "email": "jonas@helfer.email"
        },
        {
          "name": "Sashko Stubailo",
          "email": "sashko@stubailo.com"
        },
        {
          "name": "James Burgess",
          "email": "jamesmillerburgess@gmail.com"
        },
        {
          "name": "Bazyli Brzóska",
          "email": "bazyli.brzoska@gmail.com"
        }
      ],
      "license": "MIT",
      "main": "./lib/bundle.umd.js",
      "module": "./lib/index.js",
      "jsnext:main": "./lib/index.js",
      "typings": "./lib/index.d.ts",
      "sideEffects": false,
      "repository": {
        "type": "git",
        "url": "git+https://github.com/apollographql/apollo-client.git"
      },
      "bugs": {
        "url": "https://github.com/apollographql/apollo-client/issues"
      },
      "homepage": "https://github.com/apollographql/apollo-client#readme",
      "scripts": {
        "prepare": "npm run build",
        "coverage": "jest --coverage",
        "test": "jest",
        "lint": "tslint -c \"../../config/tslint.json\" -p tsconfig.json src/*.ts",
        "prebuild": "npm run clean",
        "build": "tsc -p .",
        "postbuild": "npm run bundle",
        "bundle": "../../node_modules/rollup/bin/rollup -c rollup.config.js",
        "watch": "tsc -w -p .",
        "clean": "rm -rf coverage/* && rm -rf lib/*",
        "prepublishOnly": "npm run build",
        "minify": "../../node_modules/uglify-js/bin/uglifyjs -c -m -o ./lib/bundle.min.js -- ./lib/bundle.umd.js",
        "filesize": "npm run minify"
      },
      "dependencies": {
        "apollo-cache": "^1.1.17",
        "apollo-utilities": "^1.0.21",
        "optimism": "^0.6.6"
      },
      "peerDependencies": {
        "graphql": "0.11.7 || ^0.12.0 || ^0.13.0"
      },
      "jest": {
        "transform": {
          ".(ts|tsx)": "ts-jest"
        },
        "testRegex": "(/__tests__/.*|\\.(test|spec))\\.(ts|tsx|js)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "json"
        ],
        "testURL": "http://localhost"
      },
      "readme": "---\ntitle: InMemoryCache\ndescription: An explanation of `apollo-cache-inmemory`\n---\n\n`apollo-cache-inmemory` is the recommended cache implementation for Apollo Client 2.0. `InMemoryCache` is a normalized data store that supports all of Apollo Client 1.0's features without the dependency on Redux.\n\nIn some instances, you may need to manipulate the cache directly, such as updating the store after a mutation. We'll cover some common use cases [here](#recipes).\n\n<h2 id=\"installation\">Installation</h2>\n\n```\nnpm install apollo-cache-inmemory --save\n```\n\nAfter installing the package, you'll want to initialize the cache constructor. Then, you can pass in your newly created cache to ApolloClient.\n\n```js\nimport { InMemoryCache } from 'apollo-cache-inmemory';\nimport { HttpLink } from 'apollo-link-http';\nimport ApolloClient from 'apollo-client';\n\nconst cache = new InMemoryCache();\n\nconst client = new ApolloClient({\n  link: new HttpLink(),\n  cache\n});\n```\n\n<h2 id=\"configuration\">Configuration</h2>\n\nThe `InMemoryCache` constructor takes an optional config object with properties to customize your cache:\n\n- addTypename: A boolean to determine whether to add __typename to the document (default: `true`)\n- dataIdFromObject: A function that takes a data object and returns a unique identifier to be used when normalizing the data in the store. Learn more about how to customize `dataIdFromObject` in the [Normalization](#normalization) section.\n- fragmentMatcher: By default, the `InMemoryCache` uses a heuristic fragment matcher. If you are using fragments on unions and interfaces, you will need to use an `IntrospectionFragmentMatcher`. For more information, please read [our guide to setting up fragment matching for unions & interfaces](https://www.apollographql.com/docs/react/advanced/fragments.html#fragment-matcher).\n\n<h2 id=\"normalization\">Normalization</h2>\n\nThe `InMemoryCache` normalizes your data before saving it to the store by splitting the result into individual objects, creating a unique identifier for each object, and storing those objects in a flattened data structure. By default, `InMemoryCache` will attempt to use the commonly found primary keys of `id` and `_id` for the unique identifier if they exist along with `__typename` on an object.\n\nIf `id` and `_id` are not specified, or if `__typename` is not specified, `InMemoryCache` will fall back to the path to the object in the query, such as `ROOT_QUERY.allPeople.0` for the first record returned on the `allPeople` root query.\n\nThis \"getter\" behavior for unique identifiers can be configured manually via the `dataIdFromObject` option passed to the `InMemoryCache` constructor, so you can pick which field is used if some of your data follows unorthodox primary key conventions.\n\nFor example, if you wanted to key off of the `key` field for all of your data, you could configure `dataIdFromObject` like so:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => object.key\n});\n```\n\nThis also allows you to use different unique identifiers for different data types by keying off of the `__typename` property attached to every object typed by GraphQL.  For example:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => {\n    switch (object.__typename) {\n      case 'foo': return object.key; // use `key` as the primary key\n      case 'bar': return object.blah; // use `blah` as the priamry key\n      default: return object.id || object._id; // fall back to `id` and `_id` for all other types\n    }\n  }\n});\n```\n\n<h2 id=\"direct\">Direct Cache Access</h2>\n\nTo interact directly with your cache, you can use the Apollo Client class methods readQuery, readFragment, writeQuery, and writeFragment. These methods are available to us via the [`DataProxy` interface](https://github.com/apollographql/apollo-client/blob/master/packages/apollo-cache/src/types/DataProxy.ts). Accessing these methods will vary slightly based on your view layer implementation. If you are using React, you can wrap your component in the `withApollo` higher order component, which will give you access to `this.props.client`. From there, you can use the methods to control your data.\n\nAny code demonstration in the following sections will assume that we have already initialized an instance of  `ApolloClient` and that we have imported the `gql` tag from `graphql-tag`.\n\n<h3 id=\"readquery\">readQuery</h3>\n\nThe `readQuery` method is very similar to the [`query` method on `ApolloClient`][] except that `readQuery` will _never_ make a request to your GraphQL server. The `query` method, on the other hand, may send a request to your server if the appropriate data is not in your cache whereas `readQuery` will throw an error if the data is not in your cache. `readQuery` will _always_ read from the cache. You can use `readQuery` by giving it a GraphQL query like so:\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo {\n      todo(id: 5) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n});\n```\n\nIf all of the data needed to fulfill this read is in Apollo Client’s normalized data cache then a data object will be returned in the shape of the query you wanted to read. If not all of the data needed to fulfill this read is in Apollo Client’s cache then an error will be thrown instead, so make sure to only read data that you know you have!\n\nYou can also pass variables into `readQuery`.\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo($id: Int!) {\n      todo(id: $id) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n  variables: {\n    id: 5,\n  },\n});\n```\n\n<h3 id=\"readfragment\">readFragment</h3>\n\nThis method allows you great flexibility around the data in your cache. Whereas `readQuery` only allowed you to read data from your root query type, `readFragment` allows you to read data from _any node you have queried_. This is incredibly powerful. You use this method as follows:\n\n```js\nconst todo = client.readFragment({\n  id: ..., // `id` is any id that could be returned by `dataIdFromObject`.\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\nThe first argument is the id of the data you want to read from the cache. That id must be a value that was returned by the `dataIdFromObject` function you defined when initializing `ApolloClient`. So for example if you initialized `ApolloClient` like so:\n\n```js\nconst client = new ApolloClient({\n  ...,\n  dataIdFromObject: object => object.id,\n});\n```\n\n…and you requested a todo before with an id of `5`, then you can read that todo out of your cache with the following:\n\n```js\nconst todo = client.readFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\n> **Note:** Most people add a `__typename` to the id in `dataIdFromObject`. If you do this then don’t forget to add the `__typename` when you are reading a fragment as well. So for example your id may be `Todo_5` and not just `5`.\n\nIf a todo with that id does not exist in the cache you will get `null` back. If a todo of that id does exist in the cache, but that todo does not have the `text` field then an error will be thrown.\n\nThe beauty of `readFragment` is that the todo could have come from anywhere! The todo could have been selected as a singleton (`{ todo(id: 5) { ... } }`), the todo could have come from a list of todos (`{ todos { ... } }`), or the todo could have come from a mutation (`mutation { createTodo { ... } }`). As long as at some point your GraphQL server gave you a todo with the provided id and fields `id`, `text`, and `completed` you can read it from the cache at any part of your code.\n\n<h3 id=\"writequery-and-writefragment\">writeQuery` and `writeFragment</h3>\n\nNot only can you read arbitrary data from the Apollo Client cache, but you can also write any data that you would like to the cache. The methods you use to do this are `writeQuery` and `writeFragment`. They will allow you to change data in your local cache, but it is important to remember that *they will not change any data on your server*. If you reload your environment then changes made with `writeQuery` and `writeFragment` will disappear.\n\nThese methods have the same signature as their `readQuery` and `readFragment` counterparts except they also require an additional `data` variable. So for example, if you wanted to update the `completed` flag locally for your todo with id `'5'` you could execute the following:\n\n```js\nclient.writeFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      completed\n    }\n  `,\n  data: {\n    completed: true,\n  },\n});\n```\n\nAny subscriber to the Apollo Client store will instantly see this update and render new UI accordingly.\n\n> **Note:** Again, remember that using `writeQuery` or `writeFragment` only changes data *locally*. If you reload your environment then changes made with these methods will no longer exist.\n\nOr if you wanted to add a new todo to a list fetched from the server, you could use `readQuery` and `writeQuery` together.\n\n```js\nconst query = gql`\n  query MyTodoAppQuery {\n    todos {\n      id\n      text\n      completed\n    }\n  }\n`;\n\nconst data = client.readQuery({ query });\n\nconst myNewTodo = {\n  id: '6',\n  text: 'Start using Apollo Client.',\n  completed: false,\n};\n\nclient.writeQuery({\n  query,\n  data: {\n    todos: [...data.todos, myNewTodo],\n  },\n});\n```\n\n<h2 id=\"recipes\">Recipes</h2>\n\nHere are some common situations where you would need to access the cache directly. If you're manipulating the cache in an interesting way and would like your example to be featured, please send in a pull request!\n\n<h3 id=\"server\">Server side rendering</h3>\n\nFirst, you will need to initialize an `InMemoryCache` on the server and create an instance of `ApolloClient`. In the initial serialized HTML payload from the server, you should include a script tag that extracts the data from the cache.\n\n```js\n`<script>\n  window.__APOLLO_STATE__=${JSON.stringify(cache.extract())}\n</script>`\n```\n\nOn the client, you can rehydrate the cache using the initial data passed from the server:\n\n```js\ncache: new Cache().restore(window.__APOLLO_STATE__)\n```\n\nIf you would like to learn more about server side rendering, please check our our more in depth guide [here].\n<!---\nTODO (PEGGY): Add link to SSR\n-->\n\n<h3 id=\"server\">Updating the cache after a mutation</h3>\n\nBeing able to read and write to the Apollo cache from anywhere in your application gives you a lot of power over your data. However, there is one place where we most often want to update our cached data: after a mutation. As such, Apollo Client has optimized the experience for updating your cache with the read and write methods after a mutation with the `update` function. Let us say that we have the following GraphQL mutation:\n\n```graphql\nmutation TodoCreateMutation($text: String!) {\n  createTodo(text: $text) {\n    id\n    text\n    completed\n  }\n}\n```\n\nWe may also have the following GraphQL query:\n\n```graphql\nquery TodoAppQuery {\n  todos {\n    id\n    text\n    completed\n  }\n}\n```\n\nAt the end of our mutation we want our query to include the new todo like we had sent our `TodoAppQuery` a second time after the mutation finished without actually sending the query. To do this we can use the `update` function provided as an option of the `client.mutate` method. To update your cache with the mutation just write code that looks like:\n\n```js\n// We assume that the GraphQL operations `TodoCreateMutation` and\n// `TodoAppQuery` have already been defined using the `gql` tag.\n\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    // Read the data from our cache for this query.\n    const data = proxy.readQuery({ query: TodoAppQuery });\n\n    // Add our todo from the mutation to the end.\n    data.todos.push(createTodo);\n\n    // Write our data back to the cache.\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nThe first `proxy` argument is an instance of [`DataProxy`][] has the same four methods that we just learned exist on the Apollo Client: `readQuery`, `readFragment`, `writeQuery`, and `writeFragment`. The reason we call them on a `proxy` object here instead of on our `client` instance is that we can easily apply optimistic updates (which we will demonstrate in a bit). The `proxy` object also provides an isolated transaction which shields you from any other mutations going on at the same time, and the `proxy` object also batches writes together until the very end.\n\nIf you provide an `optimisticResponse` option to the mutation then the `update` function will be run twice. Once immediately after you call `client.mutate` with the data from `optimisticResponse`. After the mutation successfully executes against the server the changes made in the first call to `update` will be rolled back and `update` will be called with the *actual* data returned by the mutation and not just the optimistic response.\n\nPutting it all together:\n\n```js\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  optimisticResponse: {\n    id: -1, // -1 is a temporary id for the optimistic response.\n    text,\n    completed: false,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    const data = proxy.readQuery({ query: TodoAppQuery });\n    data.todos.push(createTodo);\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nAs you can see the `update` function on `client.mutate` provides extra change management functionality specific to the use case of a mutation while still providing you the powerful data control APIs that are available on `client`.\n\nThe `update` function is not a good place for side-effects as it may be called multiple times. Also, you may not call any of the methods on `proxy` asynchronously.\n\n",
      "readmeFilename": "README.md",
      "_id": "apollo-cache-inmemory@1.3.2",
      "_npmVersion": "6.4.1",
      "_nodeVersion": "8.11.4",
      "_npmUser": {
        "name": "benjamn",
        "email": "ben@benjamn.com"
      },
      "dist": {
        "integrity": "sha512-4JNx+NglVldZol6k8jvvhjd79fiz26LGkCtLSXK0wI4AjN7H2K14JNzw3v7J9fChhmw+nmW4qUTLkU72XIupFw==",
        "shasum": "97e18a6c6d4c5db56240684309aa018a79706094",
        "tarball": "https://registry.npmjs.org/apollo-cache-inmemory/-/apollo-cache-inmemory-1.3.2.tgz",
        "fileCount": 83,
        "unpackedSize": 509664,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJbskxjCRA9TVsSAnZWagAAAOMP/RaaEguycEPTmGwW5lrR\n/nu8zD6X5vdyyRLH3npx5yVzt4idt5LjnsH/fr5ZuFj0+c8w8FdTEjWmhr+P\npXlfOAVW9Cx3WQAXYMpzwJ2xmFNGTV2if583es0ZJ76V5iACGooIT3sjWN1/\n8C4N9vD+feagSt2Pu2WoNdCOLcz648UOZl2FE2SwjC8MdUQTyGn+aPX7b5fY\nQIYPs5XH7IHWmGDe1+yR8At8Jn9blvp8pMIqE+1NdhEmG7lDy/eFX4XkOjWI\naxsXbNZnpEpHdUu6qYj2jHHk4diWW4GM3+R83KeJfdTwmC2mOh0b0oLPeyJb\niyuEW0QIXC/4a0sbCf7zneqYokEsRJWEjDasduI/e9xOFxQ1Cl3cygZ2uPDc\nNLeVK1lUaj7kF0v1tyOuEDkhil1GlVhLcWXbINMt3mKMVhygGmgIkP795NtP\nq9PkhHzw78RCWOHi6DNMc7/UEiSrNEsrs3fE1UvFwayFl+ZlAjssQ9GCsPHg\niv83RWlKRW9XC0DgVRXY1kCXpFZwYhaD/EuVPIkiogGGzVHdWHzVCWyUzX6+\nbFkcLWDxXko09mEor+dtVugYks6EjRwZ8HcmHHkjFQj4JpMloMWrvRd5EBOx\nHKbJGU4h61EgVWm5npEfotqwRDB/XhGvM03y5iC54cI2zVEILYDvjlZEd2Wi\ncJ/f\r\n=ds34\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEYCIQD9BVNnCgZRVz6VeBX5s6Bjy+XR+uK/afIf0GHeKmgzHAIhAOq7+TBPzm1BenH0kK/udRTxThXJYv7Fpdvr+/WOO8Ht"
          }
        ]
      },
      "maintainers": [
        {
          "email": "npm@apollographql.com",
          "name": "apollo-bot"
        },
        {
          "email": "ben@benjamn.com",
          "name": "benjamn"
        },
        {
          "email": "james@meteor.com",
          "name": "jbaxleyiii"
        },
        {
          "email": "peggyrayzis@gmail.com",
          "name": "peggyrayzis"
        }
      ],
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/apollo-cache-inmemory_1.3.2_1538411619252_0.724774855371559"
      },
      "_hasShrinkwrap": false
    },
    "1.3.3": {
      "name": "apollo-cache-inmemory",
      "version": "1.3.3",
      "description": "Core abstract of Caching layer for Apollo Client",
      "author": {
        "name": "James Baxley",
        "email": "james@meteor.com"
      },
      "contributors": [
        {
          "name": "James Baxley",
          "email": "james@meteor.com"
        },
        {
          "name": "Jonas Helfer",
          "email": "jonas@helfer.email"
        },
        {
          "name": "Sashko Stubailo",
          "email": "sashko@stubailo.com"
        },
        {
          "name": "James Burgess",
          "email": "jamesmillerburgess@gmail.com"
        },
        {
          "name": "Bazyli Brzóska",
          "email": "bazyli.brzoska@gmail.com"
        }
      ],
      "license": "MIT",
      "main": "./lib/bundle.umd.js",
      "module": "./lib/index.js",
      "jsnext:main": "./lib/index.js",
      "typings": "./lib/index.d.ts",
      "sideEffects": false,
      "repository": {
        "type": "git",
        "url": "git+https://github.com/apollographql/apollo-client.git"
      },
      "bugs": {
        "url": "https://github.com/apollographql/apollo-client/issues"
      },
      "homepage": "https://github.com/apollographql/apollo-client#readme",
      "scripts": {
        "prepare": "npm run build",
        "coverage": "jest --coverage",
        "test": "jest",
        "lint": "tslint -c \"../../config/tslint.json\" -p tsconfig.json src/*.ts",
        "prebuild": "npm run clean",
        "build": "tsc -p .",
        "postbuild": "npm run bundle",
        "bundle": "../../node_modules/rollup/bin/rollup -c rollup.config.js",
        "watch": "tsc -w -p .",
        "clean": "rm -rf coverage/* && rm -rf lib/*",
        "prepublishOnly": "npm run build",
        "minify": "../../node_modules/uglify-js/bin/uglifyjs -c -m -o ./lib/bundle.min.js -- ./lib/bundle.umd.js",
        "filesize": "npm run minify"
      },
      "dependencies": {
        "apollo-cache": "^1.1.17",
        "apollo-utilities": "^1.0.21",
        "optimism": "^0.6.6"
      },
      "peerDependencies": {
        "graphql": "0.11.7 || ^0.12.0 || ^0.13.0"
      },
      "jest": {
        "transform": {
          ".(ts|tsx)": "ts-jest"
        },
        "testRegex": "(/__tests__/.*|\\.(test|spec))\\.(ts|tsx|js)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "json"
        ],
        "testURL": "http://localhost"
      },
      "readme": "---\ntitle: InMemoryCache\ndescription: An explanation of `apollo-cache-inmemory`\n---\n\n`apollo-cache-inmemory` is the recommended cache implementation for Apollo Client 2.0. `InMemoryCache` is a normalized data store that supports all of Apollo Client 1.0's features without the dependency on Redux.\n\nIn some instances, you may need to manipulate the cache directly, such as updating the store after a mutation. We'll cover some common use cases [here](#recipes).\n\n<h2 id=\"installation\">Installation</h2>\n\n```\nnpm install apollo-cache-inmemory --save\n```\n\nAfter installing the package, you'll want to initialize the cache constructor. Then, you can pass in your newly created cache to ApolloClient.\n\n```js\nimport { InMemoryCache } from 'apollo-cache-inmemory';\nimport { HttpLink } from 'apollo-link-http';\nimport ApolloClient from 'apollo-client';\n\nconst cache = new InMemoryCache();\n\nconst client = new ApolloClient({\n  link: new HttpLink(),\n  cache\n});\n```\n\n<h2 id=\"configuration\">Configuration</h2>\n\nThe `InMemoryCache` constructor takes an optional config object with properties to customize your cache:\n\n- addTypename: A boolean to determine whether to add __typename to the document (default: `true`)\n- dataIdFromObject: A function that takes a data object and returns a unique identifier to be used when normalizing the data in the store. Learn more about how to customize `dataIdFromObject` in the [Normalization](#normalization) section.\n- fragmentMatcher: By default, the `InMemoryCache` uses a heuristic fragment matcher. If you are using fragments on unions and interfaces, you will need to use an `IntrospectionFragmentMatcher`. For more information, please read [our guide to setting up fragment matching for unions & interfaces](https://www.apollographql.com/docs/react/advanced/fragments.html#fragment-matcher).\n\n<h2 id=\"normalization\">Normalization</h2>\n\nThe `InMemoryCache` normalizes your data before saving it to the store by splitting the result into individual objects, creating a unique identifier for each object, and storing those objects in a flattened data structure. By default, `InMemoryCache` will attempt to use the commonly found primary keys of `id` and `_id` for the unique identifier if they exist along with `__typename` on an object.\n\nIf `id` and `_id` are not specified, or if `__typename` is not specified, `InMemoryCache` will fall back to the path to the object in the query, such as `ROOT_QUERY.allPeople.0` for the first record returned on the `allPeople` root query.\n\nThis \"getter\" behavior for unique identifiers can be configured manually via the `dataIdFromObject` option passed to the `InMemoryCache` constructor, so you can pick which field is used if some of your data follows unorthodox primary key conventions.\n\nFor example, if you wanted to key off of the `key` field for all of your data, you could configure `dataIdFromObject` like so:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => object.key\n});\n```\n\nThis also allows you to use different unique identifiers for different data types by keying off of the `__typename` property attached to every object typed by GraphQL.  For example:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => {\n    switch (object.__typename) {\n      case 'foo': return object.key; // use `key` as the primary key\n      case 'bar': return object.blah; // use `blah` as the priamry key\n      default: return object.id || object._id; // fall back to `id` and `_id` for all other types\n    }\n  }\n});\n```\n\n<h2 id=\"direct\">Direct Cache Access</h2>\n\nTo interact directly with your cache, you can use the Apollo Client class methods readQuery, readFragment, writeQuery, and writeFragment. These methods are available to us via the [`DataProxy` interface](https://github.com/apollographql/apollo-client/blob/master/packages/apollo-cache/src/types/DataProxy.ts). Accessing these methods will vary slightly based on your view layer implementation. If you are using React, you can wrap your component in the `withApollo` higher order component, which will give you access to `this.props.client`. From there, you can use the methods to control your data.\n\nAny code demonstration in the following sections will assume that we have already initialized an instance of  `ApolloClient` and that we have imported the `gql` tag from `graphql-tag`.\n\n<h3 id=\"readquery\">readQuery</h3>\n\nThe `readQuery` method is very similar to the [`query` method on `ApolloClient`][] except that `readQuery` will _never_ make a request to your GraphQL server. The `query` method, on the other hand, may send a request to your server if the appropriate data is not in your cache whereas `readQuery` will throw an error if the data is not in your cache. `readQuery` will _always_ read from the cache. You can use `readQuery` by giving it a GraphQL query like so:\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo {\n      todo(id: 5) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n});\n```\n\nIf all of the data needed to fulfill this read is in Apollo Client’s normalized data cache then a data object will be returned in the shape of the query you wanted to read. If not all of the data needed to fulfill this read is in Apollo Client’s cache then an error will be thrown instead, so make sure to only read data that you know you have!\n\nYou can also pass variables into `readQuery`.\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo($id: Int!) {\n      todo(id: $id) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n  variables: {\n    id: 5,\n  },\n});\n```\n\n<h3 id=\"readfragment\">readFragment</h3>\n\nThis method allows you great flexibility around the data in your cache. Whereas `readQuery` only allowed you to read data from your root query type, `readFragment` allows you to read data from _any node you have queried_. This is incredibly powerful. You use this method as follows:\n\n```js\nconst todo = client.readFragment({\n  id: ..., // `id` is any id that could be returned by `dataIdFromObject`.\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\nThe first argument is the id of the data you want to read from the cache. That id must be a value that was returned by the `dataIdFromObject` function you defined when initializing `ApolloClient`. So for example if you initialized `ApolloClient` like so:\n\n```js\nconst client = new ApolloClient({\n  ...,\n  dataIdFromObject: object => object.id,\n});\n```\n\n…and you requested a todo before with an id of `5`, then you can read that todo out of your cache with the following:\n\n```js\nconst todo = client.readFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\n> **Note:** Most people add a `__typename` to the id in `dataIdFromObject`. If you do this then don’t forget to add the `__typename` when you are reading a fragment as well. So for example your id may be `Todo_5` and not just `5`.\n\nIf a todo with that id does not exist in the cache you will get `null` back. If a todo of that id does exist in the cache, but that todo does not have the `text` field then an error will be thrown.\n\nThe beauty of `readFragment` is that the todo could have come from anywhere! The todo could have been selected as a singleton (`{ todo(id: 5) { ... } }`), the todo could have come from a list of todos (`{ todos { ... } }`), or the todo could have come from a mutation (`mutation { createTodo { ... } }`). As long as at some point your GraphQL server gave you a todo with the provided id and fields `id`, `text`, and `completed` you can read it from the cache at any part of your code.\n\n<h3 id=\"writequery-and-writefragment\">writeQuery` and `writeFragment</h3>\n\nNot only can you read arbitrary data from the Apollo Client cache, but you can also write any data that you would like to the cache. The methods you use to do this are `writeQuery` and `writeFragment`. They will allow you to change data in your local cache, but it is important to remember that *they will not change any data on your server*. If you reload your environment then changes made with `writeQuery` and `writeFragment` will disappear.\n\nThese methods have the same signature as their `readQuery` and `readFragment` counterparts except they also require an additional `data` variable. So for example, if you wanted to update the `completed` flag locally for your todo with id `'5'` you could execute the following:\n\n```js\nclient.writeFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      completed\n    }\n  `,\n  data: {\n    completed: true,\n  },\n});\n```\n\nAny subscriber to the Apollo Client store will instantly see this update and render new UI accordingly.\n\n> **Note:** Again, remember that using `writeQuery` or `writeFragment` only changes data *locally*. If you reload your environment then changes made with these methods will no longer exist.\n\nOr if you wanted to add a new todo to a list fetched from the server, you could use `readQuery` and `writeQuery` together.\n\n```js\nconst query = gql`\n  query MyTodoAppQuery {\n    todos {\n      id\n      text\n      completed\n    }\n  }\n`;\n\nconst data = client.readQuery({ query });\n\nconst myNewTodo = {\n  id: '6',\n  text: 'Start using Apollo Client.',\n  completed: false,\n};\n\nclient.writeQuery({\n  query,\n  data: {\n    todos: [...data.todos, myNewTodo],\n  },\n});\n```\n\n<h2 id=\"recipes\">Recipes</h2>\n\nHere are some common situations where you would need to access the cache directly. If you're manipulating the cache in an interesting way and would like your example to be featured, please send in a pull request!\n\n<h3 id=\"server\">Server side rendering</h3>\n\nFirst, you will need to initialize an `InMemoryCache` on the server and create an instance of `ApolloClient`. In the initial serialized HTML payload from the server, you should include a script tag that extracts the data from the cache.\n\n```js\n`<script>\n  window.__APOLLO_STATE__=${JSON.stringify(cache.extract())}\n</script>`\n```\n\nOn the client, you can rehydrate the cache using the initial data passed from the server:\n\n```js\ncache: new Cache().restore(window.__APOLLO_STATE__)\n```\n\nIf you would like to learn more about server side rendering, please check our our more in depth guide [here].\n<!---\nTODO (PEGGY): Add link to SSR\n-->\n\n<h3 id=\"server\">Updating the cache after a mutation</h3>\n\nBeing able to read and write to the Apollo cache from anywhere in your application gives you a lot of power over your data. However, there is one place where we most often want to update our cached data: after a mutation. As such, Apollo Client has optimized the experience for updating your cache with the read and write methods after a mutation with the `update` function. Let us say that we have the following GraphQL mutation:\n\n```graphql\nmutation TodoCreateMutation($text: String!) {\n  createTodo(text: $text) {\n    id\n    text\n    completed\n  }\n}\n```\n\nWe may also have the following GraphQL query:\n\n```graphql\nquery TodoAppQuery {\n  todos {\n    id\n    text\n    completed\n  }\n}\n```\n\nAt the end of our mutation we want our query to include the new todo like we had sent our `TodoAppQuery` a second time after the mutation finished without actually sending the query. To do this we can use the `update` function provided as an option of the `client.mutate` method. To update your cache with the mutation just write code that looks like:\n\n```js\n// We assume that the GraphQL operations `TodoCreateMutation` and\n// `TodoAppQuery` have already been defined using the `gql` tag.\n\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    // Read the data from our cache for this query.\n    const data = proxy.readQuery({ query: TodoAppQuery });\n\n    // Add our todo from the mutation to the end.\n    data.todos.push(createTodo);\n\n    // Write our data back to the cache.\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nThe first `proxy` argument is an instance of [`DataProxy`][] has the same four methods that we just learned exist on the Apollo Client: `readQuery`, `readFragment`, `writeQuery`, and `writeFragment`. The reason we call them on a `proxy` object here instead of on our `client` instance is that we can easily apply optimistic updates (which we will demonstrate in a bit). The `proxy` object also provides an isolated transaction which shields you from any other mutations going on at the same time, and the `proxy` object also batches writes together until the very end.\n\nIf you provide an `optimisticResponse` option to the mutation then the `update` function will be run twice. Once immediately after you call `client.mutate` with the data from `optimisticResponse`. After the mutation successfully executes against the server the changes made in the first call to `update` will be rolled back and `update` will be called with the *actual* data returned by the mutation and not just the optimistic response.\n\nPutting it all together:\n\n```js\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  optimisticResponse: {\n    id: -1, // -1 is a temporary id for the optimistic response.\n    text,\n    completed: false,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    const data = proxy.readQuery({ query: TodoAppQuery });\n    data.todos.push(createTodo);\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nAs you can see the `update` function on `client.mutate` provides extra change management functionality specific to the use case of a mutation while still providing you the powerful data control APIs that are available on `client`.\n\nThe `update` function is not a good place for side-effects as it may be called multiple times. Also, you may not call any of the methods on `proxy` asynchronously.\n\n",
      "readmeFilename": "README.md",
      "_id": "apollo-cache-inmemory@1.3.3",
      "_npmVersion": "6.4.1",
      "_nodeVersion": "8.11.4",
      "_npmUser": {
        "name": "benjamn",
        "email": "ben@benjamn.com"
      },
      "dist": {
        "integrity": "sha512-sh6TIdTt6I/tS7ZZ3ubFwR38sOsvIjTEniLnaUUvGNZ0NLHAQydpebHXZQRCxmUsDDQk+JIn9wtQyjHuQY2hWQ==",
        "shasum": "0d6642e332c108b042758d51880809c728ef1228",
        "tarball": "https://registry.npmjs.org/apollo-cache-inmemory/-/apollo-cache-inmemory-1.3.3.tgz",
        "fileCount": 83,
        "unpackedSize": 504090,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJbtArACRA9TVsSAnZWagAAv0MP/13Alf/ECGo7fSsx3as/\ngDg19pcd9LXJyZi8VB2gdgDdIgxi+6zmuSKPK1rmmFLIcRIAwvikilXo11/H\naE/0lkkRNGSq2JfQIfL9Ix3fK5GeV+9VsETuYbZFW0XUkO85Dd3GQpS9coyg\nKwEVq73DflBqnRqloKhAIzeUXInxkmJtnR++NCC++NNElnlyvvsKKvcfhq12\naCgL5W3hiUjm7XRooBnIlJfaxDYmDAc3JIU+emDvDUvDDOQjRw3nX8t+XxBI\nzFeinTQrJg4iJvTX0p41PlqQczAkoG0DoG6UvNQ5gK4r6Mob6ASEJZKOI2kW\ndbbTCt/1eWsafSSSGNGqu4D/4yjHkz9U41+7xmf3Nqe6Uq8Bg0Yg5A1fxpUC\n+CE0+r3mzcyjdDt7JdOqR9ig4heRe7RVxDf2fhMU4fW9AvnmGPQ/ptwKWlT5\nHy0njnPGa4k3sXdFQ5EqVS4O4nTpvZZCWx5B5yBOYcD3bYNe8V1krQrJ5pB7\nrQfZUhZRVPBg1Nq4bX6rMUoZ8X/5wI9BY1zAFGeyuSOLx7SrC4QmfM4k/MJc\nLSsXsSnoWscotmbwiyiK0glj9h4b3kfnPy1zovVB5mis2AjZX1Qe/BSa3wX+\ne/1fjuq9g/Upf7qBEVvU2vcjjmi64K6UVZumBV/yDbbuBt66F/1n3p93zeAE\nvtK2\r\n=YkvD\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEQCIC8sv5MDcEOwVk9rgdKZ5H4EN9DdSUcLa8UUX9Tx6q2NAiARCw4nkrMSs0yE4Ti+8XO4ZqBMEoySYOCgepH3UIJOKA=="
          }
        ]
      },
      "maintainers": [
        {
          "email": "npm@apollographql.com",
          "name": "apollo-bot"
        },
        {
          "email": "ben@benjamn.com",
          "name": "benjamn"
        },
        {
          "email": "james@meteor.com",
          "name": "jbaxleyiii"
        },
        {
          "email": "peggyrayzis@gmail.com",
          "name": "peggyrayzis"
        }
      ],
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/apollo-cache-inmemory_1.3.3_1538525887604_0.8569200055823776"
      },
      "_hasShrinkwrap": false
    },
    "1.3.4": {
      "name": "apollo-cache-inmemory",
      "version": "1.3.4",
      "description": "Core abstract of Caching layer for Apollo Client",
      "author": {
        "name": "James Baxley",
        "email": "james@meteor.com"
      },
      "contributors": [
        {
          "name": "James Baxley",
          "email": "james@meteor.com"
        },
        {
          "name": "Jonas Helfer",
          "email": "jonas@helfer.email"
        },
        {
          "name": "Sashko Stubailo",
          "email": "sashko@stubailo.com"
        },
        {
          "name": "James Burgess",
          "email": "jamesmillerburgess@gmail.com"
        },
        {
          "name": "Bazyli Brzóska",
          "email": "bazyli.brzoska@gmail.com"
        }
      ],
      "license": "MIT",
      "main": "./lib/bundle.umd.js",
      "module": "./lib/index.js",
      "jsnext:main": "./lib/index.js",
      "typings": "./lib/index.d.ts",
      "sideEffects": false,
      "repository": {
        "type": "git",
        "url": "git+https://github.com/apollographql/apollo-client.git"
      },
      "bugs": {
        "url": "https://github.com/apollographql/apollo-client/issues"
      },
      "homepage": "https://github.com/apollographql/apollo-client#readme",
      "scripts": {
        "prepare": "npm run build",
        "coverage": "jest --coverage",
        "test": "jest",
        "lint": "tslint -c \"../../config/tslint.json\" -p tsconfig.json src/*.ts",
        "prebuild": "npm run clean",
        "build": "tsc -p .",
        "postbuild": "npm run bundle",
        "bundle": "../../node_modules/rollup/bin/rollup -c rollup.config.js",
        "watch": "tsc -w -p .",
        "clean": "rm -rf coverage/* && rm -rf lib/*",
        "prepublishOnly": "npm run build",
        "minify": "../../node_modules/uglify-js/bin/uglifyjs -c -m -o ./lib/bundle.min.js -- ./lib/bundle.umd.js",
        "filesize": "npm run minify"
      },
      "dependencies": {
        "apollo-cache": "^1.1.17",
        "apollo-utilities": "^1.0.21",
        "optimism": "^0.6.6"
      },
      "peerDependencies": {
        "graphql": "0.11.7 || ^0.12.0 || ^0.13.0"
      },
      "jest": {
        "transform": {
          ".(ts|tsx)": "ts-jest"
        },
        "testRegex": "(/__tests__/.*|\\.(test|spec))\\.(ts|tsx|js)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "json"
        ],
        "testURL": "http://localhost"
      },
      "readme": "---\ntitle: InMemoryCache\ndescription: An explanation of `apollo-cache-inmemory`\n---\n\n`apollo-cache-inmemory` is the recommended cache implementation for Apollo Client 2.0. `InMemoryCache` is a normalized data store that supports all of Apollo Client 1.0's features without the dependency on Redux.\n\nIn some instances, you may need to manipulate the cache directly, such as updating the store after a mutation. We'll cover some common use cases [here](#recipes).\n\n<h2 id=\"installation\">Installation</h2>\n\n```\nnpm install apollo-cache-inmemory --save\n```\n\nAfter installing the package, you'll want to initialize the cache constructor. Then, you can pass in your newly created cache to ApolloClient.\n\n```js\nimport { InMemoryCache } from 'apollo-cache-inmemory';\nimport { HttpLink } from 'apollo-link-http';\nimport ApolloClient from 'apollo-client';\n\nconst cache = new InMemoryCache();\n\nconst client = new ApolloClient({\n  link: new HttpLink(),\n  cache\n});\n```\n\n<h2 id=\"configuration\">Configuration</h2>\n\nThe `InMemoryCache` constructor takes an optional config object with properties to customize your cache:\n\n- addTypename: A boolean to determine whether to add __typename to the document (default: `true`)\n- dataIdFromObject: A function that takes a data object and returns a unique identifier to be used when normalizing the data in the store. Learn more about how to customize `dataIdFromObject` in the [Normalization](#normalization) section.\n- fragmentMatcher: By default, the `InMemoryCache` uses a heuristic fragment matcher. If you are using fragments on unions and interfaces, you will need to use an `IntrospectionFragmentMatcher`. For more information, please read [our guide to setting up fragment matching for unions & interfaces](https://www.apollographql.com/docs/react/advanced/fragments.html#fragment-matcher).\n\n<h2 id=\"normalization\">Normalization</h2>\n\nThe `InMemoryCache` normalizes your data before saving it to the store by splitting the result into individual objects, creating a unique identifier for each object, and storing those objects in a flattened data structure. By default, `InMemoryCache` will attempt to use the commonly found primary keys of `id` and `_id` for the unique identifier if they exist along with `__typename` on an object.\n\nIf `id` and `_id` are not specified, or if `__typename` is not specified, `InMemoryCache` will fall back to the path to the object in the query, such as `ROOT_QUERY.allPeople.0` for the first record returned on the `allPeople` root query.\n\nThis \"getter\" behavior for unique identifiers can be configured manually via the `dataIdFromObject` option passed to the `InMemoryCache` constructor, so you can pick which field is used if some of your data follows unorthodox primary key conventions.\n\nFor example, if you wanted to key off of the `key` field for all of your data, you could configure `dataIdFromObject` like so:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => object.key\n});\n```\n\nThis also allows you to use different unique identifiers for different data types by keying off of the `__typename` property attached to every object typed by GraphQL.  For example:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => {\n    switch (object.__typename) {\n      case 'foo': return object.key; // use `key` as the primary key\n      case 'bar': return object.blah; // use `blah` as the priamry key\n      default: return object.id || object._id; // fall back to `id` and `_id` for all other types\n    }\n  }\n});\n```\n\n<h2 id=\"direct\">Direct Cache Access</h2>\n\nTo interact directly with your cache, you can use the Apollo Client class methods readQuery, readFragment, writeQuery, and writeFragment. These methods are available to us via the [`DataProxy` interface](https://github.com/apollographql/apollo-client/blob/master/packages/apollo-cache/src/types/DataProxy.ts). Accessing these methods will vary slightly based on your view layer implementation. If you are using React, you can wrap your component in the `withApollo` higher order component, which will give you access to `this.props.client`. From there, you can use the methods to control your data.\n\nAny code demonstration in the following sections will assume that we have already initialized an instance of  `ApolloClient` and that we have imported the `gql` tag from `graphql-tag`.\n\n<h3 id=\"readquery\">readQuery</h3>\n\nThe `readQuery` method is very similar to the [`query` method on `ApolloClient`][] except that `readQuery` will _never_ make a request to your GraphQL server. The `query` method, on the other hand, may send a request to your server if the appropriate data is not in your cache whereas `readQuery` will throw an error if the data is not in your cache. `readQuery` will _always_ read from the cache. You can use `readQuery` by giving it a GraphQL query like so:\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo {\n      todo(id: 5) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n});\n```\n\nIf all of the data needed to fulfill this read is in Apollo Client’s normalized data cache then a data object will be returned in the shape of the query you wanted to read. If not all of the data needed to fulfill this read is in Apollo Client’s cache then an error will be thrown instead, so make sure to only read data that you know you have!\n\nYou can also pass variables into `readQuery`.\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo($id: Int!) {\n      todo(id: $id) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n  variables: {\n    id: 5,\n  },\n});\n```\n\n<h3 id=\"readfragment\">readFragment</h3>\n\nThis method allows you great flexibility around the data in your cache. Whereas `readQuery` only allowed you to read data from your root query type, `readFragment` allows you to read data from _any node you have queried_. This is incredibly powerful. You use this method as follows:\n\n```js\nconst todo = client.readFragment({\n  id: ..., // `id` is any id that could be returned by `dataIdFromObject`.\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\nThe first argument is the id of the data you want to read from the cache. That id must be a value that was returned by the `dataIdFromObject` function you defined when initializing `ApolloClient`. So for example if you initialized `ApolloClient` like so:\n\n```js\nconst client = new ApolloClient({\n  ...,\n  dataIdFromObject: object => object.id,\n});\n```\n\n…and you requested a todo before with an id of `5`, then you can read that todo out of your cache with the following:\n\n```js\nconst todo = client.readFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\n> **Note:** Most people add a `__typename` to the id in `dataIdFromObject`. If you do this then don’t forget to add the `__typename` when you are reading a fragment as well. So for example your id may be `Todo_5` and not just `5`.\n\nIf a todo with that id does not exist in the cache you will get `null` back. If a todo of that id does exist in the cache, but that todo does not have the `text` field then an error will be thrown.\n\nThe beauty of `readFragment` is that the todo could have come from anywhere! The todo could have been selected as a singleton (`{ todo(id: 5) { ... } }`), the todo could have come from a list of todos (`{ todos { ... } }`), or the todo could have come from a mutation (`mutation { createTodo { ... } }`). As long as at some point your GraphQL server gave you a todo with the provided id and fields `id`, `text`, and `completed` you can read it from the cache at any part of your code.\n\n<h3 id=\"writequery-and-writefragment\">writeQuery` and `writeFragment</h3>\n\nNot only can you read arbitrary data from the Apollo Client cache, but you can also write any data that you would like to the cache. The methods you use to do this are `writeQuery` and `writeFragment`. They will allow you to change data in your local cache, but it is important to remember that *they will not change any data on your server*. If you reload your environment then changes made with `writeQuery` and `writeFragment` will disappear.\n\nThese methods have the same signature as their `readQuery` and `readFragment` counterparts except they also require an additional `data` variable. So for example, if you wanted to update the `completed` flag locally for your todo with id `'5'` you could execute the following:\n\n```js\nclient.writeFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      completed\n    }\n  `,\n  data: {\n    completed: true,\n  },\n});\n```\n\nAny subscriber to the Apollo Client store will instantly see this update and render new UI accordingly.\n\n> **Note:** Again, remember that using `writeQuery` or `writeFragment` only changes data *locally*. If you reload your environment then changes made with these methods will no longer exist.\n\nOr if you wanted to add a new todo to a list fetched from the server, you could use `readQuery` and `writeQuery` together.\n\n```js\nconst query = gql`\n  query MyTodoAppQuery {\n    todos {\n      id\n      text\n      completed\n    }\n  }\n`;\n\nconst data = client.readQuery({ query });\n\nconst myNewTodo = {\n  id: '6',\n  text: 'Start using Apollo Client.',\n  completed: false,\n};\n\nclient.writeQuery({\n  query,\n  data: {\n    todos: [...data.todos, myNewTodo],\n  },\n});\n```\n\n<h2 id=\"recipes\">Recipes</h2>\n\nHere are some common situations where you would need to access the cache directly. If you're manipulating the cache in an interesting way and would like your example to be featured, please send in a pull request!\n\n<h3 id=\"server\">Server side rendering</h3>\n\nFirst, you will need to initialize an `InMemoryCache` on the server and create an instance of `ApolloClient`. In the initial serialized HTML payload from the server, you should include a script tag that extracts the data from the cache.\n\n```js\n`<script>\n  window.__APOLLO_STATE__=${JSON.stringify(cache.extract())}\n</script>`\n```\n\nOn the client, you can rehydrate the cache using the initial data passed from the server:\n\n```js\ncache: new Cache().restore(window.__APOLLO_STATE__)\n```\n\nIf you would like to learn more about server side rendering, please check our our more in depth guide [here].\n<!---\nTODO (PEGGY): Add link to SSR\n-->\n\n<h3 id=\"server\">Updating the cache after a mutation</h3>\n\nBeing able to read and write to the Apollo cache from anywhere in your application gives you a lot of power over your data. However, there is one place where we most often want to update our cached data: after a mutation. As such, Apollo Client has optimized the experience for updating your cache with the read and write methods after a mutation with the `update` function. Let us say that we have the following GraphQL mutation:\n\n```graphql\nmutation TodoCreateMutation($text: String!) {\n  createTodo(text: $text) {\n    id\n    text\n    completed\n  }\n}\n```\n\nWe may also have the following GraphQL query:\n\n```graphql\nquery TodoAppQuery {\n  todos {\n    id\n    text\n    completed\n  }\n}\n```\n\nAt the end of our mutation we want our query to include the new todo like we had sent our `TodoAppQuery` a second time after the mutation finished without actually sending the query. To do this we can use the `update` function provided as an option of the `client.mutate` method. To update your cache with the mutation just write code that looks like:\n\n```js\n// We assume that the GraphQL operations `TodoCreateMutation` and\n// `TodoAppQuery` have already been defined using the `gql` tag.\n\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    // Read the data from our cache for this query.\n    const data = proxy.readQuery({ query: TodoAppQuery });\n\n    // Add our todo from the mutation to the end.\n    data.todos.push(createTodo);\n\n    // Write our data back to the cache.\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nThe first `proxy` argument is an instance of [`DataProxy`][] has the same four methods that we just learned exist on the Apollo Client: `readQuery`, `readFragment`, `writeQuery`, and `writeFragment`. The reason we call them on a `proxy` object here instead of on our `client` instance is that we can easily apply optimistic updates (which we will demonstrate in a bit). The `proxy` object also provides an isolated transaction which shields you from any other mutations going on at the same time, and the `proxy` object also batches writes together until the very end.\n\nIf you provide an `optimisticResponse` option to the mutation then the `update` function will be run twice. Once immediately after you call `client.mutate` with the data from `optimisticResponse`. After the mutation successfully executes against the server the changes made in the first call to `update` will be rolled back and `update` will be called with the *actual* data returned by the mutation and not just the optimistic response.\n\nPutting it all together:\n\n```js\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  optimisticResponse: {\n    id: -1, // -1 is a temporary id for the optimistic response.\n    text,\n    completed: false,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    const data = proxy.readQuery({ query: TodoAppQuery });\n    data.todos.push(createTodo);\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nAs you can see the `update` function on `client.mutate` provides extra change management functionality specific to the use case of a mutation while still providing you the powerful data control APIs that are available on `client`.\n\nThe `update` function is not a good place for side-effects as it may be called multiple times. Also, you may not call any of the methods on `proxy` asynchronously.\n\n",
      "readmeFilename": "README.md",
      "_id": "apollo-cache-inmemory@1.3.4",
      "_npmVersion": "6.4.1",
      "_nodeVersion": "8.11.4",
      "_npmUser": {
        "name": "benjamn",
        "email": "ben@benjamn.com"
      },
      "dist": {
        "integrity": "sha512-8lUb/LbK6WOLoSqf5MU/uNDN5hB8hq3aRJHvT1nBPsDo0bflL+NqQLzI2OYGJjdJt0W9f6lIYE1rMMFhyyDOog==",
        "shasum": "1f75b51f4c2f4c5ccba3c078c8f88ed4572eb161",
        "tarball": "https://registry.npmjs.org/apollo-cache-inmemory/-/apollo-cache-inmemory-1.3.4.tgz",
        "fileCount": 88,
        "unpackedSize": 510127,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJbtOH0CRA9TVsSAnZWagAArpkQAJ0LUmCNM7iscY3arqC7\nQ25mSSwN/7f3Gnuxn7Wn3AbcgcEHdr9DIjnz8pTAnP3D7vPo9FTKmhM0OOgK\npPqFryOV/G6OW+/2jzsFryT07n/cgTnbJNFZkI8doh7JMq7kFzscyrjhTJQX\nxfQnzD0NIDqADFyyO8uSO3ltHcfS+uz3TPO9FF7YINTCbERPPIbhGCuOxJbM\n5FisXe4e5NS9JTPXWeB98Gyg4pre0or4DBT0weCn43utoLD0Oj56Xh1vcTqw\n5N7vGeT0QBXI5iSDzO5baTgP24nofD7aCsYKCrjF8FVWm2WJIbJ4dGTcfDUk\nl8EbYxhxjlfjK4R73W5Ak+7NdgPj7taosNO5YXjmx1xX3BfHcARvnpvEfCjr\nEheCmjzKHSNV8IKNhlVefqXrQWXrwPPizchJ4oiwBTnup29KLa8KcTU6VxYT\nkaQwokOhEo01zoUrl0Z6890i+Y/auMOClm12nSZzPBFopZG0bPaAdPsqsXhy\nmD5zrND3fVXCa65n5uZfwneDoHxc8/jYOGMFMJ/paTzRyICmNfYNHEG4ra/Q\nuA7jkTMWqM8GOoe7fHrjd1KIW7BcKtWdUKanKunPkTv5xzwKS4njQc7NjAD2\ntEld3RrlHVbWkFfppBmNAJwYXAPZIH6bnowsM0a+U+N7rlAQUUP5RM/xkMJl\nCMtf\r\n=0Z/b\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEQCIG/XzrDFOfqSK8Qm3+ukJ059QTM1c8sfRPgUuoXfJuplAiAs4FzO/is1RmM8694MjOhxATh+VpGaTNDHHpO8SdJHcg=="
          }
        ]
      },
      "maintainers": [
        {
          "email": "npm@apollographql.com",
          "name": "apollo-bot"
        },
        {
          "email": "ben@benjamn.com",
          "name": "benjamn"
        },
        {
          "email": "james@meteor.com",
          "name": "jbaxleyiii"
        },
        {
          "email": "peggyrayzis@gmail.com",
          "name": "peggyrayzis"
        }
      ],
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/apollo-cache-inmemory_1.3.4_1538580979967_0.628831427400482"
      },
      "_hasShrinkwrap": false
    },
    "1.3.1-local-state-alpha.0": {
      "name": "apollo-cache-inmemory",
      "version": "1.3.1-local-state-alpha.0",
      "description": "Core abstract of Caching layer for Apollo Client",
      "author": {
        "name": "James Baxley",
        "email": "james@meteor.com"
      },
      "contributors": [
        {
          "name": "James Baxley",
          "email": "james@meteor.com"
        },
        {
          "name": "Jonas Helfer",
          "email": "jonas@helfer.email"
        },
        {
          "name": "Sashko Stubailo",
          "email": "sashko@stubailo.com"
        },
        {
          "name": "James Burgess",
          "email": "jamesmillerburgess@gmail.com"
        },
        {
          "name": "Bazyli Brzóska",
          "email": "bazyli.brzoska@gmail.com"
        }
      ],
      "license": "MIT",
      "main": "./lib/bundle.umd.js",
      "module": "./lib/index.js",
      "jsnext:main": "./lib/index.js",
      "typings": "./lib/index.d.ts",
      "sideEffects": false,
      "repository": {
        "type": "git",
        "url": "git+https://github.com/apollographql/apollo-client.git"
      },
      "bugs": {
        "url": "https://github.com/apollographql/apollo-client/issues"
      },
      "homepage": "https://github.com/apollographql/apollo-client#readme",
      "scripts": {
        "prepare": "npm run build",
        "coverage": "jest --coverage",
        "test": "jest",
        "lint": "tslint -c \"../../config/tslint.json\" -p tsconfig.json src/*.ts",
        "prebuild": "npm run clean",
        "build": "tsc -p .",
        "postbuild": "npm run bundle",
        "bundle": "../../node_modules/rollup/bin/rollup -c rollup.config.js",
        "watch": "tsc -w -p .",
        "clean": "rm -rf coverage/* && rm -rf lib/*",
        "prepublishOnly": "npm run build",
        "minify": "../../node_modules/uglify-js/bin/uglifyjs -c -m -o ./lib/bundle.min.js -- ./lib/bundle.umd.js",
        "filesize": "npm run minify"
      },
      "dependencies": {
        "apollo-cache": "^1.1.18-local-state-alpha.0",
        "apollo-utilities": "^1.0.22-local-state-alpha.0",
        "optimism": "^0.6.6"
      },
      "peerDependencies": {
        "graphql": "0.11.7 || ^0.12.0 || ^0.13.0"
      },
      "jest": {
        "transform": {
          ".(ts|tsx)": "ts-jest"
        },
        "testRegex": "(/__tests__/.*|\\.(test|spec))\\.(ts|tsx|js)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "json"
        ],
        "testURL": "http://localhost"
      },
      "gitHead": "46323ee30b416809433e8fccffdb933eaa68c99a",
      "_resolved": "",
      "_integrity": "",
      "_from": "file:apollo-cache-inmemory-1.3.1-local-state-alpha.0.tgz",
      "readme": "---\ntitle: InMemoryCache\ndescription: An explanation of `apollo-cache-inmemory`\n---\n\n`apollo-cache-inmemory` is the recommended cache implementation for Apollo Client 2.0. `InMemoryCache` is a normalized data store that supports all of Apollo Client 1.0's features without the dependency on Redux.\n\nIn some instances, you may need to manipulate the cache directly, such as updating the store after a mutation. We'll cover some common use cases [here](#recipes).\n\n<h2 id=\"installation\">Installation</h2>\n\n```\nnpm install apollo-cache-inmemory --save\n```\n\nAfter installing the package, you'll want to initialize the cache constructor. Then, you can pass in your newly created cache to ApolloClient.\n\n```js\nimport { InMemoryCache } from 'apollo-cache-inmemory';\nimport { HttpLink } from 'apollo-link-http';\nimport ApolloClient from 'apollo-client';\n\nconst cache = new InMemoryCache();\n\nconst client = new ApolloClient({\n  link: new HttpLink(),\n  cache\n});\n```\n\n<h2 id=\"configuration\">Configuration</h2>\n\nThe `InMemoryCache` constructor takes an optional config object with properties to customize your cache:\n\n- addTypename: A boolean to determine whether to add __typename to the document (default: `true`)\n- dataIdFromObject: A function that takes a data object and returns a unique identifier to be used when normalizing the data in the store. Learn more about how to customize `dataIdFromObject` in the [Normalization](#normalization) section.\n- fragmentMatcher: By default, the `InMemoryCache` uses a heuristic fragment matcher. If you are using fragments on unions and interfaces, you will need to use an `IntrospectionFragmentMatcher`. For more information, please read [our guide to setting up fragment matching for unions & interfaces](https://www.apollographql.com/docs/react/advanced/fragments.html#fragment-matcher).\n\n<h2 id=\"normalization\">Normalization</h2>\n\nThe `InMemoryCache` normalizes your data before saving it to the store by splitting the result into individual objects, creating a unique identifier for each object, and storing those objects in a flattened data structure. By default, `InMemoryCache` will attempt to use the commonly found primary keys of `id` and `_id` for the unique identifier if they exist along with `__typename` on an object.\n\nIf `id` and `_id` are not specified, or if `__typename` is not specified, `InMemoryCache` will fall back to the path to the object in the query, such as `ROOT_QUERY.allPeople.0` for the first record returned on the `allPeople` root query.\n\nThis \"getter\" behavior for unique identifiers can be configured manually via the `dataIdFromObject` option passed to the `InMemoryCache` constructor, so you can pick which field is used if some of your data follows unorthodox primary key conventions.\n\nFor example, if you wanted to key off of the `key` field for all of your data, you could configure `dataIdFromObject` like so:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => object.key\n});\n```\n\nThis also allows you to use different unique identifiers for different data types by keying off of the `__typename` property attached to every object typed by GraphQL.  For example:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => {\n    switch (object.__typename) {\n      case 'foo': return object.key; // use `key` as the primary key\n      case 'bar': return object.blah; // use `blah` as the priamry key\n      default: return object.id || object._id; // fall back to `id` and `_id` for all other types\n    }\n  }\n});\n```\n\n<h2 id=\"direct\">Direct Cache Access</h2>\n\nTo interact directly with your cache, you can use the Apollo Client class methods readQuery, readFragment, writeQuery, and writeFragment. These methods are available to us via the [`DataProxy` interface](https://github.com/apollographql/apollo-client/blob/master/packages/apollo-cache/src/types/DataProxy.ts). Accessing these methods will vary slightly based on your view layer implementation. If you are using React, you can wrap your component in the `withApollo` higher order component, which will give you access to `this.props.client`. From there, you can use the methods to control your data.\n\nAny code demonstration in the following sections will assume that we have already initialized an instance of  `ApolloClient` and that we have imported the `gql` tag from `graphql-tag`.\n\n<h3 id=\"readquery\">readQuery</h3>\n\nThe `readQuery` method is very similar to the [`query` method on `ApolloClient`][] except that `readQuery` will _never_ make a request to your GraphQL server. The `query` method, on the other hand, may send a request to your server if the appropriate data is not in your cache whereas `readQuery` will throw an error if the data is not in your cache. `readQuery` will _always_ read from the cache. You can use `readQuery` by giving it a GraphQL query like so:\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo {\n      todo(id: 5) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n});\n```\n\nIf all of the data needed to fulfill this read is in Apollo Client’s normalized data cache then a data object will be returned in the shape of the query you wanted to read. If not all of the data needed to fulfill this read is in Apollo Client’s cache then an error will be thrown instead, so make sure to only read data that you know you have!\n\nYou can also pass variables into `readQuery`.\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo($id: Int!) {\n      todo(id: $id) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n  variables: {\n    id: 5,\n  },\n});\n```\n\n<h3 id=\"readfragment\">readFragment</h3>\n\nThis method allows you great flexibility around the data in your cache. Whereas `readQuery` only allowed you to read data from your root query type, `readFragment` allows you to read data from _any node you have queried_. This is incredibly powerful. You use this method as follows:\n\n```js\nconst todo = client.readFragment({\n  id: ..., // `id` is any id that could be returned by `dataIdFromObject`.\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\nThe first argument is the id of the data you want to read from the cache. That id must be a value that was returned by the `dataIdFromObject` function you defined when initializing `ApolloClient`. So for example if you initialized `ApolloClient` like so:\n\n```js\nconst client = new ApolloClient({\n  ...,\n  dataIdFromObject: object => object.id,\n});\n```\n\n…and you requested a todo before with an id of `5`, then you can read that todo out of your cache with the following:\n\n```js\nconst todo = client.readFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\n> **Note:** Most people add a `__typename` to the id in `dataIdFromObject`. If you do this then don’t forget to add the `__typename` when you are reading a fragment as well. So for example your id may be `Todo_5` and not just `5`.\n\nIf a todo with that id does not exist in the cache you will get `null` back. If a todo of that id does exist in the cache, but that todo does not have the `text` field then an error will be thrown.\n\nThe beauty of `readFragment` is that the todo could have come from anywhere! The todo could have been selected as a singleton (`{ todo(id: 5) { ... } }`), the todo could have come from a list of todos (`{ todos { ... } }`), or the todo could have come from a mutation (`mutation { createTodo { ... } }`). As long as at some point your GraphQL server gave you a todo with the provided id and fields `id`, `text`, and `completed` you can read it from the cache at any part of your code.\n\n<h3 id=\"writequery-and-writefragment\">writeQuery` and `writeFragment</h3>\n\nNot only can you read arbitrary data from the Apollo Client cache, but you can also write any data that you would like to the cache. The methods you use to do this are `writeQuery` and `writeFragment`. They will allow you to change data in your local cache, but it is important to remember that *they will not change any data on your server*. If you reload your environment then changes made with `writeQuery` and `writeFragment` will disappear.\n\nThese methods have the same signature as their `readQuery` and `readFragment` counterparts except they also require an additional `data` variable. So for example, if you wanted to update the `completed` flag locally for your todo with id `'5'` you could execute the following:\n\n```js\nclient.writeFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      completed\n    }\n  `,\n  data: {\n    completed: true,\n  },\n});\n```\n\nAny subscriber to the Apollo Client store will instantly see this update and render new UI accordingly.\n\n> **Note:** Again, remember that using `writeQuery` or `writeFragment` only changes data *locally*. If you reload your environment then changes made with these methods will no longer exist.\n\nOr if you wanted to add a new todo to a list fetched from the server, you could use `readQuery` and `writeQuery` together.\n\n```js\nconst query = gql`\n  query MyTodoAppQuery {\n    todos {\n      id\n      text\n      completed\n    }\n  }\n`;\n\nconst data = client.readQuery({ query });\n\nconst myNewTodo = {\n  id: '6',\n  text: 'Start using Apollo Client.',\n  completed: false,\n};\n\nclient.writeQuery({\n  query,\n  data: {\n    todos: [...data.todos, myNewTodo],\n  },\n});\n```\n\n<h2 id=\"recipes\">Recipes</h2>\n\nHere are some common situations where you would need to access the cache directly. If you're manipulating the cache in an interesting way and would like your example to be featured, please send in a pull request!\n\n<h3 id=\"server\">Server side rendering</h3>\n\nFirst, you will need to initialize an `InMemoryCache` on the server and create an instance of `ApolloClient`. In the initial serialized HTML payload from the server, you should include a script tag that extracts the data from the cache.\n\n```js\n`<script>\n  window.__APOLLO_STATE__=${JSON.stringify(cache.extract())}\n</script>`\n```\n\nOn the client, you can rehydrate the cache using the initial data passed from the server:\n\n```js\ncache: new Cache().restore(window.__APOLLO_STATE__)\n```\n\nIf you would like to learn more about server side rendering, please check our our more in depth guide [here].\n<!---\nTODO (PEGGY): Add link to SSR\n-->\n\n<h3 id=\"server\">Updating the cache after a mutation</h3>\n\nBeing able to read and write to the Apollo cache from anywhere in your application gives you a lot of power over your data. However, there is one place where we most often want to update our cached data: after a mutation. As such, Apollo Client has optimized the experience for updating your cache with the read and write methods after a mutation with the `update` function. Let us say that we have the following GraphQL mutation:\n\n```graphql\nmutation TodoCreateMutation($text: String!) {\n  createTodo(text: $text) {\n    id\n    text\n    completed\n  }\n}\n```\n\nWe may also have the following GraphQL query:\n\n```graphql\nquery TodoAppQuery {\n  todos {\n    id\n    text\n    completed\n  }\n}\n```\n\nAt the end of our mutation we want our query to include the new todo like we had sent our `TodoAppQuery` a second time after the mutation finished without actually sending the query. To do this we can use the `update` function provided as an option of the `client.mutate` method. To update your cache with the mutation just write code that looks like:\n\n```js\n// We assume that the GraphQL operations `TodoCreateMutation` and\n// `TodoAppQuery` have already been defined using the `gql` tag.\n\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    // Read the data from our cache for this query.\n    const data = proxy.readQuery({ query: TodoAppQuery });\n\n    // Add our todo from the mutation to the end.\n    data.todos.push(createTodo);\n\n    // Write our data back to the cache.\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nThe first `proxy` argument is an instance of [`DataProxy`][] has the same four methods that we just learned exist on the Apollo Client: `readQuery`, `readFragment`, `writeQuery`, and `writeFragment`. The reason we call them on a `proxy` object here instead of on our `client` instance is that we can easily apply optimistic updates (which we will demonstrate in a bit). The `proxy` object also provides an isolated transaction which shields you from any other mutations going on at the same time, and the `proxy` object also batches writes together until the very end.\n\nIf you provide an `optimisticResponse` option to the mutation then the `update` function will be run twice. Once immediately after you call `client.mutate` with the data from `optimisticResponse`. After the mutation successfully executes against the server the changes made in the first call to `update` will be rolled back and `update` will be called with the *actual* data returned by the mutation and not just the optimistic response.\n\nPutting it all together:\n\n```js\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  optimisticResponse: {\n    id: -1, // -1 is a temporary id for the optimistic response.\n    text,\n    completed: false,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    const data = proxy.readQuery({ query: TodoAppQuery });\n    data.todos.push(createTodo);\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nAs you can see the `update` function on `client.mutate` provides extra change management functionality specific to the use case of a mutation while still providing you the powerful data control APIs that are available on `client`.\n\nThe `update` function is not a good place for side-effects as it may be called multiple times. Also, you may not call any of the methods on `proxy` asynchronously.\n\n",
      "readmeFilename": "README.md",
      "_id": "apollo-cache-inmemory@1.3.1-local-state-alpha.0",
      "_npmVersion": "6.4.1",
      "_nodeVersion": "8.12.0",
      "_npmUser": {
        "name": "apollo-bot",
        "email": "npm@apollographql.com"
      },
      "dist": {
        "integrity": "sha512-+kv+2YkPUy99DLi5lQqPiAunMXsvKTVBZnENNEGGRlYpNmfna6Yvt6JS5Ma5ChpaOK6jJRoYBoL1CkdeMI6FuQ==",
        "shasum": "fd76d9225298d1132df8080c2c76d4304f4b97d0",
        "tarball": "https://registry.npmjs.org/apollo-cache-inmemory/-/apollo-cache-inmemory-1.3.1-local-state-alpha.0.tgz",
        "fileCount": 84,
        "unpackedSize": 510406,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJbtkzTCRA9TVsSAnZWagAAILcP+QDgIjXQ2Tw5qFv74VMt\nlqM2K2hN/ZfJ69W+7gKH6ZoMgkcO1q40ujUgTrptjhp90pO7mTmMRPgaOhJp\nwSvk+nB7h/2mcP9yfuIMqmIjOFX8Yto6jLita4M/Osa/AvK6y+DpddymdKJU\nXz3Js3y6tdSVtHDAzu2I28+TmJdNFEvmmKLc7eqe33v+9CsuXje5RxAZWmYa\n4dv2Xa8IxqWxKkkvRHDK4sSRRXSQh4xgeaWB1uwz/BxxllOEjJVHgKpyY47V\nVCb90zUq07PkpDfuC6fEF7Jsh9cTJbgoSF0D0neIyRfZxs4BUrxiuEvjB0gj\n9Qhr+25enH+rgbp0ka4puBShVjJpz47uewgL6k6lTaNOWymULmUVxpeN5tq3\nouoCb7OqcwubWNBzqYZ0AQaHpT/gHHjSKot0YZRnntUQBS9LSNLMVxm3msws\nlG29VvKgtU/TaAaTXjLHKRgQNvjxCF+Kb+yIte2EK9Ur7VnebODaDQZR5yqE\nH6V7l4J0Y0MwAsXUWSp9mg5hqsb7Wf3AX8UfVjYnbolM5rC94gA9XtSCHUDZ\nAHGJOU4wsGi1jbw2AWJM7NgwzErNx8ItN6NSp94U/+mmvOINaMaDQnowyWc6\nIdUy+IDozbiZFgFgz7/ys5uRKb3R+NASDaZgnUSiOcZfXzMYurr9nALG4tbo\nq870\r\n=V2zK\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEYCIQDoxaGnF9vTICDERmVPilNFxkm/CPjwrVjTS2q7NyH7xQIhAOK2niwpEL5thYEjfwJdYMvZukcNtyQpsOsxIxphUCW5"
          }
        ]
      },
      "maintainers": [
        {
          "email": "npm@apollographql.com",
          "name": "apollo-bot"
        },
        {
          "email": "ben@benjamn.com",
          "name": "benjamn"
        },
        {
          "email": "james@meteor.com",
          "name": "jbaxleyiii"
        },
        {
          "email": "peggyrayzis@gmail.com",
          "name": "peggyrayzis"
        }
      ],
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/apollo-cache-inmemory_1.3.1-local-state-alpha.0_1538673874587_0.9946557863013616"
      },
      "_hasShrinkwrap": false
    },
    "1.3.1-local-state-alpha.1": {
      "name": "apollo-cache-inmemory",
      "version": "1.3.1-local-state-alpha.1",
      "description": "Core abstract of Caching layer for Apollo Client",
      "author": {
        "name": "James Baxley",
        "email": "james@meteor.com"
      },
      "contributors": [
        {
          "name": "James Baxley",
          "email": "james@meteor.com"
        },
        {
          "name": "Jonas Helfer",
          "email": "jonas@helfer.email"
        },
        {
          "name": "Sashko Stubailo",
          "email": "sashko@stubailo.com"
        },
        {
          "name": "James Burgess",
          "email": "jamesmillerburgess@gmail.com"
        },
        {
          "name": "Bazyli Brzóska",
          "email": "bazyli.brzoska@gmail.com"
        }
      ],
      "license": "MIT",
      "main": "./lib/bundle.umd.js",
      "module": "./lib/index.js",
      "jsnext:main": "./lib/index.js",
      "typings": "./lib/index.d.ts",
      "sideEffects": false,
      "repository": {
        "type": "git",
        "url": "git+https://github.com/apollographql/apollo-client.git"
      },
      "bugs": {
        "url": "https://github.com/apollographql/apollo-client/issues"
      },
      "homepage": "https://github.com/apollographql/apollo-client#readme",
      "scripts": {
        "prepare": "npm run build",
        "coverage": "jest --coverage",
        "test": "jest",
        "lint": "tslint -c \"../../config/tslint.json\" -p tsconfig.json src/*.ts",
        "prebuild": "npm run clean",
        "build": "tsc -p .",
        "postbuild": "npm run bundle",
        "bundle": "../../node_modules/rollup/bin/rollup -c rollup.config.js",
        "watch": "tsc -w -p .",
        "clean": "rm -rf coverage/* && rm -rf lib/*",
        "prepublishOnly": "npm run build",
        "minify": "../../node_modules/uglify-js/bin/uglifyjs -c -m -o ./lib/bundle.min.js -- ./lib/bundle.umd.js",
        "filesize": "npm run minify"
      },
      "dependencies": {
        "apollo-cache": "^1.1.18-local-state-alpha.1",
        "apollo-utilities": "^1.0.22-local-state-alpha.1",
        "optimism": "^0.6.6"
      },
      "peerDependencies": {
        "graphql": "0.11.7 || ^0.12.0 || ^0.13.0"
      },
      "jest": {
        "transform": {
          ".(ts|tsx)": "ts-jest"
        },
        "testRegex": "(/__tests__/.*|\\.(test|spec))\\.(ts|tsx|js)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "json"
        ],
        "testURL": "http://localhost"
      },
      "gitHead": "492967ff84b67a125dd871e59e5f00ea96fd8bab",
      "_resolved": "",
      "_integrity": "",
      "_from": "file:apollo-cache-inmemory-1.3.1-local-state-alpha.1.tgz",
      "readme": "---\ntitle: InMemoryCache\ndescription: An explanation of `apollo-cache-inmemory`\n---\n\n`apollo-cache-inmemory` is the recommended cache implementation for Apollo Client 2.0. `InMemoryCache` is a normalized data store that supports all of Apollo Client 1.0's features without the dependency on Redux.\n\nIn some instances, you may need to manipulate the cache directly, such as updating the store after a mutation. We'll cover some common use cases [here](#recipes).\n\n<h2 id=\"installation\">Installation</h2>\n\n```\nnpm install apollo-cache-inmemory --save\n```\n\nAfter installing the package, you'll want to initialize the cache constructor. Then, you can pass in your newly created cache to ApolloClient.\n\n```js\nimport { InMemoryCache } from 'apollo-cache-inmemory';\nimport { HttpLink } from 'apollo-link-http';\nimport ApolloClient from 'apollo-client';\n\nconst cache = new InMemoryCache();\n\nconst client = new ApolloClient({\n  link: new HttpLink(),\n  cache\n});\n```\n\n<h2 id=\"configuration\">Configuration</h2>\n\nThe `InMemoryCache` constructor takes an optional config object with properties to customize your cache:\n\n- addTypename: A boolean to determine whether to add __typename to the document (default: `true`)\n- dataIdFromObject: A function that takes a data object and returns a unique identifier to be used when normalizing the data in the store. Learn more about how to customize `dataIdFromObject` in the [Normalization](#normalization) section.\n- fragmentMatcher: By default, the `InMemoryCache` uses a heuristic fragment matcher. If you are using fragments on unions and interfaces, you will need to use an `IntrospectionFragmentMatcher`. For more information, please read [our guide to setting up fragment matching for unions & interfaces](https://www.apollographql.com/docs/react/advanced/fragments.html#fragment-matcher).\n\n<h2 id=\"normalization\">Normalization</h2>\n\nThe `InMemoryCache` normalizes your data before saving it to the store by splitting the result into individual objects, creating a unique identifier for each object, and storing those objects in a flattened data structure. By default, `InMemoryCache` will attempt to use the commonly found primary keys of `id` and `_id` for the unique identifier if they exist along with `__typename` on an object.\n\nIf `id` and `_id` are not specified, or if `__typename` is not specified, `InMemoryCache` will fall back to the path to the object in the query, such as `ROOT_QUERY.allPeople.0` for the first record returned on the `allPeople` root query.\n\nThis \"getter\" behavior for unique identifiers can be configured manually via the `dataIdFromObject` option passed to the `InMemoryCache` constructor, so you can pick which field is used if some of your data follows unorthodox primary key conventions.\n\nFor example, if you wanted to key off of the `key` field for all of your data, you could configure `dataIdFromObject` like so:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => object.key\n});\n```\n\nThis also allows you to use different unique identifiers for different data types by keying off of the `__typename` property attached to every object typed by GraphQL.  For example:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => {\n    switch (object.__typename) {\n      case 'foo': return object.key; // use `key` as the primary key\n      case 'bar': return object.blah; // use `blah` as the priamry key\n      default: return object.id || object._id; // fall back to `id` and `_id` for all other types\n    }\n  }\n});\n```\n\n<h2 id=\"direct\">Direct Cache Access</h2>\n\nTo interact directly with your cache, you can use the Apollo Client class methods readQuery, readFragment, writeQuery, and writeFragment. These methods are available to us via the [`DataProxy` interface](https://github.com/apollographql/apollo-client/blob/master/packages/apollo-cache/src/types/DataProxy.ts). Accessing these methods will vary slightly based on your view layer implementation. If you are using React, you can wrap your component in the `withApollo` higher order component, which will give you access to `this.props.client`. From there, you can use the methods to control your data.\n\nAny code demonstration in the following sections will assume that we have already initialized an instance of  `ApolloClient` and that we have imported the `gql` tag from `graphql-tag`.\n\n<h3 id=\"readquery\">readQuery</h3>\n\nThe `readQuery` method is very similar to the [`query` method on `ApolloClient`][] except that `readQuery` will _never_ make a request to your GraphQL server. The `query` method, on the other hand, may send a request to your server if the appropriate data is not in your cache whereas `readQuery` will throw an error if the data is not in your cache. `readQuery` will _always_ read from the cache. You can use `readQuery` by giving it a GraphQL query like so:\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo {\n      todo(id: 5) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n});\n```\n\nIf all of the data needed to fulfill this read is in Apollo Client’s normalized data cache then a data object will be returned in the shape of the query you wanted to read. If not all of the data needed to fulfill this read is in Apollo Client’s cache then an error will be thrown instead, so make sure to only read data that you know you have!\n\nYou can also pass variables into `readQuery`.\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo($id: Int!) {\n      todo(id: $id) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n  variables: {\n    id: 5,\n  },\n});\n```\n\n<h3 id=\"readfragment\">readFragment</h3>\n\nThis method allows you great flexibility around the data in your cache. Whereas `readQuery` only allowed you to read data from your root query type, `readFragment` allows you to read data from _any node you have queried_. This is incredibly powerful. You use this method as follows:\n\n```js\nconst todo = client.readFragment({\n  id: ..., // `id` is any id that could be returned by `dataIdFromObject`.\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\nThe first argument is the id of the data you want to read from the cache. That id must be a value that was returned by the `dataIdFromObject` function you defined when initializing `ApolloClient`. So for example if you initialized `ApolloClient` like so:\n\n```js\nconst client = new ApolloClient({\n  ...,\n  dataIdFromObject: object => object.id,\n});\n```\n\n…and you requested a todo before with an id of `5`, then you can read that todo out of your cache with the following:\n\n```js\nconst todo = client.readFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\n> **Note:** Most people add a `__typename` to the id in `dataIdFromObject`. If you do this then don’t forget to add the `__typename` when you are reading a fragment as well. So for example your id may be `Todo_5` and not just `5`.\n\nIf a todo with that id does not exist in the cache you will get `null` back. If a todo of that id does exist in the cache, but that todo does not have the `text` field then an error will be thrown.\n\nThe beauty of `readFragment` is that the todo could have come from anywhere! The todo could have been selected as a singleton (`{ todo(id: 5) { ... } }`), the todo could have come from a list of todos (`{ todos { ... } }`), or the todo could have come from a mutation (`mutation { createTodo { ... } }`). As long as at some point your GraphQL server gave you a todo with the provided id and fields `id`, `text`, and `completed` you can read it from the cache at any part of your code.\n\n<h3 id=\"writequery-and-writefragment\">writeQuery` and `writeFragment</h3>\n\nNot only can you read arbitrary data from the Apollo Client cache, but you can also write any data that you would like to the cache. The methods you use to do this are `writeQuery` and `writeFragment`. They will allow you to change data in your local cache, but it is important to remember that *they will not change any data on your server*. If you reload your environment then changes made with `writeQuery` and `writeFragment` will disappear.\n\nThese methods have the same signature as their `readQuery` and `readFragment` counterparts except they also require an additional `data` variable. So for example, if you wanted to update the `completed` flag locally for your todo with id `'5'` you could execute the following:\n\n```js\nclient.writeFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      completed\n    }\n  `,\n  data: {\n    completed: true,\n  },\n});\n```\n\nAny subscriber to the Apollo Client store will instantly see this update and render new UI accordingly.\n\n> **Note:** Again, remember that using `writeQuery` or `writeFragment` only changes data *locally*. If you reload your environment then changes made with these methods will no longer exist.\n\nOr if you wanted to add a new todo to a list fetched from the server, you could use `readQuery` and `writeQuery` together.\n\n```js\nconst query = gql`\n  query MyTodoAppQuery {\n    todos {\n      id\n      text\n      completed\n    }\n  }\n`;\n\nconst data = client.readQuery({ query });\n\nconst myNewTodo = {\n  id: '6',\n  text: 'Start using Apollo Client.',\n  completed: false,\n};\n\nclient.writeQuery({\n  query,\n  data: {\n    todos: [...data.todos, myNewTodo],\n  },\n});\n```\n\n<h2 id=\"recipes\">Recipes</h2>\n\nHere are some common situations where you would need to access the cache directly. If you're manipulating the cache in an interesting way and would like your example to be featured, please send in a pull request!\n\n<h3 id=\"server\">Server side rendering</h3>\n\nFirst, you will need to initialize an `InMemoryCache` on the server and create an instance of `ApolloClient`. In the initial serialized HTML payload from the server, you should include a script tag that extracts the data from the cache.\n\n```js\n`<script>\n  window.__APOLLO_STATE__=${JSON.stringify(cache.extract())}\n</script>`\n```\n\nOn the client, you can rehydrate the cache using the initial data passed from the server:\n\n```js\ncache: new Cache().restore(window.__APOLLO_STATE__)\n```\n\nIf you would like to learn more about server side rendering, please check our our more in depth guide [here].\n<!---\nTODO (PEGGY): Add link to SSR\n-->\n\n<h3 id=\"server\">Updating the cache after a mutation</h3>\n\nBeing able to read and write to the Apollo cache from anywhere in your application gives you a lot of power over your data. However, there is one place where we most often want to update our cached data: after a mutation. As such, Apollo Client has optimized the experience for updating your cache with the read and write methods after a mutation with the `update` function. Let us say that we have the following GraphQL mutation:\n\n```graphql\nmutation TodoCreateMutation($text: String!) {\n  createTodo(text: $text) {\n    id\n    text\n    completed\n  }\n}\n```\n\nWe may also have the following GraphQL query:\n\n```graphql\nquery TodoAppQuery {\n  todos {\n    id\n    text\n    completed\n  }\n}\n```\n\nAt the end of our mutation we want our query to include the new todo like we had sent our `TodoAppQuery` a second time after the mutation finished without actually sending the query. To do this we can use the `update` function provided as an option of the `client.mutate` method. To update your cache with the mutation just write code that looks like:\n\n```js\n// We assume that the GraphQL operations `TodoCreateMutation` and\n// `TodoAppQuery` have already been defined using the `gql` tag.\n\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    // Read the data from our cache for this query.\n    const data = proxy.readQuery({ query: TodoAppQuery });\n\n    // Add our todo from the mutation to the end.\n    data.todos.push(createTodo);\n\n    // Write our data back to the cache.\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nThe first `proxy` argument is an instance of [`DataProxy`][] has the same four methods that we just learned exist on the Apollo Client: `readQuery`, `readFragment`, `writeQuery`, and `writeFragment`. The reason we call them on a `proxy` object here instead of on our `client` instance is that we can easily apply optimistic updates (which we will demonstrate in a bit). The `proxy` object also provides an isolated transaction which shields you from any other mutations going on at the same time, and the `proxy` object also batches writes together until the very end.\n\nIf you provide an `optimisticResponse` option to the mutation then the `update` function will be run twice. Once immediately after you call `client.mutate` with the data from `optimisticResponse`. After the mutation successfully executes against the server the changes made in the first call to `update` will be rolled back and `update` will be called with the *actual* data returned by the mutation and not just the optimistic response.\n\nPutting it all together:\n\n```js\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  optimisticResponse: {\n    id: -1, // -1 is a temporary id for the optimistic response.\n    text,\n    completed: false,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    const data = proxy.readQuery({ query: TodoAppQuery });\n    data.todos.push(createTodo);\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nAs you can see the `update` function on `client.mutate` provides extra change management functionality specific to the use case of a mutation while still providing you the powerful data control APIs that are available on `client`.\n\nThe `update` function is not a good place for side-effects as it may be called multiple times. Also, you may not call any of the methods on `proxy` asynchronously.\n\n",
      "readmeFilename": "README.md",
      "_id": "apollo-cache-inmemory@1.3.1-local-state-alpha.1",
      "_npmVersion": "6.4.1",
      "_nodeVersion": "8.12.0",
      "_npmUser": {
        "name": "apollo-bot",
        "email": "npm@apollographql.com"
      },
      "dist": {
        "integrity": "sha512-fyyf5bWeF7ik3+CYhoNkJvr70NhZhE1NcWptmanjd2yYz3kzYcB2oD55ZheP6ihG4FlAX2vFeF56rCTZkyglfg==",
        "shasum": "590863331526bb0f93fd1d67defef25979b9d6e5",
        "tarball": "https://registry.npmjs.org/apollo-cache-inmemory/-/apollo-cache-inmemory-1.3.1-local-state-alpha.1.tgz",
        "fileCount": 84,
        "unpackedSize": 510406,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJbtlBvCRA9TVsSAnZWagAA00MQAIxqawiNoQEOH1iYERj4\nQE1iBIvU7yH8eqc1rY9Jq4ewjpZXJEH9rRcYRbYfCWbouIqbePUnjOOXvD5j\nXVLLL6h8aKYSLhp86f7PjC4hGv29d5sFeBJBeIvvggiOrP9ICiVchnrb8rk0\nUs5FoviqQ2W/pIPgS5+RLv2odRP8isqnkZz04r9G8w49APwqEiHSz8tbwfQq\nsxpMuX7odhbOADClGoFti1JyP3o0gYutd/uL21vSxXS97nqHqyl3JQSGjDdn\nVAb79f7x8siSJ7Ctw15vgkkzCPITSCbSWDigV7S65RvW+tjt+WHTIWDfPGhZ\n/LJvSaiI072fIMEZEcOBycdEMv7PITAkQIAhs1vAzgFaTf5Gz1mf+Ya1cRL6\nEnF4FrPpLaUjZ5FCs6Enhu9JVy3qSuOKdCb7Ct8A2YuoT6SzQGD6aT/Hax6I\nV85J7BRqdX8emz6KDm5KAhv5iHYwXFNmaEAb8YiUdArb6JFtZJZkl3TSEA3J\n9BCDr624q0KQfl3t+KOWS2/WRVlsEL1+AwtwA8qhoMgGxiMlX1IY2uwaALgy\ntVwAi49VJhXdEZfqcquF1AKQ1UCjmYlRhU7K6ROjXIbQVZmSwZ56I+GzAz4V\nCr5Skd6YCs89sDq0THCI3I69kiJAMqnGmUcJNP95eoWIBZpA6if3scoe4hmT\nrUi2\r\n=C3C3\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEQCIA6Fzkf8zwZm1/TF3EOPrVKF60qMRqVlJZB+iWK0tHpiAiApR4nunJnhKNSt1vqO1Ftu72JId495fJkzBOR4INoc+Q=="
          }
        ]
      },
      "maintainers": [
        {
          "email": "npm@apollographql.com",
          "name": "apollo-bot"
        },
        {
          "email": "ben@benjamn.com",
          "name": "benjamn"
        },
        {
          "email": "james@meteor.com",
          "name": "jbaxleyiii"
        },
        {
          "email": "peggyrayzis@gmail.com",
          "name": "peggyrayzis"
        }
      ],
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/apollo-cache-inmemory_1.3.1-local-state-alpha.1_1538674799072_0.45179943351679697"
      },
      "_hasShrinkwrap": false
    },
    "1.3.1-local-state-alpha.2": {
      "name": "apollo-cache-inmemory",
      "version": "1.3.1-local-state-alpha.2",
      "description": "Core abstract of Caching layer for Apollo Client",
      "author": {
        "name": "James Baxley",
        "email": "james@meteor.com"
      },
      "contributors": [
        {
          "name": "James Baxley",
          "email": "james@meteor.com"
        },
        {
          "name": "Jonas Helfer",
          "email": "jonas@helfer.email"
        },
        {
          "name": "Sashko Stubailo",
          "email": "sashko@stubailo.com"
        },
        {
          "name": "James Burgess",
          "email": "jamesmillerburgess@gmail.com"
        },
        {
          "name": "Bazyli Brzóska",
          "email": "bazyli.brzoska@gmail.com"
        }
      ],
      "license": "MIT",
      "main": "./lib/bundle.umd.js",
      "module": "./lib/index.js",
      "jsnext:main": "./lib/index.js",
      "typings": "./lib/index.d.ts",
      "sideEffects": false,
      "repository": {
        "type": "git",
        "url": "git+https://github.com/apollographql/apollo-client.git"
      },
      "bugs": {
        "url": "https://github.com/apollographql/apollo-client/issues"
      },
      "homepage": "https://github.com/apollographql/apollo-client#readme",
      "scripts": {
        "prepare": "npm run build",
        "coverage": "jest --coverage",
        "test": "jest",
        "lint": "tslint -c \"../../config/tslint.json\" -p tsconfig.json src/*.ts",
        "prebuild": "npm run clean",
        "build": "tsc -p .",
        "postbuild": "npm run bundle",
        "bundle": "../../node_modules/rollup/bin/rollup -c rollup.config.js",
        "watch": "tsc -w -p .",
        "clean": "rm -rf coverage/* && rm -rf lib/*",
        "prepublishOnly": "npm run build",
        "minify": "../../node_modules/uglify-js/bin/uglifyjs -c -m -o ./lib/bundle.min.js -- ./lib/bundle.umd.js",
        "filesize": "npm run minify"
      },
      "dependencies": {
        "apollo-cache": "^1.1.18-local-state-alpha.2",
        "apollo-utilities": "^1.0.22-local-state-alpha.2",
        "optimism": "^0.6.6"
      },
      "peerDependencies": {
        "graphql": "0.11.7 || ^0.12.0 || ^0.13.0"
      },
      "jest": {
        "transform": {
          ".(ts|tsx)": "ts-jest"
        },
        "testRegex": "(/__tests__/.*|\\.(test|spec))\\.(ts|tsx|js)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "json"
        ],
        "testURL": "http://localhost"
      },
      "gitHead": "bdb948ce7d73df51e02efdde8d866c66c5c0930c",
      "_resolved": "",
      "_integrity": "",
      "_from": "file:apollo-cache-inmemory-1.3.1-local-state-alpha.2.tgz",
      "readme": "---\ntitle: InMemoryCache\ndescription: An explanation of `apollo-cache-inmemory`\n---\n\n`apollo-cache-inmemory` is the recommended cache implementation for Apollo Client 2.0. `InMemoryCache` is a normalized data store that supports all of Apollo Client 1.0's features without the dependency on Redux.\n\nIn some instances, you may need to manipulate the cache directly, such as updating the store after a mutation. We'll cover some common use cases [here](#recipes).\n\n<h2 id=\"installation\">Installation</h2>\n\n```\nnpm install apollo-cache-inmemory --save\n```\n\nAfter installing the package, you'll want to initialize the cache constructor. Then, you can pass in your newly created cache to ApolloClient.\n\n```js\nimport { InMemoryCache } from 'apollo-cache-inmemory';\nimport { HttpLink } from 'apollo-link-http';\nimport ApolloClient from 'apollo-client';\n\nconst cache = new InMemoryCache();\n\nconst client = new ApolloClient({\n  link: new HttpLink(),\n  cache\n});\n```\n\n<h2 id=\"configuration\">Configuration</h2>\n\nThe `InMemoryCache` constructor takes an optional config object with properties to customize your cache:\n\n- addTypename: A boolean to determine whether to add __typename to the document (default: `true`)\n- dataIdFromObject: A function that takes a data object and returns a unique identifier to be used when normalizing the data in the store. Learn more about how to customize `dataIdFromObject` in the [Normalization](#normalization) section.\n- fragmentMatcher: By default, the `InMemoryCache` uses a heuristic fragment matcher. If you are using fragments on unions and interfaces, you will need to use an `IntrospectionFragmentMatcher`. For more information, please read [our guide to setting up fragment matching for unions & interfaces](https://www.apollographql.com/docs/react/advanced/fragments.html#fragment-matcher).\n\n<h2 id=\"normalization\">Normalization</h2>\n\nThe `InMemoryCache` normalizes your data before saving it to the store by splitting the result into individual objects, creating a unique identifier for each object, and storing those objects in a flattened data structure. By default, `InMemoryCache` will attempt to use the commonly found primary keys of `id` and `_id` for the unique identifier if they exist along with `__typename` on an object.\n\nIf `id` and `_id` are not specified, or if `__typename` is not specified, `InMemoryCache` will fall back to the path to the object in the query, such as `ROOT_QUERY.allPeople.0` for the first record returned on the `allPeople` root query.\n\nThis \"getter\" behavior for unique identifiers can be configured manually via the `dataIdFromObject` option passed to the `InMemoryCache` constructor, so you can pick which field is used if some of your data follows unorthodox primary key conventions.\n\nFor example, if you wanted to key off of the `key` field for all of your data, you could configure `dataIdFromObject` like so:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => object.key\n});\n```\n\nThis also allows you to use different unique identifiers for different data types by keying off of the `__typename` property attached to every object typed by GraphQL.  For example:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => {\n    switch (object.__typename) {\n      case 'foo': return object.key; // use `key` as the primary key\n      case 'bar': return object.blah; // use `blah` as the priamry key\n      default: return object.id || object._id; // fall back to `id` and `_id` for all other types\n    }\n  }\n});\n```\n\n<h2 id=\"direct\">Direct Cache Access</h2>\n\nTo interact directly with your cache, you can use the Apollo Client class methods readQuery, readFragment, writeQuery, and writeFragment. These methods are available to us via the [`DataProxy` interface](https://github.com/apollographql/apollo-client/blob/master/packages/apollo-cache/src/types/DataProxy.ts). Accessing these methods will vary slightly based on your view layer implementation. If you are using React, you can wrap your component in the `withApollo` higher order component, which will give you access to `this.props.client`. From there, you can use the methods to control your data.\n\nAny code demonstration in the following sections will assume that we have already initialized an instance of  `ApolloClient` and that we have imported the `gql` tag from `graphql-tag`.\n\n<h3 id=\"readquery\">readQuery</h3>\n\nThe `readQuery` method is very similar to the [`query` method on `ApolloClient`][] except that `readQuery` will _never_ make a request to your GraphQL server. The `query` method, on the other hand, may send a request to your server if the appropriate data is not in your cache whereas `readQuery` will throw an error if the data is not in your cache. `readQuery` will _always_ read from the cache. You can use `readQuery` by giving it a GraphQL query like so:\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo {\n      todo(id: 5) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n});\n```\n\nIf all of the data needed to fulfill this read is in Apollo Client’s normalized data cache then a data object will be returned in the shape of the query you wanted to read. If not all of the data needed to fulfill this read is in Apollo Client’s cache then an error will be thrown instead, so make sure to only read data that you know you have!\n\nYou can also pass variables into `readQuery`.\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo($id: Int!) {\n      todo(id: $id) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n  variables: {\n    id: 5,\n  },\n});\n```\n\n<h3 id=\"readfragment\">readFragment</h3>\n\nThis method allows you great flexibility around the data in your cache. Whereas `readQuery` only allowed you to read data from your root query type, `readFragment` allows you to read data from _any node you have queried_. This is incredibly powerful. You use this method as follows:\n\n```js\nconst todo = client.readFragment({\n  id: ..., // `id` is any id that could be returned by `dataIdFromObject`.\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\nThe first argument is the id of the data you want to read from the cache. That id must be a value that was returned by the `dataIdFromObject` function you defined when initializing `ApolloClient`. So for example if you initialized `ApolloClient` like so:\n\n```js\nconst client = new ApolloClient({\n  ...,\n  dataIdFromObject: object => object.id,\n});\n```\n\n…and you requested a todo before with an id of `5`, then you can read that todo out of your cache with the following:\n\n```js\nconst todo = client.readFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\n> **Note:** Most people add a `__typename` to the id in `dataIdFromObject`. If you do this then don’t forget to add the `__typename` when you are reading a fragment as well. So for example your id may be `Todo_5` and not just `5`.\n\nIf a todo with that id does not exist in the cache you will get `null` back. If a todo of that id does exist in the cache, but that todo does not have the `text` field then an error will be thrown.\n\nThe beauty of `readFragment` is that the todo could have come from anywhere! The todo could have been selected as a singleton (`{ todo(id: 5) { ... } }`), the todo could have come from a list of todos (`{ todos { ... } }`), or the todo could have come from a mutation (`mutation { createTodo { ... } }`). As long as at some point your GraphQL server gave you a todo with the provided id and fields `id`, `text`, and `completed` you can read it from the cache at any part of your code.\n\n<h3 id=\"writequery-and-writefragment\">writeQuery` and `writeFragment</h3>\n\nNot only can you read arbitrary data from the Apollo Client cache, but you can also write any data that you would like to the cache. The methods you use to do this are `writeQuery` and `writeFragment`. They will allow you to change data in your local cache, but it is important to remember that *they will not change any data on your server*. If you reload your environment then changes made with `writeQuery` and `writeFragment` will disappear.\n\nThese methods have the same signature as their `readQuery` and `readFragment` counterparts except they also require an additional `data` variable. So for example, if you wanted to update the `completed` flag locally for your todo with id `'5'` you could execute the following:\n\n```js\nclient.writeFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      completed\n    }\n  `,\n  data: {\n    completed: true,\n  },\n});\n```\n\nAny subscriber to the Apollo Client store will instantly see this update and render new UI accordingly.\n\n> **Note:** Again, remember that using `writeQuery` or `writeFragment` only changes data *locally*. If you reload your environment then changes made with these methods will no longer exist.\n\nOr if you wanted to add a new todo to a list fetched from the server, you could use `readQuery` and `writeQuery` together.\n\n```js\nconst query = gql`\n  query MyTodoAppQuery {\n    todos {\n      id\n      text\n      completed\n    }\n  }\n`;\n\nconst data = client.readQuery({ query });\n\nconst myNewTodo = {\n  id: '6',\n  text: 'Start using Apollo Client.',\n  completed: false,\n};\n\nclient.writeQuery({\n  query,\n  data: {\n    todos: [...data.todos, myNewTodo],\n  },\n});\n```\n\n<h2 id=\"recipes\">Recipes</h2>\n\nHere are some common situations where you would need to access the cache directly. If you're manipulating the cache in an interesting way and would like your example to be featured, please send in a pull request!\n\n<h3 id=\"server\">Server side rendering</h3>\n\nFirst, you will need to initialize an `InMemoryCache` on the server and create an instance of `ApolloClient`. In the initial serialized HTML payload from the server, you should include a script tag that extracts the data from the cache.\n\n```js\n`<script>\n  window.__APOLLO_STATE__=${JSON.stringify(cache.extract())}\n</script>`\n```\n\nOn the client, you can rehydrate the cache using the initial data passed from the server:\n\n```js\ncache: new Cache().restore(window.__APOLLO_STATE__)\n```\n\nIf you would like to learn more about server side rendering, please check our our more in depth guide [here].\n<!---\nTODO (PEGGY): Add link to SSR\n-->\n\n<h3 id=\"server\">Updating the cache after a mutation</h3>\n\nBeing able to read and write to the Apollo cache from anywhere in your application gives you a lot of power over your data. However, there is one place where we most often want to update our cached data: after a mutation. As such, Apollo Client has optimized the experience for updating your cache with the read and write methods after a mutation with the `update` function. Let us say that we have the following GraphQL mutation:\n\n```graphql\nmutation TodoCreateMutation($text: String!) {\n  createTodo(text: $text) {\n    id\n    text\n    completed\n  }\n}\n```\n\nWe may also have the following GraphQL query:\n\n```graphql\nquery TodoAppQuery {\n  todos {\n    id\n    text\n    completed\n  }\n}\n```\n\nAt the end of our mutation we want our query to include the new todo like we had sent our `TodoAppQuery` a second time after the mutation finished without actually sending the query. To do this we can use the `update` function provided as an option of the `client.mutate` method. To update your cache with the mutation just write code that looks like:\n\n```js\n// We assume that the GraphQL operations `TodoCreateMutation` and\n// `TodoAppQuery` have already been defined using the `gql` tag.\n\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    // Read the data from our cache for this query.\n    const data = proxy.readQuery({ query: TodoAppQuery });\n\n    // Add our todo from the mutation to the end.\n    data.todos.push(createTodo);\n\n    // Write our data back to the cache.\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nThe first `proxy` argument is an instance of [`DataProxy`][] has the same four methods that we just learned exist on the Apollo Client: `readQuery`, `readFragment`, `writeQuery`, and `writeFragment`. The reason we call them on a `proxy` object here instead of on our `client` instance is that we can easily apply optimistic updates (which we will demonstrate in a bit). The `proxy` object also provides an isolated transaction which shields you from any other mutations going on at the same time, and the `proxy` object also batches writes together until the very end.\n\nIf you provide an `optimisticResponse` option to the mutation then the `update` function will be run twice. Once immediately after you call `client.mutate` with the data from `optimisticResponse`. After the mutation successfully executes against the server the changes made in the first call to `update` will be rolled back and `update` will be called with the *actual* data returned by the mutation and not just the optimistic response.\n\nPutting it all together:\n\n```js\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  optimisticResponse: {\n    id: -1, // -1 is a temporary id for the optimistic response.\n    text,\n    completed: false,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    const data = proxy.readQuery({ query: TodoAppQuery });\n    data.todos.push(createTodo);\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nAs you can see the `update` function on `client.mutate` provides extra change management functionality specific to the use case of a mutation while still providing you the powerful data control APIs that are available on `client`.\n\nThe `update` function is not a good place for side-effects as it may be called multiple times. Also, you may not call any of the methods on `proxy` asynchronously.\n\n",
      "readmeFilename": "README.md",
      "_id": "apollo-cache-inmemory@1.3.1-local-state-alpha.2",
      "_npmVersion": "6.4.1",
      "_nodeVersion": "8.12.0",
      "_npmUser": {
        "name": "apollo-bot",
        "email": "npm@apollographql.com"
      },
      "dist": {
        "integrity": "sha512-KiHavXYDaS4o3EddXzLL0NtHYdoK4tyayRYa4Cr/3jsVjFpUvZ9wHrkaH0yjFYz60p8NMjKpuI5Ph1Q2DTs9zw==",
        "shasum": "0daafb46327d981f60c457e7f79a4e58b22717b0",
        "tarball": "https://registry.npmjs.org/apollo-cache-inmemory/-/apollo-cache-inmemory-1.3.1-local-state-alpha.2.tgz",
        "fileCount": 84,
        "unpackedSize": 510406,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJbttDkCRA9TVsSAnZWagAA1QwP/jinGs581WXxLvX4npS8\n8FQnLwDQJJlmRw9EBK3eUvMLX4FWu04u+yxEDU2UQhZL/E5O3CfteyBx9+1J\n9ty9/6wn5T4F0snlH9oprfxxgDbx8ajtfX17JnJAOuh+pzIf3k9B5cCVp00A\nusUNZxreyN5lI2sih8tZ+sEGnQ2agW85C1dX+7r5u9Jyp3z8VpDIo4gTmkNO\nqCm8fcwpSZE2F4AGH4wBI0369vpAVPNNKS+BMWbAc5OKRgHe3ROBtQv/YTIZ\nftYxRMHuWu0c7BjR24FMjdXUJwn9jmnEW9Mu9VjQlvFnyoVd35giNZFhMmJi\n4jCUX/7n44qenXy8bq4wIC1WulrbHNq7LwrTGMHd717z9lEZ9DlqJz3EXFi4\nnJFDlikmSBK/aHsGTdU7rk23TESujbNk6naLsLBentdJvvC1kDeKkd27EzjS\ncSybCZ9LYlIGsAI3KuWm0SMG0Q5EKyjwk8vXR3f2s1SNFaTC+0sf4RL16tAF\nZDH7kJAn6i3RMlJ2X+19u6p7DRGFb5Mf2zRBTpqpoMX+4n0bacsF+z5dbUzf\nKvjUYFi985jSlh/YxqJCMC89129bdAz0OVKP0eFbUdGOW9Z+AA+btKKLKdYQ\nWXyDT2aqOsgmCXkXnyPbSEFwyL1GCZh9Q+vHvuqNxWDGTyB1ok/8ZX0Zn8Xe\naImE\r\n=oerG\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEYCIQDNKo8CB5cqO8RpSSnDZ7CBM0tH2RiFqi6AoVCk5wZfNAIhAIpbmRHJn0nghcUDCTWQ8+ZQGQh7NB3799HTXjhX1/8d"
          }
        ]
      },
      "maintainers": [
        {
          "email": "npm@apollographql.com",
          "name": "apollo-bot"
        },
        {
          "email": "ben@benjamn.com",
          "name": "benjamn"
        },
        {
          "email": "james@meteor.com",
          "name": "jbaxleyiii"
        },
        {
          "email": "peggyrayzis@gmail.com",
          "name": "peggyrayzis"
        }
      ],
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/apollo-cache-inmemory_1.3.1-local-state-alpha.2_1538707683668_0.025477329071576182"
      },
      "_hasShrinkwrap": false
    },
    "1.3.1-local-state-alpha.3": {
      "name": "apollo-cache-inmemory",
      "version": "1.3.1-local-state-alpha.3",
      "description": "Core abstract of Caching layer for Apollo Client",
      "author": {
        "name": "James Baxley",
        "email": "james@meteor.com"
      },
      "contributors": [
        {
          "name": "James Baxley",
          "email": "james@meteor.com"
        },
        {
          "name": "Jonas Helfer",
          "email": "jonas@helfer.email"
        },
        {
          "name": "Sashko Stubailo",
          "email": "sashko@stubailo.com"
        },
        {
          "name": "James Burgess",
          "email": "jamesmillerburgess@gmail.com"
        },
        {
          "name": "Bazyli Brzóska",
          "email": "bazyli.brzoska@gmail.com"
        }
      ],
      "license": "MIT",
      "main": "./lib/bundle.umd.js",
      "module": "./lib/index.js",
      "jsnext:main": "./lib/index.js",
      "typings": "./lib/index.d.ts",
      "sideEffects": false,
      "repository": {
        "type": "git",
        "url": "git+https://github.com/apollographql/apollo-client.git"
      },
      "bugs": {
        "url": "https://github.com/apollographql/apollo-client/issues"
      },
      "homepage": "https://github.com/apollographql/apollo-client#readme",
      "scripts": {
        "prepare": "npm run build",
        "coverage": "jest --coverage",
        "test": "jest",
        "lint": "tslint -c \"../../config/tslint.json\" -p tsconfig.json src/*.ts",
        "prebuild": "npm run clean",
        "build": "tsc -p .",
        "postbuild": "npm run bundle",
        "bundle": "../../node_modules/rollup/bin/rollup -c rollup.config.js",
        "watch": "tsc -w -p .",
        "clean": "rm -rf coverage/* && rm -rf lib/*",
        "prepublishOnly": "npm run build",
        "minify": "../../node_modules/uglify-js/bin/uglifyjs -c -m -o ./lib/bundle.min.js -- ./lib/bundle.umd.js",
        "filesize": "npm run minify"
      },
      "dependencies": {
        "apollo-cache": "^1.1.18-local-state-alpha.3",
        "apollo-utilities": "^1.0.22-local-state-alpha.3",
        "optimism": "^0.6.6"
      },
      "peerDependencies": {
        "graphql": "0.11.7 || ^0.12.0 || ^0.13.0"
      },
      "jest": {
        "transform": {
          ".(ts|tsx)": "ts-jest"
        },
        "testRegex": "(/__tests__/.*|\\.(test|spec))\\.(ts|tsx|js)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "json"
        ],
        "testURL": "http://localhost"
      },
      "gitHead": "c82d181fdda51843bebf97f11c23c46b60a9e8aa",
      "_resolved": "",
      "_integrity": "",
      "_from": "file:apollo-cache-inmemory-1.3.1-local-state-alpha.3.tgz",
      "readme": "---\ntitle: InMemoryCache\ndescription: An explanation of `apollo-cache-inmemory`\n---\n\n`apollo-cache-inmemory` is the recommended cache implementation for Apollo Client 2.0. `InMemoryCache` is a normalized data store that supports all of Apollo Client 1.0's features without the dependency on Redux.\n\nIn some instances, you may need to manipulate the cache directly, such as updating the store after a mutation. We'll cover some common use cases [here](#recipes).\n\n<h2 id=\"installation\">Installation</h2>\n\n```\nnpm install apollo-cache-inmemory --save\n```\n\nAfter installing the package, you'll want to initialize the cache constructor. Then, you can pass in your newly created cache to ApolloClient.\n\n```js\nimport { InMemoryCache } from 'apollo-cache-inmemory';\nimport { HttpLink } from 'apollo-link-http';\nimport ApolloClient from 'apollo-client';\n\nconst cache = new InMemoryCache();\n\nconst client = new ApolloClient({\n  link: new HttpLink(),\n  cache\n});\n```\n\n<h2 id=\"configuration\">Configuration</h2>\n\nThe `InMemoryCache` constructor takes an optional config object with properties to customize your cache:\n\n- addTypename: A boolean to determine whether to add __typename to the document (default: `true`)\n- dataIdFromObject: A function that takes a data object and returns a unique identifier to be used when normalizing the data in the store. Learn more about how to customize `dataIdFromObject` in the [Normalization](#normalization) section.\n- fragmentMatcher: By default, the `InMemoryCache` uses a heuristic fragment matcher. If you are using fragments on unions and interfaces, you will need to use an `IntrospectionFragmentMatcher`. For more information, please read [our guide to setting up fragment matching for unions & interfaces](https://www.apollographql.com/docs/react/advanced/fragments.html#fragment-matcher).\n\n<h2 id=\"normalization\">Normalization</h2>\n\nThe `InMemoryCache` normalizes your data before saving it to the store by splitting the result into individual objects, creating a unique identifier for each object, and storing those objects in a flattened data structure. By default, `InMemoryCache` will attempt to use the commonly found primary keys of `id` and `_id` for the unique identifier if they exist along with `__typename` on an object.\n\nIf `id` and `_id` are not specified, or if `__typename` is not specified, `InMemoryCache` will fall back to the path to the object in the query, such as `ROOT_QUERY.allPeople.0` for the first record returned on the `allPeople` root query.\n\nThis \"getter\" behavior for unique identifiers can be configured manually via the `dataIdFromObject` option passed to the `InMemoryCache` constructor, so you can pick which field is used if some of your data follows unorthodox primary key conventions.\n\nFor example, if you wanted to key off of the `key` field for all of your data, you could configure `dataIdFromObject` like so:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => object.key\n});\n```\n\nThis also allows you to use different unique identifiers for different data types by keying off of the `__typename` property attached to every object typed by GraphQL.  For example:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => {\n    switch (object.__typename) {\n      case 'foo': return object.key; // use `key` as the primary key\n      case 'bar': return object.blah; // use `blah` as the priamry key\n      default: return object.id || object._id; // fall back to `id` and `_id` for all other types\n    }\n  }\n});\n```\n\n<h2 id=\"direct\">Direct Cache Access</h2>\n\nTo interact directly with your cache, you can use the Apollo Client class methods readQuery, readFragment, writeQuery, and writeFragment. These methods are available to us via the [`DataProxy` interface](https://github.com/apollographql/apollo-client/blob/master/packages/apollo-cache/src/types/DataProxy.ts). Accessing these methods will vary slightly based on your view layer implementation. If you are using React, you can wrap your component in the `withApollo` higher order component, which will give you access to `this.props.client`. From there, you can use the methods to control your data.\n\nAny code demonstration in the following sections will assume that we have already initialized an instance of  `ApolloClient` and that we have imported the `gql` tag from `graphql-tag`.\n\n<h3 id=\"readquery\">readQuery</h3>\n\nThe `readQuery` method is very similar to the [`query` method on `ApolloClient`][] except that `readQuery` will _never_ make a request to your GraphQL server. The `query` method, on the other hand, may send a request to your server if the appropriate data is not in your cache whereas `readQuery` will throw an error if the data is not in your cache. `readQuery` will _always_ read from the cache. You can use `readQuery` by giving it a GraphQL query like so:\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo {\n      todo(id: 5) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n});\n```\n\nIf all of the data needed to fulfill this read is in Apollo Client’s normalized data cache then a data object will be returned in the shape of the query you wanted to read. If not all of the data needed to fulfill this read is in Apollo Client’s cache then an error will be thrown instead, so make sure to only read data that you know you have!\n\nYou can also pass variables into `readQuery`.\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo($id: Int!) {\n      todo(id: $id) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n  variables: {\n    id: 5,\n  },\n});\n```\n\n<h3 id=\"readfragment\">readFragment</h3>\n\nThis method allows you great flexibility around the data in your cache. Whereas `readQuery` only allowed you to read data from your root query type, `readFragment` allows you to read data from _any node you have queried_. This is incredibly powerful. You use this method as follows:\n\n```js\nconst todo = client.readFragment({\n  id: ..., // `id` is any id that could be returned by `dataIdFromObject`.\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\nThe first argument is the id of the data you want to read from the cache. That id must be a value that was returned by the `dataIdFromObject` function you defined when initializing `ApolloClient`. So for example if you initialized `ApolloClient` like so:\n\n```js\nconst client = new ApolloClient({\n  ...,\n  dataIdFromObject: object => object.id,\n});\n```\n\n…and you requested a todo before with an id of `5`, then you can read that todo out of your cache with the following:\n\n```js\nconst todo = client.readFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\n> **Note:** Most people add a `__typename` to the id in `dataIdFromObject`. If you do this then don’t forget to add the `__typename` when you are reading a fragment as well. So for example your id may be `Todo_5` and not just `5`.\n\nIf a todo with that id does not exist in the cache you will get `null` back. If a todo of that id does exist in the cache, but that todo does not have the `text` field then an error will be thrown.\n\nThe beauty of `readFragment` is that the todo could have come from anywhere! The todo could have been selected as a singleton (`{ todo(id: 5) { ... } }`), the todo could have come from a list of todos (`{ todos { ... } }`), or the todo could have come from a mutation (`mutation { createTodo { ... } }`). As long as at some point your GraphQL server gave you a todo with the provided id and fields `id`, `text`, and `completed` you can read it from the cache at any part of your code.\n\n<h3 id=\"writequery-and-writefragment\">writeQuery` and `writeFragment</h3>\n\nNot only can you read arbitrary data from the Apollo Client cache, but you can also write any data that you would like to the cache. The methods you use to do this are `writeQuery` and `writeFragment`. They will allow you to change data in your local cache, but it is important to remember that *they will not change any data on your server*. If you reload your environment then changes made with `writeQuery` and `writeFragment` will disappear.\n\nThese methods have the same signature as their `readQuery` and `readFragment` counterparts except they also require an additional `data` variable. So for example, if you wanted to update the `completed` flag locally for your todo with id `'5'` you could execute the following:\n\n```js\nclient.writeFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      completed\n    }\n  `,\n  data: {\n    completed: true,\n  },\n});\n```\n\nAny subscriber to the Apollo Client store will instantly see this update and render new UI accordingly.\n\n> **Note:** Again, remember that using `writeQuery` or `writeFragment` only changes data *locally*. If you reload your environment then changes made with these methods will no longer exist.\n\nOr if you wanted to add a new todo to a list fetched from the server, you could use `readQuery` and `writeQuery` together.\n\n```js\nconst query = gql`\n  query MyTodoAppQuery {\n    todos {\n      id\n      text\n      completed\n    }\n  }\n`;\n\nconst data = client.readQuery({ query });\n\nconst myNewTodo = {\n  id: '6',\n  text: 'Start using Apollo Client.',\n  completed: false,\n};\n\nclient.writeQuery({\n  query,\n  data: {\n    todos: [...data.todos, myNewTodo],\n  },\n});\n```\n\n<h2 id=\"recipes\">Recipes</h2>\n\nHere are some common situations where you would need to access the cache directly. If you're manipulating the cache in an interesting way and would like your example to be featured, please send in a pull request!\n\n<h3 id=\"server\">Server side rendering</h3>\n\nFirst, you will need to initialize an `InMemoryCache` on the server and create an instance of `ApolloClient`. In the initial serialized HTML payload from the server, you should include a script tag that extracts the data from the cache.\n\n```js\n`<script>\n  window.__APOLLO_STATE__=${JSON.stringify(cache.extract())}\n</script>`\n```\n\nOn the client, you can rehydrate the cache using the initial data passed from the server:\n\n```js\ncache: new Cache().restore(window.__APOLLO_STATE__)\n```\n\nIf you would like to learn more about server side rendering, please check our our more in depth guide [here].\n<!---\nTODO (PEGGY): Add link to SSR\n-->\n\n<h3 id=\"server\">Updating the cache after a mutation</h3>\n\nBeing able to read and write to the Apollo cache from anywhere in your application gives you a lot of power over your data. However, there is one place where we most often want to update our cached data: after a mutation. As such, Apollo Client has optimized the experience for updating your cache with the read and write methods after a mutation with the `update` function. Let us say that we have the following GraphQL mutation:\n\n```graphql\nmutation TodoCreateMutation($text: String!) {\n  createTodo(text: $text) {\n    id\n    text\n    completed\n  }\n}\n```\n\nWe may also have the following GraphQL query:\n\n```graphql\nquery TodoAppQuery {\n  todos {\n    id\n    text\n    completed\n  }\n}\n```\n\nAt the end of our mutation we want our query to include the new todo like we had sent our `TodoAppQuery` a second time after the mutation finished without actually sending the query. To do this we can use the `update` function provided as an option of the `client.mutate` method. To update your cache with the mutation just write code that looks like:\n\n```js\n// We assume that the GraphQL operations `TodoCreateMutation` and\n// `TodoAppQuery` have already been defined using the `gql` tag.\n\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    // Read the data from our cache for this query.\n    const data = proxy.readQuery({ query: TodoAppQuery });\n\n    // Add our todo from the mutation to the end.\n    data.todos.push(createTodo);\n\n    // Write our data back to the cache.\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nThe first `proxy` argument is an instance of [`DataProxy`][] has the same four methods that we just learned exist on the Apollo Client: `readQuery`, `readFragment`, `writeQuery`, and `writeFragment`. The reason we call them on a `proxy` object here instead of on our `client` instance is that we can easily apply optimistic updates (which we will demonstrate in a bit). The `proxy` object also provides an isolated transaction which shields you from any other mutations going on at the same time, and the `proxy` object also batches writes together until the very end.\n\nIf you provide an `optimisticResponse` option to the mutation then the `update` function will be run twice. Once immediately after you call `client.mutate` with the data from `optimisticResponse`. After the mutation successfully executes against the server the changes made in the first call to `update` will be rolled back and `update` will be called with the *actual* data returned by the mutation and not just the optimistic response.\n\nPutting it all together:\n\n```js\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  optimisticResponse: {\n    id: -1, // -1 is a temporary id for the optimistic response.\n    text,\n    completed: false,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    const data = proxy.readQuery({ query: TodoAppQuery });\n    data.todos.push(createTodo);\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nAs you can see the `update` function on `client.mutate` provides extra change management functionality specific to the use case of a mutation while still providing you the powerful data control APIs that are available on `client`.\n\nThe `update` function is not a good place for side-effects as it may be called multiple times. Also, you may not call any of the methods on `proxy` asynchronously.\n\n",
      "readmeFilename": "README.md",
      "_id": "apollo-cache-inmemory@1.3.1-local-state-alpha.3",
      "_npmVersion": "6.4.1",
      "_nodeVersion": "8.12.0",
      "_npmUser": {
        "name": "apollo-bot",
        "email": "npm@apollographql.com"
      },
      "dist": {
        "integrity": "sha512-gaX5CNiGYJjeplFGERbGEQhpMxubPaXwXnwvIhbobr+Fzhl+eDOQhQW8enOSS20RTGSkthm5DPNoQP9ze8F11Q==",
        "shasum": "630c3cd03aa7273eae44b8303f03d9cf23b61386",
        "tarball": "https://registry.npmjs.org/apollo-cache-inmemory/-/apollo-cache-inmemory-1.3.1-local-state-alpha.3.tgz",
        "fileCount": 84,
        "unpackedSize": 510406,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJbt2muCRA9TVsSAnZWagAA6zgP/AowRYtOIqhoYRr8gwnA\n7QKJvwBUNFXAGjUve7TYtLWegTf8JsDC+CnyYK7g97xZEOKTbd1CxIDcBRXI\nAc8+VMUxLpelZH/7G2kmjj/loH/2tNl91CPcUVO3bFClwfxJH/5d5Ja8f2El\ne2PdlvHD3RhVlrB+3rlb/DsQBB5Df8yp51LcOrUCPXrXl+p3QUnSrNXPUuDb\nlPVkQEN8cbSE77klIjjpkmOJ/om1P/3njmx4P5bn85kIOw+ol45+r9k4NAJ2\nKmVmgLf6WJ5QfmSb+sxqYVY2hz8gnHg95iPls43w3pJs7VBl30Hi9fOA9Tb1\nVHlQ9ZMDc2e9xm4EnPzY+g4C3YDNpEJjquqZZUo/d1r+zqDXWHe7yEm+8Gw8\nwqt+C00KHQ1fL7zTowXFW+B3cgFKP1RD6x07em8yYJUBzRnaVURl79SVGPEE\nG8JmRqrJ3S2y40RHNzT5oH0SSA0D18o/w11eebYnNTddnU2ZgD3X7wseN8Ud\nGaFt6pKs/mXgWGPqsMO6rjPrgm3/zQtBDnsFu+TKoW9pfg2SXlN2yVBRsHSi\nX7f+/0Xmlw/5kYwwbpYzqyNNUfgN5SgBnUaBlaMFNtswl3WQhVRD5f9eb3e9\nEWkTnuEXcwVJGUWNHgou5N7+9W8dwefi3TUYJ6RR5oifggdYglaPd2mzTFUK\nqXYb\r\n=xQo7\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCID7Y1SO1wnK0oS6BBDmvv1+P5/xb8+tfUuHvFIC0v6/XAiEA42ViROOlshWYBkZrOgJVVLk6PsD2EGJ2+1HtYEzgJO0="
          }
        ]
      },
      "maintainers": [
        {
          "email": "npm@apollographql.com",
          "name": "apollo-bot"
        },
        {
          "email": "ben@benjamn.com",
          "name": "benjamn"
        },
        {
          "email": "james@meteor.com",
          "name": "jbaxleyiii"
        },
        {
          "email": "peggyrayzis@gmail.com",
          "name": "peggyrayzis"
        }
      ],
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/apollo-cache-inmemory_1.3.1-local-state-alpha.3_1538746797997_0.3491667387724615"
      },
      "_hasShrinkwrap": false
    },
    "1.3.1-local-state-alpha.4": {
      "name": "apollo-cache-inmemory",
      "version": "1.3.1-local-state-alpha.4",
      "description": "Core abstract of Caching layer for Apollo Client",
      "author": {
        "name": "James Baxley",
        "email": "james@meteor.com"
      },
      "contributors": [
        {
          "name": "James Baxley",
          "email": "james@meteor.com"
        },
        {
          "name": "Jonas Helfer",
          "email": "jonas@helfer.email"
        },
        {
          "name": "Sashko Stubailo",
          "email": "sashko@stubailo.com"
        },
        {
          "name": "James Burgess",
          "email": "jamesmillerburgess@gmail.com"
        },
        {
          "name": "Bazyli Brzóska",
          "email": "bazyli.brzoska@gmail.com"
        }
      ],
      "license": "MIT",
      "main": "./lib/bundle.umd.js",
      "module": "./lib/index.js",
      "jsnext:main": "./lib/index.js",
      "typings": "./lib/index.d.ts",
      "sideEffects": false,
      "repository": {
        "type": "git",
        "url": "git+https://github.com/apollographql/apollo-client.git"
      },
      "bugs": {
        "url": "https://github.com/apollographql/apollo-client/issues"
      },
      "homepage": "https://github.com/apollographql/apollo-client#readme",
      "scripts": {
        "prepare": "npm run build",
        "coverage": "jest --coverage",
        "test": "jest",
        "lint": "tslint -c \"../../config/tslint.json\" -p tsconfig.json src/*.ts",
        "prebuild": "npm run clean",
        "build": "tsc -p .",
        "postbuild": "npm run bundle",
        "bundle": "../../node_modules/rollup/bin/rollup -c rollup.config.js",
        "watch": "tsc -w -p .",
        "clean": "rm -rf coverage/* && rm -rf lib/*",
        "prepublishOnly": "npm run build",
        "minify": "../../node_modules/uglify-js/bin/uglifyjs -c -m -o ./lib/bundle.min.js -- ./lib/bundle.umd.js",
        "filesize": "npm run minify"
      },
      "dependencies": {
        "apollo-cache": "^1.1.18-local-state-alpha.4",
        "apollo-utilities": "^1.0.22-local-state-alpha.4",
        "optimism": "^0.6.6"
      },
      "peerDependencies": {
        "graphql": "0.11.7 || ^0.12.0 || ^0.13.0"
      },
      "jest": {
        "transform": {
          ".(ts|tsx)": "ts-jest"
        },
        "testRegex": "(/__tests__/.*|\\.(test|spec))\\.(ts|tsx|js)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "json"
        ],
        "testURL": "http://localhost"
      },
      "gitHead": "0e5fe6e6c9551b78b3cdfa180c6a0928bb9244bd",
      "_resolved": "",
      "_integrity": "",
      "_from": "file:apollo-cache-inmemory-1.3.1-local-state-alpha.4.tgz",
      "readme": "---\ntitle: InMemoryCache\ndescription: An explanation of `apollo-cache-inmemory`\n---\n\n`apollo-cache-inmemory` is the recommended cache implementation for Apollo Client 2.0. `InMemoryCache` is a normalized data store that supports all of Apollo Client 1.0's features without the dependency on Redux.\n\nIn some instances, you may need to manipulate the cache directly, such as updating the store after a mutation. We'll cover some common use cases [here](#recipes).\n\n<h2 id=\"installation\">Installation</h2>\n\n```\nnpm install apollo-cache-inmemory --save\n```\n\nAfter installing the package, you'll want to initialize the cache constructor. Then, you can pass in your newly created cache to ApolloClient.\n\n```js\nimport { InMemoryCache } from 'apollo-cache-inmemory';\nimport { HttpLink } from 'apollo-link-http';\nimport ApolloClient from 'apollo-client';\n\nconst cache = new InMemoryCache();\n\nconst client = new ApolloClient({\n  link: new HttpLink(),\n  cache\n});\n```\n\n<h2 id=\"configuration\">Configuration</h2>\n\nThe `InMemoryCache` constructor takes an optional config object with properties to customize your cache:\n\n- addTypename: A boolean to determine whether to add __typename to the document (default: `true`)\n- dataIdFromObject: A function that takes a data object and returns a unique identifier to be used when normalizing the data in the store. Learn more about how to customize `dataIdFromObject` in the [Normalization](#normalization) section.\n- fragmentMatcher: By default, the `InMemoryCache` uses a heuristic fragment matcher. If you are using fragments on unions and interfaces, you will need to use an `IntrospectionFragmentMatcher`. For more information, please read [our guide to setting up fragment matching for unions & interfaces](https://www.apollographql.com/docs/react/advanced/fragments.html#fragment-matcher).\n\n<h2 id=\"normalization\">Normalization</h2>\n\nThe `InMemoryCache` normalizes your data before saving it to the store by splitting the result into individual objects, creating a unique identifier for each object, and storing those objects in a flattened data structure. By default, `InMemoryCache` will attempt to use the commonly found primary keys of `id` and `_id` for the unique identifier if they exist along with `__typename` on an object.\n\nIf `id` and `_id` are not specified, or if `__typename` is not specified, `InMemoryCache` will fall back to the path to the object in the query, such as `ROOT_QUERY.allPeople.0` for the first record returned on the `allPeople` root query.\n\nThis \"getter\" behavior for unique identifiers can be configured manually via the `dataIdFromObject` option passed to the `InMemoryCache` constructor, so you can pick which field is used if some of your data follows unorthodox primary key conventions.\n\nFor example, if you wanted to key off of the `key` field for all of your data, you could configure `dataIdFromObject` like so:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => object.key\n});\n```\n\nThis also allows you to use different unique identifiers for different data types by keying off of the `__typename` property attached to every object typed by GraphQL.  For example:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => {\n    switch (object.__typename) {\n      case 'foo': return object.key; // use `key` as the primary key\n      case 'bar': return object.blah; // use `blah` as the priamry key\n      default: return object.id || object._id; // fall back to `id` and `_id` for all other types\n    }\n  }\n});\n```\n\n<h2 id=\"direct\">Direct Cache Access</h2>\n\nTo interact directly with your cache, you can use the Apollo Client class methods readQuery, readFragment, writeQuery, and writeFragment. These methods are available to us via the [`DataProxy` interface](https://github.com/apollographql/apollo-client/blob/master/packages/apollo-cache/src/types/DataProxy.ts). Accessing these methods will vary slightly based on your view layer implementation. If you are using React, you can wrap your component in the `withApollo` higher order component, which will give you access to `this.props.client`. From there, you can use the methods to control your data.\n\nAny code demonstration in the following sections will assume that we have already initialized an instance of  `ApolloClient` and that we have imported the `gql` tag from `graphql-tag`.\n\n<h3 id=\"readquery\">readQuery</h3>\n\nThe `readQuery` method is very similar to the [`query` method on `ApolloClient`][] except that `readQuery` will _never_ make a request to your GraphQL server. The `query` method, on the other hand, may send a request to your server if the appropriate data is not in your cache whereas `readQuery` will throw an error if the data is not in your cache. `readQuery` will _always_ read from the cache. You can use `readQuery` by giving it a GraphQL query like so:\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo {\n      todo(id: 5) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n});\n```\n\nIf all of the data needed to fulfill this read is in Apollo Client’s normalized data cache then a data object will be returned in the shape of the query you wanted to read. If not all of the data needed to fulfill this read is in Apollo Client’s cache then an error will be thrown instead, so make sure to only read data that you know you have!\n\nYou can also pass variables into `readQuery`.\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo($id: Int!) {\n      todo(id: $id) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n  variables: {\n    id: 5,\n  },\n});\n```\n\n<h3 id=\"readfragment\">readFragment</h3>\n\nThis method allows you great flexibility around the data in your cache. Whereas `readQuery` only allowed you to read data from your root query type, `readFragment` allows you to read data from _any node you have queried_. This is incredibly powerful. You use this method as follows:\n\n```js\nconst todo = client.readFragment({\n  id: ..., // `id` is any id that could be returned by `dataIdFromObject`.\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\nThe first argument is the id of the data you want to read from the cache. That id must be a value that was returned by the `dataIdFromObject` function you defined when initializing `ApolloClient`. So for example if you initialized `ApolloClient` like so:\n\n```js\nconst client = new ApolloClient({\n  ...,\n  dataIdFromObject: object => object.id,\n});\n```\n\n…and you requested a todo before with an id of `5`, then you can read that todo out of your cache with the following:\n\n```js\nconst todo = client.readFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\n> **Note:** Most people add a `__typename` to the id in `dataIdFromObject`. If you do this then don’t forget to add the `__typename` when you are reading a fragment as well. So for example your id may be `Todo_5` and not just `5`.\n\nIf a todo with that id does not exist in the cache you will get `null` back. If a todo of that id does exist in the cache, but that todo does not have the `text` field then an error will be thrown.\n\nThe beauty of `readFragment` is that the todo could have come from anywhere! The todo could have been selected as a singleton (`{ todo(id: 5) { ... } }`), the todo could have come from a list of todos (`{ todos { ... } }`), or the todo could have come from a mutation (`mutation { createTodo { ... } }`). As long as at some point your GraphQL server gave you a todo with the provided id and fields `id`, `text`, and `completed` you can read it from the cache at any part of your code.\n\n<h3 id=\"writequery-and-writefragment\">writeQuery` and `writeFragment</h3>\n\nNot only can you read arbitrary data from the Apollo Client cache, but you can also write any data that you would like to the cache. The methods you use to do this are `writeQuery` and `writeFragment`. They will allow you to change data in your local cache, but it is important to remember that *they will not change any data on your server*. If you reload your environment then changes made with `writeQuery` and `writeFragment` will disappear.\n\nThese methods have the same signature as their `readQuery` and `readFragment` counterparts except they also require an additional `data` variable. So for example, if you wanted to update the `completed` flag locally for your todo with id `'5'` you could execute the following:\n\n```js\nclient.writeFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      completed\n    }\n  `,\n  data: {\n    completed: true,\n  },\n});\n```\n\nAny subscriber to the Apollo Client store will instantly see this update and render new UI accordingly.\n\n> **Note:** Again, remember that using `writeQuery` or `writeFragment` only changes data *locally*. If you reload your environment then changes made with these methods will no longer exist.\n\nOr if you wanted to add a new todo to a list fetched from the server, you could use `readQuery` and `writeQuery` together.\n\n```js\nconst query = gql`\n  query MyTodoAppQuery {\n    todos {\n      id\n      text\n      completed\n    }\n  }\n`;\n\nconst data = client.readQuery({ query });\n\nconst myNewTodo = {\n  id: '6',\n  text: 'Start using Apollo Client.',\n  completed: false,\n};\n\nclient.writeQuery({\n  query,\n  data: {\n    todos: [...data.todos, myNewTodo],\n  },\n});\n```\n\n<h2 id=\"recipes\">Recipes</h2>\n\nHere are some common situations where you would need to access the cache directly. If you're manipulating the cache in an interesting way and would like your example to be featured, please send in a pull request!\n\n<h3 id=\"server\">Server side rendering</h3>\n\nFirst, you will need to initialize an `InMemoryCache` on the server and create an instance of `ApolloClient`. In the initial serialized HTML payload from the server, you should include a script tag that extracts the data from the cache.\n\n```js\n`<script>\n  window.__APOLLO_STATE__=${JSON.stringify(cache.extract())}\n</script>`\n```\n\nOn the client, you can rehydrate the cache using the initial data passed from the server:\n\n```js\ncache: new Cache().restore(window.__APOLLO_STATE__)\n```\n\nIf you would like to learn more about server side rendering, please check our our more in depth guide [here].\n<!---\nTODO (PEGGY): Add link to SSR\n-->\n\n<h3 id=\"server\">Updating the cache after a mutation</h3>\n\nBeing able to read and write to the Apollo cache from anywhere in your application gives you a lot of power over your data. However, there is one place where we most often want to update our cached data: after a mutation. As such, Apollo Client has optimized the experience for updating your cache with the read and write methods after a mutation with the `update` function. Let us say that we have the following GraphQL mutation:\n\n```graphql\nmutation TodoCreateMutation($text: String!) {\n  createTodo(text: $text) {\n    id\n    text\n    completed\n  }\n}\n```\n\nWe may also have the following GraphQL query:\n\n```graphql\nquery TodoAppQuery {\n  todos {\n    id\n    text\n    completed\n  }\n}\n```\n\nAt the end of our mutation we want our query to include the new todo like we had sent our `TodoAppQuery` a second time after the mutation finished without actually sending the query. To do this we can use the `update` function provided as an option of the `client.mutate` method. To update your cache with the mutation just write code that looks like:\n\n```js\n// We assume that the GraphQL operations `TodoCreateMutation` and\n// `TodoAppQuery` have already been defined using the `gql` tag.\n\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    // Read the data from our cache for this query.\n    const data = proxy.readQuery({ query: TodoAppQuery });\n\n    // Add our todo from the mutation to the end.\n    data.todos.push(createTodo);\n\n    // Write our data back to the cache.\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nThe first `proxy` argument is an instance of [`DataProxy`][] has the same four methods that we just learned exist on the Apollo Client: `readQuery`, `readFragment`, `writeQuery`, and `writeFragment`. The reason we call them on a `proxy` object here instead of on our `client` instance is that we can easily apply optimistic updates (which we will demonstrate in a bit). The `proxy` object also provides an isolated transaction which shields you from any other mutations going on at the same time, and the `proxy` object also batches writes together until the very end.\n\nIf you provide an `optimisticResponse` option to the mutation then the `update` function will be run twice. Once immediately after you call `client.mutate` with the data from `optimisticResponse`. After the mutation successfully executes against the server the changes made in the first call to `update` will be rolled back and `update` will be called with the *actual* data returned by the mutation and not just the optimistic response.\n\nPutting it all together:\n\n```js\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  optimisticResponse: {\n    id: -1, // -1 is a temporary id for the optimistic response.\n    text,\n    completed: false,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    const data = proxy.readQuery({ query: TodoAppQuery });\n    data.todos.push(createTodo);\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nAs you can see the `update` function on `client.mutate` provides extra change management functionality specific to the use case of a mutation while still providing you the powerful data control APIs that are available on `client`.\n\nThe `update` function is not a good place for side-effects as it may be called multiple times. Also, you may not call any of the methods on `proxy` asynchronously.\n\n",
      "readmeFilename": "README.md",
      "_id": "apollo-cache-inmemory@1.3.1-local-state-alpha.4",
      "_npmVersion": "6.4.1",
      "_nodeVersion": "8.12.0",
      "_npmUser": {
        "name": "apollo-bot",
        "email": "npm@apollographql.com"
      },
      "dist": {
        "integrity": "sha512-n3BOvsq7rIpZvxQzz8y3X16hdQJCw5dnTosv+Rm46+iRjwZj9ezCzQIt3EEIOdCqhtxGB61Scx1nGFz5e4iJ+A==",
        "shasum": "60a7a84c8fba6d944f65e9bad61d235f1b95b31f",
        "tarball": "https://registry.npmjs.org/apollo-cache-inmemory/-/apollo-cache-inmemory-1.3.1-local-state-alpha.4.tgz",
        "fileCount": 84,
        "unpackedSize": 510406,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJbt2ynCRA9TVsSAnZWagAAEbQQAJaV4Fd3FIttCE1aSFvE\nDZdkXQihU6x+CoKsE3i88x67fkiN95tKx0mEj28U02vFPfUxXFIU4uAuVHyF\nP8K5Ex9x78IupbhPcYRFiwRG6hTAnFqF9KdDZ0L99O5IUyXD196xzqup93Dj\n6Ddp/WemUfqyTXdekY5SVFDwNtFudILl5FWc2p21Bj9QHNvLt3NhT/I4DODf\nQCmhq3e5rT270ogsKvDaFdzBAgoTfQ2QQBNw1FTt3E9FjFN0EkutxJ8qUw/4\nP0u/q0ywjzJJjuv1Oa0ehKft7J1aZ2jVOY37Y7/gIbNOXfvf/3kDrvcAj41S\nEiZVvtEm7M+lQvL5uy+8PTy4Mgq6RgK+XDFVpifU31Ei32XTrLjQYMXshmZg\n6YmNXW+RjTzNC/ulTXBPj251tABUDL1fnxOYADn9uy6ZEPmPtZ4uj7FyGP9J\n1APOs3LeE0Pgq0lNo9dQDYkDFh3kgE2/6vpKE9Wv2Q1Tc6Bt1IaP7FFDeM2B\nLCn7jRdZXW8LwlRs+7mLhF1tkHu7VZUGwCq5g0fZwXn2exEHvxXJEpPbtxTu\nJqxZQzq4+Bg+wZ6xrVvUjoCfrBgIpwlTiJUOu9ngKiWIgUzpQ80Hr9l6SlzD\nQ4fKXz1m4L4XqucFxvjjHBRNolVaQOUPMcUU/bI86No1O67CYFkAASe01XUo\nCgD2\r\n=2ztu\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEQCIHH6JvvJ3nUE3fQT0SsuNTQZN2sBQ+18tnZ27/xdastJAiBOTXXS2yyal0pmi7A654CHya+jjQgYUA9SZDXyFU/3pg=="
          }
        ]
      },
      "maintainers": [
        {
          "email": "npm@apollographql.com",
          "name": "apollo-bot"
        },
        {
          "email": "ben@benjamn.com",
          "name": "benjamn"
        },
        {
          "email": "james@meteor.com",
          "name": "jbaxleyiii"
        },
        {
          "email": "peggyrayzis@gmail.com",
          "name": "peggyrayzis"
        }
      ],
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/apollo-cache-inmemory_1.3.1-local-state-alpha.4_1538747558663_0.33678516609617826"
      },
      "_hasShrinkwrap": false
    },
    "1.3.1-local-state-alpha.5": {
      "name": "apollo-cache-inmemory",
      "version": "1.3.1-local-state-alpha.5",
      "description": "Core abstract of Caching layer for Apollo Client",
      "author": {
        "name": "James Baxley",
        "email": "james@meteor.com"
      },
      "contributors": [
        {
          "name": "James Baxley",
          "email": "james@meteor.com"
        },
        {
          "name": "Jonas Helfer",
          "email": "jonas@helfer.email"
        },
        {
          "name": "Sashko Stubailo",
          "email": "sashko@stubailo.com"
        },
        {
          "name": "James Burgess",
          "email": "jamesmillerburgess@gmail.com"
        },
        {
          "name": "Bazyli Brzóska",
          "email": "bazyli.brzoska@gmail.com"
        }
      ],
      "license": "MIT",
      "main": "./lib/bundle.umd.js",
      "module": "./lib/index.js",
      "jsnext:main": "./lib/index.js",
      "typings": "./lib/index.d.ts",
      "sideEffects": false,
      "repository": {
        "type": "git",
        "url": "git+https://github.com/apollographql/apollo-client.git"
      },
      "bugs": {
        "url": "https://github.com/apollographql/apollo-client/issues"
      },
      "homepage": "https://github.com/apollographql/apollo-client#readme",
      "scripts": {
        "prepare": "npm run build",
        "coverage": "jest --coverage",
        "test": "jest",
        "lint": "tslint -c \"../../config/tslint.json\" -p tsconfig.json src/*.ts",
        "prebuild": "npm run clean",
        "build": "tsc -p .",
        "postbuild": "npm run bundle",
        "bundle": "../../node_modules/rollup/bin/rollup -c rollup.config.js",
        "watch": "tsc -w -p .",
        "clean": "rm -rf coverage/* && rm -rf lib/*",
        "prepublishOnly": "npm run build",
        "minify": "../../node_modules/uglify-js/bin/uglifyjs -c -m -o ./lib/bundle.min.js -- ./lib/bundle.umd.js",
        "filesize": "npm run minify"
      },
      "dependencies": {
        "apollo-cache": "^1.1.18-local-state-alpha.5",
        "apollo-utilities": "^1.0.22-local-state-alpha.5",
        "optimism": "^0.6.6"
      },
      "peerDependencies": {
        "graphql": "0.11.7 || ^0.12.0 || ^0.13.0"
      },
      "jest": {
        "transform": {
          ".(ts|tsx)": "ts-jest"
        },
        "testRegex": "(/__tests__/.*|\\.(test|spec))\\.(ts|tsx|js)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "json"
        ],
        "testURL": "http://localhost"
      },
      "gitHead": "212eebf60eb772d5184de25d9fd0a3265703f94d",
      "_resolved": "",
      "_integrity": "",
      "_from": "file:apollo-cache-inmemory-1.3.1-local-state-alpha.5.tgz",
      "readme": "---\ntitle: InMemoryCache\ndescription: An explanation of `apollo-cache-inmemory`\n---\n\n`apollo-cache-inmemory` is the recommended cache implementation for Apollo Client 2.0. `InMemoryCache` is a normalized data store that supports all of Apollo Client 1.0's features without the dependency on Redux.\n\nIn some instances, you may need to manipulate the cache directly, such as updating the store after a mutation. We'll cover some common use cases [here](#recipes).\n\n<h2 id=\"installation\">Installation</h2>\n\n```\nnpm install apollo-cache-inmemory --save\n```\n\nAfter installing the package, you'll want to initialize the cache constructor. Then, you can pass in your newly created cache to ApolloClient.\n\n```js\nimport { InMemoryCache } from 'apollo-cache-inmemory';\nimport { HttpLink } from 'apollo-link-http';\nimport ApolloClient from 'apollo-client';\n\nconst cache = new InMemoryCache();\n\nconst client = new ApolloClient({\n  link: new HttpLink(),\n  cache\n});\n```\n\n<h2 id=\"configuration\">Configuration</h2>\n\nThe `InMemoryCache` constructor takes an optional config object with properties to customize your cache:\n\n- addTypename: A boolean to determine whether to add __typename to the document (default: `true`)\n- dataIdFromObject: A function that takes a data object and returns a unique identifier to be used when normalizing the data in the store. Learn more about how to customize `dataIdFromObject` in the [Normalization](#normalization) section.\n- fragmentMatcher: By default, the `InMemoryCache` uses a heuristic fragment matcher. If you are using fragments on unions and interfaces, you will need to use an `IntrospectionFragmentMatcher`. For more information, please read [our guide to setting up fragment matching for unions & interfaces](https://www.apollographql.com/docs/react/advanced/fragments.html#fragment-matcher).\n\n<h2 id=\"normalization\">Normalization</h2>\n\nThe `InMemoryCache` normalizes your data before saving it to the store by splitting the result into individual objects, creating a unique identifier for each object, and storing those objects in a flattened data structure. By default, `InMemoryCache` will attempt to use the commonly found primary keys of `id` and `_id` for the unique identifier if they exist along with `__typename` on an object.\n\nIf `id` and `_id` are not specified, or if `__typename` is not specified, `InMemoryCache` will fall back to the path to the object in the query, such as `ROOT_QUERY.allPeople.0` for the first record returned on the `allPeople` root query.\n\nThis \"getter\" behavior for unique identifiers can be configured manually via the `dataIdFromObject` option passed to the `InMemoryCache` constructor, so you can pick which field is used if some of your data follows unorthodox primary key conventions.\n\nFor example, if you wanted to key off of the `key` field for all of your data, you could configure `dataIdFromObject` like so:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => object.key\n});\n```\n\nThis also allows you to use different unique identifiers for different data types by keying off of the `__typename` property attached to every object typed by GraphQL.  For example:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => {\n    switch (object.__typename) {\n      case 'foo': return object.key; // use `key` as the primary key\n      case 'bar': return object.blah; // use `blah` as the priamry key\n      default: return object.id || object._id; // fall back to `id` and `_id` for all other types\n    }\n  }\n});\n```\n\n<h2 id=\"direct\">Direct Cache Access</h2>\n\nTo interact directly with your cache, you can use the Apollo Client class methods readQuery, readFragment, writeQuery, and writeFragment. These methods are available to us via the [`DataProxy` interface](https://github.com/apollographql/apollo-client/blob/master/packages/apollo-cache/src/types/DataProxy.ts). Accessing these methods will vary slightly based on your view layer implementation. If you are using React, you can wrap your component in the `withApollo` higher order component, which will give you access to `this.props.client`. From there, you can use the methods to control your data.\n\nAny code demonstration in the following sections will assume that we have already initialized an instance of  `ApolloClient` and that we have imported the `gql` tag from `graphql-tag`.\n\n<h3 id=\"readquery\">readQuery</h3>\n\nThe `readQuery` method is very similar to the [`query` method on `ApolloClient`][] except that `readQuery` will _never_ make a request to your GraphQL server. The `query` method, on the other hand, may send a request to your server if the appropriate data is not in your cache whereas `readQuery` will throw an error if the data is not in your cache. `readQuery` will _always_ read from the cache. You can use `readQuery` by giving it a GraphQL query like so:\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo {\n      todo(id: 5) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n});\n```\n\nIf all of the data needed to fulfill this read is in Apollo Client’s normalized data cache then a data object will be returned in the shape of the query you wanted to read. If not all of the data needed to fulfill this read is in Apollo Client’s cache then an error will be thrown instead, so make sure to only read data that you know you have!\n\nYou can also pass variables into `readQuery`.\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo($id: Int!) {\n      todo(id: $id) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n  variables: {\n    id: 5,\n  },\n});\n```\n\n<h3 id=\"readfragment\">readFragment</h3>\n\nThis method allows you great flexibility around the data in your cache. Whereas `readQuery` only allowed you to read data from your root query type, `readFragment` allows you to read data from _any node you have queried_. This is incredibly powerful. You use this method as follows:\n\n```js\nconst todo = client.readFragment({\n  id: ..., // `id` is any id that could be returned by `dataIdFromObject`.\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\nThe first argument is the id of the data you want to read from the cache. That id must be a value that was returned by the `dataIdFromObject` function you defined when initializing `ApolloClient`. So for example if you initialized `ApolloClient` like so:\n\n```js\nconst client = new ApolloClient({\n  ...,\n  dataIdFromObject: object => object.id,\n});\n```\n\n…and you requested a todo before with an id of `5`, then you can read that todo out of your cache with the following:\n\n```js\nconst todo = client.readFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\n> **Note:** Most people add a `__typename` to the id in `dataIdFromObject`. If you do this then don’t forget to add the `__typename` when you are reading a fragment as well. So for example your id may be `Todo_5` and not just `5`.\n\nIf a todo with that id does not exist in the cache you will get `null` back. If a todo of that id does exist in the cache, but that todo does not have the `text` field then an error will be thrown.\n\nThe beauty of `readFragment` is that the todo could have come from anywhere! The todo could have been selected as a singleton (`{ todo(id: 5) { ... } }`), the todo could have come from a list of todos (`{ todos { ... } }`), or the todo could have come from a mutation (`mutation { createTodo { ... } }`). As long as at some point your GraphQL server gave you a todo with the provided id and fields `id`, `text`, and `completed` you can read it from the cache at any part of your code.\n\n<h3 id=\"writequery-and-writefragment\">writeQuery` and `writeFragment</h3>\n\nNot only can you read arbitrary data from the Apollo Client cache, but you can also write any data that you would like to the cache. The methods you use to do this are `writeQuery` and `writeFragment`. They will allow you to change data in your local cache, but it is important to remember that *they will not change any data on your server*. If you reload your environment then changes made with `writeQuery` and `writeFragment` will disappear.\n\nThese methods have the same signature as their `readQuery` and `readFragment` counterparts except they also require an additional `data` variable. So for example, if you wanted to update the `completed` flag locally for your todo with id `'5'` you could execute the following:\n\n```js\nclient.writeFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      completed\n    }\n  `,\n  data: {\n    completed: true,\n  },\n});\n```\n\nAny subscriber to the Apollo Client store will instantly see this update and render new UI accordingly.\n\n> **Note:** Again, remember that using `writeQuery` or `writeFragment` only changes data *locally*. If you reload your environment then changes made with these methods will no longer exist.\n\nOr if you wanted to add a new todo to a list fetched from the server, you could use `readQuery` and `writeQuery` together.\n\n```js\nconst query = gql`\n  query MyTodoAppQuery {\n    todos {\n      id\n      text\n      completed\n    }\n  }\n`;\n\nconst data = client.readQuery({ query });\n\nconst myNewTodo = {\n  id: '6',\n  text: 'Start using Apollo Client.',\n  completed: false,\n};\n\nclient.writeQuery({\n  query,\n  data: {\n    todos: [...data.todos, myNewTodo],\n  },\n});\n```\n\n<h2 id=\"recipes\">Recipes</h2>\n\nHere are some common situations where you would need to access the cache directly. If you're manipulating the cache in an interesting way and would like your example to be featured, please send in a pull request!\n\n<h3 id=\"server\">Server side rendering</h3>\n\nFirst, you will need to initialize an `InMemoryCache` on the server and create an instance of `ApolloClient`. In the initial serialized HTML payload from the server, you should include a script tag that extracts the data from the cache.\n\n```js\n`<script>\n  window.__APOLLO_STATE__=${JSON.stringify(cache.extract())}\n</script>`\n```\n\nOn the client, you can rehydrate the cache using the initial data passed from the server:\n\n```js\ncache: new Cache().restore(window.__APOLLO_STATE__)\n```\n\nIf you would like to learn more about server side rendering, please check our our more in depth guide [here].\n<!---\nTODO (PEGGY): Add link to SSR\n-->\n\n<h3 id=\"server\">Updating the cache after a mutation</h3>\n\nBeing able to read and write to the Apollo cache from anywhere in your application gives you a lot of power over your data. However, there is one place where we most often want to update our cached data: after a mutation. As such, Apollo Client has optimized the experience for updating your cache with the read and write methods after a mutation with the `update` function. Let us say that we have the following GraphQL mutation:\n\n```graphql\nmutation TodoCreateMutation($text: String!) {\n  createTodo(text: $text) {\n    id\n    text\n    completed\n  }\n}\n```\n\nWe may also have the following GraphQL query:\n\n```graphql\nquery TodoAppQuery {\n  todos {\n    id\n    text\n    completed\n  }\n}\n```\n\nAt the end of our mutation we want our query to include the new todo like we had sent our `TodoAppQuery` a second time after the mutation finished without actually sending the query. To do this we can use the `update` function provided as an option of the `client.mutate` method. To update your cache with the mutation just write code that looks like:\n\n```js\n// We assume that the GraphQL operations `TodoCreateMutation` and\n// `TodoAppQuery` have already been defined using the `gql` tag.\n\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    // Read the data from our cache for this query.\n    const data = proxy.readQuery({ query: TodoAppQuery });\n\n    // Add our todo from the mutation to the end.\n    data.todos.push(createTodo);\n\n    // Write our data back to the cache.\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nThe first `proxy` argument is an instance of [`DataProxy`][] has the same four methods that we just learned exist on the Apollo Client: `readQuery`, `readFragment`, `writeQuery`, and `writeFragment`. The reason we call them on a `proxy` object here instead of on our `client` instance is that we can easily apply optimistic updates (which we will demonstrate in a bit). The `proxy` object also provides an isolated transaction which shields you from any other mutations going on at the same time, and the `proxy` object also batches writes together until the very end.\n\nIf you provide an `optimisticResponse` option to the mutation then the `update` function will be run twice. Once immediately after you call `client.mutate` with the data from `optimisticResponse`. After the mutation successfully executes against the server the changes made in the first call to `update` will be rolled back and `update` will be called with the *actual* data returned by the mutation and not just the optimistic response.\n\nPutting it all together:\n\n```js\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  optimisticResponse: {\n    id: -1, // -1 is a temporary id for the optimistic response.\n    text,\n    completed: false,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    const data = proxy.readQuery({ query: TodoAppQuery });\n    data.todos.push(createTodo);\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nAs you can see the `update` function on `client.mutate` provides extra change management functionality specific to the use case of a mutation while still providing you the powerful data control APIs that are available on `client`.\n\nThe `update` function is not a good place for side-effects as it may be called multiple times. Also, you may not call any of the methods on `proxy` asynchronously.\n\n",
      "readmeFilename": "README.md",
      "_id": "apollo-cache-inmemory@1.3.1-local-state-alpha.5",
      "_npmVersion": "6.4.1",
      "_nodeVersion": "8.12.0",
      "_npmUser": {
        "name": "apollo-bot",
        "email": "npm@apollographql.com"
      },
      "dist": {
        "integrity": "sha512-Mnx7NxRzx7LUkHaBQRSkHl5dFocJ5lMbKwTgiROfNEbvOijzm8ooe0qBM9JM60NbvBYm7p8XwXW2IkYAKJAc0w==",
        "shasum": "80a1ca89b09bf79e6794aa0a6c97d1ff697b18c3",
        "tarball": "https://registry.npmjs.org/apollo-cache-inmemory/-/apollo-cache-inmemory-1.3.1-local-state-alpha.5.tgz",
        "fileCount": 84,
        "unpackedSize": 510406,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJbt7uZCRA9TVsSAnZWagAAWCwQAKPphrDNKs/F5Xc4T7O4\n3++ldRWKaLED53mWbyPDxAHxibPojE6k590Lb3XY+n/tTkTRm35oB4Md2r+w\naCWaKuLcN+lGY+bJpYFiGElSUu4CQdOSj1oz5dKtAazKJ7wsgZFH3p40H3Uo\nApyfKEZVshyzJg0JpAEdLeVg+Eu/t6nTmBuFmTMPbZoZKvUHi0NJiprLZyjQ\n1f3Mm+gl26irkIhD7s8CZWc+mmYuRoU9C5vCWdZTB8oh2I4ll3xQVVl06nzc\nqvWFFvoSFiMc5mYPTriRy1SyHUPvmQgpJHPMBYPmv4NmqZtW4YPVDPSEkemZ\nRmifoIZ+q4UHsfmBFrO3tNwAe6X2tsItdVGLVFAcR4aBwjYPN/+eo2Tf3RGt\nc1xIPloMLcvy9JI7I+osBxtb/gQqnOvKGnbeN0ZMaSGLDtDkMfIHhtM3/V0H\ndfyRoF9mte45Ut+AK1CTrRp5z1K75httTMXFQpUdh7G/X7jTBgV+sztGHWpZ\n3534rKljBYVyApyat37k4j+Sv20Ahe4hkT/B4qeMeXzjOi/6cQPAsauhzi3n\n+54VN7IRCZgcfjnoSM++1Fa+mCLoMIYIMhZXzIG9z5oQ2Y7g5SDK0QuCPXhx\n+GL5IakhLRWFqi9RlcisAoOVovPWvmsRGDprf/LN9vQB3i5oqjAghaxO7ay7\nnmyK\r\n=ydd3\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIDtmM0ZS6viDJqOmhXbg53W7BNgJgtAsCdGwa4dt0x5iAiEAg5gqWP0t8O/TJBapgStoaQ4ruz+lKr7PTnVkdIuBrTo="
          }
        ]
      },
      "maintainers": [
        {
          "email": "npm@apollographql.com",
          "name": "apollo-bot"
        },
        {
          "email": "ben@benjamn.com",
          "name": "benjamn"
        },
        {
          "email": "james@meteor.com",
          "name": "jbaxleyiii"
        },
        {
          "email": "peggyrayzis@gmail.com",
          "name": "peggyrayzis"
        }
      ],
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/apollo-cache-inmemory_1.3.1-local-state-alpha.5_1538767769050_0.8771468701993346"
      },
      "_hasShrinkwrap": false
    },
    "1.3.5": {
      "name": "apollo-cache-inmemory",
      "version": "1.3.5",
      "description": "Core abstract of Caching layer for Apollo Client",
      "author": {
        "name": "James Baxley",
        "email": "james@meteor.com"
      },
      "contributors": [
        {
          "name": "James Baxley",
          "email": "james@meteor.com"
        },
        {
          "name": "Jonas Helfer",
          "email": "jonas@helfer.email"
        },
        {
          "name": "Sashko Stubailo",
          "email": "sashko@stubailo.com"
        },
        {
          "name": "James Burgess",
          "email": "jamesmillerburgess@gmail.com"
        },
        {
          "name": "Bazyli Brzóska",
          "email": "bazyli.brzoska@gmail.com"
        }
      ],
      "license": "MIT",
      "main": "./lib/bundle.umd.js",
      "module": "./lib/index.js",
      "jsnext:main": "./lib/index.js",
      "typings": "./lib/index.d.ts",
      "sideEffects": false,
      "repository": {
        "type": "git",
        "url": "git+https://github.com/apollographql/apollo-client.git"
      },
      "bugs": {
        "url": "https://github.com/apollographql/apollo-client/issues"
      },
      "homepage": "https://github.com/apollographql/apollo-client#readme",
      "scripts": {
        "prepare": "npm run build",
        "coverage": "jest --coverage",
        "test": "jest",
        "lint": "tslint -c \"../../config/tslint.json\" -p tsconfig.json src/*.ts",
        "prebuild": "npm run clean",
        "build": "tsc -p .",
        "postbuild": "npm run bundle",
        "bundle": "../../node_modules/rollup/bin/rollup -c rollup.config.js",
        "watch": "tsc -w -p .",
        "clean": "rm -rf coverage/* && rm -rf lib/*",
        "prepublishOnly": "npm run build",
        "minify": "../../node_modules/uglify-js/bin/uglifyjs -c -m -o ./lib/bundle.min.js -- ./lib/bundle.umd.js",
        "filesize": "npm run minify"
      },
      "dependencies": {
        "apollo-cache": "^1.1.17",
        "apollo-utilities": "^1.0.21",
        "optimism": "^0.6.6"
      },
      "peerDependencies": {
        "graphql": "0.11.7 || ^0.12.0 || ^0.13.0"
      },
      "jest": {
        "transform": {
          ".(ts|tsx)": "ts-jest"
        },
        "testRegex": "(/__tests__/.*|\\.(test|spec))\\.(ts|tsx|js)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "json"
        ],
        "testURL": "http://localhost"
      },
      "_id": "apollo-cache-inmemory@1.3.5",
      "_npmVersion": "6.4.1",
      "_nodeVersion": "8.11.4",
      "_npmUser": {
        "name": "benjamn",
        "email": "ben@benjamn.com"
      },
      "dist": {
        "integrity": "sha512-CD4Dl9vcCp7N05KUqR3rNDj2WJ1DQNNfeyBUIo5T6XTiUhfBQp5x+CL7S+ezy5mPp+xo4TnwFzLFh/vy2LdDog==",
        "shasum": "7628ee598271cfffa611e15a7ce67652a84b07b0",
        "tarball": "https://registry.npmjs.org/apollo-cache-inmemory/-/apollo-cache-inmemory-1.3.5.tgz",
        "fileCount": 88,
        "unpackedSize": 510426,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJbt7+mCRA9TVsSAnZWagAA73QP/AoNo7niChubSFHOaAKS\nyC96tfypKxW7ReMFshFTHvH/+G9GZbrMQG6RB+/7DmJUlfm7iz5xBQshhXGS\nOtj+hGHuBw/j+rE6DG/xixbDMfuktbpskRRGkrSAV0mhmYw+8zWRjTA5vo75\nmuQvjT+zbFne9SszFqamBICimOrS0DOQLc5xhXqq3MREfBkwWlLT5HcwK8TC\nworUKPEuaS4pd4To2vVLWfYbvdMBsI5nJBqhr7Q+VpfuxX7BUAJ8fI78/qs8\n/G83YBvSMUFTNpS+lXhcXQyM0Qk1hNJKHh9THJTUM3QywJcPq4l+/lvqWPgy\n7uxoWKsLel3vLFELyoxR6g+XhNQZcFb7QL2repru9+ucVnMSR6Riy3HXLImV\nqNBmVJu2GvHTyYgBXEaxd7PPtjduyg5FCw6pw2UP7quY8x+ihwCEK9/poE8P\nTlfxyVZeIK9RIWVA30zVxbnbqIkYI24vGsYD13CdXCHKf0XKl1u/0HPF3KWD\nxGrjC1I2Ot7t6DEaRcgLsaLa7ToiRnYeg3Z2h6ZI+xbfCyGxgON0xdAkfvfs\nAgn0p43fVZbtxDGNyzMeok4T+N7pzs5wNk+4FS0dFMmhWiYsZp8YvaZMGUEA\nYqQqanadWjwhfeVOKWdeGVA4hMQd5s+Dh/00G2zzVngsRYnDamR08b2qydnY\nK8zQ\r\n=L3r5\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEQCIAtB0u7aSqIZh0fQEHKvFsMOhy3W8sr8EVWI1ma9sLnzAiBB5wABBmrlqqZ5OUTD33QoPY6ZRnn3DW5Zkk2ZeRSOmw=="
          }
        ]
      },
      "maintainers": [
        {
          "email": "npm@apollographql.com",
          "name": "apollo-bot"
        },
        {
          "email": "ben@benjamn.com",
          "name": "benjamn"
        },
        {
          "email": "james@meteor.com",
          "name": "jbaxleyiii"
        },
        {
          "email": "peggyrayzis@gmail.com",
          "name": "peggyrayzis"
        }
      ],
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/apollo-cache-inmemory_1.3.5_1538768806097_0.6223759044642945"
      },
      "_hasShrinkwrap": false
    },
    "1.3.1-local-state-alpha.6": {
      "name": "apollo-cache-inmemory",
      "version": "1.3.1-local-state-alpha.6",
      "description": "Core abstract of Caching layer for Apollo Client",
      "author": {
        "name": "James Baxley",
        "email": "james@meteor.com"
      },
      "contributors": [
        {
          "name": "James Baxley",
          "email": "james@meteor.com"
        },
        {
          "name": "Jonas Helfer",
          "email": "jonas@helfer.email"
        },
        {
          "name": "Sashko Stubailo",
          "email": "sashko@stubailo.com"
        },
        {
          "name": "James Burgess",
          "email": "jamesmillerburgess@gmail.com"
        },
        {
          "name": "Bazyli Brzóska",
          "email": "bazyli.brzoska@gmail.com"
        }
      ],
      "license": "MIT",
      "main": "./lib/bundle.umd.js",
      "module": "./lib/index.js",
      "jsnext:main": "./lib/index.js",
      "typings": "./lib/index.d.ts",
      "sideEffects": false,
      "repository": {
        "type": "git",
        "url": "git+https://github.com/apollographql/apollo-client.git"
      },
      "bugs": {
        "url": "https://github.com/apollographql/apollo-client/issues"
      },
      "homepage": "https://github.com/apollographql/apollo-client#readme",
      "scripts": {
        "prepare": "npm run build",
        "coverage": "jest --coverage",
        "test": "jest",
        "lint": "tslint -c \"../../config/tslint.json\" -p tsconfig.json src/*.ts",
        "prebuild": "npm run clean",
        "build": "tsc -p .",
        "postbuild": "npm run bundle",
        "bundle": "../../node_modules/rollup/bin/rollup -c rollup.config.js",
        "watch": "tsc -w -p .",
        "clean": "rm -rf coverage/* && rm -rf lib/*",
        "prepublishOnly": "npm run build",
        "minify": "../../node_modules/uglify-js/bin/uglifyjs -c -m -o ./lib/bundle.min.js -- ./lib/bundle.umd.js",
        "filesize": "npm run minify"
      },
      "dependencies": {
        "apollo-cache": "^1.1.18-local-state-alpha.6",
        "apollo-utilities": "^1.0.22-local-state-alpha.6",
        "optimism": "^0.6.6"
      },
      "peerDependencies": {
        "graphql": "0.11.7 || ^0.12.0 || ^0.13.0"
      },
      "jest": {
        "transform": {
          ".(ts|tsx)": "ts-jest"
        },
        "testRegex": "(/__tests__/.*|\\.(test|spec))\\.(ts|tsx|js)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "json"
        ],
        "testURL": "http://localhost"
      },
      "gitHead": "20abe0675bf14eb4d87d4001fafa1b42e24564b8",
      "_resolved": "",
      "_integrity": "",
      "_from": "file:apollo-cache-inmemory-1.3.1-local-state-alpha.6.tgz",
      "readme": "---\ntitle: InMemoryCache\ndescription: An explanation of `apollo-cache-inmemory`\n---\n\n`apollo-cache-inmemory` is the recommended cache implementation for Apollo Client 2.0. `InMemoryCache` is a normalized data store that supports all of Apollo Client 1.0's features without the dependency on Redux.\n\nIn some instances, you may need to manipulate the cache directly, such as updating the store after a mutation. We'll cover some common use cases [here](#recipes).\n\n<h2 id=\"installation\">Installation</h2>\n\n```\nnpm install apollo-cache-inmemory --save\n```\n\nAfter installing the package, you'll want to initialize the cache constructor. Then, you can pass in your newly created cache to ApolloClient.\n\n```js\nimport { InMemoryCache } from 'apollo-cache-inmemory';\nimport { HttpLink } from 'apollo-link-http';\nimport ApolloClient from 'apollo-client';\n\nconst cache = new InMemoryCache();\n\nconst client = new ApolloClient({\n  link: new HttpLink(),\n  cache\n});\n```\n\n<h2 id=\"configuration\">Configuration</h2>\n\nThe `InMemoryCache` constructor takes an optional config object with properties to customize your cache:\n\n- addTypename: A boolean to determine whether to add __typename to the document (default: `true`)\n- dataIdFromObject: A function that takes a data object and returns a unique identifier to be used when normalizing the data in the store. Learn more about how to customize `dataIdFromObject` in the [Normalization](#normalization) section.\n- fragmentMatcher: By default, the `InMemoryCache` uses a heuristic fragment matcher. If you are using fragments on unions and interfaces, you will need to use an `IntrospectionFragmentMatcher`. For more information, please read [our guide to setting up fragment matching for unions & interfaces](https://www.apollographql.com/docs/react/advanced/fragments.html#fragment-matcher).\n\n<h2 id=\"normalization\">Normalization</h2>\n\nThe `InMemoryCache` normalizes your data before saving it to the store by splitting the result into individual objects, creating a unique identifier for each object, and storing those objects in a flattened data structure. By default, `InMemoryCache` will attempt to use the commonly found primary keys of `id` and `_id` for the unique identifier if they exist along with `__typename` on an object.\n\nIf `id` and `_id` are not specified, or if `__typename` is not specified, `InMemoryCache` will fall back to the path to the object in the query, such as `ROOT_QUERY.allPeople.0` for the first record returned on the `allPeople` root query.\n\nThis \"getter\" behavior for unique identifiers can be configured manually via the `dataIdFromObject` option passed to the `InMemoryCache` constructor, so you can pick which field is used if some of your data follows unorthodox primary key conventions.\n\nFor example, if you wanted to key off of the `key` field for all of your data, you could configure `dataIdFromObject` like so:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => object.key\n});\n```\n\nThis also allows you to use different unique identifiers for different data types by keying off of the `__typename` property attached to every object typed by GraphQL.  For example:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => {\n    switch (object.__typename) {\n      case 'foo': return object.key; // use `key` as the primary key\n      case 'bar': return object.blah; // use `blah` as the priamry key\n      default: return object.id || object._id; // fall back to `id` and `_id` for all other types\n    }\n  }\n});\n```\n\n<h2 id=\"direct\">Direct Cache Access</h2>\n\nTo interact directly with your cache, you can use the Apollo Client class methods readQuery, readFragment, writeQuery, and writeFragment. These methods are available to us via the [`DataProxy` interface](https://github.com/apollographql/apollo-client/blob/master/packages/apollo-cache/src/types/DataProxy.ts). Accessing these methods will vary slightly based on your view layer implementation. If you are using React, you can wrap your component in the `withApollo` higher order component, which will give you access to `this.props.client`. From there, you can use the methods to control your data.\n\nAny code demonstration in the following sections will assume that we have already initialized an instance of  `ApolloClient` and that we have imported the `gql` tag from `graphql-tag`.\n\n<h3 id=\"readquery\">readQuery</h3>\n\nThe `readQuery` method is very similar to the [`query` method on `ApolloClient`][] except that `readQuery` will _never_ make a request to your GraphQL server. The `query` method, on the other hand, may send a request to your server if the appropriate data is not in your cache whereas `readQuery` will throw an error if the data is not in your cache. `readQuery` will _always_ read from the cache. You can use `readQuery` by giving it a GraphQL query like so:\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo {\n      todo(id: 5) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n});\n```\n\nIf all of the data needed to fulfill this read is in Apollo Client’s normalized data cache then a data object will be returned in the shape of the query you wanted to read. If not all of the data needed to fulfill this read is in Apollo Client’s cache then an error will be thrown instead, so make sure to only read data that you know you have!\n\nYou can also pass variables into `readQuery`.\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo($id: Int!) {\n      todo(id: $id) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n  variables: {\n    id: 5,\n  },\n});\n```\n\n<h3 id=\"readfragment\">readFragment</h3>\n\nThis method allows you great flexibility around the data in your cache. Whereas `readQuery` only allowed you to read data from your root query type, `readFragment` allows you to read data from _any node you have queried_. This is incredibly powerful. You use this method as follows:\n\n```js\nconst todo = client.readFragment({\n  id: ..., // `id` is any id that could be returned by `dataIdFromObject`.\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\nThe first argument is the id of the data you want to read from the cache. That id must be a value that was returned by the `dataIdFromObject` function you defined when initializing `ApolloClient`. So for example if you initialized `ApolloClient` like so:\n\n```js\nconst client = new ApolloClient({\n  ...,\n  dataIdFromObject: object => object.id,\n});\n```\n\n…and you requested a todo before with an id of `5`, then you can read that todo out of your cache with the following:\n\n```js\nconst todo = client.readFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\n> **Note:** Most people add a `__typename` to the id in `dataIdFromObject`. If you do this then don’t forget to add the `__typename` when you are reading a fragment as well. So for example your id may be `Todo_5` and not just `5`.\n\nIf a todo with that id does not exist in the cache you will get `null` back. If a todo of that id does exist in the cache, but that todo does not have the `text` field then an error will be thrown.\n\nThe beauty of `readFragment` is that the todo could have come from anywhere! The todo could have been selected as a singleton (`{ todo(id: 5) { ... } }`), the todo could have come from a list of todos (`{ todos { ... } }`), or the todo could have come from a mutation (`mutation { createTodo { ... } }`). As long as at some point your GraphQL server gave you a todo with the provided id and fields `id`, `text`, and `completed` you can read it from the cache at any part of your code.\n\n<h3 id=\"writequery-and-writefragment\">writeQuery` and `writeFragment</h3>\n\nNot only can you read arbitrary data from the Apollo Client cache, but you can also write any data that you would like to the cache. The methods you use to do this are `writeQuery` and `writeFragment`. They will allow you to change data in your local cache, but it is important to remember that *they will not change any data on your server*. If you reload your environment then changes made with `writeQuery` and `writeFragment` will disappear.\n\nThese methods have the same signature as their `readQuery` and `readFragment` counterparts except they also require an additional `data` variable. So for example, if you wanted to update the `completed` flag locally for your todo with id `'5'` you could execute the following:\n\n```js\nclient.writeFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      completed\n    }\n  `,\n  data: {\n    completed: true,\n  },\n});\n```\n\nAny subscriber to the Apollo Client store will instantly see this update and render new UI accordingly.\n\n> **Note:** Again, remember that using `writeQuery` or `writeFragment` only changes data *locally*. If you reload your environment then changes made with these methods will no longer exist.\n\nOr if you wanted to add a new todo to a list fetched from the server, you could use `readQuery` and `writeQuery` together.\n\n```js\nconst query = gql`\n  query MyTodoAppQuery {\n    todos {\n      id\n      text\n      completed\n    }\n  }\n`;\n\nconst data = client.readQuery({ query });\n\nconst myNewTodo = {\n  id: '6',\n  text: 'Start using Apollo Client.',\n  completed: false,\n};\n\nclient.writeQuery({\n  query,\n  data: {\n    todos: [...data.todos, myNewTodo],\n  },\n});\n```\n\n<h2 id=\"recipes\">Recipes</h2>\n\nHere are some common situations where you would need to access the cache directly. If you're manipulating the cache in an interesting way and would like your example to be featured, please send in a pull request!\n\n<h3 id=\"server\">Server side rendering</h3>\n\nFirst, you will need to initialize an `InMemoryCache` on the server and create an instance of `ApolloClient`. In the initial serialized HTML payload from the server, you should include a script tag that extracts the data from the cache.\n\n```js\n`<script>\n  window.__APOLLO_STATE__=${JSON.stringify(cache.extract())}\n</script>`\n```\n\nOn the client, you can rehydrate the cache using the initial data passed from the server:\n\n```js\ncache: new Cache().restore(window.__APOLLO_STATE__)\n```\n\nIf you would like to learn more about server side rendering, please check our our more in depth guide [here].\n<!---\nTODO (PEGGY): Add link to SSR\n-->\n\n<h3 id=\"server\">Updating the cache after a mutation</h3>\n\nBeing able to read and write to the Apollo cache from anywhere in your application gives you a lot of power over your data. However, there is one place where we most often want to update our cached data: after a mutation. As such, Apollo Client has optimized the experience for updating your cache with the read and write methods after a mutation with the `update` function. Let us say that we have the following GraphQL mutation:\n\n```graphql\nmutation TodoCreateMutation($text: String!) {\n  createTodo(text: $text) {\n    id\n    text\n    completed\n  }\n}\n```\n\nWe may also have the following GraphQL query:\n\n```graphql\nquery TodoAppQuery {\n  todos {\n    id\n    text\n    completed\n  }\n}\n```\n\nAt the end of our mutation we want our query to include the new todo like we had sent our `TodoAppQuery` a second time after the mutation finished without actually sending the query. To do this we can use the `update` function provided as an option of the `client.mutate` method. To update your cache with the mutation just write code that looks like:\n\n```js\n// We assume that the GraphQL operations `TodoCreateMutation` and\n// `TodoAppQuery` have already been defined using the `gql` tag.\n\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    // Read the data from our cache for this query.\n    const data = proxy.readQuery({ query: TodoAppQuery });\n\n    // Add our todo from the mutation to the end.\n    data.todos.push(createTodo);\n\n    // Write our data back to the cache.\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nThe first `proxy` argument is an instance of [`DataProxy`][] has the same four methods that we just learned exist on the Apollo Client: `readQuery`, `readFragment`, `writeQuery`, and `writeFragment`. The reason we call them on a `proxy` object here instead of on our `client` instance is that we can easily apply optimistic updates (which we will demonstrate in a bit). The `proxy` object also provides an isolated transaction which shields you from any other mutations going on at the same time, and the `proxy` object also batches writes together until the very end.\n\nIf you provide an `optimisticResponse` option to the mutation then the `update` function will be run twice. Once immediately after you call `client.mutate` with the data from `optimisticResponse`. After the mutation successfully executes against the server the changes made in the first call to `update` will be rolled back and `update` will be called with the *actual* data returned by the mutation and not just the optimistic response.\n\nPutting it all together:\n\n```js\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  optimisticResponse: {\n    id: -1, // -1 is a temporary id for the optimistic response.\n    text,\n    completed: false,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    const data = proxy.readQuery({ query: TodoAppQuery });\n    data.todos.push(createTodo);\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nAs you can see the `update` function on `client.mutate` provides extra change management functionality specific to the use case of a mutation while still providing you the powerful data control APIs that are available on `client`.\n\nThe `update` function is not a good place for side-effects as it may be called multiple times. Also, you may not call any of the methods on `proxy` asynchronously.\n\n",
      "readmeFilename": "README.md",
      "_id": "apollo-cache-inmemory@1.3.1-local-state-alpha.6",
      "_npmVersion": "6.4.1",
      "_nodeVersion": "8.12.0",
      "_npmUser": {
        "name": "apollo-bot",
        "email": "npm@apollographql.com"
      },
      "dist": {
        "integrity": "sha512-4rHduu2A3gtChBCCdQZJ8+v+xEcYXKytckt4+ByUxDuYqRfcmajZvmg99C5E5a85XTQCyTX6DSaNcBEy4gVFQg==",
        "shasum": "794ba0ba14a36010a3fa3488de5c5bcd17c55a80",
        "tarball": "https://registry.npmjs.org/apollo-cache-inmemory/-/apollo-cache-inmemory-1.3.1-local-state-alpha.6.tgz",
        "fileCount": 84,
        "unpackedSize": 510406,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJbuinzCRA9TVsSAnZWagAAtwcP/17QQ8cOxjZhc7713Zz5\nJULsBY6dNfx3zTVxEAB0hUeSiTW+zg7wf1VjEUDYFR2DtKphZO1nAIhLpdlR\nhDOm8Q168iSQcwg8ZCnrXkKfSpel8n+SRBOHo5KQW8celNDdAV0IuPdhxEFX\nEVg/duSlaH96FLvzf7ODxAZl+beY0/mfCkCEdO4C21e4fRftk98ItD3U1Ppl\nNybx5BRQrAtvZ4L/egoXkqVBabmueacwn86cqFu9KriXDtVN1oe0Oenluf/9\n/Ciptygzf1SF5wuJ3x2dzyNnhphgz2cjPgi7K3QljErtlTpwUqsx9jLQ5mcG\nJzq+J3jJAgim7lktGcqVOVvDohWkw4/oB99cBpMkj4Bwl6Ty5o2SZu+lYK8b\n+KhLuJokzsZBQyUA+r+xrEaC37QqpCHcV+E+JHr/UZ1lwACetkt5uPJKjjUD\nWx6dJr3y3whaIlFPTELINSXaKus+SAdLF/a9zzh/8G7PDZsr7LcL+WO0tChV\nIb4igZfZgCsrGDYTAkxedvfbKgW06aOzSDejXngVHPAefUwp4FBfhm4BbzEJ\nJ4zvkHmRk/QXEwf4/ck+hFNcYwbU2PZAXn1bLHgKNG7gHk+278+MeB0pDvps\ndQdkfd8F8HL57iryAMBgJKsnEQFVrHWd5JEaT76J14YuFVRjgsXJ0EOUJsNx\nzMrW\r\n=wVes\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEYCIQCeuBdZZtTgWHVPmyC7Diyevu4gn4iq8zKqadgqhH8bdgIhAMm0HsztqMBtGMCe/LgQxwD7qSRuNJAUqgbPC3vy22Gq"
          }
        ]
      },
      "maintainers": [
        {
          "email": "npm@apollographql.com",
          "name": "apollo-bot"
        },
        {
          "email": "ben@benjamn.com",
          "name": "benjamn"
        },
        {
          "email": "james@meteor.com",
          "name": "jbaxleyiii"
        },
        {
          "email": "peggyrayzis@gmail.com",
          "name": "peggyrayzis"
        }
      ],
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/apollo-cache-inmemory_1.3.1-local-state-alpha.6_1538927090449_0.0842804552987293"
      },
      "_hasShrinkwrap": false
    },
    "1.3.1-local-state-alpha.7": {
      "name": "apollo-cache-inmemory",
      "version": "1.3.1-local-state-alpha.7",
      "description": "Core abstract of Caching layer for Apollo Client",
      "author": {
        "name": "James Baxley",
        "email": "james@meteor.com"
      },
      "contributors": [
        {
          "name": "James Baxley",
          "email": "james@meteor.com"
        },
        {
          "name": "Jonas Helfer",
          "email": "jonas@helfer.email"
        },
        {
          "name": "Sashko Stubailo",
          "email": "sashko@stubailo.com"
        },
        {
          "name": "James Burgess",
          "email": "jamesmillerburgess@gmail.com"
        },
        {
          "name": "Bazyli Brzóska",
          "email": "bazyli.brzoska@gmail.com"
        }
      ],
      "license": "MIT",
      "main": "./lib/bundle.umd.js",
      "module": "./lib/index.js",
      "jsnext:main": "./lib/index.js",
      "typings": "./lib/index.d.ts",
      "sideEffects": false,
      "repository": {
        "type": "git",
        "url": "git+https://github.com/apollographql/apollo-client.git"
      },
      "bugs": {
        "url": "https://github.com/apollographql/apollo-client/issues"
      },
      "homepage": "https://github.com/apollographql/apollo-client#readme",
      "scripts": {
        "prepare": "npm run build",
        "coverage": "jest --coverage",
        "test": "jest",
        "lint": "tslint -c \"../../config/tslint.json\" -p tsconfig.json src/*.ts",
        "prebuild": "npm run clean",
        "build": "tsc -p .",
        "postbuild": "npm run bundle",
        "bundle": "../../node_modules/rollup/bin/rollup -c rollup.config.js",
        "watch": "tsc -w -p .",
        "clean": "rm -rf coverage/* && rm -rf lib/*",
        "prepublishOnly": "npm run build",
        "minify": "../../node_modules/uglify-js/bin/uglifyjs -c -m -o ./lib/bundle.min.js -- ./lib/bundle.umd.js",
        "filesize": "npm run minify"
      },
      "dependencies": {
        "apollo-cache": "^1.1.18-local-state-alpha.7",
        "apollo-utilities": "^1.0.22-local-state-alpha.7",
        "optimism": "^0.6.6"
      },
      "peerDependencies": {
        "graphql": "0.11.7 || ^0.12.0 || ^0.13.0"
      },
      "jest": {
        "transform": {
          ".(ts|tsx)": "ts-jest"
        },
        "testRegex": "(/__tests__/.*|\\.(test|spec))\\.(ts|tsx|js)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "json"
        ],
        "testURL": "http://localhost"
      },
      "gitHead": "2a872426024b3b647212d4d4ade273efac689a5d",
      "_resolved": "",
      "_integrity": "",
      "_from": "file:apollo-cache-inmemory-1.3.1-local-state-alpha.7.tgz",
      "readme": "---\ntitle: InMemoryCache\ndescription: An explanation of `apollo-cache-inmemory`\n---\n\n`apollo-cache-inmemory` is the recommended cache implementation for Apollo Client 2.0. `InMemoryCache` is a normalized data store that supports all of Apollo Client 1.0's features without the dependency on Redux.\n\nIn some instances, you may need to manipulate the cache directly, such as updating the store after a mutation. We'll cover some common use cases [here](#recipes).\n\n<h2 id=\"installation\">Installation</h2>\n\n```\nnpm install apollo-cache-inmemory --save\n```\n\nAfter installing the package, you'll want to initialize the cache constructor. Then, you can pass in your newly created cache to ApolloClient.\n\n```js\nimport { InMemoryCache } from 'apollo-cache-inmemory';\nimport { HttpLink } from 'apollo-link-http';\nimport ApolloClient from 'apollo-client';\n\nconst cache = new InMemoryCache();\n\nconst client = new ApolloClient({\n  link: new HttpLink(),\n  cache\n});\n```\n\n<h2 id=\"configuration\">Configuration</h2>\n\nThe `InMemoryCache` constructor takes an optional config object with properties to customize your cache:\n\n- addTypename: A boolean to determine whether to add __typename to the document (default: `true`)\n- dataIdFromObject: A function that takes a data object and returns a unique identifier to be used when normalizing the data in the store. Learn more about how to customize `dataIdFromObject` in the [Normalization](#normalization) section.\n- fragmentMatcher: By default, the `InMemoryCache` uses a heuristic fragment matcher. If you are using fragments on unions and interfaces, you will need to use an `IntrospectionFragmentMatcher`. For more information, please read [our guide to setting up fragment matching for unions & interfaces](https://www.apollographql.com/docs/react/advanced/fragments.html#fragment-matcher).\n\n<h2 id=\"normalization\">Normalization</h2>\n\nThe `InMemoryCache` normalizes your data before saving it to the store by splitting the result into individual objects, creating a unique identifier for each object, and storing those objects in a flattened data structure. By default, `InMemoryCache` will attempt to use the commonly found primary keys of `id` and `_id` for the unique identifier if they exist along with `__typename` on an object.\n\nIf `id` and `_id` are not specified, or if `__typename` is not specified, `InMemoryCache` will fall back to the path to the object in the query, such as `ROOT_QUERY.allPeople.0` for the first record returned on the `allPeople` root query.\n\nThis \"getter\" behavior for unique identifiers can be configured manually via the `dataIdFromObject` option passed to the `InMemoryCache` constructor, so you can pick which field is used if some of your data follows unorthodox primary key conventions.\n\nFor example, if you wanted to key off of the `key` field for all of your data, you could configure `dataIdFromObject` like so:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => object.key\n});\n```\n\nThis also allows you to use different unique identifiers for different data types by keying off of the `__typename` property attached to every object typed by GraphQL.  For example:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => {\n    switch (object.__typename) {\n      case 'foo': return object.key; // use `key` as the primary key\n      case 'bar': return object.blah; // use `blah` as the priamry key\n      default: return object.id || object._id; // fall back to `id` and `_id` for all other types\n    }\n  }\n});\n```\n\n<h2 id=\"direct\">Direct Cache Access</h2>\n\nTo interact directly with your cache, you can use the Apollo Client class methods readQuery, readFragment, writeQuery, and writeFragment. These methods are available to us via the [`DataProxy` interface](https://github.com/apollographql/apollo-client/blob/master/packages/apollo-cache/src/types/DataProxy.ts). Accessing these methods will vary slightly based on your view layer implementation. If you are using React, you can wrap your component in the `withApollo` higher order component, which will give you access to `this.props.client`. From there, you can use the methods to control your data.\n\nAny code demonstration in the following sections will assume that we have already initialized an instance of  `ApolloClient` and that we have imported the `gql` tag from `graphql-tag`.\n\n<h3 id=\"readquery\">readQuery</h3>\n\nThe `readQuery` method is very similar to the [`query` method on `ApolloClient`][] except that `readQuery` will _never_ make a request to your GraphQL server. The `query` method, on the other hand, may send a request to your server if the appropriate data is not in your cache whereas `readQuery` will throw an error if the data is not in your cache. `readQuery` will _always_ read from the cache. You can use `readQuery` by giving it a GraphQL query like so:\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo {\n      todo(id: 5) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n});\n```\n\nIf all of the data needed to fulfill this read is in Apollo Client’s normalized data cache then a data object will be returned in the shape of the query you wanted to read. If not all of the data needed to fulfill this read is in Apollo Client’s cache then an error will be thrown instead, so make sure to only read data that you know you have!\n\nYou can also pass variables into `readQuery`.\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo($id: Int!) {\n      todo(id: $id) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n  variables: {\n    id: 5,\n  },\n});\n```\n\n<h3 id=\"readfragment\">readFragment</h3>\n\nThis method allows you great flexibility around the data in your cache. Whereas `readQuery` only allowed you to read data from your root query type, `readFragment` allows you to read data from _any node you have queried_. This is incredibly powerful. You use this method as follows:\n\n```js\nconst todo = client.readFragment({\n  id: ..., // `id` is any id that could be returned by `dataIdFromObject`.\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\nThe first argument is the id of the data you want to read from the cache. That id must be a value that was returned by the `dataIdFromObject` function you defined when initializing `ApolloClient`. So for example if you initialized `ApolloClient` like so:\n\n```js\nconst client = new ApolloClient({\n  ...,\n  dataIdFromObject: object => object.id,\n});\n```\n\n…and you requested a todo before with an id of `5`, then you can read that todo out of your cache with the following:\n\n```js\nconst todo = client.readFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\n> **Note:** Most people add a `__typename` to the id in `dataIdFromObject`. If you do this then don’t forget to add the `__typename` when you are reading a fragment as well. So for example your id may be `Todo_5` and not just `5`.\n\nIf a todo with that id does not exist in the cache you will get `null` back. If a todo of that id does exist in the cache, but that todo does not have the `text` field then an error will be thrown.\n\nThe beauty of `readFragment` is that the todo could have come from anywhere! The todo could have been selected as a singleton (`{ todo(id: 5) { ... } }`), the todo could have come from a list of todos (`{ todos { ... } }`), or the todo could have come from a mutation (`mutation { createTodo { ... } }`). As long as at some point your GraphQL server gave you a todo with the provided id and fields `id`, `text`, and `completed` you can read it from the cache at any part of your code.\n\n<h3 id=\"writequery-and-writefragment\">writeQuery` and `writeFragment</h3>\n\nNot only can you read arbitrary data from the Apollo Client cache, but you can also write any data that you would like to the cache. The methods you use to do this are `writeQuery` and `writeFragment`. They will allow you to change data in your local cache, but it is important to remember that *they will not change any data on your server*. If you reload your environment then changes made with `writeQuery` and `writeFragment` will disappear.\n\nThese methods have the same signature as their `readQuery` and `readFragment` counterparts except they also require an additional `data` variable. So for example, if you wanted to update the `completed` flag locally for your todo with id `'5'` you could execute the following:\n\n```js\nclient.writeFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      completed\n    }\n  `,\n  data: {\n    completed: true,\n  },\n});\n```\n\nAny subscriber to the Apollo Client store will instantly see this update and render new UI accordingly.\n\n> **Note:** Again, remember that using `writeQuery` or `writeFragment` only changes data *locally*. If you reload your environment then changes made with these methods will no longer exist.\n\nOr if you wanted to add a new todo to a list fetched from the server, you could use `readQuery` and `writeQuery` together.\n\n```js\nconst query = gql`\n  query MyTodoAppQuery {\n    todos {\n      id\n      text\n      completed\n    }\n  }\n`;\n\nconst data = client.readQuery({ query });\n\nconst myNewTodo = {\n  id: '6',\n  text: 'Start using Apollo Client.',\n  completed: false,\n};\n\nclient.writeQuery({\n  query,\n  data: {\n    todos: [...data.todos, myNewTodo],\n  },\n});\n```\n\n<h2 id=\"recipes\">Recipes</h2>\n\nHere are some common situations where you would need to access the cache directly. If you're manipulating the cache in an interesting way and would like your example to be featured, please send in a pull request!\n\n<h3 id=\"server\">Server side rendering</h3>\n\nFirst, you will need to initialize an `InMemoryCache` on the server and create an instance of `ApolloClient`. In the initial serialized HTML payload from the server, you should include a script tag that extracts the data from the cache.\n\n```js\n`<script>\n  window.__APOLLO_STATE__=${JSON.stringify(cache.extract())}\n</script>`\n```\n\nOn the client, you can rehydrate the cache using the initial data passed from the server:\n\n```js\ncache: new Cache().restore(window.__APOLLO_STATE__)\n```\n\nIf you would like to learn more about server side rendering, please check our our more in depth guide [here].\n<!---\nTODO (PEGGY): Add link to SSR\n-->\n\n<h3 id=\"server\">Updating the cache after a mutation</h3>\n\nBeing able to read and write to the Apollo cache from anywhere in your application gives you a lot of power over your data. However, there is one place where we most often want to update our cached data: after a mutation. As such, Apollo Client has optimized the experience for updating your cache with the read and write methods after a mutation with the `update` function. Let us say that we have the following GraphQL mutation:\n\n```graphql\nmutation TodoCreateMutation($text: String!) {\n  createTodo(text: $text) {\n    id\n    text\n    completed\n  }\n}\n```\n\nWe may also have the following GraphQL query:\n\n```graphql\nquery TodoAppQuery {\n  todos {\n    id\n    text\n    completed\n  }\n}\n```\n\nAt the end of our mutation we want our query to include the new todo like we had sent our `TodoAppQuery` a second time after the mutation finished without actually sending the query. To do this we can use the `update` function provided as an option of the `client.mutate` method. To update your cache with the mutation just write code that looks like:\n\n```js\n// We assume that the GraphQL operations `TodoCreateMutation` and\n// `TodoAppQuery` have already been defined using the `gql` tag.\n\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    // Read the data from our cache for this query.\n    const data = proxy.readQuery({ query: TodoAppQuery });\n\n    // Add our todo from the mutation to the end.\n    data.todos.push(createTodo);\n\n    // Write our data back to the cache.\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nThe first `proxy` argument is an instance of [`DataProxy`][] has the same four methods that we just learned exist on the Apollo Client: `readQuery`, `readFragment`, `writeQuery`, and `writeFragment`. The reason we call them on a `proxy` object here instead of on our `client` instance is that we can easily apply optimistic updates (which we will demonstrate in a bit). The `proxy` object also provides an isolated transaction which shields you from any other mutations going on at the same time, and the `proxy` object also batches writes together until the very end.\n\nIf you provide an `optimisticResponse` option to the mutation then the `update` function will be run twice. Once immediately after you call `client.mutate` with the data from `optimisticResponse`. After the mutation successfully executes against the server the changes made in the first call to `update` will be rolled back and `update` will be called with the *actual* data returned by the mutation and not just the optimistic response.\n\nPutting it all together:\n\n```js\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  optimisticResponse: {\n    id: -1, // -1 is a temporary id for the optimistic response.\n    text,\n    completed: false,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    const data = proxy.readQuery({ query: TodoAppQuery });\n    data.todos.push(createTodo);\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nAs you can see the `update` function on `client.mutate` provides extra change management functionality specific to the use case of a mutation while still providing you the powerful data control APIs that are available on `client`.\n\nThe `update` function is not a good place for side-effects as it may be called multiple times. Also, you may not call any of the methods on `proxy` asynchronously.\n\n",
      "readmeFilename": "README.md",
      "_id": "apollo-cache-inmemory@1.3.1-local-state-alpha.7",
      "_npmVersion": "6.4.1",
      "_nodeVersion": "8.12.0",
      "_npmUser": {
        "name": "apollo-bot",
        "email": "npm@apollographql.com"
      },
      "dist": {
        "integrity": "sha512-GrxMPV3ITYqJuPAyEH3qNoQati7MyqYm8K25y0QP5Az99LU4s0SRiOweUcs1XjYM6buL/qgDlnwLQJWGeLe+5g==",
        "shasum": "13d86eb472faaf61777668b6865ccf2f9763eb18",
        "tarball": "https://registry.npmjs.org/apollo-cache-inmemory/-/apollo-cache-inmemory-1.3.1-local-state-alpha.7.tgz",
        "fileCount": 84,
        "unpackedSize": 510406,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJbvPkkCRA9TVsSAnZWagAArqkP/jxvEQiaED/guGdS5ME+\n3kyrhEKCR/yXKWXIPIOixYAog9S3jKBhTWg0gR2GMEMD+4IAHCaMJHLUAnLO\ndCSSe9xYFKQyC6PruEe7GNZoPjOMGVg6vd6Xss9byc/6GqCmAvKMFt59A+Ez\nFuhfv6AE1DXvdJsrMOvlbKKPCGX0/tUI0dzKTJyIdOiE0ZHIwt56PMmC2kl8\nG36yACEX2PBnSALX5fPSyU9BdYrhuQhyJvDO+MSIYpUadGr5SdfUaE3vy9oe\n0A74e5uH21WdmQZ3VtwH9CICNFNzkbHrNBLqq2yXNN2hjwtZk8fJIjbcaSss\nV2W9ij3VVhZL66KCjECNs9wNWjV7FcftoSThIpfviI6+1CWQ8gfIid9V52cz\ntGyLhDp2KKSQZXNqBDLn4gSrwKgBJn+Eir3T5kIx1QLp0sc3RHLw0fxKUqpI\nqDn3qyUNVnAMbKkUA7IRuM+hV0kqrVUh7kaZFnAV9rauYP69aegwrRaYVCpc\ncVBigyGtKmqPvEL5922PicnqZkT+oVRPeAZAoCM1jSSycqio+hJ2lU7m48ch\n9FVLHCC7yOKi7OZrCn7zCz9XPpqDZO80ukLApf3ZMi6QMr6ZrkuM74s1ontp\nju1PHjcst+tZvOLvjObppP/VuB6O6Asmmy1m8pZL5vNGqkYvcbP9WEBTiOFu\nGSvO\r\n=xuzx\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIQDsfKaXMLMDGxETA5Aj/gGfHtYRc6NEBHyO6okimp0DqQIgG2wfmF/QkK/iVoaEuv4xWzE9Jp8j/fZzpbTh91l8Tjo="
          }
        ]
      },
      "maintainers": [
        {
          "email": "npm@apollographql.com",
          "name": "apollo-bot"
        },
        {
          "email": "ben@benjamn.com",
          "name": "benjamn"
        },
        {
          "email": "james@meteor.com",
          "name": "jbaxleyiii"
        },
        {
          "email": "peggyrayzis@gmail.com",
          "name": "peggyrayzis"
        }
      ],
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/apollo-cache-inmemory_1.3.1-local-state-alpha.7_1539111204103_0.8540934785055048"
      },
      "_hasShrinkwrap": false
    },
    "1.3.1-local-state-alpha.8": {
      "name": "apollo-cache-inmemory",
      "version": "1.3.1-local-state-alpha.8",
      "description": "Core abstract of Caching layer for Apollo Client",
      "author": {
        "name": "James Baxley",
        "email": "james@meteor.com"
      },
      "contributors": [
        {
          "name": "James Baxley",
          "email": "james@meteor.com"
        },
        {
          "name": "Jonas Helfer",
          "email": "jonas@helfer.email"
        },
        {
          "name": "Sashko Stubailo",
          "email": "sashko@stubailo.com"
        },
        {
          "name": "James Burgess",
          "email": "jamesmillerburgess@gmail.com"
        },
        {
          "name": "Bazyli Brzóska",
          "email": "bazyli.brzoska@gmail.com"
        }
      ],
      "license": "MIT",
      "main": "./lib/bundle.umd.js",
      "module": "./lib/index.js",
      "jsnext:main": "./lib/index.js",
      "typings": "./lib/index.d.ts",
      "sideEffects": false,
      "repository": {
        "type": "git",
        "url": "git+https://github.com/apollographql/apollo-client.git"
      },
      "bugs": {
        "url": "https://github.com/apollographql/apollo-client/issues"
      },
      "homepage": "https://github.com/apollographql/apollo-client#readme",
      "scripts": {
        "prepare": "npm run build",
        "coverage": "jest --coverage",
        "test": "jest",
        "lint": "tslint -c \"../../config/tslint.json\" -p tsconfig.json src/*.ts",
        "prebuild": "npm run clean",
        "build": "tsc -p .",
        "postbuild": "npm run bundle",
        "bundle": "../../node_modules/rollup/bin/rollup -c rollup.config.js",
        "watch": "tsc -w -p .",
        "clean": "rm -rf coverage/* && rm -rf lib/*",
        "prepublishOnly": "npm run build",
        "minify": "../../node_modules/uglify-js/bin/uglifyjs -c -m -o ./lib/bundle.min.js -- ./lib/bundle.umd.js",
        "filesize": "npm run minify"
      },
      "dependencies": {
        "apollo-cache": "^1.1.18-local-state-alpha.8",
        "apollo-utilities": "^1.0.22-local-state-alpha.8",
        "optimism": "^0.6.6"
      },
      "peerDependencies": {
        "graphql": "0.11.7 || ^0.12.0 || ^0.13.0"
      },
      "jest": {
        "transform": {
          ".(ts|tsx)": "ts-jest"
        },
        "testRegex": "(/__tests__/.*|\\.(test|spec))\\.(ts|tsx|js)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "json"
        ],
        "testURL": "http://localhost"
      },
      "gitHead": "f2b76919d190b65c73256220e3331228bb8a8b72",
      "_resolved": "",
      "_integrity": "",
      "_from": "file:apollo-cache-inmemory-1.3.1-local-state-alpha.8.tgz",
      "readme": "---\ntitle: InMemoryCache\ndescription: An explanation of `apollo-cache-inmemory`\n---\n\n`apollo-cache-inmemory` is the recommended cache implementation for Apollo Client 2.0. `InMemoryCache` is a normalized data store that supports all of Apollo Client 1.0's features without the dependency on Redux.\n\nIn some instances, you may need to manipulate the cache directly, such as updating the store after a mutation. We'll cover some common use cases [here](#recipes).\n\n<h2 id=\"installation\">Installation</h2>\n\n```\nnpm install apollo-cache-inmemory --save\n```\n\nAfter installing the package, you'll want to initialize the cache constructor. Then, you can pass in your newly created cache to ApolloClient.\n\n```js\nimport { InMemoryCache } from 'apollo-cache-inmemory';\nimport { HttpLink } from 'apollo-link-http';\nimport ApolloClient from 'apollo-client';\n\nconst cache = new InMemoryCache();\n\nconst client = new ApolloClient({\n  link: new HttpLink(),\n  cache\n});\n```\n\n<h2 id=\"configuration\">Configuration</h2>\n\nThe `InMemoryCache` constructor takes an optional config object with properties to customize your cache:\n\n- addTypename: A boolean to determine whether to add __typename to the document (default: `true`)\n- dataIdFromObject: A function that takes a data object and returns a unique identifier to be used when normalizing the data in the store. Learn more about how to customize `dataIdFromObject` in the [Normalization](#normalization) section.\n- fragmentMatcher: By default, the `InMemoryCache` uses a heuristic fragment matcher. If you are using fragments on unions and interfaces, you will need to use an `IntrospectionFragmentMatcher`. For more information, please read [our guide to setting up fragment matching for unions & interfaces](https://www.apollographql.com/docs/react/advanced/fragments.html#fragment-matcher).\n\n<h2 id=\"normalization\">Normalization</h2>\n\nThe `InMemoryCache` normalizes your data before saving it to the store by splitting the result into individual objects, creating a unique identifier for each object, and storing those objects in a flattened data structure. By default, `InMemoryCache` will attempt to use the commonly found primary keys of `id` and `_id` for the unique identifier if they exist along with `__typename` on an object.\n\nIf `id` and `_id` are not specified, or if `__typename` is not specified, `InMemoryCache` will fall back to the path to the object in the query, such as `ROOT_QUERY.allPeople.0` for the first record returned on the `allPeople` root query.\n\nThis \"getter\" behavior for unique identifiers can be configured manually via the `dataIdFromObject` option passed to the `InMemoryCache` constructor, so you can pick which field is used if some of your data follows unorthodox primary key conventions.\n\nFor example, if you wanted to key off of the `key` field for all of your data, you could configure `dataIdFromObject` like so:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => object.key\n});\n```\n\nThis also allows you to use different unique identifiers for different data types by keying off of the `__typename` property attached to every object typed by GraphQL.  For example:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => {\n    switch (object.__typename) {\n      case 'foo': return object.key; // use `key` as the primary key\n      case 'bar': return object.blah; // use `blah` as the priamry key\n      default: return object.id || object._id; // fall back to `id` and `_id` for all other types\n    }\n  }\n});\n```\n\n<h2 id=\"direct\">Direct Cache Access</h2>\n\nTo interact directly with your cache, you can use the Apollo Client class methods readQuery, readFragment, writeQuery, and writeFragment. These methods are available to us via the [`DataProxy` interface](https://github.com/apollographql/apollo-client/blob/master/packages/apollo-cache/src/types/DataProxy.ts). Accessing these methods will vary slightly based on your view layer implementation. If you are using React, you can wrap your component in the `withApollo` higher order component, which will give you access to `this.props.client`. From there, you can use the methods to control your data.\n\nAny code demonstration in the following sections will assume that we have already initialized an instance of  `ApolloClient` and that we have imported the `gql` tag from `graphql-tag`.\n\n<h3 id=\"readquery\">readQuery</h3>\n\nThe `readQuery` method is very similar to the [`query` method on `ApolloClient`][] except that `readQuery` will _never_ make a request to your GraphQL server. The `query` method, on the other hand, may send a request to your server if the appropriate data is not in your cache whereas `readQuery` will throw an error if the data is not in your cache. `readQuery` will _always_ read from the cache. You can use `readQuery` by giving it a GraphQL query like so:\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo {\n      todo(id: 5) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n});\n```\n\nIf all of the data needed to fulfill this read is in Apollo Client’s normalized data cache then a data object will be returned in the shape of the query you wanted to read. If not all of the data needed to fulfill this read is in Apollo Client’s cache then an error will be thrown instead, so make sure to only read data that you know you have!\n\nYou can also pass variables into `readQuery`.\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo($id: Int!) {\n      todo(id: $id) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n  variables: {\n    id: 5,\n  },\n});\n```\n\n<h3 id=\"readfragment\">readFragment</h3>\n\nThis method allows you great flexibility around the data in your cache. Whereas `readQuery` only allowed you to read data from your root query type, `readFragment` allows you to read data from _any node you have queried_. This is incredibly powerful. You use this method as follows:\n\n```js\nconst todo = client.readFragment({\n  id: ..., // `id` is any id that could be returned by `dataIdFromObject`.\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\nThe first argument is the id of the data you want to read from the cache. That id must be a value that was returned by the `dataIdFromObject` function you defined when initializing `ApolloClient`. So for example if you initialized `ApolloClient` like so:\n\n```js\nconst client = new ApolloClient({\n  ...,\n  dataIdFromObject: object => object.id,\n});\n```\n\n…and you requested a todo before with an id of `5`, then you can read that todo out of your cache with the following:\n\n```js\nconst todo = client.readFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\n> **Note:** Most people add a `__typename` to the id in `dataIdFromObject`. If you do this then don’t forget to add the `__typename` when you are reading a fragment as well. So for example your id may be `Todo_5` and not just `5`.\n\nIf a todo with that id does not exist in the cache you will get `null` back. If a todo of that id does exist in the cache, but that todo does not have the `text` field then an error will be thrown.\n\nThe beauty of `readFragment` is that the todo could have come from anywhere! The todo could have been selected as a singleton (`{ todo(id: 5) { ... } }`), the todo could have come from a list of todos (`{ todos { ... } }`), or the todo could have come from a mutation (`mutation { createTodo { ... } }`). As long as at some point your GraphQL server gave you a todo with the provided id and fields `id`, `text`, and `completed` you can read it from the cache at any part of your code.\n\n<h3 id=\"writequery-and-writefragment\">writeQuery` and `writeFragment</h3>\n\nNot only can you read arbitrary data from the Apollo Client cache, but you can also write any data that you would like to the cache. The methods you use to do this are `writeQuery` and `writeFragment`. They will allow you to change data in your local cache, but it is important to remember that *they will not change any data on your server*. If you reload your environment then changes made with `writeQuery` and `writeFragment` will disappear.\n\nThese methods have the same signature as their `readQuery` and `readFragment` counterparts except they also require an additional `data` variable. So for example, if you wanted to update the `completed` flag locally for your todo with id `'5'` you could execute the following:\n\n```js\nclient.writeFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      completed\n    }\n  `,\n  data: {\n    completed: true,\n  },\n});\n```\n\nAny subscriber to the Apollo Client store will instantly see this update and render new UI accordingly.\n\n> **Note:** Again, remember that using `writeQuery` or `writeFragment` only changes data *locally*. If you reload your environment then changes made with these methods will no longer exist.\n\nOr if you wanted to add a new todo to a list fetched from the server, you could use `readQuery` and `writeQuery` together.\n\n```js\nconst query = gql`\n  query MyTodoAppQuery {\n    todos {\n      id\n      text\n      completed\n    }\n  }\n`;\n\nconst data = client.readQuery({ query });\n\nconst myNewTodo = {\n  id: '6',\n  text: 'Start using Apollo Client.',\n  completed: false,\n};\n\nclient.writeQuery({\n  query,\n  data: {\n    todos: [...data.todos, myNewTodo],\n  },\n});\n```\n\n<h2 id=\"recipes\">Recipes</h2>\n\nHere are some common situations where you would need to access the cache directly. If you're manipulating the cache in an interesting way and would like your example to be featured, please send in a pull request!\n\n<h3 id=\"server\">Server side rendering</h3>\n\nFirst, you will need to initialize an `InMemoryCache` on the server and create an instance of `ApolloClient`. In the initial serialized HTML payload from the server, you should include a script tag that extracts the data from the cache.\n\n```js\n`<script>\n  window.__APOLLO_STATE__=${JSON.stringify(cache.extract())}\n</script>`\n```\n\nOn the client, you can rehydrate the cache using the initial data passed from the server:\n\n```js\ncache: new Cache().restore(window.__APOLLO_STATE__)\n```\n\nIf you would like to learn more about server side rendering, please check our our more in depth guide [here].\n<!---\nTODO (PEGGY): Add link to SSR\n-->\n\n<h3 id=\"server\">Updating the cache after a mutation</h3>\n\nBeing able to read and write to the Apollo cache from anywhere in your application gives you a lot of power over your data. However, there is one place where we most often want to update our cached data: after a mutation. As such, Apollo Client has optimized the experience for updating your cache with the read and write methods after a mutation with the `update` function. Let us say that we have the following GraphQL mutation:\n\n```graphql\nmutation TodoCreateMutation($text: String!) {\n  createTodo(text: $text) {\n    id\n    text\n    completed\n  }\n}\n```\n\nWe may also have the following GraphQL query:\n\n```graphql\nquery TodoAppQuery {\n  todos {\n    id\n    text\n    completed\n  }\n}\n```\n\nAt the end of our mutation we want our query to include the new todo like we had sent our `TodoAppQuery` a second time after the mutation finished without actually sending the query. To do this we can use the `update` function provided as an option of the `client.mutate` method. To update your cache with the mutation just write code that looks like:\n\n```js\n// We assume that the GraphQL operations `TodoCreateMutation` and\n// `TodoAppQuery` have already been defined using the `gql` tag.\n\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    // Read the data from our cache for this query.\n    const data = proxy.readQuery({ query: TodoAppQuery });\n\n    // Add our todo from the mutation to the end.\n    data.todos.push(createTodo);\n\n    // Write our data back to the cache.\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nThe first `proxy` argument is an instance of [`DataProxy`][] has the same four methods that we just learned exist on the Apollo Client: `readQuery`, `readFragment`, `writeQuery`, and `writeFragment`. The reason we call them on a `proxy` object here instead of on our `client` instance is that we can easily apply optimistic updates (which we will demonstrate in a bit). The `proxy` object also provides an isolated transaction which shields you from any other mutations going on at the same time, and the `proxy` object also batches writes together until the very end.\n\nIf you provide an `optimisticResponse` option to the mutation then the `update` function will be run twice. Once immediately after you call `client.mutate` with the data from `optimisticResponse`. After the mutation successfully executes against the server the changes made in the first call to `update` will be rolled back and `update` will be called with the *actual* data returned by the mutation and not just the optimistic response.\n\nPutting it all together:\n\n```js\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  optimisticResponse: {\n    id: -1, // -1 is a temporary id for the optimistic response.\n    text,\n    completed: false,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    const data = proxy.readQuery({ query: TodoAppQuery });\n    data.todos.push(createTodo);\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nAs you can see the `update` function on `client.mutate` provides extra change management functionality specific to the use case of a mutation while still providing you the powerful data control APIs that are available on `client`.\n\nThe `update` function is not a good place for side-effects as it may be called multiple times. Also, you may not call any of the methods on `proxy` asynchronously.\n\n",
      "readmeFilename": "README.md",
      "_id": "apollo-cache-inmemory@1.3.1-local-state-alpha.8",
      "_npmVersion": "6.4.1",
      "_nodeVersion": "8.12.0",
      "_npmUser": {
        "name": "apollo-bot",
        "email": "npm@apollographql.com"
      },
      "dist": {
        "integrity": "sha512-UDeCAGeZBui4BihJjscMKKOxNNYbig4T4a6DEkSyB3GCNMy9ns+8iWfOqNmDZuXNgvpb+ieIa7UpqbhbG1VP8w==",
        "shasum": "9249bce61cf66bdb2e24631f214de8f26b334331",
        "tarball": "https://registry.npmjs.org/apollo-cache-inmemory/-/apollo-cache-inmemory-1.3.1-local-state-alpha.8.tgz",
        "fileCount": 84,
        "unpackedSize": 510406,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJbvRCTCRA9TVsSAnZWagAAJVQP+wXTd4vMJTEVGQyNOK4E\nYcf4lcHs17qqIk6W5nnoa86Vqw9lpdjatsq/htvTr/C+zSzmN5FPdnowAjxJ\nDr3rUW9fbyLp/2JxkyVTS7AOI/fKBGXPacILYwHdHE0VSThIgvWX50zYLC1c\nB0i7Ktj3DhaJ4U2mUefGNnaRi2djS3G2JRwpPD0sTQfslEoE34qTmh6BhHsS\nY5mXydae9xicbqf8OTvUM4q1nzd3QuiC7Nljh5B0HPhruOWpOrRuUjFcaQuw\nTjwErGgA9WvFIy/mVI6yirJg8JdsiqaT8ix2wXv7lqkdU11ww/EolrwxqkHZ\nL2FpSoT/j2FBL3DcyY4cmJsmIZg8oT3oKOEbSWX4HZW1vp9b7GLlqkfnAZM0\ntIwh59lKZviFahU9Eaz7GilESKfsZMU0v/WL6By4ijVUMSty3sInH0oJiUVE\nWZenPtGuSsJUO6J9GNC50KtImuHA2EtAu3OdHq1wIZ0a6EoTOIiDY3kmSK7L\nrsubMnFhIv/jpoVrQKvlESQ7Go0olGseg8U39oJdhorytkPCm2wIezJSCnbX\nBFoi2yxuyx228qjPYpboLnNiTCtb3QltQ4g+4wDssGr2A8ygNRzsoavbim0k\nzRPDfprSSKlg+L+68507AD09h9tDjyiU9x+3oQdtNbnHkWSrsJjC2CIfBe2A\nfiJ3\r\n=eUcA\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIQDFmzlHhVkdgVZ38T+xhsnvozShTLmNPFPPLS2jbEf0TQIgKdofCDcO5JrhxkOnNISDuG3yhfmimVFrEX/o2VmoMZg="
          }
        ]
      },
      "maintainers": [
        {
          "email": "npm@apollographql.com",
          "name": "apollo-bot"
        },
        {
          "email": "ben@benjamn.com",
          "name": "benjamn"
        },
        {
          "email": "james@meteor.com",
          "name": "jbaxleyiii"
        },
        {
          "email": "peggyrayzis@gmail.com",
          "name": "peggyrayzis"
        }
      ],
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/apollo-cache-inmemory_1.3.1-local-state-alpha.8_1539117202533_0.8311791165170135"
      },
      "_hasShrinkwrap": false
    },
    "1.3.1-local-state-alpha.9": {
      "name": "apollo-cache-inmemory",
      "version": "1.3.1-local-state-alpha.9",
      "description": "Core abstract of Caching layer for Apollo Client",
      "author": {
        "name": "James Baxley",
        "email": "james@meteor.com"
      },
      "contributors": [
        {
          "name": "James Baxley",
          "email": "james@meteor.com"
        },
        {
          "name": "Jonas Helfer",
          "email": "jonas@helfer.email"
        },
        {
          "name": "Sashko Stubailo",
          "email": "sashko@stubailo.com"
        },
        {
          "name": "James Burgess",
          "email": "jamesmillerburgess@gmail.com"
        },
        {
          "name": "Bazyli Brzóska",
          "email": "bazyli.brzoska@gmail.com"
        }
      ],
      "license": "MIT",
      "main": "./lib/bundle.umd.js",
      "module": "./lib/index.js",
      "jsnext:main": "./lib/index.js",
      "typings": "./lib/index.d.ts",
      "sideEffects": false,
      "repository": {
        "type": "git",
        "url": "git+https://github.com/apollographql/apollo-client.git"
      },
      "bugs": {
        "url": "https://github.com/apollographql/apollo-client/issues"
      },
      "homepage": "https://github.com/apollographql/apollo-client#readme",
      "scripts": {
        "prepare": "npm run build",
        "coverage": "jest --coverage",
        "test": "jest",
        "lint": "tslint -c \"../../config/tslint.json\" -p tsconfig.json src/*.ts",
        "prebuild": "npm run clean",
        "build": "tsc -p .",
        "postbuild": "npm run bundle",
        "bundle": "../../node_modules/rollup/bin/rollup -c rollup.config.js",
        "watch": "tsc -w -p .",
        "clean": "rm -rf coverage/* && rm -rf lib/*",
        "prepublishOnly": "npm run build",
        "minify": "../../node_modules/uglify-js/bin/uglifyjs -c -m -o ./lib/bundle.min.js -- ./lib/bundle.umd.js",
        "filesize": "npm run minify"
      },
      "dependencies": {
        "apollo-cache": "^1.1.18-local-state-alpha.9",
        "apollo-utilities": "^1.0.22-local-state-alpha.9",
        "optimism": "^0.6.6"
      },
      "peerDependencies": {
        "graphql": "0.11.7 || ^0.12.0 || ^0.13.0"
      },
      "jest": {
        "transform": {
          ".(ts|tsx)": "ts-jest"
        },
        "testRegex": "(/__tests__/.*|\\.(test|spec))\\.(ts|tsx|js)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "json"
        ],
        "testURL": "http://localhost"
      },
      "gitHead": "bf9299494cdb2bc29e10ebb52dc6276b2e2fc90b",
      "_resolved": "",
      "_integrity": "",
      "_from": "file:apollo-cache-inmemory-1.3.1-local-state-alpha.9.tgz",
      "readme": "---\ntitle: InMemoryCache\ndescription: An explanation of `apollo-cache-inmemory`\n---\n\n`apollo-cache-inmemory` is the recommended cache implementation for Apollo Client 2.0. `InMemoryCache` is a normalized data store that supports all of Apollo Client 1.0's features without the dependency on Redux.\n\nIn some instances, you may need to manipulate the cache directly, such as updating the store after a mutation. We'll cover some common use cases [here](#recipes).\n\n<h2 id=\"installation\">Installation</h2>\n\n```\nnpm install apollo-cache-inmemory --save\n```\n\nAfter installing the package, you'll want to initialize the cache constructor. Then, you can pass in your newly created cache to ApolloClient.\n\n```js\nimport { InMemoryCache } from 'apollo-cache-inmemory';\nimport { HttpLink } from 'apollo-link-http';\nimport ApolloClient from 'apollo-client';\n\nconst cache = new InMemoryCache();\n\nconst client = new ApolloClient({\n  link: new HttpLink(),\n  cache\n});\n```\n\n<h2 id=\"configuration\">Configuration</h2>\n\nThe `InMemoryCache` constructor takes an optional config object with properties to customize your cache:\n\n- addTypename: A boolean to determine whether to add __typename to the document (default: `true`)\n- dataIdFromObject: A function that takes a data object and returns a unique identifier to be used when normalizing the data in the store. Learn more about how to customize `dataIdFromObject` in the [Normalization](#normalization) section.\n- fragmentMatcher: By default, the `InMemoryCache` uses a heuristic fragment matcher. If you are using fragments on unions and interfaces, you will need to use an `IntrospectionFragmentMatcher`. For more information, please read [our guide to setting up fragment matching for unions & interfaces](https://www.apollographql.com/docs/react/advanced/fragments.html#fragment-matcher).\n\n<h2 id=\"normalization\">Normalization</h2>\n\nThe `InMemoryCache` normalizes your data before saving it to the store by splitting the result into individual objects, creating a unique identifier for each object, and storing those objects in a flattened data structure. By default, `InMemoryCache` will attempt to use the commonly found primary keys of `id` and `_id` for the unique identifier if they exist along with `__typename` on an object.\n\nIf `id` and `_id` are not specified, or if `__typename` is not specified, `InMemoryCache` will fall back to the path to the object in the query, such as `ROOT_QUERY.allPeople.0` for the first record returned on the `allPeople` root query.\n\nThis \"getter\" behavior for unique identifiers can be configured manually via the `dataIdFromObject` option passed to the `InMemoryCache` constructor, so you can pick which field is used if some of your data follows unorthodox primary key conventions.\n\nFor example, if you wanted to key off of the `key` field for all of your data, you could configure `dataIdFromObject` like so:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => object.key\n});\n```\n\nThis also allows you to use different unique identifiers for different data types by keying off of the `__typename` property attached to every object typed by GraphQL.  For example:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => {\n    switch (object.__typename) {\n      case 'foo': return object.key; // use `key` as the primary key\n      case 'bar': return object.blah; // use `blah` as the priamry key\n      default: return object.id || object._id; // fall back to `id` and `_id` for all other types\n    }\n  }\n});\n```\n\n<h2 id=\"direct\">Direct Cache Access</h2>\n\nTo interact directly with your cache, you can use the Apollo Client class methods readQuery, readFragment, writeQuery, and writeFragment. These methods are available to us via the [`DataProxy` interface](https://github.com/apollographql/apollo-client/blob/master/packages/apollo-cache/src/types/DataProxy.ts). Accessing these methods will vary slightly based on your view layer implementation. If you are using React, you can wrap your component in the `withApollo` higher order component, which will give you access to `this.props.client`. From there, you can use the methods to control your data.\n\nAny code demonstration in the following sections will assume that we have already initialized an instance of  `ApolloClient` and that we have imported the `gql` tag from `graphql-tag`.\n\n<h3 id=\"readquery\">readQuery</h3>\n\nThe `readQuery` method is very similar to the [`query` method on `ApolloClient`][] except that `readQuery` will _never_ make a request to your GraphQL server. The `query` method, on the other hand, may send a request to your server if the appropriate data is not in your cache whereas `readQuery` will throw an error if the data is not in your cache. `readQuery` will _always_ read from the cache. You can use `readQuery` by giving it a GraphQL query like so:\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo {\n      todo(id: 5) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n});\n```\n\nIf all of the data needed to fulfill this read is in Apollo Client’s normalized data cache then a data object will be returned in the shape of the query you wanted to read. If not all of the data needed to fulfill this read is in Apollo Client’s cache then an error will be thrown instead, so make sure to only read data that you know you have!\n\nYou can also pass variables into `readQuery`.\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo($id: Int!) {\n      todo(id: $id) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n  variables: {\n    id: 5,\n  },\n});\n```\n\n<h3 id=\"readfragment\">readFragment</h3>\n\nThis method allows you great flexibility around the data in your cache. Whereas `readQuery` only allowed you to read data from your root query type, `readFragment` allows you to read data from _any node you have queried_. This is incredibly powerful. You use this method as follows:\n\n```js\nconst todo = client.readFragment({\n  id: ..., // `id` is any id that could be returned by `dataIdFromObject`.\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\nThe first argument is the id of the data you want to read from the cache. That id must be a value that was returned by the `dataIdFromObject` function you defined when initializing `ApolloClient`. So for example if you initialized `ApolloClient` like so:\n\n```js\nconst client = new ApolloClient({\n  ...,\n  dataIdFromObject: object => object.id,\n});\n```\n\n…and you requested a todo before with an id of `5`, then you can read that todo out of your cache with the following:\n\n```js\nconst todo = client.readFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\n> **Note:** Most people add a `__typename` to the id in `dataIdFromObject`. If you do this then don’t forget to add the `__typename` when you are reading a fragment as well. So for example your id may be `Todo_5` and not just `5`.\n\nIf a todo with that id does not exist in the cache you will get `null` back. If a todo of that id does exist in the cache, but that todo does not have the `text` field then an error will be thrown.\n\nThe beauty of `readFragment` is that the todo could have come from anywhere! The todo could have been selected as a singleton (`{ todo(id: 5) { ... } }`), the todo could have come from a list of todos (`{ todos { ... } }`), or the todo could have come from a mutation (`mutation { createTodo { ... } }`). As long as at some point your GraphQL server gave you a todo with the provided id and fields `id`, `text`, and `completed` you can read it from the cache at any part of your code.\n\n<h3 id=\"writequery-and-writefragment\">writeQuery` and `writeFragment</h3>\n\nNot only can you read arbitrary data from the Apollo Client cache, but you can also write any data that you would like to the cache. The methods you use to do this are `writeQuery` and `writeFragment`. They will allow you to change data in your local cache, but it is important to remember that *they will not change any data on your server*. If you reload your environment then changes made with `writeQuery` and `writeFragment` will disappear.\n\nThese methods have the same signature as their `readQuery` and `readFragment` counterparts except they also require an additional `data` variable. So for example, if you wanted to update the `completed` flag locally for your todo with id `'5'` you could execute the following:\n\n```js\nclient.writeFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      completed\n    }\n  `,\n  data: {\n    completed: true,\n  },\n});\n```\n\nAny subscriber to the Apollo Client store will instantly see this update and render new UI accordingly.\n\n> **Note:** Again, remember that using `writeQuery` or `writeFragment` only changes data *locally*. If you reload your environment then changes made with these methods will no longer exist.\n\nOr if you wanted to add a new todo to a list fetched from the server, you could use `readQuery` and `writeQuery` together.\n\n```js\nconst query = gql`\n  query MyTodoAppQuery {\n    todos {\n      id\n      text\n      completed\n    }\n  }\n`;\n\nconst data = client.readQuery({ query });\n\nconst myNewTodo = {\n  id: '6',\n  text: 'Start using Apollo Client.',\n  completed: false,\n};\n\nclient.writeQuery({\n  query,\n  data: {\n    todos: [...data.todos, myNewTodo],\n  },\n});\n```\n\n<h2 id=\"recipes\">Recipes</h2>\n\nHere are some common situations where you would need to access the cache directly. If you're manipulating the cache in an interesting way and would like your example to be featured, please send in a pull request!\n\n<h3 id=\"server\">Server side rendering</h3>\n\nFirst, you will need to initialize an `InMemoryCache` on the server and create an instance of `ApolloClient`. In the initial serialized HTML payload from the server, you should include a script tag that extracts the data from the cache.\n\n```js\n`<script>\n  window.__APOLLO_STATE__=${JSON.stringify(cache.extract())}\n</script>`\n```\n\nOn the client, you can rehydrate the cache using the initial data passed from the server:\n\n```js\ncache: new Cache().restore(window.__APOLLO_STATE__)\n```\n\nIf you would like to learn more about server side rendering, please check our our more in depth guide [here].\n<!---\nTODO (PEGGY): Add link to SSR\n-->\n\n<h3 id=\"server\">Updating the cache after a mutation</h3>\n\nBeing able to read and write to the Apollo cache from anywhere in your application gives you a lot of power over your data. However, there is one place where we most often want to update our cached data: after a mutation. As such, Apollo Client has optimized the experience for updating your cache with the read and write methods after a mutation with the `update` function. Let us say that we have the following GraphQL mutation:\n\n```graphql\nmutation TodoCreateMutation($text: String!) {\n  createTodo(text: $text) {\n    id\n    text\n    completed\n  }\n}\n```\n\nWe may also have the following GraphQL query:\n\n```graphql\nquery TodoAppQuery {\n  todos {\n    id\n    text\n    completed\n  }\n}\n```\n\nAt the end of our mutation we want our query to include the new todo like we had sent our `TodoAppQuery` a second time after the mutation finished without actually sending the query. To do this we can use the `update` function provided as an option of the `client.mutate` method. To update your cache with the mutation just write code that looks like:\n\n```js\n// We assume that the GraphQL operations `TodoCreateMutation` and\n// `TodoAppQuery` have already been defined using the `gql` tag.\n\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    // Read the data from our cache for this query.\n    const data = proxy.readQuery({ query: TodoAppQuery });\n\n    // Add our todo from the mutation to the end.\n    data.todos.push(createTodo);\n\n    // Write our data back to the cache.\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nThe first `proxy` argument is an instance of [`DataProxy`][] has the same four methods that we just learned exist on the Apollo Client: `readQuery`, `readFragment`, `writeQuery`, and `writeFragment`. The reason we call them on a `proxy` object here instead of on our `client` instance is that we can easily apply optimistic updates (which we will demonstrate in a bit). The `proxy` object also provides an isolated transaction which shields you from any other mutations going on at the same time, and the `proxy` object also batches writes together until the very end.\n\nIf you provide an `optimisticResponse` option to the mutation then the `update` function will be run twice. Once immediately after you call `client.mutate` with the data from `optimisticResponse`. After the mutation successfully executes against the server the changes made in the first call to `update` will be rolled back and `update` will be called with the *actual* data returned by the mutation and not just the optimistic response.\n\nPutting it all together:\n\n```js\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  optimisticResponse: {\n    id: -1, // -1 is a temporary id for the optimistic response.\n    text,\n    completed: false,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    const data = proxy.readQuery({ query: TodoAppQuery });\n    data.todos.push(createTodo);\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nAs you can see the `update` function on `client.mutate` provides extra change management functionality specific to the use case of a mutation while still providing you the powerful data control APIs that are available on `client`.\n\nThe `update` function is not a good place for side-effects as it may be called multiple times. Also, you may not call any of the methods on `proxy` asynchronously.\n\n",
      "readmeFilename": "README.md",
      "_id": "apollo-cache-inmemory@1.3.1-local-state-alpha.9",
      "_npmVersion": "6.4.1",
      "_nodeVersion": "8.12.0",
      "_npmUser": {
        "name": "apollo-bot",
        "email": "npm@apollographql.com"
      },
      "dist": {
        "integrity": "sha512-nnGuGPqNAB8XMBG9q3e36nXxdxHG1ILzI6Ni/yN5MzNh472eJ6CgGStdao5+FPm1Iz7afFijK8YAXGeeVazvPA==",
        "shasum": "400393840968f38f855cca95c288e91ea1b24678",
        "tarball": "https://registry.npmjs.org/apollo-cache-inmemory/-/apollo-cache-inmemory-1.3.1-local-state-alpha.9.tgz",
        "fileCount": 84,
        "unpackedSize": 510406,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJbyikLCRA9TVsSAnZWagAA5EAP/1Tj+RvjztQ4ZEJ7WTif\n03vT5FGmtropiIQXr9kWecPqlL10l4XIvRVe2lGRPQlfD18ezcmgvQRPqSpu\nypAKDKAYp3TvUugT9wD63txWSjGda/t4NyfuW+jYC88/lr7jkf3WbveLlCPN\nbyepY/S6/WuZGv6u9uUE/aozWd+SkK9NN6fAdmK1Hwgj8ppY9YWkQFXsSPzw\now1KPT41Fbz7R5SZkB9ZEaUQ3wwrF9eWzak+A77saXLl4xlmsu2GzNr9Ucaj\nJTrFeUD0ZJQ6l6I78HONovl+L0INGOmDpY4CgX1Bd4xOiKM2vNYSObf5BRw8\noAhes1ynPN/x0aAAXck1tRNO8coL1MzNZaBg1yvoad5/GmOD1tPf3YCNzcrd\nTFGiVyucyCj0koyh1jbkXwGlyPSbOddo/hZYg4Jgwqbf9eBytpFCYYMGX9uj\nC2cSyEhnyVSjcHhqYWO8/KtEUiMpBmA9sslZxLQCN1ImKnL1d6+hr15GdMbj\nAG7WW2HmhdcBX+QgckvnH78Ani2Id7YgyDUVELBA8DD/yife48vSosqG5uY6\n09hIyBASdt3fZUOMZ7Kzp01CSDtVdluZWPLDrfrfZ3QlZbpK5ikpkuwcK4/3\nhDGE3w5U5Cb188WNx3Q8zzx78r2HhEw8Xqmx2BG+SrNIk6Bs6NoVmGPAvk3r\nUYke\r\n=8tER\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEQCIGBcvQBgwfJmytAKaYgd6xoj7Yt6zDX9FT0nUyf74fyQAiA+kP8yl7FDHX+dkc1J4p/1S0pq93vWWdoQ06LL9Ni5/Q=="
          }
        ]
      },
      "maintainers": [
        {
          "email": "npm@apollographql.com",
          "name": "apollo-bot"
        },
        {
          "email": "ben@benjamn.com",
          "name": "benjamn"
        },
        {
          "email": "james@meteor.com",
          "name": "jbaxleyiii"
        },
        {
          "email": "peggyrayzis@gmail.com",
          "name": "peggyrayzis"
        }
      ],
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/apollo-cache-inmemory_1.3.1-local-state-alpha.9_1539975434645_0.5032476599358442"
      },
      "_hasShrinkwrap": false
    },
    "1.3.6": {
      "name": "apollo-cache-inmemory",
      "version": "1.3.6",
      "description": "Core abstract of Caching layer for Apollo Client",
      "author": {
        "name": "James Baxley",
        "email": "james@meteor.com"
      },
      "contributors": [
        {
          "name": "James Baxley",
          "email": "james@meteor.com"
        },
        {
          "name": "Jonas Helfer",
          "email": "jonas@helfer.email"
        },
        {
          "name": "Sashko Stubailo",
          "email": "sashko@stubailo.com"
        },
        {
          "name": "James Burgess",
          "email": "jamesmillerburgess@gmail.com"
        },
        {
          "name": "Bazyli Brzóska",
          "email": "bazyli.brzoska@gmail.com"
        }
      ],
      "license": "MIT",
      "main": "./lib/bundle.umd.js",
      "module": "./lib/index.js",
      "jsnext:main": "./lib/index.js",
      "typings": "./lib/index.d.ts",
      "sideEffects": [
        "./lib/fixPolyfills.js"
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/apollographql/apollo-client.git"
      },
      "bugs": {
        "url": "https://github.com/apollographql/apollo-client/issues"
      },
      "homepage": "https://github.com/apollographql/apollo-client#readme",
      "scripts": {
        "prepare": "npm run build",
        "coverage": "jest --coverage",
        "test": "jest",
        "lint": "tslint -c \"../../config/tslint.json\" -p tsconfig.json src/*.ts",
        "prebuild": "npm run clean",
        "build": "tsc -p .",
        "postbuild": "npm run bundle",
        "bundle": "../../node_modules/rollup/bin/rollup -c rollup.config.js",
        "watch": "tsc -w -p .",
        "clean": "rm -rf coverage/* && rm -rf lib/*",
        "prepublishOnly": "npm run build",
        "minify": "../../node_modules/uglify-js/bin/uglifyjs -c -m -o ./lib/bundle.min.js -- ./lib/bundle.umd.js",
        "filesize": "npm run minify"
      },
      "dependencies": {
        "apollo-cache": "^1.1.18",
        "apollo-utilities": "^1.0.22",
        "optimism": "^0.6.6"
      },
      "peerDependencies": {
        "graphql": "0.11.7 || ^0.12.0 || ^0.13.0 || ^14.0.0"
      },
      "jest": {
        "transform": {
          ".(ts|tsx)": "ts-jest"
        },
        "testRegex": "(/__tests__/.*|\\.(test|spec))\\.(ts|tsx|js)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "json"
        ],
        "testURL": "http://localhost"
      },
      "gitHead": "87ac6dc37cf6b3f1b8b8e6d21e46f357b6d8060b",
      "_resolved": "",
      "_integrity": "",
      "_from": "file:apollo-cache-inmemory-1.3.6.tgz",
      "_id": "apollo-cache-inmemory@1.3.6",
      "_npmVersion": "6.4.1",
      "_nodeVersion": "8.11.4",
      "_npmUser": {
        "name": "benjamn",
        "email": "ben@benjamn.com"
      },
      "dist": {
        "integrity": "sha512-ARSMDNFAPS1xLx79PrOFGd+iEFsC/pVusRbirA+p0AHVJSWyZdhW2fNy7RyFA+2pLbCFFgOgS2SoCq+JFu1RTA==",
        "shasum": "5761268c0f9f9d09df62cf3435046635e29b708b",
        "tarball": "https://registry.npmjs.org/apollo-cache-inmemory/-/apollo-cache-inmemory-1.3.6.tgz",
        "fileCount": 89,
        "unpackedSize": 511503,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJbzlU1CRA9TVsSAnZWagAANYYQAJCjU/VSeM8xBRIqfwUi\nKsFsooumhFUHGdPx59daHjjGmXQQ6RnxweW0aCOubh9Bz/qz3NT1ftVSY/E2\n59Z6f1Sz8Gcuv1wrGxGSsoeOzffIXIdIqVmTQr8z4jSp3LBsF9RyOFKUeI8g\nkDPBwYJOdmMooqiMCyVHl1HTBOg8m6bjB/T8kDFg0yVhEiSAc3TYHlIkY9VS\nZ7XY5gtgUWkGwB2FWoRpKwlAoOJ8vLe8mN0GI0SlYyT9D89pUvPdSMxI3eo0\nMyqyW7b3bW7IpEid52H0rLs17Ni01+euAu9xu4hT7G4NS+SzoIXe8e4CwpvY\nQzTc21QQ8TVWzME4enBdv/eQ/teNs3g1rbXWsQXsSRqxWK8P3SVgHjrY0Tmg\nFIRZukaAmbatBSH3gtXKCVQuvt7xg4qJff652g02ef4bp+rMSrLjXlXj/m9r\nE2rZe24hTvVeTbh1hsoOuDKSzvyIisaFXaaXEXjZKhwRcVePWTqshTu76AwO\nxfh40ifQCHK4mStuZ8TN7npkG7SgwOZ5wbVhouAAw6BahpIfj6VPKowCpfNp\nL4Mnf2m/6++C+oob3O4sW2Va0maQcvKn0SV6psOLPXoMbuWR4aQrepcILz96\nDdFHjZhaCD30QOGy/82ZfE0r+iJAtKzTZA9GqtHk8p5RvjV3lf4m5pWosg1U\nmqEV\r\n=xzlk\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEQCIAN1eTizfPNx58DSx5stDH2s0ObIAFLHGXatiUYZ3KlEAiBtssZ087cMaE3u7U1vkgHCFvOontGz5MG0HPujbRJVfw=="
          }
        ]
      },
      "maintainers": [
        {
          "email": "npm@apollographql.com",
          "name": "apollo-bot"
        },
        {
          "email": "ben@benjamn.com",
          "name": "benjamn"
        },
        {
          "email": "james@meteor.com",
          "name": "jbaxleyiii"
        },
        {
          "email": "peggyrayzis@gmail.com",
          "name": "peggyrayzis"
        }
      ],
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/apollo-cache-inmemory_1.3.6_1540248884294_0.868277299400956"
      },
      "_hasShrinkwrap": false
    },
    "1.3.1-local-state-alpha.10": {
      "name": "apollo-cache-inmemory",
      "version": "1.3.1-local-state-alpha.10",
      "description": "Core abstract of Caching layer for Apollo Client",
      "author": {
        "name": "James Baxley",
        "email": "james@meteor.com"
      },
      "contributors": [
        {
          "name": "James Baxley",
          "email": "james@meteor.com"
        },
        {
          "name": "Jonas Helfer",
          "email": "jonas@helfer.email"
        },
        {
          "name": "Sashko Stubailo",
          "email": "sashko@stubailo.com"
        },
        {
          "name": "James Burgess",
          "email": "jamesmillerburgess@gmail.com"
        },
        {
          "name": "Bazyli Brzóska",
          "email": "bazyli.brzoska@gmail.com"
        }
      ],
      "license": "MIT",
      "main": "./lib/bundle.umd.js",
      "module": "./lib/index.js",
      "jsnext:main": "./lib/index.js",
      "typings": "./lib/index.d.ts",
      "sideEffects": false,
      "repository": {
        "type": "git",
        "url": "git+https://github.com/apollographql/apollo-client.git"
      },
      "bugs": {
        "url": "https://github.com/apollographql/apollo-client/issues"
      },
      "homepage": "https://github.com/apollographql/apollo-client#readme",
      "scripts": {
        "prepare": "npm run build",
        "coverage": "jest --coverage",
        "test": "jest",
        "lint": "tslint -c \"../../config/tslint.json\" -p tsconfig.json src/*.ts",
        "prebuild": "npm run clean",
        "build": "tsc -p .",
        "postbuild": "npm run bundle",
        "bundle": "../../node_modules/rollup/bin/rollup -c rollup.config.js",
        "watch": "tsc -w -p .",
        "clean": "rm -rf coverage/* && rm -rf lib/*",
        "prepublishOnly": "npm run build",
        "minify": "../../node_modules/uglify-js/bin/uglifyjs -c -m -o ./lib/bundle.min.js -- ./lib/bundle.umd.js",
        "filesize": "npm run minify"
      },
      "dependencies": {
        "apollo-cache": "^1.1.18-local-state-alpha.10",
        "apollo-utilities": "^1.0.22-local-state-alpha.10",
        "optimism": "^0.6.6"
      },
      "peerDependencies": {
        "graphql": "0.11.7 || ^0.12.0 || ^0.13.0"
      },
      "jest": {
        "transform": {
          ".(ts|tsx)": "ts-jest"
        },
        "testRegex": "(/__tests__/.*|\\.(test|spec))\\.(ts|tsx|js)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "json"
        ],
        "testURL": "http://localhost"
      },
      "gitHead": "b5daa3bdf3e1bec9e969b7435cfc5ea6d9f159ce",
      "_resolved": "",
      "_integrity": "",
      "_from": "file:apollo-cache-inmemory-1.3.1-local-state-alpha.10.tgz",
      "readme": "---\ntitle: InMemoryCache\ndescription: An explanation of `apollo-cache-inmemory`\n---\n\n`apollo-cache-inmemory` is the recommended cache implementation for Apollo Client 2.0. `InMemoryCache` is a normalized data store that supports all of Apollo Client 1.0's features without the dependency on Redux.\n\nIn some instances, you may need to manipulate the cache directly, such as updating the store after a mutation. We'll cover some common use cases [here](#recipes).\n\n<h2 id=\"installation\">Installation</h2>\n\n```\nnpm install apollo-cache-inmemory --save\n```\n\nAfter installing the package, you'll want to initialize the cache constructor. Then, you can pass in your newly created cache to ApolloClient.\n\n```js\nimport { InMemoryCache } from 'apollo-cache-inmemory';\nimport { HttpLink } from 'apollo-link-http';\nimport ApolloClient from 'apollo-client';\n\nconst cache = new InMemoryCache();\n\nconst client = new ApolloClient({\n  link: new HttpLink(),\n  cache\n});\n```\n\n<h2 id=\"configuration\">Configuration</h2>\n\nThe `InMemoryCache` constructor takes an optional config object with properties to customize your cache:\n\n- addTypename: A boolean to determine whether to add __typename to the document (default: `true`)\n- dataIdFromObject: A function that takes a data object and returns a unique identifier to be used when normalizing the data in the store. Learn more about how to customize `dataIdFromObject` in the [Normalization](#normalization) section.\n- fragmentMatcher: By default, the `InMemoryCache` uses a heuristic fragment matcher. If you are using fragments on unions and interfaces, you will need to use an `IntrospectionFragmentMatcher`. For more information, please read [our guide to setting up fragment matching for unions & interfaces](https://www.apollographql.com/docs/react/advanced/fragments.html#fragment-matcher).\n\n<h2 id=\"normalization\">Normalization</h2>\n\nThe `InMemoryCache` normalizes your data before saving it to the store by splitting the result into individual objects, creating a unique identifier for each object, and storing those objects in a flattened data structure. By default, `InMemoryCache` will attempt to use the commonly found primary keys of `id` and `_id` for the unique identifier if they exist along with `__typename` on an object.\n\nIf `id` and `_id` are not specified, or if `__typename` is not specified, `InMemoryCache` will fall back to the path to the object in the query, such as `ROOT_QUERY.allPeople.0` for the first record returned on the `allPeople` root query.\n\nThis \"getter\" behavior for unique identifiers can be configured manually via the `dataIdFromObject` option passed to the `InMemoryCache` constructor, so you can pick which field is used if some of your data follows unorthodox primary key conventions.\n\nFor example, if you wanted to key off of the `key` field for all of your data, you could configure `dataIdFromObject` like so:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => object.key\n});\n```\n\nThis also allows you to use different unique identifiers for different data types by keying off of the `__typename` property attached to every object typed by GraphQL.  For example:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => {\n    switch (object.__typename) {\n      case 'foo': return object.key; // use `key` as the primary key\n      case 'bar': return object.blah; // use `blah` as the priamry key\n      default: return object.id || object._id; // fall back to `id` and `_id` for all other types\n    }\n  }\n});\n```\n\n<h2 id=\"direct\">Direct Cache Access</h2>\n\nTo interact directly with your cache, you can use the Apollo Client class methods readQuery, readFragment, writeQuery, and writeFragment. These methods are available to us via the [`DataProxy` interface](https://github.com/apollographql/apollo-client/blob/master/packages/apollo-cache/src/types/DataProxy.ts). Accessing these methods will vary slightly based on your view layer implementation. If you are using React, you can wrap your component in the `withApollo` higher order component, which will give you access to `this.props.client`. From there, you can use the methods to control your data.\n\nAny code demonstration in the following sections will assume that we have already initialized an instance of  `ApolloClient` and that we have imported the `gql` tag from `graphql-tag`.\n\n<h3 id=\"readquery\">readQuery</h3>\n\nThe `readQuery` method is very similar to the [`query` method on `ApolloClient`][] except that `readQuery` will _never_ make a request to your GraphQL server. The `query` method, on the other hand, may send a request to your server if the appropriate data is not in your cache whereas `readQuery` will throw an error if the data is not in your cache. `readQuery` will _always_ read from the cache. You can use `readQuery` by giving it a GraphQL query like so:\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo {\n      todo(id: 5) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n});\n```\n\nIf all of the data needed to fulfill this read is in Apollo Client’s normalized data cache then a data object will be returned in the shape of the query you wanted to read. If not all of the data needed to fulfill this read is in Apollo Client’s cache then an error will be thrown instead, so make sure to only read data that you know you have!\n\nYou can also pass variables into `readQuery`.\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo($id: Int!) {\n      todo(id: $id) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n  variables: {\n    id: 5,\n  },\n});\n```\n\n<h3 id=\"readfragment\">readFragment</h3>\n\nThis method allows you great flexibility around the data in your cache. Whereas `readQuery` only allowed you to read data from your root query type, `readFragment` allows you to read data from _any node you have queried_. This is incredibly powerful. You use this method as follows:\n\n```js\nconst todo = client.readFragment({\n  id: ..., // `id` is any id that could be returned by `dataIdFromObject`.\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\nThe first argument is the id of the data you want to read from the cache. That id must be a value that was returned by the `dataIdFromObject` function you defined when initializing `ApolloClient`. So for example if you initialized `ApolloClient` like so:\n\n```js\nconst client = new ApolloClient({\n  ...,\n  dataIdFromObject: object => object.id,\n});\n```\n\n…and you requested a todo before with an id of `5`, then you can read that todo out of your cache with the following:\n\n```js\nconst todo = client.readFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\n> **Note:** Most people add a `__typename` to the id in `dataIdFromObject`. If you do this then don’t forget to add the `__typename` when you are reading a fragment as well. So for example your id may be `Todo_5` and not just `5`.\n\nIf a todo with that id does not exist in the cache you will get `null` back. If a todo of that id does exist in the cache, but that todo does not have the `text` field then an error will be thrown.\n\nThe beauty of `readFragment` is that the todo could have come from anywhere! The todo could have been selected as a singleton (`{ todo(id: 5) { ... } }`), the todo could have come from a list of todos (`{ todos { ... } }`), or the todo could have come from a mutation (`mutation { createTodo { ... } }`). As long as at some point your GraphQL server gave you a todo with the provided id and fields `id`, `text`, and `completed` you can read it from the cache at any part of your code.\n\n<h3 id=\"writequery-and-writefragment\">writeQuery` and `writeFragment</h3>\n\nNot only can you read arbitrary data from the Apollo Client cache, but you can also write any data that you would like to the cache. The methods you use to do this are `writeQuery` and `writeFragment`. They will allow you to change data in your local cache, but it is important to remember that *they will not change any data on your server*. If you reload your environment then changes made with `writeQuery` and `writeFragment` will disappear.\n\nThese methods have the same signature as their `readQuery` and `readFragment` counterparts except they also require an additional `data` variable. So for example, if you wanted to update the `completed` flag locally for your todo with id `'5'` you could execute the following:\n\n```js\nclient.writeFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      completed\n    }\n  `,\n  data: {\n    completed: true,\n  },\n});\n```\n\nAny subscriber to the Apollo Client store will instantly see this update and render new UI accordingly.\n\n> **Note:** Again, remember that using `writeQuery` or `writeFragment` only changes data *locally*. If you reload your environment then changes made with these methods will no longer exist.\n\nOr if you wanted to add a new todo to a list fetched from the server, you could use `readQuery` and `writeQuery` together.\n\n```js\nconst query = gql`\n  query MyTodoAppQuery {\n    todos {\n      id\n      text\n      completed\n    }\n  }\n`;\n\nconst data = client.readQuery({ query });\n\nconst myNewTodo = {\n  id: '6',\n  text: 'Start using Apollo Client.',\n  completed: false,\n};\n\nclient.writeQuery({\n  query,\n  data: {\n    todos: [...data.todos, myNewTodo],\n  },\n});\n```\n\n<h2 id=\"recipes\">Recipes</h2>\n\nHere are some common situations where you would need to access the cache directly. If you're manipulating the cache in an interesting way and would like your example to be featured, please send in a pull request!\n\n<h3 id=\"server\">Server side rendering</h3>\n\nFirst, you will need to initialize an `InMemoryCache` on the server and create an instance of `ApolloClient`. In the initial serialized HTML payload from the server, you should include a script tag that extracts the data from the cache.\n\n```js\n`<script>\n  window.__APOLLO_STATE__=${JSON.stringify(cache.extract())}\n</script>`\n```\n\nOn the client, you can rehydrate the cache using the initial data passed from the server:\n\n```js\ncache: new Cache().restore(window.__APOLLO_STATE__)\n```\n\nIf you would like to learn more about server side rendering, please check our our more in depth guide [here].\n<!---\nTODO (PEGGY): Add link to SSR\n-->\n\n<h3 id=\"server\">Updating the cache after a mutation</h3>\n\nBeing able to read and write to the Apollo cache from anywhere in your application gives you a lot of power over your data. However, there is one place where we most often want to update our cached data: after a mutation. As such, Apollo Client has optimized the experience for updating your cache with the read and write methods after a mutation with the `update` function. Let us say that we have the following GraphQL mutation:\n\n```graphql\nmutation TodoCreateMutation($text: String!) {\n  createTodo(text: $text) {\n    id\n    text\n    completed\n  }\n}\n```\n\nWe may also have the following GraphQL query:\n\n```graphql\nquery TodoAppQuery {\n  todos {\n    id\n    text\n    completed\n  }\n}\n```\n\nAt the end of our mutation we want our query to include the new todo like we had sent our `TodoAppQuery` a second time after the mutation finished without actually sending the query. To do this we can use the `update` function provided as an option of the `client.mutate` method. To update your cache with the mutation just write code that looks like:\n\n```js\n// We assume that the GraphQL operations `TodoCreateMutation` and\n// `TodoAppQuery` have already been defined using the `gql` tag.\n\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    // Read the data from our cache for this query.\n    const data = proxy.readQuery({ query: TodoAppQuery });\n\n    // Add our todo from the mutation to the end.\n    data.todos.push(createTodo);\n\n    // Write our data back to the cache.\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nThe first `proxy` argument is an instance of [`DataProxy`][] has the same four methods that we just learned exist on the Apollo Client: `readQuery`, `readFragment`, `writeQuery`, and `writeFragment`. The reason we call them on a `proxy` object here instead of on our `client` instance is that we can easily apply optimistic updates (which we will demonstrate in a bit). The `proxy` object also provides an isolated transaction which shields you from any other mutations going on at the same time, and the `proxy` object also batches writes together until the very end.\n\nIf you provide an `optimisticResponse` option to the mutation then the `update` function will be run twice. Once immediately after you call `client.mutate` with the data from `optimisticResponse`. After the mutation successfully executes against the server the changes made in the first call to `update` will be rolled back and `update` will be called with the *actual* data returned by the mutation and not just the optimistic response.\n\nPutting it all together:\n\n```js\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  optimisticResponse: {\n    id: -1, // -1 is a temporary id for the optimistic response.\n    text,\n    completed: false,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    const data = proxy.readQuery({ query: TodoAppQuery });\n    data.todos.push(createTodo);\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nAs you can see the `update` function on `client.mutate` provides extra change management functionality specific to the use case of a mutation while still providing you the powerful data control APIs that are available on `client`.\n\nThe `update` function is not a good place for side-effects as it may be called multiple times. Also, you may not call any of the methods on `proxy` asynchronously.\n\n",
      "readmeFilename": "README.md",
      "_id": "apollo-cache-inmemory@1.3.1-local-state-alpha.10",
      "_npmVersion": "6.4.1",
      "_nodeVersion": "8.12.0",
      "_npmUser": {
        "name": "apollo-bot",
        "email": "npm@apollographql.com"
      },
      "dist": {
        "integrity": "sha512-Ib2Sb8oKqPC6Pv09gynseoCvdn2OtkLeOpRojaaNmWJIBjfnp7oZ1CltfxkcTTCxNKqdjqglKUvJgwOL2S8E0Q==",
        "shasum": "eafeefd7d99905eae41088861f924aeb4a4f833f",
        "tarball": "https://registry.npmjs.org/apollo-cache-inmemory/-/apollo-cache-inmemory-1.3.1-local-state-alpha.10.tgz",
        "fileCount": 84,
        "unpackedSize": 510409,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJbzz2oCRA9TVsSAnZWagAAF9oP/AtzLIRcVxHomCmhDe0h\ngc5sfe8CK04izqmFWhdQAyquaNSOTve+wKVYP4advmgq18jCTkGuRz8/DrE+\nnQ9k9L+j7bDXAqivKY9Q1clADXNy4fblzOfwkRiK/v1fU/k3PQ7r4hwKYiQL\ntMpBcX7lBf/fFy2RCWMCc2Q48Maq7oYW94X0E5rsXOasXvOt5eX6reG9lJr0\nqiwU9NIwJUqZl43eiisFN7HL0lcvpJ7f12dBgWKBLPpjd2mS1IcTvEQIxe0X\nuJ6aKbM0Lexwwt14+LWIT9Vt436ZuQEtFbxid+PrxH/l79YPN34iyAq4FDq8\nXdRetmdDukXqoUwTz81904jjjzSFoSLWO422xrcG/1eXKwc7YogIDLnzNCg5\n1RmmgdvzDu2dMemG1PWqXCnUfFV6bePIiDV59Tnb0HAfv3Tic6b3WEl2paHY\nB0cmONwwjIdOYP1vtd62IWPhNRPmgI6w19mlck0o245E4VRoMbzSZluoz5db\nxVm6HkIAKj3B1REjho6hoVCz0VaMZLce+NqBBWHVyvH8QrS/kkgOB64CN6UR\nTx/2tn2vhsm8mSiiaJVPHryKfmh8WAVsa1IMhSYml+1Dk9ezB/al8BDhmH/K\noQeDBrZTz18mXBVJTHpm7PPRZtC7qx/6IwE7D2gf6janA9zo2JUUtjdckNDC\n3yrH\r\n=mlPu\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEQCIBxsXy0dNtdlFW1KWSJEUyBv4jq7tJLG+l0hOlJubsA4AiAkQ/dNqc5VmzCZ+JTtD0YGupuaBH93H5NKqSAe9Na2ww=="
          }
        ]
      },
      "maintainers": [
        {
          "email": "npm@apollographql.com",
          "name": "apollo-bot"
        },
        {
          "email": "ben@benjamn.com",
          "name": "benjamn"
        },
        {
          "email": "james@meteor.com",
          "name": "jbaxleyiii"
        },
        {
          "email": "peggyrayzis@gmail.com",
          "name": "peggyrayzis"
        }
      ],
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/apollo-cache-inmemory_1.3.1-local-state-alpha.10_1540308391542_0.5245023976166083"
      },
      "_hasShrinkwrap": false
    },
    "1.3.1-local-state-alpha.11": {
      "name": "apollo-cache-inmemory",
      "version": "1.3.1-local-state-alpha.11",
      "description": "Core abstract of Caching layer for Apollo Client",
      "author": {
        "name": "James Baxley",
        "email": "james@meteor.com"
      },
      "contributors": [
        {
          "name": "James Baxley",
          "email": "james@meteor.com"
        },
        {
          "name": "Jonas Helfer",
          "email": "jonas@helfer.email"
        },
        {
          "name": "Sashko Stubailo",
          "email": "sashko@stubailo.com"
        },
        {
          "name": "James Burgess",
          "email": "jamesmillerburgess@gmail.com"
        },
        {
          "name": "Bazyli Brzóska",
          "email": "bazyli.brzoska@gmail.com"
        }
      ],
      "license": "MIT",
      "main": "./lib/bundle.umd.js",
      "module": "./lib/index.js",
      "jsnext:main": "./lib/index.js",
      "typings": "./lib/index.d.ts",
      "sideEffects": false,
      "repository": {
        "type": "git",
        "url": "git+https://github.com/apollographql/apollo-client.git"
      },
      "bugs": {
        "url": "https://github.com/apollographql/apollo-client/issues"
      },
      "homepage": "https://github.com/apollographql/apollo-client#readme",
      "scripts": {
        "prepare": "npm run build",
        "coverage": "jest --coverage",
        "test": "jest",
        "lint": "tslint -c \"../../config/tslint.json\" -p tsconfig.json src/*.ts",
        "prebuild": "npm run clean",
        "build": "tsc -p .",
        "postbuild": "npm run bundle",
        "bundle": "../../node_modules/rollup/bin/rollup -c rollup.config.js",
        "watch": "tsc -w -p .",
        "clean": "rm -rf coverage/* && rm -rf lib/*",
        "prepublishOnly": "npm run build",
        "minify": "../../node_modules/uglify-js/bin/uglifyjs -c -m -o ./lib/bundle.min.js -- ./lib/bundle.umd.js",
        "filesize": "npm run minify"
      },
      "dependencies": {
        "apollo-cache": "^1.1.18-local-state-alpha.11",
        "apollo-utilities": "^1.0.22-local-state-alpha.11",
        "optimism": "^0.6.6"
      },
      "peerDependencies": {
        "graphql": "0.11.7 || ^0.12.0 || ^0.13.0"
      },
      "jest": {
        "transform": {
          ".(ts|tsx)": "ts-jest"
        },
        "testRegex": "(/__tests__/.*|\\.(test|spec))\\.(ts|tsx|js)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "json"
        ],
        "testURL": "http://localhost"
      },
      "gitHead": "9cb985fcb3ae37eb98dfca9211da0d45048b8c1c",
      "_resolved": "",
      "_integrity": "",
      "_from": "file:apollo-cache-inmemory-1.3.1-local-state-alpha.11.tgz",
      "readme": "---\ntitle: InMemoryCache\ndescription: An explanation of `apollo-cache-inmemory`\n---\n\n`apollo-cache-inmemory` is the recommended cache implementation for Apollo Client 2.0. `InMemoryCache` is a normalized data store that supports all of Apollo Client 1.0's features without the dependency on Redux.\n\nIn some instances, you may need to manipulate the cache directly, such as updating the store after a mutation. We'll cover some common use cases [here](#recipes).\n\n<h2 id=\"installation\">Installation</h2>\n\n```\nnpm install apollo-cache-inmemory --save\n```\n\nAfter installing the package, you'll want to initialize the cache constructor. Then, you can pass in your newly created cache to ApolloClient.\n\n```js\nimport { InMemoryCache } from 'apollo-cache-inmemory';\nimport { HttpLink } from 'apollo-link-http';\nimport ApolloClient from 'apollo-client';\n\nconst cache = new InMemoryCache();\n\nconst client = new ApolloClient({\n  link: new HttpLink(),\n  cache\n});\n```\n\n<h2 id=\"configuration\">Configuration</h2>\n\nThe `InMemoryCache` constructor takes an optional config object with properties to customize your cache:\n\n- addTypename: A boolean to determine whether to add __typename to the document (default: `true`)\n- dataIdFromObject: A function that takes a data object and returns a unique identifier to be used when normalizing the data in the store. Learn more about how to customize `dataIdFromObject` in the [Normalization](#normalization) section.\n- fragmentMatcher: By default, the `InMemoryCache` uses a heuristic fragment matcher. If you are using fragments on unions and interfaces, you will need to use an `IntrospectionFragmentMatcher`. For more information, please read [our guide to setting up fragment matching for unions & interfaces](https://www.apollographql.com/docs/react/advanced/fragments.html#fragment-matcher).\n\n<h2 id=\"normalization\">Normalization</h2>\n\nThe `InMemoryCache` normalizes your data before saving it to the store by splitting the result into individual objects, creating a unique identifier for each object, and storing those objects in a flattened data structure. By default, `InMemoryCache` will attempt to use the commonly found primary keys of `id` and `_id` for the unique identifier if they exist along with `__typename` on an object.\n\nIf `id` and `_id` are not specified, or if `__typename` is not specified, `InMemoryCache` will fall back to the path to the object in the query, such as `ROOT_QUERY.allPeople.0` for the first record returned on the `allPeople` root query.\n\nThis \"getter\" behavior for unique identifiers can be configured manually via the `dataIdFromObject` option passed to the `InMemoryCache` constructor, so you can pick which field is used if some of your data follows unorthodox primary key conventions.\n\nFor example, if you wanted to key off of the `key` field for all of your data, you could configure `dataIdFromObject` like so:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => object.key\n});\n```\n\nThis also allows you to use different unique identifiers for different data types by keying off of the `__typename` property attached to every object typed by GraphQL.  For example:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => {\n    switch (object.__typename) {\n      case 'foo': return object.key; // use `key` as the primary key\n      case 'bar': return object.blah; // use `blah` as the priamry key\n      default: return object.id || object._id; // fall back to `id` and `_id` for all other types\n    }\n  }\n});\n```\n\n<h2 id=\"direct\">Direct Cache Access</h2>\n\nTo interact directly with your cache, you can use the Apollo Client class methods readQuery, readFragment, writeQuery, and writeFragment. These methods are available to us via the [`DataProxy` interface](https://github.com/apollographql/apollo-client/blob/master/packages/apollo-cache/src/types/DataProxy.ts). Accessing these methods will vary slightly based on your view layer implementation. If you are using React, you can wrap your component in the `withApollo` higher order component, which will give you access to `this.props.client`. From there, you can use the methods to control your data.\n\nAny code demonstration in the following sections will assume that we have already initialized an instance of  `ApolloClient` and that we have imported the `gql` tag from `graphql-tag`.\n\n<h3 id=\"readquery\">readQuery</h3>\n\nThe `readQuery` method is very similar to the [`query` method on `ApolloClient`][] except that `readQuery` will _never_ make a request to your GraphQL server. The `query` method, on the other hand, may send a request to your server if the appropriate data is not in your cache whereas `readQuery` will throw an error if the data is not in your cache. `readQuery` will _always_ read from the cache. You can use `readQuery` by giving it a GraphQL query like so:\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo {\n      todo(id: 5) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n});\n```\n\nIf all of the data needed to fulfill this read is in Apollo Client’s normalized data cache then a data object will be returned in the shape of the query you wanted to read. If not all of the data needed to fulfill this read is in Apollo Client’s cache then an error will be thrown instead, so make sure to only read data that you know you have!\n\nYou can also pass variables into `readQuery`.\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo($id: Int!) {\n      todo(id: $id) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n  variables: {\n    id: 5,\n  },\n});\n```\n\n<h3 id=\"readfragment\">readFragment</h3>\n\nThis method allows you great flexibility around the data in your cache. Whereas `readQuery` only allowed you to read data from your root query type, `readFragment` allows you to read data from _any node you have queried_. This is incredibly powerful. You use this method as follows:\n\n```js\nconst todo = client.readFragment({\n  id: ..., // `id` is any id that could be returned by `dataIdFromObject`.\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\nThe first argument is the id of the data you want to read from the cache. That id must be a value that was returned by the `dataIdFromObject` function you defined when initializing `ApolloClient`. So for example if you initialized `ApolloClient` like so:\n\n```js\nconst client = new ApolloClient({\n  ...,\n  dataIdFromObject: object => object.id,\n});\n```\n\n…and you requested a todo before with an id of `5`, then you can read that todo out of your cache with the following:\n\n```js\nconst todo = client.readFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\n> **Note:** Most people add a `__typename` to the id in `dataIdFromObject`. If you do this then don’t forget to add the `__typename` when you are reading a fragment as well. So for example your id may be `Todo_5` and not just `5`.\n\nIf a todo with that id does not exist in the cache you will get `null` back. If a todo of that id does exist in the cache, but that todo does not have the `text` field then an error will be thrown.\n\nThe beauty of `readFragment` is that the todo could have come from anywhere! The todo could have been selected as a singleton (`{ todo(id: 5) { ... } }`), the todo could have come from a list of todos (`{ todos { ... } }`), or the todo could have come from a mutation (`mutation { createTodo { ... } }`). As long as at some point your GraphQL server gave you a todo with the provided id and fields `id`, `text`, and `completed` you can read it from the cache at any part of your code.\n\n<h3 id=\"writequery-and-writefragment\">writeQuery` and `writeFragment</h3>\n\nNot only can you read arbitrary data from the Apollo Client cache, but you can also write any data that you would like to the cache. The methods you use to do this are `writeQuery` and `writeFragment`. They will allow you to change data in your local cache, but it is important to remember that *they will not change any data on your server*. If you reload your environment then changes made with `writeQuery` and `writeFragment` will disappear.\n\nThese methods have the same signature as their `readQuery` and `readFragment` counterparts except they also require an additional `data` variable. So for example, if you wanted to update the `completed` flag locally for your todo with id `'5'` you could execute the following:\n\n```js\nclient.writeFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      completed\n    }\n  `,\n  data: {\n    completed: true,\n  },\n});\n```\n\nAny subscriber to the Apollo Client store will instantly see this update and render new UI accordingly.\n\n> **Note:** Again, remember that using `writeQuery` or `writeFragment` only changes data *locally*. If you reload your environment then changes made with these methods will no longer exist.\n\nOr if you wanted to add a new todo to a list fetched from the server, you could use `readQuery` and `writeQuery` together.\n\n```js\nconst query = gql`\n  query MyTodoAppQuery {\n    todos {\n      id\n      text\n      completed\n    }\n  }\n`;\n\nconst data = client.readQuery({ query });\n\nconst myNewTodo = {\n  id: '6',\n  text: 'Start using Apollo Client.',\n  completed: false,\n};\n\nclient.writeQuery({\n  query,\n  data: {\n    todos: [...data.todos, myNewTodo],\n  },\n});\n```\n\n<h2 id=\"recipes\">Recipes</h2>\n\nHere are some common situations where you would need to access the cache directly. If you're manipulating the cache in an interesting way and would like your example to be featured, please send in a pull request!\n\n<h3 id=\"server\">Server side rendering</h3>\n\nFirst, you will need to initialize an `InMemoryCache` on the server and create an instance of `ApolloClient`. In the initial serialized HTML payload from the server, you should include a script tag that extracts the data from the cache.\n\n```js\n`<script>\n  window.__APOLLO_STATE__=${JSON.stringify(cache.extract())}\n</script>`\n```\n\nOn the client, you can rehydrate the cache using the initial data passed from the server:\n\n```js\ncache: new Cache().restore(window.__APOLLO_STATE__)\n```\n\nIf you would like to learn more about server side rendering, please check our our more in depth guide [here].\n<!---\nTODO (PEGGY): Add link to SSR\n-->\n\n<h3 id=\"server\">Updating the cache after a mutation</h3>\n\nBeing able to read and write to the Apollo cache from anywhere in your application gives you a lot of power over your data. However, there is one place where we most often want to update our cached data: after a mutation. As such, Apollo Client has optimized the experience for updating your cache with the read and write methods after a mutation with the `update` function. Let us say that we have the following GraphQL mutation:\n\n```graphql\nmutation TodoCreateMutation($text: String!) {\n  createTodo(text: $text) {\n    id\n    text\n    completed\n  }\n}\n```\n\nWe may also have the following GraphQL query:\n\n```graphql\nquery TodoAppQuery {\n  todos {\n    id\n    text\n    completed\n  }\n}\n```\n\nAt the end of our mutation we want our query to include the new todo like we had sent our `TodoAppQuery` a second time after the mutation finished without actually sending the query. To do this we can use the `update` function provided as an option of the `client.mutate` method. To update your cache with the mutation just write code that looks like:\n\n```js\n// We assume that the GraphQL operations `TodoCreateMutation` and\n// `TodoAppQuery` have already been defined using the `gql` tag.\n\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    // Read the data from our cache for this query.\n    const data = proxy.readQuery({ query: TodoAppQuery });\n\n    // Add our todo from the mutation to the end.\n    data.todos.push(createTodo);\n\n    // Write our data back to the cache.\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nThe first `proxy` argument is an instance of [`DataProxy`][] has the same four methods that we just learned exist on the Apollo Client: `readQuery`, `readFragment`, `writeQuery`, and `writeFragment`. The reason we call them on a `proxy` object here instead of on our `client` instance is that we can easily apply optimistic updates (which we will demonstrate in a bit). The `proxy` object also provides an isolated transaction which shields you from any other mutations going on at the same time, and the `proxy` object also batches writes together until the very end.\n\nIf you provide an `optimisticResponse` option to the mutation then the `update` function will be run twice. Once immediately after you call `client.mutate` with the data from `optimisticResponse`. After the mutation successfully executes against the server the changes made in the first call to `update` will be rolled back and `update` will be called with the *actual* data returned by the mutation and not just the optimistic response.\n\nPutting it all together:\n\n```js\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  optimisticResponse: {\n    id: -1, // -1 is a temporary id for the optimistic response.\n    text,\n    completed: false,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    const data = proxy.readQuery({ query: TodoAppQuery });\n    data.todos.push(createTodo);\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nAs you can see the `update` function on `client.mutate` provides extra change management functionality specific to the use case of a mutation while still providing you the powerful data control APIs that are available on `client`.\n\nThe `update` function is not a good place for side-effects as it may be called multiple times. Also, you may not call any of the methods on `proxy` asynchronously.\n\n",
      "readmeFilename": "README.md",
      "_id": "apollo-cache-inmemory@1.3.1-local-state-alpha.11",
      "_npmVersion": "6.4.1",
      "_nodeVersion": "8.12.0",
      "_npmUser": {
        "name": "apollo-bot",
        "email": "npm@apollographql.com"
      },
      "dist": {
        "integrity": "sha512-jqaLhI7nQrjEOJ3dHpmaDxMxSZsH9SRv4b4ly7G5MIHAqrfqlM3IzvxFFoB0FnUYywEzYONN9gkJeig9zZKdZA==",
        "shasum": "32ea8934dbcbef2684d0cbcf7ddbb9f8092cc718",
        "tarball": "https://registry.npmjs.org/apollo-cache-inmemory/-/apollo-cache-inmemory-1.3.1-local-state-alpha.11.tgz",
        "fileCount": 84,
        "unpackedSize": 510409,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJb0gvqCRA9TVsSAnZWagAAzZ8P/2nUL9/pz5yga/ozI05B\n+fP/4GF04PaoG6m0sXwh25/0vfSqRJwKTGErWgvt9WVhfDcU58toaE50g6RN\n1J8b4IQDrSp/4mvGqeu+TlJHAD71TsTX+ijWCSLnrPkjhZmIWyW+RQvstxga\nZmadortr2BK2zkiy3IRAU+Te2YaMzxMuSfbRkXh6HQP4F8Q7ZjHJdXMeKooE\n75DZkPxyy3xErIsh1wvQzHPSDcnS+V1HiM4FkNEgUzyD+qKyhXt4wIIqroXx\n8a3UigF6Y1WKKP+QnIptYL2IRCHA9HlEWFS6DLD3itdzjWOD1NioeceFB85q\nDTfxE9VK9Yyct9KBpliP5AsThm2BlipahkrTngLgv92VP8+VaXY6fWTQVjR0\nXYEmYJ93guh1tOatQaLitprhvsg/z6Nve5Q7vEfNBnQoPpII7xd643zC/q4V\nAVVjnolmIAUH1HmKByQKw4mtwM5DdzJwsz210OTh2TlDrmVAJ/1HbZH/yajb\nDJ9Yhw2GgZYnKve3frKqBvXtROnxkYl/odQY68OHcARBIH/yCOQ/RToN7c5t\n+Xc0GJ9Kwvt6mKe+AI6HB2eEKffW+hZz4EGjz7huig9y0bQNXY95xkk1VWq+\nEVyb1QI3Dl/K6mmdfxPWwxWDo3Zs5XlBo8MuUj5ZOvecSHrEA5AJq/8HmdWf\nWmVi\r\n=xRwe\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEQCIDI9mk8YFXte+K3w5UARX24QkGIZDU4GG8uLUtQ6XyZRAiB2nbRUOGuSoodRkKz8HTxCoxSby+bc5P8Q2DqlJQ+uDA=="
          }
        ]
      },
      "maintainers": [
        {
          "email": "npm@apollographql.com",
          "name": "apollo-bot"
        },
        {
          "email": "ben@benjamn.com",
          "name": "benjamn"
        },
        {
          "email": "james@meteor.com",
          "name": "jbaxleyiii"
        },
        {
          "email": "peggyrayzis@gmail.com",
          "name": "peggyrayzis"
        }
      ],
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/apollo-cache-inmemory_1.3.1-local-state-alpha.11_1540492266003_0.7587316358592895"
      },
      "_hasShrinkwrap": false
    },
    "1.3.1-local-state-alpha.12": {
      "name": "apollo-cache-inmemory",
      "version": "1.3.1-local-state-alpha.12",
      "description": "Core abstract of Caching layer for Apollo Client",
      "author": {
        "name": "James Baxley",
        "email": "james@meteor.com"
      },
      "contributors": [
        {
          "name": "James Baxley",
          "email": "james@meteor.com"
        },
        {
          "name": "Jonas Helfer",
          "email": "jonas@helfer.email"
        },
        {
          "name": "Sashko Stubailo",
          "email": "sashko@stubailo.com"
        },
        {
          "name": "James Burgess",
          "email": "jamesmillerburgess@gmail.com"
        },
        {
          "name": "Bazyli Brzóska",
          "email": "bazyli.brzoska@gmail.com"
        }
      ],
      "license": "MIT",
      "main": "./lib/bundle.umd.js",
      "module": "./lib/index.js",
      "jsnext:main": "./lib/index.js",
      "typings": "./lib/index.d.ts",
      "sideEffects": false,
      "repository": {
        "type": "git",
        "url": "git+https://github.com/apollographql/apollo-client.git"
      },
      "bugs": {
        "url": "https://github.com/apollographql/apollo-client/issues"
      },
      "homepage": "https://github.com/apollographql/apollo-client#readme",
      "scripts": {
        "prepare": "npm run build",
        "coverage": "jest --coverage",
        "test": "jest",
        "lint": "tslint -c \"../../config/tslint.json\" -p tsconfig.json src/*.ts",
        "prebuild": "npm run clean",
        "build": "tsc -p .",
        "postbuild": "npm run bundle",
        "bundle": "../../node_modules/rollup/bin/rollup -c rollup.config.js",
        "watch": "tsc -w -p .",
        "clean": "rm -rf coverage/* && rm -rf lib/*",
        "prepublishOnly": "npm run build",
        "minify": "../../node_modules/uglify-js/bin/uglifyjs -c -m -o ./lib/bundle.min.js -- ./lib/bundle.umd.js",
        "filesize": "npm run minify"
      },
      "dependencies": {
        "apollo-cache": "^1.1.18-local-state-alpha.12",
        "apollo-utilities": "^1.0.22-local-state-alpha.12",
        "optimism": "^0.6.6"
      },
      "peerDependencies": {
        "graphql": "0.11.7 || ^0.12.0 || ^0.13.0"
      },
      "jest": {
        "transform": {
          ".(ts|tsx)": "ts-jest"
        },
        "testRegex": "(/__tests__/.*|\\.(test|spec))\\.(ts|tsx|js)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "json"
        ],
        "testURL": "http://localhost"
      },
      "gitHead": "30aaccf8b9b02340ea0c21b41022802386901dd0",
      "_resolved": "",
      "_integrity": "",
      "_from": "file:apollo-cache-inmemory-1.3.1-local-state-alpha.12.tgz",
      "readme": "---\ntitle: InMemoryCache\ndescription: An explanation of `apollo-cache-inmemory`\n---\n\n`apollo-cache-inmemory` is the recommended cache implementation for Apollo Client 2.0. `InMemoryCache` is a normalized data store that supports all of Apollo Client 1.0's features without the dependency on Redux.\n\nIn some instances, you may need to manipulate the cache directly, such as updating the store after a mutation. We'll cover some common use cases [here](#recipes).\n\n<h2 id=\"installation\">Installation</h2>\n\n```\nnpm install apollo-cache-inmemory --save\n```\n\nAfter installing the package, you'll want to initialize the cache constructor. Then, you can pass in your newly created cache to ApolloClient.\n\n```js\nimport { InMemoryCache } from 'apollo-cache-inmemory';\nimport { HttpLink } from 'apollo-link-http';\nimport ApolloClient from 'apollo-client';\n\nconst cache = new InMemoryCache();\n\nconst client = new ApolloClient({\n  link: new HttpLink(),\n  cache\n});\n```\n\n<h2 id=\"configuration\">Configuration</h2>\n\nThe `InMemoryCache` constructor takes an optional config object with properties to customize your cache:\n\n- addTypename: A boolean to determine whether to add __typename to the document (default: `true`)\n- dataIdFromObject: A function that takes a data object and returns a unique identifier to be used when normalizing the data in the store. Learn more about how to customize `dataIdFromObject` in the [Normalization](#normalization) section.\n- fragmentMatcher: By default, the `InMemoryCache` uses a heuristic fragment matcher. If you are using fragments on unions and interfaces, you will need to use an `IntrospectionFragmentMatcher`. For more information, please read [our guide to setting up fragment matching for unions & interfaces](https://www.apollographql.com/docs/react/advanced/fragments.html#fragment-matcher).\n\n<h2 id=\"normalization\">Normalization</h2>\n\nThe `InMemoryCache` normalizes your data before saving it to the store by splitting the result into individual objects, creating a unique identifier for each object, and storing those objects in a flattened data structure. By default, `InMemoryCache` will attempt to use the commonly found primary keys of `id` and `_id` for the unique identifier if they exist along with `__typename` on an object.\n\nIf `id` and `_id` are not specified, or if `__typename` is not specified, `InMemoryCache` will fall back to the path to the object in the query, such as `ROOT_QUERY.allPeople.0` for the first record returned on the `allPeople` root query.\n\nThis \"getter\" behavior for unique identifiers can be configured manually via the `dataIdFromObject` option passed to the `InMemoryCache` constructor, so you can pick which field is used if some of your data follows unorthodox primary key conventions.\n\nFor example, if you wanted to key off of the `key` field for all of your data, you could configure `dataIdFromObject` like so:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => object.key\n});\n```\n\nThis also allows you to use different unique identifiers for different data types by keying off of the `__typename` property attached to every object typed by GraphQL.  For example:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => {\n    switch (object.__typename) {\n      case 'foo': return object.key; // use `key` as the primary key\n      case 'bar': return object.blah; // use `blah` as the priamry key\n      default: return object.id || object._id; // fall back to `id` and `_id` for all other types\n    }\n  }\n});\n```\n\n<h2 id=\"direct\">Direct Cache Access</h2>\n\nTo interact directly with your cache, you can use the Apollo Client class methods readQuery, readFragment, writeQuery, and writeFragment. These methods are available to us via the [`DataProxy` interface](https://github.com/apollographql/apollo-client/blob/master/packages/apollo-cache/src/types/DataProxy.ts). Accessing these methods will vary slightly based on your view layer implementation. If you are using React, you can wrap your component in the `withApollo` higher order component, which will give you access to `this.props.client`. From there, you can use the methods to control your data.\n\nAny code demonstration in the following sections will assume that we have already initialized an instance of  `ApolloClient` and that we have imported the `gql` tag from `graphql-tag`.\n\n<h3 id=\"readquery\">readQuery</h3>\n\nThe `readQuery` method is very similar to the [`query` method on `ApolloClient`][] except that `readQuery` will _never_ make a request to your GraphQL server. The `query` method, on the other hand, may send a request to your server if the appropriate data is not in your cache whereas `readQuery` will throw an error if the data is not in your cache. `readQuery` will _always_ read from the cache. You can use `readQuery` by giving it a GraphQL query like so:\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo {\n      todo(id: 5) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n});\n```\n\nIf all of the data needed to fulfill this read is in Apollo Client’s normalized data cache then a data object will be returned in the shape of the query you wanted to read. If not all of the data needed to fulfill this read is in Apollo Client’s cache then an error will be thrown instead, so make sure to only read data that you know you have!\n\nYou can also pass variables into `readQuery`.\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo($id: Int!) {\n      todo(id: $id) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n  variables: {\n    id: 5,\n  },\n});\n```\n\n<h3 id=\"readfragment\">readFragment</h3>\n\nThis method allows you great flexibility around the data in your cache. Whereas `readQuery` only allowed you to read data from your root query type, `readFragment` allows you to read data from _any node you have queried_. This is incredibly powerful. You use this method as follows:\n\n```js\nconst todo = client.readFragment({\n  id: ..., // `id` is any id that could be returned by `dataIdFromObject`.\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\nThe first argument is the id of the data you want to read from the cache. That id must be a value that was returned by the `dataIdFromObject` function you defined when initializing `ApolloClient`. So for example if you initialized `ApolloClient` like so:\n\n```js\nconst client = new ApolloClient({\n  ...,\n  dataIdFromObject: object => object.id,\n});\n```\n\n…and you requested a todo before with an id of `5`, then you can read that todo out of your cache with the following:\n\n```js\nconst todo = client.readFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\n> **Note:** Most people add a `__typename` to the id in `dataIdFromObject`. If you do this then don’t forget to add the `__typename` when you are reading a fragment as well. So for example your id may be `Todo_5` and not just `5`.\n\nIf a todo with that id does not exist in the cache you will get `null` back. If a todo of that id does exist in the cache, but that todo does not have the `text` field then an error will be thrown.\n\nThe beauty of `readFragment` is that the todo could have come from anywhere! The todo could have been selected as a singleton (`{ todo(id: 5) { ... } }`), the todo could have come from a list of todos (`{ todos { ... } }`), or the todo could have come from a mutation (`mutation { createTodo { ... } }`). As long as at some point your GraphQL server gave you a todo with the provided id and fields `id`, `text`, and `completed` you can read it from the cache at any part of your code.\n\n<h3 id=\"writequery-and-writefragment\">writeQuery` and `writeFragment</h3>\n\nNot only can you read arbitrary data from the Apollo Client cache, but you can also write any data that you would like to the cache. The methods you use to do this are `writeQuery` and `writeFragment`. They will allow you to change data in your local cache, but it is important to remember that *they will not change any data on your server*. If you reload your environment then changes made with `writeQuery` and `writeFragment` will disappear.\n\nThese methods have the same signature as their `readQuery` and `readFragment` counterparts except they also require an additional `data` variable. So for example, if you wanted to update the `completed` flag locally for your todo with id `'5'` you could execute the following:\n\n```js\nclient.writeFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      completed\n    }\n  `,\n  data: {\n    completed: true,\n  },\n});\n```\n\nAny subscriber to the Apollo Client store will instantly see this update and render new UI accordingly.\n\n> **Note:** Again, remember that using `writeQuery` or `writeFragment` only changes data *locally*. If you reload your environment then changes made with these methods will no longer exist.\n\nOr if you wanted to add a new todo to a list fetched from the server, you could use `readQuery` and `writeQuery` together.\n\n```js\nconst query = gql`\n  query MyTodoAppQuery {\n    todos {\n      id\n      text\n      completed\n    }\n  }\n`;\n\nconst data = client.readQuery({ query });\n\nconst myNewTodo = {\n  id: '6',\n  text: 'Start using Apollo Client.',\n  completed: false,\n};\n\nclient.writeQuery({\n  query,\n  data: {\n    todos: [...data.todos, myNewTodo],\n  },\n});\n```\n\n<h2 id=\"recipes\">Recipes</h2>\n\nHere are some common situations where you would need to access the cache directly. If you're manipulating the cache in an interesting way and would like your example to be featured, please send in a pull request!\n\n<h3 id=\"server\">Server side rendering</h3>\n\nFirst, you will need to initialize an `InMemoryCache` on the server and create an instance of `ApolloClient`. In the initial serialized HTML payload from the server, you should include a script tag that extracts the data from the cache.\n\n```js\n`<script>\n  window.__APOLLO_STATE__=${JSON.stringify(cache.extract())}\n</script>`\n```\n\nOn the client, you can rehydrate the cache using the initial data passed from the server:\n\n```js\ncache: new Cache().restore(window.__APOLLO_STATE__)\n```\n\nIf you would like to learn more about server side rendering, please check our our more in depth guide [here].\n<!---\nTODO (PEGGY): Add link to SSR\n-->\n\n<h3 id=\"server\">Updating the cache after a mutation</h3>\n\nBeing able to read and write to the Apollo cache from anywhere in your application gives you a lot of power over your data. However, there is one place where we most often want to update our cached data: after a mutation. As such, Apollo Client has optimized the experience for updating your cache with the read and write methods after a mutation with the `update` function. Let us say that we have the following GraphQL mutation:\n\n```graphql\nmutation TodoCreateMutation($text: String!) {\n  createTodo(text: $text) {\n    id\n    text\n    completed\n  }\n}\n```\n\nWe may also have the following GraphQL query:\n\n```graphql\nquery TodoAppQuery {\n  todos {\n    id\n    text\n    completed\n  }\n}\n```\n\nAt the end of our mutation we want our query to include the new todo like we had sent our `TodoAppQuery` a second time after the mutation finished without actually sending the query. To do this we can use the `update` function provided as an option of the `client.mutate` method. To update your cache with the mutation just write code that looks like:\n\n```js\n// We assume that the GraphQL operations `TodoCreateMutation` and\n// `TodoAppQuery` have already been defined using the `gql` tag.\n\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    // Read the data from our cache for this query.\n    const data = proxy.readQuery({ query: TodoAppQuery });\n\n    // Add our todo from the mutation to the end.\n    data.todos.push(createTodo);\n\n    // Write our data back to the cache.\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nThe first `proxy` argument is an instance of [`DataProxy`][] has the same four methods that we just learned exist on the Apollo Client: `readQuery`, `readFragment`, `writeQuery`, and `writeFragment`. The reason we call them on a `proxy` object here instead of on our `client` instance is that we can easily apply optimistic updates (which we will demonstrate in a bit). The `proxy` object also provides an isolated transaction which shields you from any other mutations going on at the same time, and the `proxy` object also batches writes together until the very end.\n\nIf you provide an `optimisticResponse` option to the mutation then the `update` function will be run twice. Once immediately after you call `client.mutate` with the data from `optimisticResponse`. After the mutation successfully executes against the server the changes made in the first call to `update` will be rolled back and `update` will be called with the *actual* data returned by the mutation and not just the optimistic response.\n\nPutting it all together:\n\n```js\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  optimisticResponse: {\n    id: -1, // -1 is a temporary id for the optimistic response.\n    text,\n    completed: false,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    const data = proxy.readQuery({ query: TodoAppQuery });\n    data.todos.push(createTodo);\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nAs you can see the `update` function on `client.mutate` provides extra change management functionality specific to the use case of a mutation while still providing you the powerful data control APIs that are available on `client`.\n\nThe `update` function is not a good place for side-effects as it may be called multiple times. Also, you may not call any of the methods on `proxy` asynchronously.\n\n",
      "readmeFilename": "README.md",
      "_id": "apollo-cache-inmemory@1.3.1-local-state-alpha.12",
      "_npmVersion": "6.4.1",
      "_nodeVersion": "8.12.0",
      "_npmUser": {
        "name": "apollo-bot",
        "email": "npm@apollographql.com"
      },
      "dist": {
        "integrity": "sha512-tPPRbxI5qeoTRXGBli/PHBkxeQpjfZRgjilRc+Ratf1eFt8mGG6uNlb/9uDKrIcYusnAui3DmgXoWWPouavGxw==",
        "shasum": "5853ce5ee3243a4af1a859b575646eec80170fdd",
        "tarball": "https://registry.npmjs.org/apollo-cache-inmemory/-/apollo-cache-inmemory-1.3.1-local-state-alpha.12.tgz",
        "fileCount": 84,
        "unpackedSize": 510409,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJb0xGNCRA9TVsSAnZWagAA9S8QAJbXI6v/0OSvjIJqsls9\nbmdifr4kDWHmbKwms9BOKPu4CV6gtCDGt2CxANJtcEw/iHarvw52uz4XEacz\n+QHQwxm27VDcu8wXrbtDybuL3i4liQ3n1OXczszP2isIEj7d9Fls6zNqz0DB\nbmf6Y3TX0jEEmYCJ4sSInZK6knZ4lqJPllfnavwE6LlUrDc0sn0HpFMT7oJn\neAJVjEIluCDHG4kzODoDYbABg+VJSPvTtEkf5Jx2BHD5jC6lGLbelsLkd4ek\nuf3pWbUOUM3Olr0QZDq4D+XPe1MpusXnE/WUdDUp/rjLaDJKPY4rXVo3homa\ndowoJ/mwAnO2hULxXJ9NC/b5wYSF48nPBUlLDxJsnXQXlJeaYe0uHyU5w5B0\nvNq1sv8eRHRcQjMGpnsjOkwrmNcsjvNX6HHkRSJ/XctT45INKL+sRGq3sXWP\nExA582t2PVLGszB7htFFBbLHVGCQO0565RniAYOhzH8eGa5iF0XUcwlYnC7K\n1Mhvg7qzmjioJyg5U6fowPDY+P48HtGfPUVF2gVYPx2br/tbN82e/zSNG2lF\nQ/2hHXjU+B6wJAJphye1DIAlm2eqiBcvezIKq2vakN2+icL3Acr/DS9dI4hs\nUmIJ6DEStufF/KRqyQazNQzPff/OEuYKJs9pGjcnJw2xHRAcwGL602iUaU8Z\ncsbj\r\n=3bg2\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIQCYVlpahEHc82Js2PfYLUnXIPfJaQ1mCYNlUzRI527HHAIgRU+7uBBoXPSxnekWQishI7AGmVQCv/+YV4q62oKgr3o="
          }
        ]
      },
      "maintainers": [
        {
          "email": "npm@apollographql.com",
          "name": "apollo-bot"
        },
        {
          "email": "ben@benjamn.com",
          "name": "benjamn"
        },
        {
          "email": "james@meteor.com",
          "name": "jbaxleyiii"
        },
        {
          "email": "peggyrayzis@gmail.com",
          "name": "peggyrayzis"
        }
      ],
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/apollo-cache-inmemory_1.3.1-local-state-alpha.12_1540559244812_0.19257319062436973"
      },
      "_hasShrinkwrap": false
    },
    "1.3.7": {
      "name": "apollo-cache-inmemory",
      "version": "1.3.7",
      "description": "Core abstract of Caching layer for Apollo Client",
      "author": {
        "name": "James Baxley",
        "email": "james@meteor.com"
      },
      "contributors": [
        {
          "name": "James Baxley",
          "email": "james@meteor.com"
        },
        {
          "name": "Jonas Helfer",
          "email": "jonas@helfer.email"
        },
        {
          "name": "Sashko Stubailo",
          "email": "sashko@stubailo.com"
        },
        {
          "name": "James Burgess",
          "email": "jamesmillerburgess@gmail.com"
        },
        {
          "name": "Bazyli Brzóska",
          "email": "bazyli.brzoska@gmail.com"
        }
      ],
      "license": "MIT",
      "main": "./lib/bundle.umd.js",
      "module": "./lib/index.js",
      "jsnext:main": "./lib/index.js",
      "typings": "./lib/index.d.ts",
      "sideEffects": [
        "./lib/fixPolyfills.js"
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/apollographql/apollo-client.git"
      },
      "bugs": {
        "url": "https://github.com/apollographql/apollo-client/issues"
      },
      "homepage": "https://github.com/apollographql/apollo-client#readme",
      "scripts": {
        "prepare": "npm run build",
        "coverage": "jest --coverage",
        "test": "jest",
        "lint": "tslint -c \"../../config/tslint.json\" -p tsconfig.json src/*.ts",
        "prebuild": "npm run clean",
        "build": "tsc -p .",
        "postbuild": "npm run bundle",
        "bundle": "../../node_modules/rollup/bin/rollup -c rollup.config.js",
        "watch": "tsc -w -p .",
        "clean": "rm -rf coverage/* && rm -rf lib/*",
        "prepublishOnly": "npm run build",
        "minify": "../../node_modules/uglify-js/bin/uglifyjs -c -m -o ./lib/bundle.min.js -- ./lib/bundle.umd.js",
        "filesize": "npm run minify"
      },
      "dependencies": {
        "apollo-cache": "^1.1.19",
        "apollo-utilities": "^1.0.24",
        "optimism": "^0.6.6"
      },
      "peerDependencies": {
        "graphql": "0.11.7 || ^0.12.0 || ^0.13.0 || ^14.0.0"
      },
      "jest": {
        "transform": {
          ".(ts|tsx)": "ts-jest"
        },
        "testRegex": "(/__tests__/.*|\\.(test|spec))\\.(ts|tsx|js)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "json"
        ],
        "testURL": "http://localhost"
      },
      "gitHead": "45d1902c7c7948ef6a34184afbf2cf3120e44503",
      "_resolved": "",
      "_integrity": "",
      "_from": "file:apollo-cache-inmemory-1.3.7.tgz",
      "_id": "apollo-cache-inmemory@1.3.7",
      "_npmVersion": "6.4.1",
      "_nodeVersion": "8.11.4",
      "_npmUser": {
        "name": "benjamn",
        "email": "ben@benjamn.com"
      },
      "dist": {
        "integrity": "sha512-7AKGBuVRfgsjtq1yxcTWgpzi0WDVpjX2HJU9GFoYd+j7I253bSRn7YbwCNwkxyrH6ilSDU6JKm8DQ3QMA/z7rQ==",
        "shasum": "a9dabead5939e19068040c97c7c1009619a9df37",
        "tarball": "https://registry.npmjs.org/apollo-cache-inmemory/-/apollo-cache-inmemory-1.3.7.tgz",
        "fileCount": 89,
        "unpackedSize": 518951,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJb01FaCRA9TVsSAnZWagAAZNAQAJQ10nF9TtpFyKKBd0Y+\nJATujKZIXyC8ziU7dESyHpvIzkrwwOCg3xuE9cPoYgYXFCJFJX7DQsgBwtvh\nwkzcAOYAIZzTVtcWBn/5OLaTNB2qjGcmpq67SCJZEwkNTj7+6hheptCa3XRZ\nYdP/wLSCiqavs8k1JlnChshQgfckntXV4y2RoQU7k1qq9M1406XTFvPQ0G0l\n/yBIAZYqpASQku4Grna5eBq10OcpQfR1apbJLevBAt7A6NlbK0D9eHYnf/8N\nRzjfBq82yr1ppjTdJ6DnM0KTI3KX4ul0JU1/sVZsCwYdmODZzlzuMjFtC/Bt\n9Pgy4JLuvz9g148C0BO5UPHS2zy0EPdePiYPpUQcVy8mHWvQMEahDpAps7qc\nXLrapmJAFRmKETGyXfk5fO0gGscE6GnGFo/IAP+AtG7Z1FI3OfM0BYQPBZXK\nY1bmzNrLdUp3Z3ceR/QT5wlCTS2yIv296d/79vIYK6gY+xP2SlDhb0XlFr7v\nnokoHE7Gac8o4a+/J2TRwaeTmRmRwYMlSmxErtnFnKrJ4kQnl51pLmIXJ4qv\nL3rLG7KsZdjrJA509uJzqNWP/HKnRKzSDVC1JJAfEjQjlnH5w+LTeyKzt9MJ\nxPY5+fHK1t33LOHS7ChpEwxAIfMcrET/fDt/TXq8NUx1WQjFCLazMA/KZRUp\ncn+n\r\n=TCOB\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIBwfKEmiC8bts63jMh4mJEmgQbIYju7+nTzHZO0goLNzAiEAyDJP1IW+1DzaQvP+sW48jYR9gGo2oP4htJ45QyOLcJs="
          }
        ]
      },
      "maintainers": [
        {
          "email": "npm@apollographql.com",
          "name": "apollo-bot"
        },
        {
          "email": "ben@benjamn.com",
          "name": "benjamn"
        },
        {
          "email": "james@meteor.com",
          "name": "jbaxleyiii"
        },
        {
          "email": "peggyrayzis@gmail.com",
          "name": "peggyrayzis"
        }
      ],
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/apollo-cache-inmemory_1.3.7_1540575577252_0.5736016597521749"
      },
      "_hasShrinkwrap": false
    },
    "1.3.8": {
      "name": "apollo-cache-inmemory",
      "version": "1.3.8",
      "description": "Core abstract of Caching layer for Apollo Client",
      "author": {
        "name": "James Baxley",
        "email": "james@meteor.com"
      },
      "contributors": [
        {
          "name": "James Baxley",
          "email": "james@meteor.com"
        },
        {
          "name": "Jonas Helfer",
          "email": "jonas@helfer.email"
        },
        {
          "name": "Sashko Stubailo",
          "email": "sashko@stubailo.com"
        },
        {
          "name": "James Burgess",
          "email": "jamesmillerburgess@gmail.com"
        },
        {
          "name": "Bazyli Brzóska",
          "email": "bazyli.brzoska@gmail.com"
        }
      ],
      "license": "MIT",
      "main": "./lib/bundle.umd.js",
      "module": "./lib/index.js",
      "jsnext:main": "./lib/index.js",
      "typings": "./lib/index.d.ts",
      "sideEffects": [
        "./lib/fixPolyfills.js"
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/apollographql/apollo-client.git"
      },
      "bugs": {
        "url": "https://github.com/apollographql/apollo-client/issues"
      },
      "homepage": "https://github.com/apollographql/apollo-client#readme",
      "scripts": {
        "prepare": "npm run build",
        "coverage": "jest --coverage",
        "test": "jest",
        "lint": "tslint -c \"../../config/tslint.json\" -p tsconfig.json src/*.ts",
        "prebuild": "npm run clean",
        "build": "tsc -p .",
        "postbuild": "npm run bundle",
        "bundle": "../../node_modules/rollup/bin/rollup -c rollup.config.js",
        "watch": "tsc -w -p .",
        "clean": "rm -rf coverage/* && rm -rf lib/*",
        "prepublishOnly": "npm run build",
        "minify": "../../node_modules/uglify-js/bin/uglifyjs -c -m -o ./lib/bundle.min.js -- ./lib/bundle.umd.js",
        "filesize": "npm run minify"
      },
      "dependencies": {
        "apollo-cache": "^1.1.20",
        "apollo-utilities": "^1.0.25",
        "optimism": "^0.6.6"
      },
      "peerDependencies": {
        "graphql": "0.11.7 || ^0.12.0 || ^0.13.0 || ^14.0.0"
      },
      "jest": {
        "transform": {
          ".(ts|tsx)": "ts-jest"
        },
        "testRegex": "(/__tests__/.*|\\.(test|spec))\\.(ts|tsx|js)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "json"
        ],
        "testURL": "http://localhost"
      },
      "gitHead": "31b0ee4a027c60394cf9297df8f9eeeda3918272",
      "_resolved": "",
      "_integrity": "",
      "_from": "file:apollo-cache-inmemory-1.3.8.tgz",
      "_id": "apollo-cache-inmemory@1.3.8",
      "_npmVersion": "6.4.1",
      "_nodeVersion": "8.11.4",
      "_npmUser": {
        "name": "benjamn",
        "email": "ben@benjamn.com"
      },
      "dist": {
        "integrity": "sha512-bT1v8+kKgM9u8NvCODOZ2qKxdufsmBaUsnLp7s5+kv0Zq5u/Bw4Ltb3DxrYFQoqZYrKJKy1iMJE3MV2J/Dthjg==",
        "shasum": "5529a58b7b72b4bb133ce11ab22a012951297bb7",
        "tarball": "https://registry.npmjs.org/apollo-cache-inmemory/-/apollo-cache-inmemory-1.3.8.tgz",
        "fileCount": 89,
        "unpackedSize": 518694,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJb2He6CRA9TVsSAnZWagAAP+0P/3+64UWN0gaHKWmBCZlQ\nFfbcTSLm6w66KqsTputQm/eVEpvDT2NpdCNB5SrnagnWIPa3HxzdAWPflZE0\nuuBYkXvF5Ph1xhHV7t92lawXRrOoFc95KTRYCKMk7XNh3siFBLTEi1utnNkH\nKsPqt7lsb/7maEcrp/nOplLWx9O2EGVaFDLss9RZUm9ehZb7CmV1Zk19nuhx\nPqlZ72m9bTC/GKsGpvAfMMXKXsxqVIJClAH8mLv0bkFbLk7n8EJE0iaD5IZN\n1cPNLdrtk7T4gQdU3xTLABS4tEnckqjetN4fVqA1RN7Q6+9P6reHHt508PI2\nHyDcF4N5D47iuxyUy86amn+N4FvxtOS2bIkIlL6UlvbikpLwBSjhQcBUhS6I\nc5ciXlZJxDVfklpUcgyIFTqToJYYyLy2oqnX8ItTvhq0o61jdmB8PKQX5fGz\nAp1Nv2LR/7ubCLU0NmfTeVzV8IObSfOFz80tjeu6r90fjM9ix/co4yLlhxx9\nqM3Zl3jrPiwgKxiOM0Z7UoHHMdT050ID9m8XSILubkJmaAFOzXXRacM94J/V\nyA4pLyAEyofOttEL6la5GqQEWVCRv3Gafd7jYQY8dRuHEwFKUl66QCwHd09v\n/Mkc+V/b+EW5p/o6Ct6wduDo7tbBIVAYpQlSe5tjLt7Gt2GG9vOy3EIs9Gcw\nCi4R\r\n=Wmws\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIQCVvP2Vf8fFtpO3Em4RSBtK39PcA9UsMhBV01gtoBQc6wIgS6ixB0hiFfN1+XBKUmLGiXI8EZnf9+nywKIT8vLbYj4="
          }
        ]
      },
      "maintainers": [
        {
          "email": "npm@apollographql.com",
          "name": "apollo-bot"
        },
        {
          "email": "ben@benjamn.com",
          "name": "benjamn"
        },
        {
          "email": "james@meteor.com",
          "name": "jbaxleyiii"
        },
        {
          "email": "peggyrayzis@gmail.com",
          "name": "peggyrayzis"
        }
      ],
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/apollo-cache-inmemory_1.3.8_1540913081925_0.285835253919948"
      },
      "_hasShrinkwrap": false
    },
    "1.3.9-beta.0": {
      "name": "apollo-cache-inmemory",
      "version": "1.3.9-beta.0",
      "description": "Core abstract of Caching layer for Apollo Client",
      "author": {
        "name": "James Baxley",
        "email": "james@meteor.com"
      },
      "contributors": [
        {
          "name": "James Baxley",
          "email": "james@meteor.com"
        },
        {
          "name": "Jonas Helfer",
          "email": "jonas@helfer.email"
        },
        {
          "name": "Sashko Stubailo",
          "email": "sashko@stubailo.com"
        },
        {
          "name": "James Burgess",
          "email": "jamesmillerburgess@gmail.com"
        },
        {
          "name": "Bazyli Brzóska",
          "email": "bazyli.brzoska@gmail.com"
        }
      ],
      "license": "MIT",
      "main": "./lib/bundle.umd.js",
      "module": "./lib/index.js",
      "jsnext:main": "./lib/index.js",
      "typings": "./lib/index.d.ts",
      "sideEffects": [
        "./lib/fixPolyfills.js"
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/apollographql/apollo-client.git"
      },
      "bugs": {
        "url": "https://github.com/apollographql/apollo-client/issues"
      },
      "homepage": "https://github.com/apollographql/apollo-client#readme",
      "scripts": {
        "prepare": "npm run build",
        "coverage": "jest --coverage",
        "test": "jest",
        "lint": "tslint -c \"../../config/tslint.json\" -p tsconfig.json src/*.ts",
        "prebuild": "npm run clean",
        "build": "tsc -p .",
        "postbuild": "npm run bundle",
        "bundle": "../../node_modules/rollup/bin/rollup -c rollup.config.js",
        "watch": "tsc -w -p .",
        "clean": "rm -rf coverage/* && rm -rf lib/*",
        "prepublishOnly": "npm run build",
        "minify": "../../node_modules/uglify-js/bin/uglifyjs -c -m -o ./lib/bundle.min.js -- ./lib/bundle.umd.js",
        "filesize": "npm run minify"
      },
      "dependencies": {
        "apollo-cache": "file:../apollo-cache",
        "apollo-utilities": "file:../apollo-utilities",
        "optimism": "^0.6.6"
      },
      "peerDependencies": {
        "graphql": "0.11.7 || ^0.12.0 || ^0.13.0 || ^14.0.0"
      },
      "jest": {
        "transform": {
          ".(ts|tsx)": "ts-jest"
        },
        "testRegex": "(/__tests__/.*|\\.(test|spec))\\.(ts|tsx|js)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "json"
        ],
        "testURL": "http://localhost"
      },
      "readme": "---\ntitle: InMemoryCache\ndescription: An explanation of `apollo-cache-inmemory`\n---\n\n`apollo-cache-inmemory` is the recommended cache implementation for Apollo Client 2.0. `InMemoryCache` is a normalized data store that supports all of Apollo Client 1.0's features without the dependency on Redux.\n\nIn some instances, you may need to manipulate the cache directly, such as updating the store after a mutation. We'll cover some common use cases [here](#recipes).\n\n<h2 id=\"installation\">Installation</h2>\n\n```\nnpm install apollo-cache-inmemory --save\n```\n\nAfter installing the package, you'll want to initialize the cache constructor. Then, you can pass in your newly created cache to ApolloClient.\n\n```js\nimport { InMemoryCache } from 'apollo-cache-inmemory';\nimport { HttpLink } from 'apollo-link-http';\nimport ApolloClient from 'apollo-client';\n\nconst cache = new InMemoryCache();\n\nconst client = new ApolloClient({\n  link: new HttpLink(),\n  cache\n});\n```\n\n<h2 id=\"configuration\">Configuration</h2>\n\nThe `InMemoryCache` constructor takes an optional config object with properties to customize your cache:\n\n- addTypename: A boolean to determine whether to add __typename to the document (default: `true`)\n- dataIdFromObject: A function that takes a data object and returns a unique identifier to be used when normalizing the data in the store. Learn more about how to customize `dataIdFromObject` in the [Normalization](#normalization) section.\n- fragmentMatcher: By default, the `InMemoryCache` uses a heuristic fragment matcher. If you are using fragments on unions and interfaces, you will need to use an `IntrospectionFragmentMatcher`. For more information, please read [our guide to setting up fragment matching for unions & interfaces](https://www.apollographql.com/docs/react/advanced/fragments.html#fragment-matcher).\n\n<h2 id=\"normalization\">Normalization</h2>\n\nThe `InMemoryCache` normalizes your data before saving it to the store by splitting the result into individual objects, creating a unique identifier for each object, and storing those objects in a flattened data structure. By default, `InMemoryCache` will attempt to use the commonly found primary keys of `id` and `_id` for the unique identifier if they exist along with `__typename` on an object.\n\nIf `id` and `_id` are not specified, or if `__typename` is not specified, `InMemoryCache` will fall back to the path to the object in the query, such as `ROOT_QUERY.allPeople.0` for the first record returned on the `allPeople` root query.\n\nThis \"getter\" behavior for unique identifiers can be configured manually via the `dataIdFromObject` option passed to the `InMemoryCache` constructor, so you can pick which field is used if some of your data follows unorthodox primary key conventions.\n\nFor example, if you wanted to key off of the `key` field for all of your data, you could configure `dataIdFromObject` like so:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => object.key\n});\n```\n\nThis also allows you to use different unique identifiers for different data types by keying off of the `__typename` property attached to every object typed by GraphQL.  For example:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => {\n    switch (object.__typename) {\n      case 'foo': return object.key; // use `key` as the primary key\n      case 'bar': return object.blah; // use `blah` as the priamry key\n      default: return object.id || object._id; // fall back to `id` and `_id` for all other types\n    }\n  }\n});\n```\n\n<h2 id=\"direct\">Direct Cache Access</h2>\n\nTo interact directly with your cache, you can use the Apollo Client class methods readQuery, readFragment, writeQuery, and writeFragment. These methods are available to us via the [`DataProxy` interface](https://github.com/apollographql/apollo-client/blob/master/packages/apollo-cache/src/types/DataProxy.ts). Accessing these methods will vary slightly based on your view layer implementation. If you are using React, you can wrap your component in the `withApollo` higher order component, which will give you access to `this.props.client`. From there, you can use the methods to control your data.\n\nAny code demonstration in the following sections will assume that we have already initialized an instance of  `ApolloClient` and that we have imported the `gql` tag from `graphql-tag`.\n\n<h3 id=\"readquery\">readQuery</h3>\n\nThe `readQuery` method is very similar to the [`query` method on `ApolloClient`][] except that `readQuery` will _never_ make a request to your GraphQL server. The `query` method, on the other hand, may send a request to your server if the appropriate data is not in your cache whereas `readQuery` will throw an error if the data is not in your cache. `readQuery` will _always_ read from the cache. You can use `readQuery` by giving it a GraphQL query like so:\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo {\n      todo(id: 5) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n});\n```\n\nIf all of the data needed to fulfill this read is in Apollo Client’s normalized data cache then a data object will be returned in the shape of the query you wanted to read. If not all of the data needed to fulfill this read is in Apollo Client’s cache then an error will be thrown instead, so make sure to only read data that you know you have!\n\nYou can also pass variables into `readQuery`.\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo($id: Int!) {\n      todo(id: $id) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n  variables: {\n    id: 5,\n  },\n});\n```\n\n<h3 id=\"readfragment\">readFragment</h3>\n\nThis method allows you great flexibility around the data in your cache. Whereas `readQuery` only allowed you to read data from your root query type, `readFragment` allows you to read data from _any node you have queried_. This is incredibly powerful. You use this method as follows:\n\n```js\nconst todo = client.readFragment({\n  id: ..., // `id` is any id that could be returned by `dataIdFromObject`.\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\nThe first argument is the id of the data you want to read from the cache. That id must be a value that was returned by the `dataIdFromObject` function you defined when initializing `ApolloClient`. So for example if you initialized `ApolloClient` like so:\n\n```js\nconst client = new ApolloClient({\n  ...,\n  dataIdFromObject: object => object.id,\n});\n```\n\n…and you requested a todo before with an id of `5`, then you can read that todo out of your cache with the following:\n\n```js\nconst todo = client.readFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\n> **Note:** Most people add a `__typename` to the id in `dataIdFromObject`. If you do this then don’t forget to add the `__typename` when you are reading a fragment as well. So for example your id may be `Todo_5` and not just `5`.\n\nIf a todo with that id does not exist in the cache you will get `null` back. If a todo of that id does exist in the cache, but that todo does not have the `text` field then an error will be thrown.\n\nThe beauty of `readFragment` is that the todo could have come from anywhere! The todo could have been selected as a singleton (`{ todo(id: 5) { ... } }`), the todo could have come from a list of todos (`{ todos { ... } }`), or the todo could have come from a mutation (`mutation { createTodo { ... } }`). As long as at some point your GraphQL server gave you a todo with the provided id and fields `id`, `text`, and `completed` you can read it from the cache at any part of your code.\n\n<h3 id=\"writequery-and-writefragment\">writeQuery` and `writeFragment</h3>\n\nNot only can you read arbitrary data from the Apollo Client cache, but you can also write any data that you would like to the cache. The methods you use to do this are `writeQuery` and `writeFragment`. They will allow you to change data in your local cache, but it is important to remember that *they will not change any data on your server*. If you reload your environment then changes made with `writeQuery` and `writeFragment` will disappear.\n\nThese methods have the same signature as their `readQuery` and `readFragment` counterparts except they also require an additional `data` variable. So for example, if you wanted to update the `completed` flag locally for your todo with id `'5'` you could execute the following:\n\n```js\nclient.writeFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      completed\n    }\n  `,\n  data: {\n    completed: true,\n  },\n});\n```\n\nAny subscriber to the Apollo Client store will instantly see this update and render new UI accordingly.\n\n> **Note:** Again, remember that using `writeQuery` or `writeFragment` only changes data *locally*. If you reload your environment then changes made with these methods will no longer exist.\n\nOr if you wanted to add a new todo to a list fetched from the server, you could use `readQuery` and `writeQuery` together.\n\n```js\nconst query = gql`\n  query MyTodoAppQuery {\n    todos {\n      id\n      text\n      completed\n    }\n  }\n`;\n\nconst data = client.readQuery({ query });\n\nconst myNewTodo = {\n  id: '6',\n  text: 'Start using Apollo Client.',\n  completed: false,\n};\n\nclient.writeQuery({\n  query,\n  data: {\n    todos: [...data.todos, myNewTodo],\n  },\n});\n```\n\n<h2 id=\"recipes\">Recipes</h2>\n\nHere are some common situations where you would need to access the cache directly. If you're manipulating the cache in an interesting way and would like your example to be featured, please send in a pull request!\n\n<h3 id=\"server\">Server side rendering</h3>\n\nFirst, you will need to initialize an `InMemoryCache` on the server and create an instance of `ApolloClient`. In the initial serialized HTML payload from the server, you should include a script tag that extracts the data from the cache.\n\n```js\n`<script>\n  window.__APOLLO_STATE__=${JSON.stringify(cache.extract())}\n</script>`\n```\n\nOn the client, you can rehydrate the cache using the initial data passed from the server:\n\n```js\ncache: new Cache().restore(window.__APOLLO_STATE__)\n```\n\nIf you would like to learn more about server side rendering, please check our our more in depth guide [here].\n<!---\nTODO (PEGGY): Add link to SSR\n-->\n\n<h3 id=\"server\">Updating the cache after a mutation</h3>\n\nBeing able to read and write to the Apollo cache from anywhere in your application gives you a lot of power over your data. However, there is one place where we most often want to update our cached data: after a mutation. As such, Apollo Client has optimized the experience for updating your cache with the read and write methods after a mutation with the `update` function. Let us say that we have the following GraphQL mutation:\n\n```graphql\nmutation TodoCreateMutation($text: String!) {\n  createTodo(text: $text) {\n    id\n    text\n    completed\n  }\n}\n```\n\nWe may also have the following GraphQL query:\n\n```graphql\nquery TodoAppQuery {\n  todos {\n    id\n    text\n    completed\n  }\n}\n```\n\nAt the end of our mutation we want our query to include the new todo like we had sent our `TodoAppQuery` a second time after the mutation finished without actually sending the query. To do this we can use the `update` function provided as an option of the `client.mutate` method. To update your cache with the mutation just write code that looks like:\n\n```js\n// We assume that the GraphQL operations `TodoCreateMutation` and\n// `TodoAppQuery` have already been defined using the `gql` tag.\n\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    // Read the data from our cache for this query.\n    const data = proxy.readQuery({ query: TodoAppQuery });\n\n    // Add our todo from the mutation to the end.\n    data.todos.push(createTodo);\n\n    // Write our data back to the cache.\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nThe first `proxy` argument is an instance of [`DataProxy`][] has the same four methods that we just learned exist on the Apollo Client: `readQuery`, `readFragment`, `writeQuery`, and `writeFragment`. The reason we call them on a `proxy` object here instead of on our `client` instance is that we can easily apply optimistic updates (which we will demonstrate in a bit). The `proxy` object also provides an isolated transaction which shields you from any other mutations going on at the same time, and the `proxy` object also batches writes together until the very end.\n\nIf you provide an `optimisticResponse` option to the mutation then the `update` function will be run twice. Once immediately after you call `client.mutate` with the data from `optimisticResponse`. After the mutation successfully executes against the server the changes made in the first call to `update` will be rolled back and `update` will be called with the *actual* data returned by the mutation and not just the optimistic response.\n\nPutting it all together:\n\n```js\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  optimisticResponse: {\n    id: -1, // -1 is a temporary id for the optimistic response.\n    text,\n    completed: false,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    const data = proxy.readQuery({ query: TodoAppQuery });\n    data.todos.push(createTodo);\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nAs you can see the `update` function on `client.mutate` provides extra change management functionality specific to the use case of a mutation while still providing you the powerful data control APIs that are available on `client`.\n\nThe `update` function is not a good place for side-effects as it may be called multiple times. Also, you may not call any of the methods on `proxy` asynchronously.\n\n",
      "readmeFilename": "README.md",
      "_id": "apollo-cache-inmemory@1.3.9-beta.0",
      "_npmVersion": "6.4.1",
      "_nodeVersion": "8.12.0",
      "_npmUser": {
        "name": "benjamn",
        "email": "ben@benjamn.com"
      },
      "dist": {
        "integrity": "sha512-n1KsBMiup+fNIk6aUVgjCijfxRE1La4Rn1/eoKGQ8czc+nPA7hVfM5L0DuZwMAmh0hzfL11Fu0T7rLX2QF9DRg==",
        "shasum": "63129c563c5bd084533abe1a972e846794818d10",
        "tarball": "https://registry.npmjs.org/apollo-cache-inmemory/-/apollo-cache-inmemory-1.3.9-beta.0.tgz",
        "fileCount": 88,
        "unpackedSize": 523586,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJb26p5CRA9TVsSAnZWagAArvkP/jpgCD1VEhEdYsV2BR+d\nc6hxbihGNT+6wCYR4wclb/prw9F2r8qA4CidYEiyzJFWAeJJmVbwvua3lB4z\nU3waL4y1BO0qWUcpe/JKihv3V1KJavEp2rZbj3n69wew/UEeCC8LfVA9pjbz\ndd8hfQiFGm404IQvrWxZLSh2Sg/6v9mcd+l2v+C/qAZcpQVK4OgTZXvEIdVK\n8Pyo+vKq8gU42udCkc3I23jhbfXTmLDNVVWrbSExpwv1X+rTjTSsN+/zK77Q\nwTgMo80SZWSpMjhXQ9l1UedvN3o31Qyf0+ElKNJPV34UVkJAnnyEJ7zsWKmn\nVLawueLHXQXAwDYpXNwfNhcRP5buWCWszJ4bNdQqu2kefwEdeV/nHzmjgRvL\nFTKoLWWZz2oJOlwPKwtME4PFcmgZfwb427yEkUBdvJBX1sqySmbnbpjxbzSJ\nuuqykvDAEal9OscA/a01cN/S3mxMi+kZJx5lOZbfp97wtzTsy4LDr6ujj58N\n2GiRYN+JPraLC3Z3FFZPyjga2AS8KSSVZFFzhqWjEZL2BPYMhox5WNiPbXCJ\nF3F3lGpM+no846FikLmNsQQNmKWOQeqr4CDZ7AQ57kP7z93+XlJHEECm+Rrq\ns295DOqRyO/5qxF3K7rkvX59yfPjz1ip/KfqJpXBs2F8FQ5LTk1erGCl9lwo\nPkaQ\r\n=Kytn\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCICxe2r93HdZ/5Olcpbgeg4SGuzxnrhftPPTb/PlExM4MAiEAswdKfdJUYd57t5Vwxv4ZLcec5FWoKd5VLlvjPOrud7k="
          }
        ]
      },
      "maintainers": [
        {
          "email": "npm@apollographql.com",
          "name": "apollo-bot"
        },
        {
          "email": "ben@benjamn.com",
          "name": "benjamn"
        },
        {
          "email": "james@meteor.com",
          "name": "jbaxleyiii"
        },
        {
          "email": "peggyrayzis@gmail.com",
          "name": "peggyrayzis"
        }
      ],
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/apollo-cache-inmemory_1.3.9-beta.0_1541122680996_0.894146580587992"
      },
      "_hasShrinkwrap": false
    },
    "1.3.9-beta.1": {
      "name": "apollo-cache-inmemory",
      "version": "1.3.9-beta.1",
      "description": "Core abstract of Caching layer for Apollo Client",
      "author": {
        "name": "James Baxley",
        "email": "james@meteor.com"
      },
      "contributors": [
        {
          "name": "James Baxley",
          "email": "james@meteor.com"
        },
        {
          "name": "Jonas Helfer",
          "email": "jonas@helfer.email"
        },
        {
          "name": "Sashko Stubailo",
          "email": "sashko@stubailo.com"
        },
        {
          "name": "James Burgess",
          "email": "jamesmillerburgess@gmail.com"
        },
        {
          "name": "Bazyli Brzóska",
          "email": "bazyli.brzoska@gmail.com"
        }
      ],
      "license": "MIT",
      "main": "./lib/bundle.umd.js",
      "module": "./lib/index.js",
      "jsnext:main": "./lib/index.js",
      "typings": "./lib/index.d.ts",
      "sideEffects": [
        "./lib/fixPolyfills.js"
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/apollographql/apollo-client.git"
      },
      "bugs": {
        "url": "https://github.com/apollographql/apollo-client/issues"
      },
      "homepage": "https://github.com/apollographql/apollo-client#readme",
      "scripts": {
        "prepare": "npm run build",
        "coverage": "jest --coverage",
        "test": "jest",
        "lint": "tslint -c \"../../config/tslint.json\" -p tsconfig.json src/*.ts",
        "prebuild": "npm run clean",
        "build": "tsc -p .",
        "postbuild": "npm run bundle",
        "bundle": "../../node_modules/rollup/bin/rollup -c rollup.config.js",
        "watch": "tsc -w -p .",
        "clean": "rm -rf coverage/* && rm -rf lib/*",
        "prepublishOnly": "npm run build",
        "minify": "../../node_modules/uglify-js/bin/uglifyjs -c -m -o ./lib/bundle.min.js -- ./lib/bundle.umd.js",
        "filesize": "npm run minify"
      },
      "dependencies": {
        "apollo-cache": "^1.1.20",
        "apollo-utilities": "^1.0.25",
        "optimism": "^0.6.6"
      },
      "peerDependencies": {
        "graphql": "0.11.7 || ^0.12.0 || ^0.13.0 || ^14.0.0"
      },
      "jest": {
        "transform": {
          ".(ts|tsx)": "ts-jest"
        },
        "testRegex": "(/__tests__/.*|\\.(test|spec))\\.(ts|tsx|js)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "json"
        ],
        "testURL": "http://localhost"
      },
      "readme": "---\ntitle: InMemoryCache\ndescription: An explanation of `apollo-cache-inmemory`\n---\n\n`apollo-cache-inmemory` is the recommended cache implementation for Apollo Client 2.0. `InMemoryCache` is a normalized data store that supports all of Apollo Client 1.0's features without the dependency on Redux.\n\nIn some instances, you may need to manipulate the cache directly, such as updating the store after a mutation. We'll cover some common use cases [here](#recipes).\n\n<h2 id=\"installation\">Installation</h2>\n\n```\nnpm install apollo-cache-inmemory --save\n```\n\nAfter installing the package, you'll want to initialize the cache constructor. Then, you can pass in your newly created cache to ApolloClient.\n\n```js\nimport { InMemoryCache } from 'apollo-cache-inmemory';\nimport { HttpLink } from 'apollo-link-http';\nimport ApolloClient from 'apollo-client';\n\nconst cache = new InMemoryCache();\n\nconst client = new ApolloClient({\n  link: new HttpLink(),\n  cache\n});\n```\n\n<h2 id=\"configuration\">Configuration</h2>\n\nThe `InMemoryCache` constructor takes an optional config object with properties to customize your cache:\n\n- addTypename: A boolean to determine whether to add __typename to the document (default: `true`)\n- dataIdFromObject: A function that takes a data object and returns a unique identifier to be used when normalizing the data in the store. Learn more about how to customize `dataIdFromObject` in the [Normalization](#normalization) section.\n- fragmentMatcher: By default, the `InMemoryCache` uses a heuristic fragment matcher. If you are using fragments on unions and interfaces, you will need to use an `IntrospectionFragmentMatcher`. For more information, please read [our guide to setting up fragment matching for unions & interfaces](https://www.apollographql.com/docs/react/advanced/fragments.html#fragment-matcher).\n\n<h2 id=\"normalization\">Normalization</h2>\n\nThe `InMemoryCache` normalizes your data before saving it to the store by splitting the result into individual objects, creating a unique identifier for each object, and storing those objects in a flattened data structure. By default, `InMemoryCache` will attempt to use the commonly found primary keys of `id` and `_id` for the unique identifier if they exist along with `__typename` on an object.\n\nIf `id` and `_id` are not specified, or if `__typename` is not specified, `InMemoryCache` will fall back to the path to the object in the query, such as `ROOT_QUERY.allPeople.0` for the first record returned on the `allPeople` root query.\n\nThis \"getter\" behavior for unique identifiers can be configured manually via the `dataIdFromObject` option passed to the `InMemoryCache` constructor, so you can pick which field is used if some of your data follows unorthodox primary key conventions.\n\nFor example, if you wanted to key off of the `key` field for all of your data, you could configure `dataIdFromObject` like so:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => object.key\n});\n```\n\nThis also allows you to use different unique identifiers for different data types by keying off of the `__typename` property attached to every object typed by GraphQL.  For example:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => {\n    switch (object.__typename) {\n      case 'foo': return object.key; // use `key` as the primary key\n      case 'bar': return object.blah; // use `blah` as the priamry key\n      default: return object.id || object._id; // fall back to `id` and `_id` for all other types\n    }\n  }\n});\n```\n\n<h2 id=\"direct\">Direct Cache Access</h2>\n\nTo interact directly with your cache, you can use the Apollo Client class methods readQuery, readFragment, writeQuery, and writeFragment. These methods are available to us via the [`DataProxy` interface](https://github.com/apollographql/apollo-client/blob/master/packages/apollo-cache/src/types/DataProxy.ts). Accessing these methods will vary slightly based on your view layer implementation. If you are using React, you can wrap your component in the `withApollo` higher order component, which will give you access to `this.props.client`. From there, you can use the methods to control your data.\n\nAny code demonstration in the following sections will assume that we have already initialized an instance of  `ApolloClient` and that we have imported the `gql` tag from `graphql-tag`.\n\n<h3 id=\"readquery\">readQuery</h3>\n\nThe `readQuery` method is very similar to the [`query` method on `ApolloClient`][] except that `readQuery` will _never_ make a request to your GraphQL server. The `query` method, on the other hand, may send a request to your server if the appropriate data is not in your cache whereas `readQuery` will throw an error if the data is not in your cache. `readQuery` will _always_ read from the cache. You can use `readQuery` by giving it a GraphQL query like so:\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo {\n      todo(id: 5) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n});\n```\n\nIf all of the data needed to fulfill this read is in Apollo Client’s normalized data cache then a data object will be returned in the shape of the query you wanted to read. If not all of the data needed to fulfill this read is in Apollo Client’s cache then an error will be thrown instead, so make sure to only read data that you know you have!\n\nYou can also pass variables into `readQuery`.\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo($id: Int!) {\n      todo(id: $id) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n  variables: {\n    id: 5,\n  },\n});\n```\n\n<h3 id=\"readfragment\">readFragment</h3>\n\nThis method allows you great flexibility around the data in your cache. Whereas `readQuery` only allowed you to read data from your root query type, `readFragment` allows you to read data from _any node you have queried_. This is incredibly powerful. You use this method as follows:\n\n```js\nconst todo = client.readFragment({\n  id: ..., // `id` is any id that could be returned by `dataIdFromObject`.\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\nThe first argument is the id of the data you want to read from the cache. That id must be a value that was returned by the `dataIdFromObject` function you defined when initializing `ApolloClient`. So for example if you initialized `ApolloClient` like so:\n\n```js\nconst client = new ApolloClient({\n  ...,\n  dataIdFromObject: object => object.id,\n});\n```\n\n…and you requested a todo before with an id of `5`, then you can read that todo out of your cache with the following:\n\n```js\nconst todo = client.readFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\n> **Note:** Most people add a `__typename` to the id in `dataIdFromObject`. If you do this then don’t forget to add the `__typename` when you are reading a fragment as well. So for example your id may be `Todo_5` and not just `5`.\n\nIf a todo with that id does not exist in the cache you will get `null` back. If a todo of that id does exist in the cache, but that todo does not have the `text` field then an error will be thrown.\n\nThe beauty of `readFragment` is that the todo could have come from anywhere! The todo could have been selected as a singleton (`{ todo(id: 5) { ... } }`), the todo could have come from a list of todos (`{ todos { ... } }`), or the todo could have come from a mutation (`mutation { createTodo { ... } }`). As long as at some point your GraphQL server gave you a todo with the provided id and fields `id`, `text`, and `completed` you can read it from the cache at any part of your code.\n\n<h3 id=\"writequery-and-writefragment\">writeQuery` and `writeFragment</h3>\n\nNot only can you read arbitrary data from the Apollo Client cache, but you can also write any data that you would like to the cache. The methods you use to do this are `writeQuery` and `writeFragment`. They will allow you to change data in your local cache, but it is important to remember that *they will not change any data on your server*. If you reload your environment then changes made with `writeQuery` and `writeFragment` will disappear.\n\nThese methods have the same signature as their `readQuery` and `readFragment` counterparts except they also require an additional `data` variable. So for example, if you wanted to update the `completed` flag locally for your todo with id `'5'` you could execute the following:\n\n```js\nclient.writeFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      completed\n    }\n  `,\n  data: {\n    completed: true,\n  },\n});\n```\n\nAny subscriber to the Apollo Client store will instantly see this update and render new UI accordingly.\n\n> **Note:** Again, remember that using `writeQuery` or `writeFragment` only changes data *locally*. If you reload your environment then changes made with these methods will no longer exist.\n\nOr if you wanted to add a new todo to a list fetched from the server, you could use `readQuery` and `writeQuery` together.\n\n```js\nconst query = gql`\n  query MyTodoAppQuery {\n    todos {\n      id\n      text\n      completed\n    }\n  }\n`;\n\nconst data = client.readQuery({ query });\n\nconst myNewTodo = {\n  id: '6',\n  text: 'Start using Apollo Client.',\n  completed: false,\n};\n\nclient.writeQuery({\n  query,\n  data: {\n    todos: [...data.todos, myNewTodo],\n  },\n});\n```\n\n<h2 id=\"recipes\">Recipes</h2>\n\nHere are some common situations where you would need to access the cache directly. If you're manipulating the cache in an interesting way and would like your example to be featured, please send in a pull request!\n\n<h3 id=\"server\">Server side rendering</h3>\n\nFirst, you will need to initialize an `InMemoryCache` on the server and create an instance of `ApolloClient`. In the initial serialized HTML payload from the server, you should include a script tag that extracts the data from the cache.\n\n```js\n`<script>\n  window.__APOLLO_STATE__=${JSON.stringify(cache.extract())}\n</script>`\n```\n\nOn the client, you can rehydrate the cache using the initial data passed from the server:\n\n```js\ncache: new Cache().restore(window.__APOLLO_STATE__)\n```\n\nIf you would like to learn more about server side rendering, please check our our more in depth guide [here].\n<!---\nTODO (PEGGY): Add link to SSR\n-->\n\n<h3 id=\"server\">Updating the cache after a mutation</h3>\n\nBeing able to read and write to the Apollo cache from anywhere in your application gives you a lot of power over your data. However, there is one place where we most often want to update our cached data: after a mutation. As such, Apollo Client has optimized the experience for updating your cache with the read and write methods after a mutation with the `update` function. Let us say that we have the following GraphQL mutation:\n\n```graphql\nmutation TodoCreateMutation($text: String!) {\n  createTodo(text: $text) {\n    id\n    text\n    completed\n  }\n}\n```\n\nWe may also have the following GraphQL query:\n\n```graphql\nquery TodoAppQuery {\n  todos {\n    id\n    text\n    completed\n  }\n}\n```\n\nAt the end of our mutation we want our query to include the new todo like we had sent our `TodoAppQuery` a second time after the mutation finished without actually sending the query. To do this we can use the `update` function provided as an option of the `client.mutate` method. To update your cache with the mutation just write code that looks like:\n\n```js\n// We assume that the GraphQL operations `TodoCreateMutation` and\n// `TodoAppQuery` have already been defined using the `gql` tag.\n\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    // Read the data from our cache for this query.\n    const data = proxy.readQuery({ query: TodoAppQuery });\n\n    // Add our todo from the mutation to the end.\n    data.todos.push(createTodo);\n\n    // Write our data back to the cache.\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nThe first `proxy` argument is an instance of [`DataProxy`][] has the same four methods that we just learned exist on the Apollo Client: `readQuery`, `readFragment`, `writeQuery`, and `writeFragment`. The reason we call them on a `proxy` object here instead of on our `client` instance is that we can easily apply optimistic updates (which we will demonstrate in a bit). The `proxy` object also provides an isolated transaction which shields you from any other mutations going on at the same time, and the `proxy` object also batches writes together until the very end.\n\nIf you provide an `optimisticResponse` option to the mutation then the `update` function will be run twice. Once immediately after you call `client.mutate` with the data from `optimisticResponse`. After the mutation successfully executes against the server the changes made in the first call to `update` will be rolled back and `update` will be called with the *actual* data returned by the mutation and not just the optimistic response.\n\nPutting it all together:\n\n```js\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  optimisticResponse: {\n    id: -1, // -1 is a temporary id for the optimistic response.\n    text,\n    completed: false,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    const data = proxy.readQuery({ query: TodoAppQuery });\n    data.todos.push(createTodo);\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nAs you can see the `update` function on `client.mutate` provides extra change management functionality specific to the use case of a mutation while still providing you the powerful data control APIs that are available on `client`.\n\nThe `update` function is not a good place for side-effects as it may be called multiple times. Also, you may not call any of the methods on `proxy` asynchronously.\n\n",
      "readmeFilename": "README.md",
      "_id": "apollo-cache-inmemory@1.3.9-beta.1",
      "_npmVersion": "6.4.1",
      "_nodeVersion": "8.12.0",
      "_npmUser": {
        "name": "benjamn",
        "email": "ben@benjamn.com"
      },
      "dist": {
        "integrity": "sha512-TWeFp1sRNd6vbRL9yK3Smcmi4YSndscp9OGQDErgWOt2elcEnN0aHbnbzlFTt3t3ipMAKIM/dfEDHIsLteG0DQ==",
        "shasum": "dd8ca42c214890628c1150275f1aabb69ec1ddc8",
        "tarball": "https://registry.npmjs.org/apollo-cache-inmemory/-/apollo-cache-inmemory-1.3.9-beta.1.tgz",
        "fileCount": 88,
        "unpackedSize": 523556,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJb26r1CRA9TVsSAnZWagAA4+8P+wfBfwekW+SkI38on7x0\n2yL/UYJqsm/0j53mUNMqQdJ4Ec7fm2kd3OPioa0s773jT0VmAfDwLrfCmNnh\nk7t2vh6yA4iLY4aR/Jx1NhF6AHeEa+2VzXzozIx+yNFYIsY95wdGgGEPrkI2\n+jWq8z4IQyNui0D1zPWrqzOKK7bJYMBqfGFgpTHqdqqqS772YPcdgpsA2T5i\nYNfNUJ8bYH0TQOyo7HfYVvUt9VckMhSgp057RspayjEiaFcibSoWv0BayzTP\nwMl8vsh9EfS48GJWd6UoDqfR5wqjo14jd1qHGnGuXuGDqcc9SyWuN7yw6rt1\nceMg5SdQ+wzl4cLJ6qsmEMUx/J5d30/JUj2XL4bck2puwFx5ul7uSrleKWUW\nvc6dswbqwTCq8RNeImJqxKLQQCCa93p9bLtZc0Dv5jwyOAMD63R6JOmwONM2\ntKQNWVW7JiKKfY8hEl3n2Wd7SVEGVW/4V2A3eFEkmyZnDu2mw/FccW8DnWjc\nEhY0/hLNimyErO8X/jc6NW/GhwgOocvLOhEVv+VQ298WBKGWl14nuRjMtdyP\nOl1Qg/FPGuzHX/O6PVKETdCfVi53fA/vMJoa+DQvM2Y2RVnBQEkwsVX0pCMm\n7p1s0PiDxBszh/9eMeb0SSv6sX0FRDEKP17iqrC5OZxLd3pN94h92Xt7QLni\nQyH/\r\n=SiEm\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEQCICQBA1nWYp1MXc2mshSylkWqkuvTXhtZZ7Aj5TC3ATDtAiBJ/XRyWa4VZ5KZGymBjBuwloGMpauh4OcryNGMNS+pJA=="
          }
        ]
      },
      "maintainers": [
        {
          "email": "npm@apollographql.com",
          "name": "apollo-bot"
        },
        {
          "email": "ben@benjamn.com",
          "name": "benjamn"
        },
        {
          "email": "james@meteor.com",
          "name": "jbaxleyiii"
        },
        {
          "email": "peggyrayzis@gmail.com",
          "name": "peggyrayzis"
        }
      ],
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/apollo-cache-inmemory_1.3.9-beta.1_1541122804531_0.6460317292549229"
      },
      "_hasShrinkwrap": false
    },
    "1.3.9": {
      "name": "apollo-cache-inmemory",
      "version": "1.3.9",
      "description": "Core abstract of Caching layer for Apollo Client",
      "author": {
        "name": "James Baxley",
        "email": "james@meteor.com"
      },
      "contributors": [
        {
          "name": "James Baxley",
          "email": "james@meteor.com"
        },
        {
          "name": "Jonas Helfer",
          "email": "jonas@helfer.email"
        },
        {
          "name": "Sashko Stubailo",
          "email": "sashko@stubailo.com"
        },
        {
          "name": "James Burgess",
          "email": "jamesmillerburgess@gmail.com"
        },
        {
          "name": "Bazyli Brzóska",
          "email": "bazyli.brzoska@gmail.com"
        }
      ],
      "license": "MIT",
      "main": "./lib/bundle.umd.js",
      "module": "./lib/index.js",
      "jsnext:main": "./lib/index.js",
      "typings": "./lib/index.d.ts",
      "sideEffects": [
        "./lib/fixPolyfills.js"
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/apollographql/apollo-client.git"
      },
      "bugs": {
        "url": "https://github.com/apollographql/apollo-client/issues"
      },
      "homepage": "https://github.com/apollographql/apollo-client#readme",
      "scripts": {
        "prepare": "npm run build",
        "coverage": "jest --coverage",
        "test": "jest",
        "lint": "tslint -c \"../../config/tslint.json\" -p tsconfig.json src/*.ts",
        "prebuild": "npm run clean",
        "build": "tsc -p .",
        "postbuild": "npm run bundle",
        "bundle": "../../node_modules/rollup/bin/rollup -c rollup.config.js",
        "watch": "tsc -w -p .",
        "clean": "rm -rf coverage/* && rm -rf lib/*",
        "prepublishOnly": "npm run build",
        "minify": "../../node_modules/uglify-js/bin/uglifyjs -c -m -o ./lib/bundle.min.js -- ./lib/bundle.umd.js",
        "filesize": "npm run minify"
      },
      "dependencies": {
        "apollo-cache": "^1.1.20",
        "apollo-utilities": "^1.0.25",
        "optimism": "^0.6.6"
      },
      "peerDependencies": {
        "graphql": "0.11.7 || ^0.12.0 || ^0.13.0 || ^14.0.0"
      },
      "jest": {
        "transform": {
          ".(ts|tsx)": "ts-jest"
        },
        "testRegex": "(/__tests__/.*|\\.(test|spec))\\.(ts|tsx|js)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "json"
        ],
        "testURL": "http://localhost"
      },
      "gitHead": "9e7f06b856b133216bb639f787d8da81a6ab2df4",
      "_resolved": "",
      "_integrity": "",
      "_from": "file:apollo-cache-inmemory-1.3.9.tgz",
      "_id": "apollo-cache-inmemory@1.3.9",
      "_npmVersion": "6.4.1",
      "_nodeVersion": "8.12.0",
      "_npmUser": {
        "name": "benjamn",
        "email": "ben@benjamn.com"
      },
      "dist": {
        "integrity": "sha512-Q2k84p/OqIuMUyeWGc6XbVXXZu0erYOO+wTx9p+CnQUspnNvf7zmvFNgFnmudXzfuG1m1CSzePk6fC/M1ehOqQ==",
        "shasum": "10738ba6a04faaeeb0da21bbcc1f7c0b5902910c",
        "tarball": "https://registry.npmjs.org/apollo-cache-inmemory/-/apollo-cache-inmemory-1.3.9.tgz",
        "fileCount": 89,
        "unpackedSize": 526968,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJb3go3CRA9TVsSAnZWagAA3sAQAJLQOtO9CwKzbou79UrO\nF41bJCNrsFfxEhv5BH4nq6e/G7dClWxXksHCWkVoVJSOrPhlUkQXqtQnH58r\nw8kNoSxfG1xlmI22M8ZAuG+f32uz+FY93VdrfEfb5BpU7DPzeBrk5Alc/4ZH\nixBmc2DOyar3oWBvHtb704B6ZBbjf3D5sD0EB0lbQC8jDiW8zjJ2oWSdpMpt\n1jan6eYNOTFM2YJoLePFALZWdNeRHUFKZbLxaeHI0WQOzzpAH4wbOGOvm7/l\neoO4kCK+q3J6hubEtmQ+9hCohkD2hWspttXkBxuH8Qda4doFbmhB20xq+zkN\nMHIU1BYdqv7MjfLtAJ+1rV4gK16Zpe48aBjyz/48kl84gbwbZJ+oedauKKjv\nNalR+lNk+cZLuELn1rpCHgaQBAeY4tkZyxcNkFqtEUmJh1/AMsBot++d4X8f\nJM0qPcMpZDH/Rw7nrmxFheY3SENKevPhP76XVUksb1YJjz2rzolhcSSlV1OV\nRfDmhwvcqasT7anajz5ybAxi+LlWvH73x1xu899QLm2Caj2TLP/TYo8kPDtH\niKo6peVe8mZvNvqHZQOlHMdexGou6kCiEo+XDVglyCTwg0hSULRGoikwuLG7\nvS+1PB6xk/H6uqlNzI8rjbRley27zuVwGTf8Z9n6o8ueV553w0t1wc1xAXDE\nUb2q\r\n=GIUQ\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIGt0jM6J9VUj+UW0AznrLGg7f0vP032gDdP+oAx9/kGjAiEA8P9rpaTb0i0TBJYKio1Xv0om22HAUR8oUTUFxNQv1aM="
          }
        ]
      },
      "maintainers": [
        {
          "email": "npm@apollographql.com",
          "name": "apollo-bot"
        },
        {
          "email": "ben@benjamn.com",
          "name": "benjamn"
        },
        {
          "email": "james@meteor.com",
          "name": "jbaxleyiii"
        },
        {
          "email": "peggyrayzis@gmail.com",
          "name": "peggyrayzis"
        }
      ],
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/apollo-cache-inmemory_1.3.9_1541278262397_0.9949009560035422"
      },
      "_hasShrinkwrap": false
    },
    "1.3.1-local-state-alpha.13": {
      "name": "apollo-cache-inmemory",
      "version": "1.3.1-local-state-alpha.13",
      "description": "Core abstract of Caching layer for Apollo Client",
      "author": {
        "name": "James Baxley",
        "email": "james@meteor.com"
      },
      "contributors": [
        {
          "name": "James Baxley",
          "email": "james@meteor.com"
        },
        {
          "name": "Jonas Helfer",
          "email": "jonas@helfer.email"
        },
        {
          "name": "Sashko Stubailo",
          "email": "sashko@stubailo.com"
        },
        {
          "name": "James Burgess",
          "email": "jamesmillerburgess@gmail.com"
        },
        {
          "name": "Bazyli Brzóska",
          "email": "bazyli.brzoska@gmail.com"
        }
      ],
      "license": "MIT",
      "main": "./lib/bundle.umd.js",
      "module": "./lib/index.js",
      "jsnext:main": "./lib/index.js",
      "typings": "./lib/index.d.ts",
      "sideEffects": false,
      "repository": {
        "type": "git",
        "url": "git+https://github.com/apollographql/apollo-client.git"
      },
      "bugs": {
        "url": "https://github.com/apollographql/apollo-client/issues"
      },
      "homepage": "https://github.com/apollographql/apollo-client#readme",
      "scripts": {
        "prepare": "npm run build",
        "coverage": "jest --coverage",
        "test": "jest",
        "lint": "tslint -c \"../../config/tslint.json\" -p tsconfig.json src/*.ts",
        "prebuild": "npm run clean",
        "build": "tsc -p .",
        "postbuild": "npm run bundle",
        "bundle": "../../node_modules/rollup/bin/rollup -c rollup.config.js",
        "watch": "tsc -w -p .",
        "clean": "rm -rf coverage/* && rm -rf lib/*",
        "prepublishOnly": "npm run build",
        "minify": "../../node_modules/uglify-js/bin/uglifyjs -c -m -o ./lib/bundle.min.js -- ./lib/bundle.umd.js",
        "filesize": "npm run minify"
      },
      "dependencies": {
        "apollo-cache": "^1.1.18-local-state-alpha.13",
        "apollo-utilities": "^1.0.22-local-state-alpha.13",
        "optimism": "^0.6.6"
      },
      "peerDependencies": {
        "graphql": "0.11.7 || ^0.12.0 || ^0.13.0"
      },
      "jest": {
        "transform": {
          ".(ts|tsx)": "ts-jest"
        },
        "testRegex": "(/__tests__/.*|\\.(test|spec))\\.(ts|tsx|js)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "json"
        ],
        "testURL": "http://localhost"
      },
      "gitHead": "7f2ae57d86e61b38008e56f9aec2ac49f4674a29",
      "_resolved": "",
      "_integrity": "",
      "_from": "file:apollo-cache-inmemory-1.3.1-local-state-alpha.13.tgz",
      "readme": "---\ntitle: InMemoryCache\ndescription: An explanation of `apollo-cache-inmemory`\n---\n\n`apollo-cache-inmemory` is the recommended cache implementation for Apollo Client 2.0. `InMemoryCache` is a normalized data store that supports all of Apollo Client 1.0's features without the dependency on Redux.\n\nIn some instances, you may need to manipulate the cache directly, such as updating the store after a mutation. We'll cover some common use cases [here](#recipes).\n\n<h2 id=\"installation\">Installation</h2>\n\n```\nnpm install apollo-cache-inmemory --save\n```\n\nAfter installing the package, you'll want to initialize the cache constructor. Then, you can pass in your newly created cache to ApolloClient.\n\n```js\nimport { InMemoryCache } from 'apollo-cache-inmemory';\nimport { HttpLink } from 'apollo-link-http';\nimport ApolloClient from 'apollo-client';\n\nconst cache = new InMemoryCache();\n\nconst client = new ApolloClient({\n  link: new HttpLink(),\n  cache\n});\n```\n\n<h2 id=\"configuration\">Configuration</h2>\n\nThe `InMemoryCache` constructor takes an optional config object with properties to customize your cache:\n\n- addTypename: A boolean to determine whether to add __typename to the document (default: `true`)\n- dataIdFromObject: A function that takes a data object and returns a unique identifier to be used when normalizing the data in the store. Learn more about how to customize `dataIdFromObject` in the [Normalization](#normalization) section.\n- fragmentMatcher: By default, the `InMemoryCache` uses a heuristic fragment matcher. If you are using fragments on unions and interfaces, you will need to use an `IntrospectionFragmentMatcher`. For more information, please read [our guide to setting up fragment matching for unions & interfaces](https://www.apollographql.com/docs/react/advanced/fragments.html#fragment-matcher).\n\n<h2 id=\"normalization\">Normalization</h2>\n\nThe `InMemoryCache` normalizes your data before saving it to the store by splitting the result into individual objects, creating a unique identifier for each object, and storing those objects in a flattened data structure. By default, `InMemoryCache` will attempt to use the commonly found primary keys of `id` and `_id` for the unique identifier if they exist along with `__typename` on an object.\n\nIf `id` and `_id` are not specified, or if `__typename` is not specified, `InMemoryCache` will fall back to the path to the object in the query, such as `ROOT_QUERY.allPeople.0` for the first record returned on the `allPeople` root query.\n\nThis \"getter\" behavior for unique identifiers can be configured manually via the `dataIdFromObject` option passed to the `InMemoryCache` constructor, so you can pick which field is used if some of your data follows unorthodox primary key conventions.\n\nFor example, if you wanted to key off of the `key` field for all of your data, you could configure `dataIdFromObject` like so:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => object.key\n});\n```\n\nThis also allows you to use different unique identifiers for different data types by keying off of the `__typename` property attached to every object typed by GraphQL.  For example:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => {\n    switch (object.__typename) {\n      case 'foo': return object.key; // use `key` as the primary key\n      case 'bar': return object.blah; // use `blah` as the priamry key\n      default: return object.id || object._id; // fall back to `id` and `_id` for all other types\n    }\n  }\n});\n```\n\n<h2 id=\"direct\">Direct Cache Access</h2>\n\nTo interact directly with your cache, you can use the Apollo Client class methods readQuery, readFragment, writeQuery, and writeFragment. These methods are available to us via the [`DataProxy` interface](https://github.com/apollographql/apollo-client/blob/master/packages/apollo-cache/src/types/DataProxy.ts). Accessing these methods will vary slightly based on your view layer implementation. If you are using React, you can wrap your component in the `withApollo` higher order component, which will give you access to `this.props.client`. From there, you can use the methods to control your data.\n\nAny code demonstration in the following sections will assume that we have already initialized an instance of  `ApolloClient` and that we have imported the `gql` tag from `graphql-tag`.\n\n<h3 id=\"readquery\">readQuery</h3>\n\nThe `readQuery` method is very similar to the [`query` method on `ApolloClient`][] except that `readQuery` will _never_ make a request to your GraphQL server. The `query` method, on the other hand, may send a request to your server if the appropriate data is not in your cache whereas `readQuery` will throw an error if the data is not in your cache. `readQuery` will _always_ read from the cache. You can use `readQuery` by giving it a GraphQL query like so:\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo {\n      todo(id: 5) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n});\n```\n\nIf all of the data needed to fulfill this read is in Apollo Client’s normalized data cache then a data object will be returned in the shape of the query you wanted to read. If not all of the data needed to fulfill this read is in Apollo Client’s cache then an error will be thrown instead, so make sure to only read data that you know you have!\n\nYou can also pass variables into `readQuery`.\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo($id: Int!) {\n      todo(id: $id) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n  variables: {\n    id: 5,\n  },\n});\n```\n\n<h3 id=\"readfragment\">readFragment</h3>\n\nThis method allows you great flexibility around the data in your cache. Whereas `readQuery` only allowed you to read data from your root query type, `readFragment` allows you to read data from _any node you have queried_. This is incredibly powerful. You use this method as follows:\n\n```js\nconst todo = client.readFragment({\n  id: ..., // `id` is any id that could be returned by `dataIdFromObject`.\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\nThe first argument is the id of the data you want to read from the cache. That id must be a value that was returned by the `dataIdFromObject` function you defined when initializing `ApolloClient`. So for example if you initialized `ApolloClient` like so:\n\n```js\nconst client = new ApolloClient({\n  ...,\n  dataIdFromObject: object => object.id,\n});\n```\n\n…and you requested a todo before with an id of `5`, then you can read that todo out of your cache with the following:\n\n```js\nconst todo = client.readFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\n> **Note:** Most people add a `__typename` to the id in `dataIdFromObject`. If you do this then don’t forget to add the `__typename` when you are reading a fragment as well. So for example your id may be `Todo_5` and not just `5`.\n\nIf a todo with that id does not exist in the cache you will get `null` back. If a todo of that id does exist in the cache, but that todo does not have the `text` field then an error will be thrown.\n\nThe beauty of `readFragment` is that the todo could have come from anywhere! The todo could have been selected as a singleton (`{ todo(id: 5) { ... } }`), the todo could have come from a list of todos (`{ todos { ... } }`), or the todo could have come from a mutation (`mutation { createTodo { ... } }`). As long as at some point your GraphQL server gave you a todo with the provided id and fields `id`, `text`, and `completed` you can read it from the cache at any part of your code.\n\n<h3 id=\"writequery-and-writefragment\">writeQuery` and `writeFragment</h3>\n\nNot only can you read arbitrary data from the Apollo Client cache, but you can also write any data that you would like to the cache. The methods you use to do this are `writeQuery` and `writeFragment`. They will allow you to change data in your local cache, but it is important to remember that *they will not change any data on your server*. If you reload your environment then changes made with `writeQuery` and `writeFragment` will disappear.\n\nThese methods have the same signature as their `readQuery` and `readFragment` counterparts except they also require an additional `data` variable. So for example, if you wanted to update the `completed` flag locally for your todo with id `'5'` you could execute the following:\n\n```js\nclient.writeFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      completed\n    }\n  `,\n  data: {\n    completed: true,\n  },\n});\n```\n\nAny subscriber to the Apollo Client store will instantly see this update and render new UI accordingly.\n\n> **Note:** Again, remember that using `writeQuery` or `writeFragment` only changes data *locally*. If you reload your environment then changes made with these methods will no longer exist.\n\nOr if you wanted to add a new todo to a list fetched from the server, you could use `readQuery` and `writeQuery` together.\n\n```js\nconst query = gql`\n  query MyTodoAppQuery {\n    todos {\n      id\n      text\n      completed\n    }\n  }\n`;\n\nconst data = client.readQuery({ query });\n\nconst myNewTodo = {\n  id: '6',\n  text: 'Start using Apollo Client.',\n  completed: false,\n};\n\nclient.writeQuery({\n  query,\n  data: {\n    todos: [...data.todos, myNewTodo],\n  },\n});\n```\n\n<h2 id=\"recipes\">Recipes</h2>\n\nHere are some common situations where you would need to access the cache directly. If you're manipulating the cache in an interesting way and would like your example to be featured, please send in a pull request!\n\n<h3 id=\"server\">Server side rendering</h3>\n\nFirst, you will need to initialize an `InMemoryCache` on the server and create an instance of `ApolloClient`. In the initial serialized HTML payload from the server, you should include a script tag that extracts the data from the cache.\n\n```js\n`<script>\n  window.__APOLLO_STATE__=${JSON.stringify(cache.extract())}\n</script>`\n```\n\nOn the client, you can rehydrate the cache using the initial data passed from the server:\n\n```js\ncache: new Cache().restore(window.__APOLLO_STATE__)\n```\n\nIf you would like to learn more about server side rendering, please check our our more in depth guide [here].\n<!---\nTODO (PEGGY): Add link to SSR\n-->\n\n<h3 id=\"server\">Updating the cache after a mutation</h3>\n\nBeing able to read and write to the Apollo cache from anywhere in your application gives you a lot of power over your data. However, there is one place where we most often want to update our cached data: after a mutation. As such, Apollo Client has optimized the experience for updating your cache with the read and write methods after a mutation with the `update` function. Let us say that we have the following GraphQL mutation:\n\n```graphql\nmutation TodoCreateMutation($text: String!) {\n  createTodo(text: $text) {\n    id\n    text\n    completed\n  }\n}\n```\n\nWe may also have the following GraphQL query:\n\n```graphql\nquery TodoAppQuery {\n  todos {\n    id\n    text\n    completed\n  }\n}\n```\n\nAt the end of our mutation we want our query to include the new todo like we had sent our `TodoAppQuery` a second time after the mutation finished without actually sending the query. To do this we can use the `update` function provided as an option of the `client.mutate` method. To update your cache with the mutation just write code that looks like:\n\n```js\n// We assume that the GraphQL operations `TodoCreateMutation` and\n// `TodoAppQuery` have already been defined using the `gql` tag.\n\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    // Read the data from our cache for this query.\n    const data = proxy.readQuery({ query: TodoAppQuery });\n\n    // Add our todo from the mutation to the end.\n    data.todos.push(createTodo);\n\n    // Write our data back to the cache.\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nThe first `proxy` argument is an instance of [`DataProxy`][] has the same four methods that we just learned exist on the Apollo Client: `readQuery`, `readFragment`, `writeQuery`, and `writeFragment`. The reason we call them on a `proxy` object here instead of on our `client` instance is that we can easily apply optimistic updates (which we will demonstrate in a bit). The `proxy` object also provides an isolated transaction which shields you from any other mutations going on at the same time, and the `proxy` object also batches writes together until the very end.\n\nIf you provide an `optimisticResponse` option to the mutation then the `update` function will be run twice. Once immediately after you call `client.mutate` with the data from `optimisticResponse`. After the mutation successfully executes against the server the changes made in the first call to `update` will be rolled back and `update` will be called with the *actual* data returned by the mutation and not just the optimistic response.\n\nPutting it all together:\n\n```js\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  optimisticResponse: {\n    id: -1, // -1 is a temporary id for the optimistic response.\n    text,\n    completed: false,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    const data = proxy.readQuery({ query: TodoAppQuery });\n    data.todos.push(createTodo);\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nAs you can see the `update` function on `client.mutate` provides extra change management functionality specific to the use case of a mutation while still providing you the powerful data control APIs that are available on `client`.\n\nThe `update` function is not a good place for side-effects as it may be called multiple times. Also, you may not call any of the methods on `proxy` asynchronously.\n\n",
      "readmeFilename": "README.md",
      "_id": "apollo-cache-inmemory@1.3.1-local-state-alpha.13",
      "_npmVersion": "6.4.1",
      "_nodeVersion": "8.12.0",
      "_npmUser": {
        "name": "apollo-bot",
        "email": "npm@apollographql.com"
      },
      "dist": {
        "integrity": "sha512-mx8d+oLNzyHmCBtFSOAilXccfA9ZW3N0sDIaHIM6LB97uXW6+cyIrHmH/yUP4ZXMASeRkA8FGkNaM3HsIWAVUg==",
        "shasum": "81944a6aa112cff864ef1dddb5eb6de8f57e1720",
        "tarball": "https://registry.npmjs.org/apollo-cache-inmemory/-/apollo-cache-inmemory-1.3.1-local-state-alpha.13.tgz",
        "fileCount": 84,
        "unpackedSize": 510409,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJb4N8uCRA9TVsSAnZWagAAY6cP/0aDEzImwpQtB4B/HOVs\neAUaLgdt5KWh1KsD6OawtIAFT4EYrLddVNzvdWWCFmMbKV+0s8fdkMenu1Fk\nDEipMD3JMZUCIFhmgl6V2Bz1naCCZM641Wf4tjFwa9knTtKJw9Fl5J1T7isU\nfnpKCEXYzXxtV3c8eZSMPwDYn7lOCuyPUPmn2i+ej1idk38PMYT49nREU5Vq\nUIZWzXfxVDHzNGmxnw4y+yDfFtRUuPK53jbBqebaoS+NZZT6VqgcEqDmhZGo\n1Ucg2faHNdkhN5ySaB2wzdS0EJZgjxVszI8xUDOmwhQmK7bpk2Pg7G8wuZWm\nAPa+b2i+merioREeWusCR8aGgjIKWRa7GFFweytHpfFpGXIbs9Oq2oVQ+S7L\n+ehtcbodNCDgoyipZj0j/MRkTmrL8gJILOMr55ORjdS1ZWw2kYtv1wiYGvIn\nTOn/5UJALgaHss8CCWRbza4o+xgOjCbprn8ADYCqx2WyDlKNIXXdsNIBIJrd\n5w4/qLrPUaohmcPIaApZOxy0z9hIkRgsqiF+0ie1uX7bibJbgzkznkadKoez\nOsgiHV3jrLgDphDHvbnMNhnOhA4IvslgiU6K/nYknf1HqcFLRRTbBw1cUMtS\nh9UQ1qyMbQJ2ZDFNjh+XqIzHeFPrNUDS9/CzTzXUk2G42Dyylth87ah6wPCB\n6dUk\r\n=YLYh\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEYCIQD1eUJUiK/SNQDwrrqvo/1FRy9zUcP8+lD7WbiB4HoVYQIhAOBK2bPmPmEEYHRKuCzupYJVao+HkjcSBFmA2O6856i8"
          }
        ]
      },
      "maintainers": [
        {
          "email": "npm@apollographql.com",
          "name": "apollo-bot"
        },
        {
          "email": "ben@benjamn.com",
          "name": "benjamn"
        },
        {
          "email": "james@meteor.com",
          "name": "jbaxleyiii"
        },
        {
          "email": "peggyrayzis@gmail.com",
          "name": "peggyrayzis"
        }
      ],
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/apollo-cache-inmemory_1.3.1-local-state-alpha.13_1541463853753_0.6816677247154792"
      },
      "_hasShrinkwrap": false
    },
    "1.3.1-local-state-alpha.14": {
      "name": "apollo-cache-inmemory",
      "version": "1.3.1-local-state-alpha.14",
      "description": "Core abstract of Caching layer for Apollo Client",
      "author": {
        "name": "James Baxley",
        "email": "james@meteor.com"
      },
      "contributors": [
        {
          "name": "James Baxley",
          "email": "james@meteor.com"
        },
        {
          "name": "Jonas Helfer",
          "email": "jonas@helfer.email"
        },
        {
          "name": "Sashko Stubailo",
          "email": "sashko@stubailo.com"
        },
        {
          "name": "James Burgess",
          "email": "jamesmillerburgess@gmail.com"
        },
        {
          "name": "Bazyli Brzóska",
          "email": "bazyli.brzoska@gmail.com"
        }
      ],
      "license": "MIT",
      "main": "./lib/bundle.umd.js",
      "module": "./lib/index.js",
      "jsnext:main": "./lib/index.js",
      "typings": "./lib/index.d.ts",
      "sideEffects": false,
      "repository": {
        "type": "git",
        "url": "git+https://github.com/apollographql/apollo-client.git"
      },
      "bugs": {
        "url": "https://github.com/apollographql/apollo-client/issues"
      },
      "homepage": "https://github.com/apollographql/apollo-client#readme",
      "scripts": {
        "prepare": "npm run build",
        "coverage": "jest --coverage",
        "test": "jest",
        "lint": "tslint -c \"../../config/tslint.json\" -p tsconfig.json src/*.ts",
        "prebuild": "npm run clean",
        "build": "tsc -p .",
        "postbuild": "npm run bundle",
        "bundle": "../../node_modules/rollup/bin/rollup -c rollup.config.js",
        "watch": "tsc -w -p .",
        "clean": "rm -rf coverage/* && rm -rf lib/*",
        "prepublishOnly": "npm run build",
        "minify": "../../node_modules/uglify-js/bin/uglifyjs -c -m -o ./lib/bundle.min.js -- ./lib/bundle.umd.js",
        "filesize": "npm run minify"
      },
      "dependencies": {
        "apollo-cache": "^1.1.18-local-state-alpha.14",
        "apollo-utilities": "^1.0.22-local-state-alpha.14",
        "optimism": "^0.6.6"
      },
      "peerDependencies": {
        "graphql": "0.11.7 || ^0.12.0 || ^0.13.0"
      },
      "jest": {
        "transform": {
          ".(ts|tsx)": "ts-jest"
        },
        "testRegex": "(/__tests__/.*|\\.(test|spec))\\.(ts|tsx|js)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "json"
        ],
        "testURL": "http://localhost"
      },
      "gitHead": "312181a01e472dcd68f4857ccf692a737fe7f1e2",
      "_resolved": "",
      "_integrity": "",
      "_from": "file:apollo-cache-inmemory-1.3.1-local-state-alpha.14.tgz",
      "readme": "---\ntitle: InMemoryCache\ndescription: An explanation of `apollo-cache-inmemory`\n---\n\n`apollo-cache-inmemory` is the recommended cache implementation for Apollo Client 2.0. `InMemoryCache` is a normalized data store that supports all of Apollo Client 1.0's features without the dependency on Redux.\n\nIn some instances, you may need to manipulate the cache directly, such as updating the store after a mutation. We'll cover some common use cases [here](#recipes).\n\n<h2 id=\"installation\">Installation</h2>\n\n```\nnpm install apollo-cache-inmemory --save\n```\n\nAfter installing the package, you'll want to initialize the cache constructor. Then, you can pass in your newly created cache to ApolloClient.\n\n```js\nimport { InMemoryCache } from 'apollo-cache-inmemory';\nimport { HttpLink } from 'apollo-link-http';\nimport ApolloClient from 'apollo-client';\n\nconst cache = new InMemoryCache();\n\nconst client = new ApolloClient({\n  link: new HttpLink(),\n  cache\n});\n```\n\n<h2 id=\"configuration\">Configuration</h2>\n\nThe `InMemoryCache` constructor takes an optional config object with properties to customize your cache:\n\n- addTypename: A boolean to determine whether to add __typename to the document (default: `true`)\n- dataIdFromObject: A function that takes a data object and returns a unique identifier to be used when normalizing the data in the store. Learn more about how to customize `dataIdFromObject` in the [Normalization](#normalization) section.\n- fragmentMatcher: By default, the `InMemoryCache` uses a heuristic fragment matcher. If you are using fragments on unions and interfaces, you will need to use an `IntrospectionFragmentMatcher`. For more information, please read [our guide to setting up fragment matching for unions & interfaces](https://www.apollographql.com/docs/react/advanced/fragments.html#fragment-matcher).\n\n<h2 id=\"normalization\">Normalization</h2>\n\nThe `InMemoryCache` normalizes your data before saving it to the store by splitting the result into individual objects, creating a unique identifier for each object, and storing those objects in a flattened data structure. By default, `InMemoryCache` will attempt to use the commonly found primary keys of `id` and `_id` for the unique identifier if they exist along with `__typename` on an object.\n\nIf `id` and `_id` are not specified, or if `__typename` is not specified, `InMemoryCache` will fall back to the path to the object in the query, such as `ROOT_QUERY.allPeople.0` for the first record returned on the `allPeople` root query.\n\nThis \"getter\" behavior for unique identifiers can be configured manually via the `dataIdFromObject` option passed to the `InMemoryCache` constructor, so you can pick which field is used if some of your data follows unorthodox primary key conventions.\n\nFor example, if you wanted to key off of the `key` field for all of your data, you could configure `dataIdFromObject` like so:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => object.key\n});\n```\n\nThis also allows you to use different unique identifiers for different data types by keying off of the `__typename` property attached to every object typed by GraphQL.  For example:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => {\n    switch (object.__typename) {\n      case 'foo': return object.key; // use `key` as the primary key\n      case 'bar': return object.blah; // use `blah` as the priamry key\n      default: return object.id || object._id; // fall back to `id` and `_id` for all other types\n    }\n  }\n});\n```\n\n<h2 id=\"direct\">Direct Cache Access</h2>\n\nTo interact directly with your cache, you can use the Apollo Client class methods readQuery, readFragment, writeQuery, and writeFragment. These methods are available to us via the [`DataProxy` interface](https://github.com/apollographql/apollo-client/blob/master/packages/apollo-cache/src/types/DataProxy.ts). Accessing these methods will vary slightly based on your view layer implementation. If you are using React, you can wrap your component in the `withApollo` higher order component, which will give you access to `this.props.client`. From there, you can use the methods to control your data.\n\nAny code demonstration in the following sections will assume that we have already initialized an instance of  `ApolloClient` and that we have imported the `gql` tag from `graphql-tag`.\n\n<h3 id=\"readquery\">readQuery</h3>\n\nThe `readQuery` method is very similar to the [`query` method on `ApolloClient`][] except that `readQuery` will _never_ make a request to your GraphQL server. The `query` method, on the other hand, may send a request to your server if the appropriate data is not in your cache whereas `readQuery` will throw an error if the data is not in your cache. `readQuery` will _always_ read from the cache. You can use `readQuery` by giving it a GraphQL query like so:\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo {\n      todo(id: 5) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n});\n```\n\nIf all of the data needed to fulfill this read is in Apollo Client’s normalized data cache then a data object will be returned in the shape of the query you wanted to read. If not all of the data needed to fulfill this read is in Apollo Client’s cache then an error will be thrown instead, so make sure to only read data that you know you have!\n\nYou can also pass variables into `readQuery`.\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo($id: Int!) {\n      todo(id: $id) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n  variables: {\n    id: 5,\n  },\n});\n```\n\n<h3 id=\"readfragment\">readFragment</h3>\n\nThis method allows you great flexibility around the data in your cache. Whereas `readQuery` only allowed you to read data from your root query type, `readFragment` allows you to read data from _any node you have queried_. This is incredibly powerful. You use this method as follows:\n\n```js\nconst todo = client.readFragment({\n  id: ..., // `id` is any id that could be returned by `dataIdFromObject`.\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\nThe first argument is the id of the data you want to read from the cache. That id must be a value that was returned by the `dataIdFromObject` function you defined when initializing `ApolloClient`. So for example if you initialized `ApolloClient` like so:\n\n```js\nconst client = new ApolloClient({\n  ...,\n  dataIdFromObject: object => object.id,\n});\n```\n\n…and you requested a todo before with an id of `5`, then you can read that todo out of your cache with the following:\n\n```js\nconst todo = client.readFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\n> **Note:** Most people add a `__typename` to the id in `dataIdFromObject`. If you do this then don’t forget to add the `__typename` when you are reading a fragment as well. So for example your id may be `Todo_5` and not just `5`.\n\nIf a todo with that id does not exist in the cache you will get `null` back. If a todo of that id does exist in the cache, but that todo does not have the `text` field then an error will be thrown.\n\nThe beauty of `readFragment` is that the todo could have come from anywhere! The todo could have been selected as a singleton (`{ todo(id: 5) { ... } }`), the todo could have come from a list of todos (`{ todos { ... } }`), or the todo could have come from a mutation (`mutation { createTodo { ... } }`). As long as at some point your GraphQL server gave you a todo with the provided id and fields `id`, `text`, and `completed` you can read it from the cache at any part of your code.\n\n<h3 id=\"writequery-and-writefragment\">writeQuery` and `writeFragment</h3>\n\nNot only can you read arbitrary data from the Apollo Client cache, but you can also write any data that you would like to the cache. The methods you use to do this are `writeQuery` and `writeFragment`. They will allow you to change data in your local cache, but it is important to remember that *they will not change any data on your server*. If you reload your environment then changes made with `writeQuery` and `writeFragment` will disappear.\n\nThese methods have the same signature as their `readQuery` and `readFragment` counterparts except they also require an additional `data` variable. So for example, if you wanted to update the `completed` flag locally for your todo with id `'5'` you could execute the following:\n\n```js\nclient.writeFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      completed\n    }\n  `,\n  data: {\n    completed: true,\n  },\n});\n```\n\nAny subscriber to the Apollo Client store will instantly see this update and render new UI accordingly.\n\n> **Note:** Again, remember that using `writeQuery` or `writeFragment` only changes data *locally*. If you reload your environment then changes made with these methods will no longer exist.\n\nOr if you wanted to add a new todo to a list fetched from the server, you could use `readQuery` and `writeQuery` together.\n\n```js\nconst query = gql`\n  query MyTodoAppQuery {\n    todos {\n      id\n      text\n      completed\n    }\n  }\n`;\n\nconst data = client.readQuery({ query });\n\nconst myNewTodo = {\n  id: '6',\n  text: 'Start using Apollo Client.',\n  completed: false,\n};\n\nclient.writeQuery({\n  query,\n  data: {\n    todos: [...data.todos, myNewTodo],\n  },\n});\n```\n\n<h2 id=\"recipes\">Recipes</h2>\n\nHere are some common situations where you would need to access the cache directly. If you're manipulating the cache in an interesting way and would like your example to be featured, please send in a pull request!\n\n<h3 id=\"server\">Server side rendering</h3>\n\nFirst, you will need to initialize an `InMemoryCache` on the server and create an instance of `ApolloClient`. In the initial serialized HTML payload from the server, you should include a script tag that extracts the data from the cache.\n\n```js\n`<script>\n  window.__APOLLO_STATE__=${JSON.stringify(cache.extract())}\n</script>`\n```\n\nOn the client, you can rehydrate the cache using the initial data passed from the server:\n\n```js\ncache: new Cache().restore(window.__APOLLO_STATE__)\n```\n\nIf you would like to learn more about server side rendering, please check our our more in depth guide [here].\n<!---\nTODO (PEGGY): Add link to SSR\n-->\n\n<h3 id=\"server\">Updating the cache after a mutation</h3>\n\nBeing able to read and write to the Apollo cache from anywhere in your application gives you a lot of power over your data. However, there is one place where we most often want to update our cached data: after a mutation. As such, Apollo Client has optimized the experience for updating your cache with the read and write methods after a mutation with the `update` function. Let us say that we have the following GraphQL mutation:\n\n```graphql\nmutation TodoCreateMutation($text: String!) {\n  createTodo(text: $text) {\n    id\n    text\n    completed\n  }\n}\n```\n\nWe may also have the following GraphQL query:\n\n```graphql\nquery TodoAppQuery {\n  todos {\n    id\n    text\n    completed\n  }\n}\n```\n\nAt the end of our mutation we want our query to include the new todo like we had sent our `TodoAppQuery` a second time after the mutation finished without actually sending the query. To do this we can use the `update` function provided as an option of the `client.mutate` method. To update your cache with the mutation just write code that looks like:\n\n```js\n// We assume that the GraphQL operations `TodoCreateMutation` and\n// `TodoAppQuery` have already been defined using the `gql` tag.\n\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    // Read the data from our cache for this query.\n    const data = proxy.readQuery({ query: TodoAppQuery });\n\n    // Add our todo from the mutation to the end.\n    data.todos.push(createTodo);\n\n    // Write our data back to the cache.\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nThe first `proxy` argument is an instance of [`DataProxy`][] has the same four methods that we just learned exist on the Apollo Client: `readQuery`, `readFragment`, `writeQuery`, and `writeFragment`. The reason we call them on a `proxy` object here instead of on our `client` instance is that we can easily apply optimistic updates (which we will demonstrate in a bit). The `proxy` object also provides an isolated transaction which shields you from any other mutations going on at the same time, and the `proxy` object also batches writes together until the very end.\n\nIf you provide an `optimisticResponse` option to the mutation then the `update` function will be run twice. Once immediately after you call `client.mutate` with the data from `optimisticResponse`. After the mutation successfully executes against the server the changes made in the first call to `update` will be rolled back and `update` will be called with the *actual* data returned by the mutation and not just the optimistic response.\n\nPutting it all together:\n\n```js\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  optimisticResponse: {\n    id: -1, // -1 is a temporary id for the optimistic response.\n    text,\n    completed: false,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    const data = proxy.readQuery({ query: TodoAppQuery });\n    data.todos.push(createTodo);\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nAs you can see the `update` function on `client.mutate` provides extra change management functionality specific to the use case of a mutation while still providing you the powerful data control APIs that are available on `client`.\n\nThe `update` function is not a good place for side-effects as it may be called multiple times. Also, you may not call any of the methods on `proxy` asynchronously.\n\n",
      "readmeFilename": "README.md",
      "_id": "apollo-cache-inmemory@1.3.1-local-state-alpha.14",
      "_npmVersion": "6.4.1",
      "_nodeVersion": "8.12.0",
      "_npmUser": {
        "name": "apollo-bot",
        "email": "npm@apollographql.com"
      },
      "dist": {
        "integrity": "sha512-COSKuRQ653LI5bKxZ081cGs+hvDKQ30GWpTUoBc5iWYhdYOho5Z4HocRCd6kuWXaB2IOMshXvLUiosVs1HZmng==",
        "shasum": "8c9256ae2d6c4020e940279ddafe1245eee7cd4b",
        "tarball": "https://registry.npmjs.org/apollo-cache-inmemory/-/apollo-cache-inmemory-1.3.1-local-state-alpha.14.tgz",
        "fileCount": 84,
        "unpackedSize": 510409,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJb4eKYCRA9TVsSAnZWagAA758P/iKD9ejgqGD2FRH0rYsB\nB4XYtoXvyQ7+fSyjIdt4KCAP2uyVyv4/3d0yRJs0x3+QiasH7zcOtYScGAU9\nYwmY76EagxsW2Rrpc1Dt/CjqMb1PtT1pJMFrbrWwWDY0xZ5PT+iAa2iF/ihQ\n9xq9sbMb4ccvOK1sDUu++Wyre/u06W21ZygmG4N+JXrrYGwX5XTwRK3YYK0U\nlINUYGCWIRsyRf/vR7IZzNDVx1g3q06/r40g/M9DJbWMNdeozdun0IAQSsJf\nPpE0AMyIe53GyAM98vro5/kcmCeusJQWHdvRrLXYo46SHSBm/afU2XMYAVim\nBMYi05MVBYQgk6ZSv7j6W2gVfaW8UDQnzSxka+0B7SZ0G0Wfv4cAecPTZSVR\nA6FzKowweu0yEgzP4iW3A6CzXAscWtMtLfCMMrOdiDuJ7UJcI3kh5gviiQNv\n0LPUFBPjZQOeFT6ca1+EOGxAa8Ul7qyHVCf5SVPpUpvCC3KqxODcuqoWSIu2\nDdxWvOAezDglGsHBU9V0cmX9FXGyGw6sHzb3QfpvcC3A8Wih5fiQVm4knnLe\ns63HxbnDYPnaY5SwuryTlSeCR5rlM9L8u58+FqHl9H8Zm0v5uUNopgRocONL\nqUPub+4MDomZo3WNcSTxujz6Vnp1OfKjvIMOuHVUNk15AONkrC516e0paix2\nQ/RD\r\n=7JAV\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEYCIQDfljEzwRmVvkAtWzbxapYSn16P4IVSkq5JCWteoUHb9QIhALHwQiItcirvbHC340/L+EaLqPzkzIWkV0cOts0sloPC"
          }
        ]
      },
      "maintainers": [
        {
          "email": "npm@apollographql.com",
          "name": "apollo-bot"
        },
        {
          "email": "ben@benjamn.com",
          "name": "benjamn"
        },
        {
          "email": "james@meteor.com",
          "name": "jbaxleyiii"
        },
        {
          "email": "peggyrayzis@gmail.com",
          "name": "peggyrayzis"
        }
      ],
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/apollo-cache-inmemory_1.3.1-local-state-alpha.14_1541530263897_0.55103635320638"
      },
      "_hasShrinkwrap": false
    },
    "1.4.0-alpha.1": {
      "name": "apollo-cache-inmemory",
      "version": "1.4.0-alpha.1",
      "description": "Core abstract of Caching layer for Apollo Client",
      "author": {
        "name": "James Baxley",
        "email": "james@meteor.com"
      },
      "contributors": [
        {
          "name": "James Baxley",
          "email": "james@meteor.com"
        },
        {
          "name": "Jonas Helfer",
          "email": "jonas@helfer.email"
        },
        {
          "name": "Sashko Stubailo",
          "email": "sashko@stubailo.com"
        },
        {
          "name": "James Burgess",
          "email": "jamesmillerburgess@gmail.com"
        },
        {
          "name": "Bazyli Brzóska",
          "email": "bazyli.brzoska@gmail.com"
        }
      ],
      "license": "MIT",
      "main": "./lib/bundle.umd.js",
      "module": "./lib/index.js",
      "jsnext:main": "./lib/index.js",
      "typings": "./lib/index.d.ts",
      "sideEffects": false,
      "repository": {
        "type": "git",
        "url": "git+https://github.com/apollographql/apollo-client.git"
      },
      "bugs": {
        "url": "https://github.com/apollographql/apollo-client/issues"
      },
      "homepage": "https://github.com/apollographql/apollo-client#readme",
      "scripts": {
        "prepare": "npm run build",
        "coverage": "jest --coverage",
        "test": "jest",
        "lint": "tslint -c \"../../config/tslint.json\" -p tsconfig.json src/*.ts",
        "prebuild": "npm run clean",
        "build": "tsc -p .",
        "postbuild": "npm run bundle",
        "bundle": "../../node_modules/rollup/bin/rollup -c rollup.config.js",
        "watch": "tsc -w -p .",
        "clean": "rm -rf coverage/* && rm -rf lib/*",
        "prepublishOnly": "npm run build",
        "minify": "../../node_modules/uglify-js/bin/uglifyjs -c -m -o ./lib/bundle.min.js -- ./lib/bundle.umd.js",
        "filesize": "npm run minify"
      },
      "dependencies": {
        "apollo-cache": "^1.2.0-alpha.1",
        "apollo-utilities": "^1.1.0-alpha.1",
        "optimism": "^0.6.6"
      },
      "peerDependencies": {
        "graphql": "0.11.7 || ^0.12.0 || ^0.13.0"
      },
      "jest": {
        "transform": {
          ".(ts|tsx)": "ts-jest"
        },
        "testRegex": "(/__tests__/.*|\\.(test|spec))\\.(ts|tsx|js)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "json"
        ],
        "testURL": "http://localhost"
      },
      "gitHead": "cc787f8f294943fe1f1b8de427ed9a70725744f6",
      "_resolved": "",
      "_integrity": "",
      "_from": "file:apollo-cache-inmemory-1.4.0-alpha.1.tgz",
      "readme": "---\ntitle: InMemoryCache\ndescription: An explanation of `apollo-cache-inmemory`\n---\n\n`apollo-cache-inmemory` is the recommended cache implementation for Apollo Client 2.0. `InMemoryCache` is a normalized data store that supports all of Apollo Client 1.0's features without the dependency on Redux.\n\nIn some instances, you may need to manipulate the cache directly, such as updating the store after a mutation. We'll cover some common use cases [here](#recipes).\n\n<h2 id=\"installation\">Installation</h2>\n\n```\nnpm install apollo-cache-inmemory --save\n```\n\nAfter installing the package, you'll want to initialize the cache constructor. Then, you can pass in your newly created cache to ApolloClient.\n\n```js\nimport { InMemoryCache } from 'apollo-cache-inmemory';\nimport { HttpLink } from 'apollo-link-http';\nimport ApolloClient from 'apollo-client';\n\nconst cache = new InMemoryCache();\n\nconst client = new ApolloClient({\n  link: new HttpLink(),\n  cache\n});\n```\n\n<h2 id=\"configuration\">Configuration</h2>\n\nThe `InMemoryCache` constructor takes an optional config object with properties to customize your cache:\n\n- addTypename: A boolean to determine whether to add __typename to the document (default: `true`)\n- dataIdFromObject: A function that takes a data object and returns a unique identifier to be used when normalizing the data in the store. Learn more about how to customize `dataIdFromObject` in the [Normalization](#normalization) section.\n- fragmentMatcher: By default, the `InMemoryCache` uses a heuristic fragment matcher. If you are using fragments on unions and interfaces, you will need to use an `IntrospectionFragmentMatcher`. For more information, please read [our guide to setting up fragment matching for unions & interfaces](https://www.apollographql.com/docs/react/advanced/fragments.html#fragment-matcher).\n\n<h2 id=\"normalization\">Normalization</h2>\n\nThe `InMemoryCache` normalizes your data before saving it to the store by splitting the result into individual objects, creating a unique identifier for each object, and storing those objects in a flattened data structure. By default, `InMemoryCache` will attempt to use the commonly found primary keys of `id` and `_id` for the unique identifier if they exist along with `__typename` on an object.\n\nIf `id` and `_id` are not specified, or if `__typename` is not specified, `InMemoryCache` will fall back to the path to the object in the query, such as `ROOT_QUERY.allPeople.0` for the first record returned on the `allPeople` root query.\n\nThis \"getter\" behavior for unique identifiers can be configured manually via the `dataIdFromObject` option passed to the `InMemoryCache` constructor, so you can pick which field is used if some of your data follows unorthodox primary key conventions.\n\nFor example, if you wanted to key off of the `key` field for all of your data, you could configure `dataIdFromObject` like so:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => object.key\n});\n```\n\nThis also allows you to use different unique identifiers for different data types by keying off of the `__typename` property attached to every object typed by GraphQL.  For example:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => {\n    switch (object.__typename) {\n      case 'foo': return object.key; // use `key` as the primary key\n      case 'bar': return object.blah; // use `blah` as the priamry key\n      default: return object.id || object._id; // fall back to `id` and `_id` for all other types\n    }\n  }\n});\n```\n\n<h2 id=\"direct\">Direct Cache Access</h2>\n\nTo interact directly with your cache, you can use the Apollo Client class methods readQuery, readFragment, writeQuery, and writeFragment. These methods are available to us via the [`DataProxy` interface](https://github.com/apollographql/apollo-client/blob/master/packages/apollo-cache/src/types/DataProxy.ts). Accessing these methods will vary slightly based on your view layer implementation. If you are using React, you can wrap your component in the `withApollo` higher order component, which will give you access to `this.props.client`. From there, you can use the methods to control your data.\n\nAny code demonstration in the following sections will assume that we have already initialized an instance of  `ApolloClient` and that we have imported the `gql` tag from `graphql-tag`.\n\n<h3 id=\"readquery\">readQuery</h3>\n\nThe `readQuery` method is very similar to the [`query` method on `ApolloClient`][] except that `readQuery` will _never_ make a request to your GraphQL server. The `query` method, on the other hand, may send a request to your server if the appropriate data is not in your cache whereas `readQuery` will throw an error if the data is not in your cache. `readQuery` will _always_ read from the cache. You can use `readQuery` by giving it a GraphQL query like so:\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo {\n      todo(id: 5) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n});\n```\n\nIf all of the data needed to fulfill this read is in Apollo Client’s normalized data cache then a data object will be returned in the shape of the query you wanted to read. If not all of the data needed to fulfill this read is in Apollo Client’s cache then an error will be thrown instead, so make sure to only read data that you know you have!\n\nYou can also pass variables into `readQuery`.\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo($id: Int!) {\n      todo(id: $id) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n  variables: {\n    id: 5,\n  },\n});\n```\n\n<h3 id=\"readfragment\">readFragment</h3>\n\nThis method allows you great flexibility around the data in your cache. Whereas `readQuery` only allowed you to read data from your root query type, `readFragment` allows you to read data from _any node you have queried_. This is incredibly powerful. You use this method as follows:\n\n```js\nconst todo = client.readFragment({\n  id: ..., // `id` is any id that could be returned by `dataIdFromObject`.\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\nThe first argument is the id of the data you want to read from the cache. That id must be a value that was returned by the `dataIdFromObject` function you defined when initializing `ApolloClient`. So for example if you initialized `ApolloClient` like so:\n\n```js\nconst client = new ApolloClient({\n  ...,\n  dataIdFromObject: object => object.id,\n});\n```\n\n…and you requested a todo before with an id of `5`, then you can read that todo out of your cache with the following:\n\n```js\nconst todo = client.readFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\n> **Note:** Most people add a `__typename` to the id in `dataIdFromObject`. If you do this then don’t forget to add the `__typename` when you are reading a fragment as well. So for example your id may be `Todo_5` and not just `5`.\n\nIf a todo with that id does not exist in the cache you will get `null` back. If a todo of that id does exist in the cache, but that todo does not have the `text` field then an error will be thrown.\n\nThe beauty of `readFragment` is that the todo could have come from anywhere! The todo could have been selected as a singleton (`{ todo(id: 5) { ... } }`), the todo could have come from a list of todos (`{ todos { ... } }`), or the todo could have come from a mutation (`mutation { createTodo { ... } }`). As long as at some point your GraphQL server gave you a todo with the provided id and fields `id`, `text`, and `completed` you can read it from the cache at any part of your code.\n\n<h3 id=\"writequery-and-writefragment\">writeQuery` and `writeFragment</h3>\n\nNot only can you read arbitrary data from the Apollo Client cache, but you can also write any data that you would like to the cache. The methods you use to do this are `writeQuery` and `writeFragment`. They will allow you to change data in your local cache, but it is important to remember that *they will not change any data on your server*. If you reload your environment then changes made with `writeQuery` and `writeFragment` will disappear.\n\nThese methods have the same signature as their `readQuery` and `readFragment` counterparts except they also require an additional `data` variable. So for example, if you wanted to update the `completed` flag locally for your todo with id `'5'` you could execute the following:\n\n```js\nclient.writeFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      completed\n    }\n  `,\n  data: {\n    completed: true,\n  },\n});\n```\n\nAny subscriber to the Apollo Client store will instantly see this update and render new UI accordingly.\n\n> **Note:** Again, remember that using `writeQuery` or `writeFragment` only changes data *locally*. If you reload your environment then changes made with these methods will no longer exist.\n\nOr if you wanted to add a new todo to a list fetched from the server, you could use `readQuery` and `writeQuery` together.\n\n```js\nconst query = gql`\n  query MyTodoAppQuery {\n    todos {\n      id\n      text\n      completed\n    }\n  }\n`;\n\nconst data = client.readQuery({ query });\n\nconst myNewTodo = {\n  id: '6',\n  text: 'Start using Apollo Client.',\n  completed: false,\n};\n\nclient.writeQuery({\n  query,\n  data: {\n    todos: [...data.todos, myNewTodo],\n  },\n});\n```\n\n<h2 id=\"recipes\">Recipes</h2>\n\nHere are some common situations where you would need to access the cache directly. If you're manipulating the cache in an interesting way and would like your example to be featured, please send in a pull request!\n\n<h3 id=\"server\">Server side rendering</h3>\n\nFirst, you will need to initialize an `InMemoryCache` on the server and create an instance of `ApolloClient`. In the initial serialized HTML payload from the server, you should include a script tag that extracts the data from the cache.\n\n```js\n`<script>\n  window.__APOLLO_STATE__=${JSON.stringify(cache.extract())}\n</script>`\n```\n\nOn the client, you can rehydrate the cache using the initial data passed from the server:\n\n```js\ncache: new Cache().restore(window.__APOLLO_STATE__)\n```\n\nIf you would like to learn more about server side rendering, please check our our more in depth guide [here].\n<!---\nTODO (PEGGY): Add link to SSR\n-->\n\n<h3 id=\"server\">Updating the cache after a mutation</h3>\n\nBeing able to read and write to the Apollo cache from anywhere in your application gives you a lot of power over your data. However, there is one place where we most often want to update our cached data: after a mutation. As such, Apollo Client has optimized the experience for updating your cache with the read and write methods after a mutation with the `update` function. Let us say that we have the following GraphQL mutation:\n\n```graphql\nmutation TodoCreateMutation($text: String!) {\n  createTodo(text: $text) {\n    id\n    text\n    completed\n  }\n}\n```\n\nWe may also have the following GraphQL query:\n\n```graphql\nquery TodoAppQuery {\n  todos {\n    id\n    text\n    completed\n  }\n}\n```\n\nAt the end of our mutation we want our query to include the new todo like we had sent our `TodoAppQuery` a second time after the mutation finished without actually sending the query. To do this we can use the `update` function provided as an option of the `client.mutate` method. To update your cache with the mutation just write code that looks like:\n\n```js\n// We assume that the GraphQL operations `TodoCreateMutation` and\n// `TodoAppQuery` have already been defined using the `gql` tag.\n\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    // Read the data from our cache for this query.\n    const data = proxy.readQuery({ query: TodoAppQuery });\n\n    // Add our todo from the mutation to the end.\n    data.todos.push(createTodo);\n\n    // Write our data back to the cache.\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nThe first `proxy` argument is an instance of [`DataProxy`][] has the same four methods that we just learned exist on the Apollo Client: `readQuery`, `readFragment`, `writeQuery`, and `writeFragment`. The reason we call them on a `proxy` object here instead of on our `client` instance is that we can easily apply optimistic updates (which we will demonstrate in a bit). The `proxy` object also provides an isolated transaction which shields you from any other mutations going on at the same time, and the `proxy` object also batches writes together until the very end.\n\nIf you provide an `optimisticResponse` option to the mutation then the `update` function will be run twice. Once immediately after you call `client.mutate` with the data from `optimisticResponse`. After the mutation successfully executes against the server the changes made in the first call to `update` will be rolled back and `update` will be called with the *actual* data returned by the mutation and not just the optimistic response.\n\nPutting it all together:\n\n```js\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  optimisticResponse: {\n    id: -1, // -1 is a temporary id for the optimistic response.\n    text,\n    completed: false,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    const data = proxy.readQuery({ query: TodoAppQuery });\n    data.todos.push(createTodo);\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nAs you can see the `update` function on `client.mutate` provides extra change management functionality specific to the use case of a mutation while still providing you the powerful data control APIs that are available on `client`.\n\nThe `update` function is not a good place for side-effects as it may be called multiple times. Also, you may not call any of the methods on `proxy` asynchronously.\n\n",
      "readmeFilename": "README.md",
      "_id": "apollo-cache-inmemory@1.4.0-alpha.1",
      "_npmVersion": "6.4.1",
      "_nodeVersion": "8.12.0",
      "_npmUser": {
        "name": "apollo-bot",
        "email": "npm@apollographql.com"
      },
      "dist": {
        "integrity": "sha512-nfRJDY3grTZ7MY3WPjbbabFKqvR+d8xqyhSqBWQsZ15yypDdsXmbkzXHb5gDEGvpBYcscEKUfMjoWoXeeeAzHQ==",
        "shasum": "fc5f2e28b14cad9bc8da35d7d522d2b327d5bc5f",
        "tarball": "https://registry.npmjs.org/apollo-cache-inmemory/-/apollo-cache-inmemory-1.4.0-alpha.1.tgz",
        "fileCount": 84,
        "unpackedSize": 510368,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJb4iYBCRA9TVsSAnZWagAA2xoQAJXRQElVj5SzVknFgFR4\nBxDiAJQtuIFAGY05ERHL4P/4oYHpOlHpP4kUD3C3yOLpFLZtRCDKJZ+v01RL\nqXkygZrlRCvl1OIig6uLVDzAYdG6q++j6MZACWfnCCNsT7xbtA1xbKR8ODr2\ntxrwxZ/jWuRnuNvcQY2Ad2S9ANu8DeZ3sjdN2I+Wl6eO00xZdZEVnl+v8DU8\nr550/ZUI2hutkGtOit1b7iZDPOdzAtRH6KHBOJu1CApgEFufNlK1W8AWh/BK\n8wHmpxUAZOKtrkllHj+1OLSiqUIiZjkv/bEp3xYAGICtJQalRz/Ffka+31ET\n3dGg9rUDS09yxua+bV5F4g9WZeglGzM3zzqhJifdDMCxa79Pxc6Z3kXtff8D\nTlehyTe5kcujxfUQiqjddPP2b0tE/w7sXv06xZViybGTTnjaiuD55BXnLHat\n76TNAIFyjYf3R5lxnLFe0UDblLlvjwOjAfiuqvfzwAQPuTOwU3Y+9m92bxrR\nVzQt6TTMJbUmpd8j2xXGla571Cu2CfPzyHMaapLmDILJvyoXsDQgp/Ljcr+D\n1829bAgq4WSOem7THaeDLntPZCg5Q8k0bhwqA7iISHV2gYP2QJKLZ/Ncndcr\nWajQz/qHGa+/W5GS2P9jQ5FLqTTk2sk2YYjrxgjqF2/TjwHjPyVtnSOYTFRZ\ntTRc\r\n=Z4DG\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEYCIQC7DXDTvHIB0ajNl7Lx0Xoy6hd+KQKedYZhuLtHjaZvvAIhAJgXCa4jFnTBt4FJaFA4apq+04upOwMfybPVWcLkdql9"
          }
        ]
      },
      "maintainers": [
        {
          "email": "npm@apollographql.com",
          "name": "apollo-bot"
        },
        {
          "email": "ben@benjamn.com",
          "name": "benjamn"
        },
        {
          "email": "james@meteor.com",
          "name": "jbaxleyiii"
        },
        {
          "email": "peggyrayzis@gmail.com",
          "name": "peggyrayzis"
        }
      ],
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/apollo-cache-inmemory_1.4.0-alpha.1_1541547520426_0.11688392082431509"
      },
      "_hasShrinkwrap": false
    },
    "1.3.10": {
      "name": "apollo-cache-inmemory",
      "version": "1.3.10",
      "description": "Core abstract of Caching layer for Apollo Client",
      "author": {
        "name": "James Baxley",
        "email": "james@meteor.com"
      },
      "contributors": [
        {
          "name": "James Baxley",
          "email": "james@meteor.com"
        },
        {
          "name": "Jonas Helfer",
          "email": "jonas@helfer.email"
        },
        {
          "name": "Sashko Stubailo",
          "email": "sashko@stubailo.com"
        },
        {
          "name": "James Burgess",
          "email": "jamesmillerburgess@gmail.com"
        },
        {
          "name": "Bazyli Brzóska",
          "email": "bazyli.brzoska@gmail.com"
        }
      ],
      "license": "MIT",
      "main": "./lib/bundle.umd.js",
      "module": "./lib/index.js",
      "jsnext:main": "./lib/index.js",
      "typings": "./lib/index.d.ts",
      "sideEffects": [
        "./lib/fixPolyfills.js"
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/apollographql/apollo-client.git"
      },
      "bugs": {
        "url": "https://github.com/apollographql/apollo-client/issues"
      },
      "homepage": "https://github.com/apollographql/apollo-client#readme",
      "scripts": {
        "prepare": "npm run build",
        "coverage": "jest --coverage",
        "test": "jest",
        "lint": "tslint -c \"../../config/tslint.json\" -p tsconfig.json src/*.ts",
        "prebuild": "npm run clean",
        "build": "tsc -p .",
        "postbuild": "npm run bundle",
        "bundle": "../../node_modules/rollup/bin/rollup -c rollup.config.js",
        "watch": "tsc -w -p .",
        "clean": "rm -rf coverage/* && rm -rf lib/*",
        "prepublishOnly": "npm run build",
        "minify": "../../node_modules/uglify-js/bin/uglifyjs -c -m -o ./lib/bundle.min.js -- ./lib/bundle.umd.js",
        "filesize": "npm run minify"
      },
      "dependencies": {
        "apollo-cache": "^1.1.20",
        "apollo-utilities": "^1.0.25",
        "optimism": "^0.6.6"
      },
      "peerDependencies": {
        "graphql": "0.11.7 || ^0.12.0 || ^0.13.0 || ^14.0.0"
      },
      "jest": {
        "transform": {
          ".(ts|tsx)": "ts-jest"
        },
        "testRegex": "(/__tests__/.*|\\.(test|spec))\\.(ts|tsx|js)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "json"
        ],
        "testURL": "http://localhost"
      },
      "gitHead": "87cecbeea9255b6c3c7f2e4b2a65a27819609335",
      "_resolved": "",
      "_integrity": "",
      "_from": "file:apollo-cache-inmemory-1.3.10.tgz",
      "_id": "apollo-cache-inmemory@1.3.10",
      "_npmVersion": "6.4.1",
      "_nodeVersion": "8.11.4",
      "_npmUser": {
        "name": "benjamn",
        "email": "ben@benjamn.com"
      },
      "dist": {
        "integrity": "sha512-cJL8xxX2iytludvxY4goxYJ41n8avXirAjQkEwgSvGqrEzC0PG2DwtHZZh1QTnRRuM1rgj4MKiUiX/Ykhc5L+Q==",
        "shasum": "2e5375ad7ac0d30d59aaae3a2b5967673d0cf968",
        "tarball": "https://registry.npmjs.org/apollo-cache-inmemory/-/apollo-cache-inmemory-1.3.10.tgz",
        "fileCount": 62,
        "unpackedSize": 315554,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJb70QVCRA9TVsSAnZWagAA+hgP/1ukSTVaAlS2lJVcNFqx\n8ITesU9PaFYzsao7teQG28PA/L/Bh35iTBYqxA3c/jDZ2+OBRCr/i23UPZ8G\np2nUbgpT2v3ErRmdPnRVBwXV2a3cPSQsCSIir+jkZB8O+oeQg+y6OuL0Oguv\nx8udOUyVCll34RXzh25T+hysmhbDJqyowgUSyLzVIFg1z+D6WCP7EVn3bTvq\nZjtVtyjLNoA1rvlDhoLcUPV6xTgEtjVlZrGqmSYTcHoVr4rFFs4ZpyTQdTRG\nGdWIVM4IC4PYzwYjNaHE1FG/i62L237lL7h9qu4Q2PVY2ZBgbTd8nCRvELhG\ngVPFtLLS7kVvz/HjrWNz/JXGtoiIwtbQEm9c1ZRvgN+fpeonuRMb0wjPQxpy\n7BkX6ZA0pZeqNadrg4Pmvw5Rwrt8tIyNJ2jQDVtJTbJ0UT9BonGp/X4piCmr\niSYraTfGu7XYQ4c1vgjL5qe0XtVtBCxuiKLVv+KB7QExNADgxhLSp3s68oy5\nRJ+NAOOtHmgLtxEGjZsti0vRVC+r/eyGvsnvgwxqie5a7g0enjXfCWrVpsTm\ns70iGHIGCOMJn1MCIWLiIrCaAWrSDTBhBr0B7nNuG2qasgTeMeaWyln/EE3r\nVfk7Dc/y+xOsn0oNuoeHvAj7/NWjq2BISgOCLvF25cqG10gJe8OqUZjdWZoA\nuNB+\r\n=pF8L\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEQCIF+lYCa02Ob9si0D1nECL7/lObo7ckBzYJTjTfmxIYkzAiARiQgZAmvmz/leUQfc8KeG+T8xe/vyIYotS0gn0S/JqA=="
          }
        ]
      },
      "maintainers": [
        {
          "email": "npm@apollographql.com",
          "name": "apollo-bot"
        },
        {
          "email": "ben@benjamn.com",
          "name": "benjamn"
        },
        {
          "email": "james@meteor.com",
          "name": "jbaxleyiii"
        },
        {
          "email": "peggyrayzis@gmail.com",
          "name": "peggyrayzis"
        }
      ],
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/apollo-cache-inmemory_1.3.10_1542407188151_0.5293663536350766"
      },
      "_hasShrinkwrap": false
    },
    "1.3.11": {
      "name": "apollo-cache-inmemory",
      "version": "1.3.11",
      "description": "Core abstract of Caching layer for Apollo Client",
      "author": {
        "name": "James Baxley",
        "email": "james@meteor.com"
      },
      "contributors": [
        {
          "name": "James Baxley",
          "email": "james@meteor.com"
        },
        {
          "name": "Jonas Helfer",
          "email": "jonas@helfer.email"
        },
        {
          "name": "Sashko Stubailo",
          "email": "sashko@stubailo.com"
        },
        {
          "name": "James Burgess",
          "email": "jamesmillerburgess@gmail.com"
        },
        {
          "name": "Bazyli Brzóska",
          "email": "bazyli.brzoska@gmail.com"
        }
      ],
      "license": "MIT",
      "main": "./lib/bundle.umd.js",
      "module": "./lib/index.js",
      "jsnext:main": "./lib/index.js",
      "typings": "./lib/index.d.ts",
      "sideEffects": [
        "./lib/fixPolyfills.js"
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/apollographql/apollo-client.git"
      },
      "bugs": {
        "url": "https://github.com/apollographql/apollo-client/issues"
      },
      "homepage": "https://github.com/apollographql/apollo-client#readme",
      "scripts": {
        "prepare": "npm run build",
        "coverage": "jest --coverage",
        "test": "jest",
        "lint": "tslint -c \"../../config/tslint.json\" -p tsconfig.json src/*.ts",
        "prebuild": "npm run clean",
        "build": "tsc -p .",
        "postbuild": "npm run bundle",
        "bundle": "../../node_modules/rollup/bin/rollup -c rollup.config.js",
        "watch": "tsc -w -p .",
        "clean": "rm -rf coverage/* && rm -rf lib/*",
        "prepublishOnly": "npm run build",
        "minify": "../../node_modules/uglify-js/bin/uglifyjs -c -m -o ./lib/bundle.min.js -- ./lib/bundle.umd.js",
        "filesize": "npm run minify"
      },
      "dependencies": {
        "apollo-cache": "^1.1.21",
        "apollo-utilities": "^1.0.26",
        "optimism": "^0.6.6"
      },
      "peerDependencies": {
        "graphql": "0.11.7 || ^0.12.0 || ^0.13.0 || ^14.0.0"
      },
      "jest": {
        "transform": {
          ".(ts|tsx)": "ts-jest"
        },
        "testRegex": "(/__tests__/.*|\\.(test|spec))\\.(ts|tsx|js)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "json"
        ],
        "testURL": "http://localhost"
      },
      "gitHead": "1da881cce56a1cde8e2fd5eb86e9429f718f09b4",
      "_resolved": "",
      "_integrity": "",
      "_from": "file:apollo-cache-inmemory-1.3.11.tgz",
      "_id": "apollo-cache-inmemory@1.3.11",
      "_npmVersion": "6.4.1",
      "_nodeVersion": "8.12.0",
      "_npmUser": {
        "name": "apollo-bot",
        "email": "npm@apollographql.com"
      },
      "dist": {
        "integrity": "sha512-fSoyjBV5RV57J3i/VHDDB74ZgXc0PFiogheNFHEhC0mL6rg5e/DjTx0Vg+csIBk23gvlzTvV+eypx7Q2NJ+dYg==",
        "shasum": "6cb8f24ec812715169f9acbb0b67833f9a19ec90",
        "tarball": "https://registry.npmjs.org/apollo-cache-inmemory/-/apollo-cache-inmemory-1.3.11.tgz",
        "fileCount": 62,
        "unpackedSize": 315554,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJb9aBvCRA9TVsSAnZWagAAUKsP/1cC5krzrGDrTbsO+VZc\n3mthNkc3cF1pgjfbB+wTch7zBNF/pqn5nWioasDwBaerxmKfHrqTc9OVIca0\nhbRxpNFS+pYNL8drPrnGxaRr9iO//1tvLzv4ygnBGkuubwDqimD0qLJODKDS\n8BB5e69mINqD1umXDYSeCHAZ78ZNH3SM81d8E3JGSX/WBRtJhNRVioGpfLjb\n7l9/QRqsg/fLFAejdsoX4e8ubfKJyrpxK05SW4yxUrnHl03tjwjmh8Fz63Mb\n62aGX267RwAXDwOJgrLSmtGzvSsVy/CGZmOhX/6T8cPXJQlvwfeGK1l7+2WJ\nW3RkD56y0btHxMj+Ggm+mwq5DEwmbBo7VexzPgcpETow4tWTokf4pUN8QANt\nXRr2fQ1+tyvEXcuapWmXSUMosbrM35repoX+6o8xcJCLCJmPt4EniTFVg0jr\nPKi5qGhf1aOVypf5vCKSK8iRi3a0Dwj795BX/r77XKolAIbtDH4kq8056HtQ\nMsSiJ0fQzUpIQO6nlL2MEIrnx0Re7nDfUCHm6KfWVA6dzt3IKuSEpC1udhGB\n97U0jlvY82c3nN1PjaSjGrJwk5aIqU+pJ0dBmrIu8AArnndWgNpb16UCm8yI\n2hP1oyxvR8ljsdnKHnvh2XwDgs2BQ26K2BWFUEoTvxbLw2JwhZCVATazbC56\npHTC\r\n=qlwx\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEYCIQCAm6WIynM5QdFbSAPpSdH1l7DfpYiUGzh/5feK/egwAwIhAIf9/XoMzcDMBBp8d5RWwQzrtZ3Ym425in382/QIU4ru"
          }
        ]
      },
      "maintainers": [
        {
          "email": "npm@apollographql.com",
          "name": "apollo-bot"
        },
        {
          "email": "ben@benjamn.com",
          "name": "benjamn"
        },
        {
          "email": "james@meteor.com",
          "name": "jbaxleyiii"
        },
        {
          "email": "peggyrayzis@gmail.com",
          "name": "peggyrayzis"
        }
      ],
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/apollo-cache-inmemory_1.3.11_1542824046143_0.5124356394308214"
      },
      "_hasShrinkwrap": false
    },
    "1.4.0-alpha.2": {
      "name": "apollo-cache-inmemory",
      "version": "1.4.0-alpha.2",
      "description": "Core abstract of Caching layer for Apollo Client",
      "author": {
        "name": "James Baxley",
        "email": "james@meteor.com"
      },
      "contributors": [
        {
          "name": "James Baxley",
          "email": "james@meteor.com"
        },
        {
          "name": "Jonas Helfer",
          "email": "jonas@helfer.email"
        },
        {
          "name": "Sashko Stubailo",
          "email": "sashko@stubailo.com"
        },
        {
          "name": "James Burgess",
          "email": "jamesmillerburgess@gmail.com"
        },
        {
          "name": "Bazyli Brzóska",
          "email": "bazyli.brzoska@gmail.com"
        }
      ],
      "license": "MIT",
      "main": "./lib/bundle.umd.js",
      "module": "./lib/index.js",
      "jsnext:main": "./lib/index.js",
      "typings": "./lib/index.d.ts",
      "sideEffects": [
        "./lib/fixPolyfills.js"
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/apollographql/apollo-client.git"
      },
      "bugs": {
        "url": "https://github.com/apollographql/apollo-client/issues"
      },
      "homepage": "https://github.com/apollographql/apollo-client#readme",
      "scripts": {
        "prepare": "npm run build",
        "coverage": "jest --coverage",
        "test": "jest",
        "lint": "tslint -c \"../../config/tslint.json\" -p tsconfig.json src/*.ts",
        "prebuild": "npm run clean",
        "build": "tsc -p .",
        "postbuild": "npm run bundle",
        "bundle": "../../node_modules/rollup/bin/rollup -c rollup.config.js",
        "watch": "tsc -w -p .",
        "clean": "rm -rf coverage/* && rm -rf lib/*",
        "prepublishOnly": "npm run build",
        "minify": "../../node_modules/uglify-js/bin/uglifyjs -c -m -o ./lib/bundle.min.js -- ./lib/bundle.umd.js",
        "filesize": "npm run minify"
      },
      "dependencies": {
        "apollo-cache": "^1.2.0-alpha.2",
        "apollo-utilities": "^1.1.0-alpha.2",
        "optimism": "^0.6.6"
      },
      "peerDependencies": {
        "graphql": "0.11.7 || ^0.12.0 || ^0.13.0 || ^14.0.0"
      },
      "jest": {
        "transform": {
          ".(ts|tsx)": "ts-jest"
        },
        "testRegex": "(/__tests__/.*|\\.(test|spec))\\.(ts|tsx|js)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "json"
        ],
        "testURL": "http://localhost"
      },
      "gitHead": "a3e32b0ec42d221d443b402d108b428c53975d05",
      "_resolved": "",
      "_integrity": "",
      "_from": "file:apollo-cache-inmemory-1.4.0-alpha.2.tgz",
      "readme": "---\ntitle: InMemoryCache\ndescription: An explanation of `apollo-cache-inmemory`\n---\n\n`apollo-cache-inmemory` is the recommended cache implementation for Apollo Client 2.0. `InMemoryCache` is a normalized data store that supports all of Apollo Client 1.0's features without the dependency on Redux.\n\nIn some instances, you may need to manipulate the cache directly, such as updating the store after a mutation. We'll cover some common use cases [here](#recipes).\n\n<h2 id=\"installation\">Installation</h2>\n\n```\nnpm install apollo-cache-inmemory --save\n```\n\nAfter installing the package, you'll want to initialize the cache constructor. Then, you can pass in your newly created cache to ApolloClient.\n\n```js\nimport { InMemoryCache } from 'apollo-cache-inmemory';\nimport { HttpLink } from 'apollo-link-http';\nimport ApolloClient from 'apollo-client';\n\nconst cache = new InMemoryCache();\n\nconst client = new ApolloClient({\n  link: new HttpLink(),\n  cache\n});\n```\n\n<h2 id=\"configuration\">Configuration</h2>\n\nThe `InMemoryCache` constructor takes an optional config object with properties to customize your cache:\n\n- addTypename: A boolean to determine whether to add __typename to the document (default: `true`)\n- dataIdFromObject: A function that takes a data object and returns a unique identifier to be used when normalizing the data in the store. Learn more about how to customize `dataIdFromObject` in the [Normalization](#normalization) section.\n- fragmentMatcher: By default, the `InMemoryCache` uses a heuristic fragment matcher. If you are using fragments on unions and interfaces, you will need to use an `IntrospectionFragmentMatcher`. For more information, please read [our guide to setting up fragment matching for unions & interfaces](https://www.apollographql.com/docs/react/advanced/fragments.html#fragment-matcher).\n\n<h2 id=\"normalization\">Normalization</h2>\n\nThe `InMemoryCache` normalizes your data before saving it to the store by splitting the result into individual objects, creating a unique identifier for each object, and storing those objects in a flattened data structure. By default, `InMemoryCache` will attempt to use the commonly found primary keys of `id` and `_id` for the unique identifier if they exist along with `__typename` on an object.\n\nIf `id` and `_id` are not specified, or if `__typename` is not specified, `InMemoryCache` will fall back to the path to the object in the query, such as `ROOT_QUERY.allPeople.0` for the first record returned on the `allPeople` root query.\n\nThis \"getter\" behavior for unique identifiers can be configured manually via the `dataIdFromObject` option passed to the `InMemoryCache` constructor, so you can pick which field is used if some of your data follows unorthodox primary key conventions.\n\nFor example, if you wanted to key off of the `key` field for all of your data, you could configure `dataIdFromObject` like so:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => object.key\n});\n```\n\nThis also allows you to use different unique identifiers for different data types by keying off of the `__typename` property attached to every object typed by GraphQL.  For example:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => {\n    switch (object.__typename) {\n      case 'foo': return object.key; // use `key` as the primary key\n      case 'bar': return object.blah; // use `blah` as the priamry key\n      default: return object.id || object._id; // fall back to `id` and `_id` for all other types\n    }\n  }\n});\n```\n\n<h2 id=\"direct\">Direct Cache Access</h2>\n\nTo interact directly with your cache, you can use the Apollo Client class methods readQuery, readFragment, writeQuery, and writeFragment. These methods are available to us via the [`DataProxy` interface](https://github.com/apollographql/apollo-client/blob/master/packages/apollo-cache/src/types/DataProxy.ts). Accessing these methods will vary slightly based on your view layer implementation. If you are using React, you can wrap your component in the `withApollo` higher order component, which will give you access to `this.props.client`. From there, you can use the methods to control your data.\n\nAny code demonstration in the following sections will assume that we have already initialized an instance of  `ApolloClient` and that we have imported the `gql` tag from `graphql-tag`.\n\n<h3 id=\"readquery\">readQuery</h3>\n\nThe `readQuery` method is very similar to the [`query` method on `ApolloClient`][] except that `readQuery` will _never_ make a request to your GraphQL server. The `query` method, on the other hand, may send a request to your server if the appropriate data is not in your cache whereas `readQuery` will throw an error if the data is not in your cache. `readQuery` will _always_ read from the cache. You can use `readQuery` by giving it a GraphQL query like so:\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo {\n      todo(id: 5) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n});\n```\n\nIf all of the data needed to fulfill this read is in Apollo Client’s normalized data cache then a data object will be returned in the shape of the query you wanted to read. If not all of the data needed to fulfill this read is in Apollo Client’s cache then an error will be thrown instead, so make sure to only read data that you know you have!\n\nYou can also pass variables into `readQuery`.\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo($id: Int!) {\n      todo(id: $id) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n  variables: {\n    id: 5,\n  },\n});\n```\n\n<h3 id=\"readfragment\">readFragment</h3>\n\nThis method allows you great flexibility around the data in your cache. Whereas `readQuery` only allowed you to read data from your root query type, `readFragment` allows you to read data from _any node you have queried_. This is incredibly powerful. You use this method as follows:\n\n```js\nconst todo = client.readFragment({\n  id: ..., // `id` is any id that could be returned by `dataIdFromObject`.\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\nThe first argument is the id of the data you want to read from the cache. That id must be a value that was returned by the `dataIdFromObject` function you defined when initializing `ApolloClient`. So for example if you initialized `ApolloClient` like so:\n\n```js\nconst client = new ApolloClient({\n  ...,\n  dataIdFromObject: object => object.id,\n});\n```\n\n…and you requested a todo before with an id of `5`, then you can read that todo out of your cache with the following:\n\n```js\nconst todo = client.readFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\n> **Note:** Most people add a `__typename` to the id in `dataIdFromObject`. If you do this then don’t forget to add the `__typename` when you are reading a fragment as well. So for example your id may be `Todo_5` and not just `5`.\n\nIf a todo with that id does not exist in the cache you will get `null` back. If a todo of that id does exist in the cache, but that todo does not have the `text` field then an error will be thrown.\n\nThe beauty of `readFragment` is that the todo could have come from anywhere! The todo could have been selected as a singleton (`{ todo(id: 5) { ... } }`), the todo could have come from a list of todos (`{ todos { ... } }`), or the todo could have come from a mutation (`mutation { createTodo { ... } }`). As long as at some point your GraphQL server gave you a todo with the provided id and fields `id`, `text`, and `completed` you can read it from the cache at any part of your code.\n\n<h3 id=\"writequery-and-writefragment\">writeQuery` and `writeFragment</h3>\n\nNot only can you read arbitrary data from the Apollo Client cache, but you can also write any data that you would like to the cache. The methods you use to do this are `writeQuery` and `writeFragment`. They will allow you to change data in your local cache, but it is important to remember that *they will not change any data on your server*. If you reload your environment then changes made with `writeQuery` and `writeFragment` will disappear.\n\nThese methods have the same signature as their `readQuery` and `readFragment` counterparts except they also require an additional `data` variable. So for example, if you wanted to update the `completed` flag locally for your todo with id `'5'` you could execute the following:\n\n```js\nclient.writeFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      completed\n    }\n  `,\n  data: {\n    completed: true,\n  },\n});\n```\n\nAny subscriber to the Apollo Client store will instantly see this update and render new UI accordingly.\n\n> **Note:** Again, remember that using `writeQuery` or `writeFragment` only changes data *locally*. If you reload your environment then changes made with these methods will no longer exist.\n\nOr if you wanted to add a new todo to a list fetched from the server, you could use `readQuery` and `writeQuery` together.\n\n```js\nconst query = gql`\n  query MyTodoAppQuery {\n    todos {\n      id\n      text\n      completed\n    }\n  }\n`;\n\nconst data = client.readQuery({ query });\n\nconst myNewTodo = {\n  id: '6',\n  text: 'Start using Apollo Client.',\n  completed: false,\n};\n\nclient.writeQuery({\n  query,\n  data: {\n    todos: [...data.todos, myNewTodo],\n  },\n});\n```\n\n<h2 id=\"recipes\">Recipes</h2>\n\nHere are some common situations where you would need to access the cache directly. If you're manipulating the cache in an interesting way and would like your example to be featured, please send in a pull request!\n\n<h3 id=\"server\">Server side rendering</h3>\n\nFirst, you will need to initialize an `InMemoryCache` on the server and create an instance of `ApolloClient`. In the initial serialized HTML payload from the server, you should include a script tag that extracts the data from the cache.\n\n```js\n`<script>\n  window.__APOLLO_STATE__=${JSON.stringify(cache.extract())}\n</script>`\n```\n\nOn the client, you can rehydrate the cache using the initial data passed from the server:\n\n```js\ncache: new Cache().restore(window.__APOLLO_STATE__)\n```\n\nIf you would like to learn more about server side rendering, please check our our more in depth guide [here].\n<!---\nTODO (PEGGY): Add link to SSR\n-->\n\n<h3 id=\"server\">Updating the cache after a mutation</h3>\n\nBeing able to read and write to the Apollo cache from anywhere in your application gives you a lot of power over your data. However, there is one place where we most often want to update our cached data: after a mutation. As such, Apollo Client has optimized the experience for updating your cache with the read and write methods after a mutation with the `update` function. Let us say that we have the following GraphQL mutation:\n\n```graphql\nmutation TodoCreateMutation($text: String!) {\n  createTodo(text: $text) {\n    id\n    text\n    completed\n  }\n}\n```\n\nWe may also have the following GraphQL query:\n\n```graphql\nquery TodoAppQuery {\n  todos {\n    id\n    text\n    completed\n  }\n}\n```\n\nAt the end of our mutation we want our query to include the new todo like we had sent our `TodoAppQuery` a second time after the mutation finished without actually sending the query. To do this we can use the `update` function provided as an option of the `client.mutate` method. To update your cache with the mutation just write code that looks like:\n\n```js\n// We assume that the GraphQL operations `TodoCreateMutation` and\n// `TodoAppQuery` have already been defined using the `gql` tag.\n\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    // Read the data from our cache for this query.\n    const data = proxy.readQuery({ query: TodoAppQuery });\n\n    // Add our todo from the mutation to the end.\n    data.todos.push(createTodo);\n\n    // Write our data back to the cache.\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nThe first `proxy` argument is an instance of [`DataProxy`][] has the same four methods that we just learned exist on the Apollo Client: `readQuery`, `readFragment`, `writeQuery`, and `writeFragment`. The reason we call them on a `proxy` object here instead of on our `client` instance is that we can easily apply optimistic updates (which we will demonstrate in a bit). The `proxy` object also provides an isolated transaction which shields you from any other mutations going on at the same time, and the `proxy` object also batches writes together until the very end.\n\nIf you provide an `optimisticResponse` option to the mutation then the `update` function will be run twice. Once immediately after you call `client.mutate` with the data from `optimisticResponse`. After the mutation successfully executes against the server the changes made in the first call to `update` will be rolled back and `update` will be called with the *actual* data returned by the mutation and not just the optimistic response.\n\nPutting it all together:\n\n```js\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  optimisticResponse: {\n    id: -1, // -1 is a temporary id for the optimistic response.\n    text,\n    completed: false,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    const data = proxy.readQuery({ query: TodoAppQuery });\n    data.todos.push(createTodo);\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nAs you can see the `update` function on `client.mutate` provides extra change management functionality specific to the use case of a mutation while still providing you the powerful data control APIs that are available on `client`.\n\nThe `update` function is not a good place for side-effects as it may be called multiple times. Also, you may not call any of the methods on `proxy` asynchronously.\n\n",
      "readmeFilename": "README.md",
      "_id": "apollo-cache-inmemory@1.4.0-alpha.2",
      "_npmVersion": "6.4.1",
      "_nodeVersion": "8.12.0",
      "_npmUser": {
        "name": "apollo-bot",
        "email": "npm@apollographql.com"
      },
      "dist": {
        "integrity": "sha512-8OcOzvf7RAjSaGpF+ioBmgOetDO6Jvw5ZtPoqVnRy11m7xaIOzWr3DKQoK5YdXv+YoZQ+CQAnPar2pRbA4CGLg==",
        "shasum": "4c4a45786e3d203c7bd53ab16f21434266dea87e",
        "tarball": "https://registry.npmjs.org/apollo-cache-inmemory/-/apollo-cache-inmemory-1.4.0-alpha.2.tgz",
        "fileCount": 62,
        "unpackedSize": 318076,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJcDxMDCRA9TVsSAnZWagAAtKUP/0Yx9gEhXmpJrClZSE1R\n6Ex+jgmFHHqqPBgo4Ih9fkTy7GQv3BZ/iG0fzk1iWFZED8qtx9vG1IZgfqcR\n04HOg4DD1ab919rKwvfYQke3fYKL9REdv5EuiLHPBc72C4cu4VkhEO7PFwR6\n/yFeH7tgmTZcsbS0hmChSJPYnsqL72alVCFrTSR/G6JCN80bhF0EJBkuucXu\nrqUBcBFpCf/t+9RYup/6v9z9/g0eCGTfN8raoaGmBJradTM23ldwKLTwwAbX\nKAqQ4l8zivEW8XsNA1+YJsOFKMlxvnSPOY9SivaFWKRvXPJb2c2QhSjVQdYv\nlKHJyE6rr8WmoiUWpJNHAEt40OUICNomYzx7+bC3Tfnumip0Vnb9ipn528+M\nTGdiLiwBphXejE7Q6fnImfuwY8E/AnlaH5vNQGAz+8Oo7olLvzshFIpVKmxY\nkFNSqNgtJ17/wBWwa+i4oFmP1hl++g5+gz27M+Av4IAMutOaohFxz41dy0hb\nHmIjd/YSu3uajQLoOBCpGFsZ9zQnjGFVliz83Co61yxTtVNG0xPhqXSSplq3\nppMry8nIY6dYyUjAXndyWmFBVRAln0NKD/7ulFfrH5ysXAKtBh0fNRAxgoW/\nMatYGlkaeRa9RRC/JDf9RJzXQpeyneF0sOZTnSNHkbx0GDGbAhTsUHvloXfG\nm0W+\r\n=5+2H\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIQCCr4uzSU/W+F+7snD6SFFRD+iDfneq1dh5AT4g4CYKCAIgEehgCXbffdgFNOBAL8DyHodctFlCNt3zqIOqry3X6r0="
          }
        ]
      },
      "maintainers": [
        {
          "email": "npm@apollographql.com",
          "name": "apollo-bot"
        },
        {
          "email": "ben@benjamn.com",
          "name": "benjamn"
        },
        {
          "email": "james@meteor.com",
          "name": "jbaxleyiii"
        },
        {
          "email": "peggyrayzis@gmail.com",
          "name": "peggyrayzis"
        }
      ],
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/apollo-cache-inmemory_1.4.0-alpha.2_1544491778179_0.14502441149409884"
      },
      "_hasShrinkwrap": false
    },
    "1.3.12-beta.0": {
      "name": "apollo-cache-inmemory",
      "version": "1.3.12-beta.0",
      "description": "Core abstract of Caching layer for Apollo Client",
      "author": {
        "name": "James Baxley",
        "email": "james@meteor.com"
      },
      "contributors": [
        {
          "name": "James Baxley",
          "email": "james@meteor.com"
        },
        {
          "name": "Jonas Helfer",
          "email": "jonas@helfer.email"
        },
        {
          "name": "Sashko Stubailo",
          "email": "sashko@stubailo.com"
        },
        {
          "name": "James Burgess",
          "email": "jamesmillerburgess@gmail.com"
        },
        {
          "name": "Bazyli Brzóska",
          "email": "bazyli.brzoska@gmail.com"
        }
      ],
      "license": "MIT",
      "main": "./lib/bundle.umd.js",
      "module": "./lib/index.js",
      "jsnext:main": "./lib/index.js",
      "typings": "./lib/index.d.ts",
      "sideEffects": [
        "./lib/fixPolyfills.js"
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/apollographql/apollo-client.git"
      },
      "bugs": {
        "url": "https://github.com/apollographql/apollo-client/issues"
      },
      "homepage": "https://github.com/apollographql/apollo-client#readme",
      "scripts": {
        "prepare": "npm run build",
        "coverage": "jest --coverage",
        "test": "jest",
        "lint": "tslint -c \"../../config/tslint.json\" -p tsconfig.json src/*.ts",
        "prebuild": "npm run clean",
        "build": "tsc -p .",
        "postbuild": "npm run bundle",
        "bundle": "../../node_modules/rollup/bin/rollup -c rollup.config.js",
        "watch": "tsc -w -p .",
        "clean": "rm -rf coverage/* && rm -rf lib/*",
        "prepublishOnly": "npm run build",
        "minify": "../../node_modules/uglify-js/bin/uglifyjs -c -m -o ./lib/bundle.min.js -- ./lib/bundle.umd.js",
        "filesize": "npm run minify"
      },
      "dependencies": {
        "apollo-cache": "^1.1.21",
        "apollo-utilities": "^1.0.26",
        "optimism": "^0.6.8"
      },
      "peerDependencies": {
        "graphql": "0.11.7 || ^0.12.0 || ^0.13.0 || ^14.0.0"
      },
      "jest": {
        "transform": {
          ".(ts|tsx)": "ts-jest"
        },
        "testRegex": "(/__tests__/.*|\\.(test|spec))\\.(ts|tsx|js)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "json"
        ],
        "testURL": "http://localhost"
      },
      "readme": "---\ntitle: InMemoryCache\ndescription: An explanation of `apollo-cache-inmemory`\n---\n\n`apollo-cache-inmemory` is the recommended cache implementation for Apollo Client 2.0. `InMemoryCache` is a normalized data store that supports all of Apollo Client 1.0's features without the dependency on Redux.\n\nIn some instances, you may need to manipulate the cache directly, such as updating the store after a mutation. We'll cover some common use cases [here](#recipes).\n\n<h2 id=\"installation\">Installation</h2>\n\n```\nnpm install apollo-cache-inmemory --save\n```\n\nAfter installing the package, you'll want to initialize the cache constructor. Then, you can pass in your newly created cache to ApolloClient.\n\n```js\nimport { InMemoryCache } from 'apollo-cache-inmemory';\nimport { HttpLink } from 'apollo-link-http';\nimport ApolloClient from 'apollo-client';\n\nconst cache = new InMemoryCache();\n\nconst client = new ApolloClient({\n  link: new HttpLink(),\n  cache\n});\n```\n\n<h2 id=\"configuration\">Configuration</h2>\n\nThe `InMemoryCache` constructor takes an optional config object with properties to customize your cache:\n\n- addTypename: A boolean to determine whether to add __typename to the document (default: `true`)\n- dataIdFromObject: A function that takes a data object and returns a unique identifier to be used when normalizing the data in the store. Learn more about how to customize `dataIdFromObject` in the [Normalization](#normalization) section.\n- fragmentMatcher: By default, the `InMemoryCache` uses a heuristic fragment matcher. If you are using fragments on unions and interfaces, you will need to use an `IntrospectionFragmentMatcher`. For more information, please read [our guide to setting up fragment matching for unions & interfaces](https://www.apollographql.com/docs/react/advanced/fragments.html#fragment-matcher).\n\n<h2 id=\"normalization\">Normalization</h2>\n\nThe `InMemoryCache` normalizes your data before saving it to the store by splitting the result into individual objects, creating a unique identifier for each object, and storing those objects in a flattened data structure. By default, `InMemoryCache` will attempt to use the commonly found primary keys of `id` and `_id` for the unique identifier if they exist along with `__typename` on an object.\n\nIf `id` and `_id` are not specified, or if `__typename` is not specified, `InMemoryCache` will fall back to the path to the object in the query, such as `ROOT_QUERY.allPeople.0` for the first record returned on the `allPeople` root query.\n\nThis \"getter\" behavior for unique identifiers can be configured manually via the `dataIdFromObject` option passed to the `InMemoryCache` constructor, so you can pick which field is used if some of your data follows unorthodox primary key conventions.\n\nFor example, if you wanted to key off of the `key` field for all of your data, you could configure `dataIdFromObject` like so:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => object.key\n});\n```\n\nThis also allows you to use different unique identifiers for different data types by keying off of the `__typename` property attached to every object typed by GraphQL.  For example:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => {\n    switch (object.__typename) {\n      case 'foo': return object.key; // use `key` as the primary key\n      case 'bar': return object.blah; // use `blah` as the priamry key\n      default: return object.id || object._id; // fall back to `id` and `_id` for all other types\n    }\n  }\n});\n```\n\n<h2 id=\"direct\">Direct Cache Access</h2>\n\nTo interact directly with your cache, you can use the Apollo Client class methods readQuery, readFragment, writeQuery, and writeFragment. These methods are available to us via the [`DataProxy` interface](https://github.com/apollographql/apollo-client/blob/master/packages/apollo-cache/src/types/DataProxy.ts). Accessing these methods will vary slightly based on your view layer implementation. If you are using React, you can wrap your component in the `withApollo` higher order component, which will give you access to `this.props.client`. From there, you can use the methods to control your data.\n\nAny code demonstration in the following sections will assume that we have already initialized an instance of  `ApolloClient` and that we have imported the `gql` tag from `graphql-tag`.\n\n<h3 id=\"readquery\">readQuery</h3>\n\nThe `readQuery` method is very similar to the [`query` method on `ApolloClient`][] except that `readQuery` will _never_ make a request to your GraphQL server. The `query` method, on the other hand, may send a request to your server if the appropriate data is not in your cache whereas `readQuery` will throw an error if the data is not in your cache. `readQuery` will _always_ read from the cache. You can use `readQuery` by giving it a GraphQL query like so:\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo {\n      todo(id: 5) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n});\n```\n\nIf all of the data needed to fulfill this read is in Apollo Client’s normalized data cache then a data object will be returned in the shape of the query you wanted to read. If not all of the data needed to fulfill this read is in Apollo Client’s cache then an error will be thrown instead, so make sure to only read data that you know you have!\n\nYou can also pass variables into `readQuery`.\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo($id: Int!) {\n      todo(id: $id) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n  variables: {\n    id: 5,\n  },\n});\n```\n\n<h3 id=\"readfragment\">readFragment</h3>\n\nThis method allows you great flexibility around the data in your cache. Whereas `readQuery` only allowed you to read data from your root query type, `readFragment` allows you to read data from _any node you have queried_. This is incredibly powerful. You use this method as follows:\n\n```js\nconst todo = client.readFragment({\n  id: ..., // `id` is any id that could be returned by `dataIdFromObject`.\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\nThe first argument is the id of the data you want to read from the cache. That id must be a value that was returned by the `dataIdFromObject` function you defined when initializing `ApolloClient`. So for example if you initialized `ApolloClient` like so:\n\n```js\nconst client = new ApolloClient({\n  ...,\n  dataIdFromObject: object => object.id,\n});\n```\n\n…and you requested a todo before with an id of `5`, then you can read that todo out of your cache with the following:\n\n```js\nconst todo = client.readFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\n> **Note:** Most people add a `__typename` to the id in `dataIdFromObject`. If you do this then don’t forget to add the `__typename` when you are reading a fragment as well. So for example your id may be `Todo_5` and not just `5`.\n\nIf a todo with that id does not exist in the cache you will get `null` back. If a todo of that id does exist in the cache, but that todo does not have the `text` field then an error will be thrown.\n\nThe beauty of `readFragment` is that the todo could have come from anywhere! The todo could have been selected as a singleton (`{ todo(id: 5) { ... } }`), the todo could have come from a list of todos (`{ todos { ... } }`), or the todo could have come from a mutation (`mutation { createTodo { ... } }`). As long as at some point your GraphQL server gave you a todo with the provided id and fields `id`, `text`, and `completed` you can read it from the cache at any part of your code.\n\n<h3 id=\"writequery-and-writefragment\">writeQuery` and `writeFragment</h3>\n\nNot only can you read arbitrary data from the Apollo Client cache, but you can also write any data that you would like to the cache. The methods you use to do this are `writeQuery` and `writeFragment`. They will allow you to change data in your local cache, but it is important to remember that *they will not change any data on your server*. If you reload your environment then changes made with `writeQuery` and `writeFragment` will disappear.\n\nThese methods have the same signature as their `readQuery` and `readFragment` counterparts except they also require an additional `data` variable. So for example, if you wanted to update the `completed` flag locally for your todo with id `'5'` you could execute the following:\n\n```js\nclient.writeFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      completed\n    }\n  `,\n  data: {\n    completed: true,\n  },\n});\n```\n\nAny subscriber to the Apollo Client store will instantly see this update and render new UI accordingly.\n\n> **Note:** Again, remember that using `writeQuery` or `writeFragment` only changes data *locally*. If you reload your environment then changes made with these methods will no longer exist.\n\nOr if you wanted to add a new todo to a list fetched from the server, you could use `readQuery` and `writeQuery` together.\n\n```js\nconst query = gql`\n  query MyTodoAppQuery {\n    todos {\n      id\n      text\n      completed\n    }\n  }\n`;\n\nconst data = client.readQuery({ query });\n\nconst myNewTodo = {\n  id: '6',\n  text: 'Start using Apollo Client.',\n  completed: false,\n};\n\nclient.writeQuery({\n  query,\n  data: {\n    todos: [...data.todos, myNewTodo],\n  },\n});\n```\n\n<h2 id=\"recipes\">Recipes</h2>\n\nHere are some common situations where you would need to access the cache directly. If you're manipulating the cache in an interesting way and would like your example to be featured, please send in a pull request!\n\n<h3 id=\"server\">Server side rendering</h3>\n\nFirst, you will need to initialize an `InMemoryCache` on the server and create an instance of `ApolloClient`. In the initial serialized HTML payload from the server, you should include a script tag that extracts the data from the cache.\n\n```js\n`<script>\n  window.__APOLLO_STATE__=${JSON.stringify(cache.extract())}\n</script>`\n```\n\nOn the client, you can rehydrate the cache using the initial data passed from the server:\n\n```js\ncache: new Cache().restore(window.__APOLLO_STATE__)\n```\n\nIf you would like to learn more about server side rendering, please check our our more in depth guide [here].\n<!---\nTODO (PEGGY): Add link to SSR\n-->\n\n<h3 id=\"server\">Updating the cache after a mutation</h3>\n\nBeing able to read and write to the Apollo cache from anywhere in your application gives you a lot of power over your data. However, there is one place where we most often want to update our cached data: after a mutation. As such, Apollo Client has optimized the experience for updating your cache with the read and write methods after a mutation with the `update` function. Let us say that we have the following GraphQL mutation:\n\n```graphql\nmutation TodoCreateMutation($text: String!) {\n  createTodo(text: $text) {\n    id\n    text\n    completed\n  }\n}\n```\n\nWe may also have the following GraphQL query:\n\n```graphql\nquery TodoAppQuery {\n  todos {\n    id\n    text\n    completed\n  }\n}\n```\n\nAt the end of our mutation we want our query to include the new todo like we had sent our `TodoAppQuery` a second time after the mutation finished without actually sending the query. To do this we can use the `update` function provided as an option of the `client.mutate` method. To update your cache with the mutation just write code that looks like:\n\n```js\n// We assume that the GraphQL operations `TodoCreateMutation` and\n// `TodoAppQuery` have already been defined using the `gql` tag.\n\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    // Read the data from our cache for this query.\n    const data = proxy.readQuery({ query: TodoAppQuery });\n\n    // Add our todo from the mutation to the end.\n    data.todos.push(createTodo);\n\n    // Write our data back to the cache.\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nThe first `proxy` argument is an instance of [`DataProxy`][] has the same four methods that we just learned exist on the Apollo Client: `readQuery`, `readFragment`, `writeQuery`, and `writeFragment`. The reason we call them on a `proxy` object here instead of on our `client` instance is that we can easily apply optimistic updates (which we will demonstrate in a bit). The `proxy` object also provides an isolated transaction which shields you from any other mutations going on at the same time, and the `proxy` object also batches writes together until the very end.\n\nIf you provide an `optimisticResponse` option to the mutation then the `update` function will be run twice. Once immediately after you call `client.mutate` with the data from `optimisticResponse`. After the mutation successfully executes against the server the changes made in the first call to `update` will be rolled back and `update` will be called with the *actual* data returned by the mutation and not just the optimistic response.\n\nPutting it all together:\n\n```js\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  optimisticResponse: {\n    id: -1, // -1 is a temporary id for the optimistic response.\n    text,\n    completed: false,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    const data = proxy.readQuery({ query: TodoAppQuery });\n    data.todos.push(createTodo);\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nAs you can see the `update` function on `client.mutate` provides extra change management functionality specific to the use case of a mutation while still providing you the powerful data control APIs that are available on `client`.\n\nThe `update` function is not a good place for side-effects as it may be called multiple times. Also, you may not call any of the methods on `proxy` asynchronously.\n\n",
      "readmeFilename": "README.md",
      "_id": "apollo-cache-inmemory@1.3.12-beta.0",
      "_npmVersion": "6.4.1",
      "_nodeVersion": "8.14.0",
      "_npmUser": {
        "name": "benjamn",
        "email": "ben@benjamn.com"
      },
      "dist": {
        "integrity": "sha512-bTQONAbg4KXPw64aj8xeifB4W50Hy2qsRqgsXfSbVDSg/799lFTuz9V3GWVi1PqUFyC7B3rzyEopGCVrRA1GUA==",
        "shasum": "7c7e659fd0ad41f744ea977f24b471ff5a1ffc8b",
        "tarball": "https://registry.npmjs.org/apollo-cache-inmemory/-/apollo-cache-inmemory-1.3.12-beta.0.tgz",
        "fileCount": 61,
        "unpackedSize": 314451,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJcGnX8CRA9TVsSAnZWagAABDcP/3YujJGLbeWkJPV95Zbh\n1xHUzWya/tVScz1H3XVCjm8TXwUzFnRiNEOqEqMe98f4vKF3Tlq2NM0ErkoJ\n/cWoKaRV+bpueXjMNF/o+gmz+RTWXgSJubhAqzeLRlhR6EpZpbaZ2PgMafXb\n3rvP33Fw0M5tkNSpTt4hCxWv7zRlgwqk6FbLhdkKMc7MBX8fg2xSM141oxC8\nAa9crf59FXoSFjobgCtr3Ax2GhfGwlCr2z+EvpuCpLQBJ9vVQufCfGHrHz8h\nJAqHiFk7KKzZdcNsBWFSKQsHFcuqHueiFFzYUlqKJgamyXIcB4WxPxvJDkvh\neClqdgoPCResIANg8szPMrcqd2kmx5O6ts8bb3qlqr6LvYIdFmjbiHQ3Pc/R\n915uZdcEsas6EFtPbAwZ46hD8lRzwycAH3bb7syxCZ5YCj6dmGCVu2KQZbLr\nJoFiWNCZOoa+nfCFMPIwVnAezzC6U1zwhhTT6QIGrliAvrIqHbRpFBU6aSbD\n4dMcdAJ/f25n0d3n74+EbxCNmy/7apzznl+lPrlx7mzM/OJfeMT6f0Ah3aXj\ny23MGc0ea5Y+sacMv5yXmk52yzxfzJIsw1nPX1H2yuRAWqqzjP+BEwiM41FI\nnz2f96kPc7XMP/QH0a1qS+GK+R/Dn91tGTYJum1pG9DLbIBscigHASeF4/9P\n5DF0\r\n=U1a9\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEQCIHkYet6muErCcH/t1z/dcTVaFO+xVFXkAzlaeMJc5vcBAiBrvfRHZgaRuHVq+FC6YhSPsHoDJNcV/ZV1FUMwgb+t/Q=="
          }
        ]
      },
      "maintainers": [
        {
          "email": "npm@apollographql.com",
          "name": "apollo-bot"
        },
        {
          "email": "ben@benjamn.com",
          "name": "benjamn"
        },
        {
          "email": "james@meteor.com",
          "name": "jbaxleyiii"
        },
        {
          "email": "peggyrayzis@gmail.com",
          "name": "peggyrayzis"
        }
      ],
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/apollo-cache-inmemory_1.3.12-beta.0_1545238011834_0.16034483472815242"
      },
      "_hasShrinkwrap": false
    },
    "1.3.12-beta.1": {
      "name": "apollo-cache-inmemory",
      "version": "1.3.12-beta.1",
      "description": "Core abstract of Caching layer for Apollo Client",
      "author": {
        "name": "James Baxley",
        "email": "james@meteor.com"
      },
      "contributors": [
        {
          "name": "James Baxley",
          "email": "james@meteor.com"
        },
        {
          "name": "Jonas Helfer",
          "email": "jonas@helfer.email"
        },
        {
          "name": "Sashko Stubailo",
          "email": "sashko@stubailo.com"
        },
        {
          "name": "James Burgess",
          "email": "jamesmillerburgess@gmail.com"
        },
        {
          "name": "Bazyli Brzóska",
          "email": "bazyli.brzoska@gmail.com"
        }
      ],
      "license": "MIT",
      "main": "./lib/bundle.umd.js",
      "module": "./lib/index.js",
      "jsnext:main": "./lib/index.js",
      "typings": "./lib/index.d.ts",
      "sideEffects": [
        "./lib/fixPolyfills.js"
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/apollographql/apollo-client.git"
      },
      "bugs": {
        "url": "https://github.com/apollographql/apollo-client/issues"
      },
      "homepage": "https://github.com/apollographql/apollo-client#readme",
      "scripts": {
        "prepare": "npm run build",
        "coverage": "jest --coverage",
        "test": "jest",
        "lint": "tslint -c \"../../config/tslint.json\" -p tsconfig.json src/*.ts",
        "prebuild": "npm run clean",
        "build": "tsc -p .",
        "postbuild": "npm run bundle",
        "bundle": "../../node_modules/rollup/bin/rollup -c rollup.config.js",
        "watch": "tsc -w -p .",
        "clean": "rm -rf coverage/* && rm -rf lib/*",
        "prepublishOnly": "npm run build",
        "minify": "../../node_modules/uglify-js/bin/uglifyjs -c -m -o ./lib/bundle.min.js -- ./lib/bundle.umd.js",
        "filesize": "npm run minify"
      },
      "dependencies": {
        "apollo-cache": "^1.1.21",
        "apollo-utilities": "^1.0.26",
        "optimism": "^0.6.8"
      },
      "peerDependencies": {
        "graphql": "0.11.7 || ^0.12.0 || ^0.13.0 || ^14.0.0"
      },
      "jest": {
        "transform": {
          ".(ts|tsx)": "ts-jest"
        },
        "testRegex": "(/__tests__/.*|\\.(test|spec))\\.(ts|tsx|js)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "json"
        ],
        "testURL": "http://localhost"
      },
      "readme": "---\ntitle: InMemoryCache\ndescription: An explanation of `apollo-cache-inmemory`\n---\n\n`apollo-cache-inmemory` is the recommended cache implementation for Apollo Client 2.0. `InMemoryCache` is a normalized data store that supports all of Apollo Client 1.0's features without the dependency on Redux.\n\nIn some instances, you may need to manipulate the cache directly, such as updating the store after a mutation. We'll cover some common use cases [here](#recipes).\n\n<h2 id=\"installation\">Installation</h2>\n\n```\nnpm install apollo-cache-inmemory --save\n```\n\nAfter installing the package, you'll want to initialize the cache constructor. Then, you can pass in your newly created cache to ApolloClient.\n\n```js\nimport { InMemoryCache } from 'apollo-cache-inmemory';\nimport { HttpLink } from 'apollo-link-http';\nimport ApolloClient from 'apollo-client';\n\nconst cache = new InMemoryCache();\n\nconst client = new ApolloClient({\n  link: new HttpLink(),\n  cache\n});\n```\n\n<h2 id=\"configuration\">Configuration</h2>\n\nThe `InMemoryCache` constructor takes an optional config object with properties to customize your cache:\n\n- addTypename: A boolean to determine whether to add __typename to the document (default: `true`)\n- dataIdFromObject: A function that takes a data object and returns a unique identifier to be used when normalizing the data in the store. Learn more about how to customize `dataIdFromObject` in the [Normalization](#normalization) section.\n- fragmentMatcher: By default, the `InMemoryCache` uses a heuristic fragment matcher. If you are using fragments on unions and interfaces, you will need to use an `IntrospectionFragmentMatcher`. For more information, please read [our guide to setting up fragment matching for unions & interfaces](https://www.apollographql.com/docs/react/advanced/fragments.html#fragment-matcher).\n\n<h2 id=\"normalization\">Normalization</h2>\n\nThe `InMemoryCache` normalizes your data before saving it to the store by splitting the result into individual objects, creating a unique identifier for each object, and storing those objects in a flattened data structure. By default, `InMemoryCache` will attempt to use the commonly found primary keys of `id` and `_id` for the unique identifier if they exist along with `__typename` on an object.\n\nIf `id` and `_id` are not specified, or if `__typename` is not specified, `InMemoryCache` will fall back to the path to the object in the query, such as `ROOT_QUERY.allPeople.0` for the first record returned on the `allPeople` root query.\n\nThis \"getter\" behavior for unique identifiers can be configured manually via the `dataIdFromObject` option passed to the `InMemoryCache` constructor, so you can pick which field is used if some of your data follows unorthodox primary key conventions.\n\nFor example, if you wanted to key off of the `key` field for all of your data, you could configure `dataIdFromObject` like so:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => object.key\n});\n```\n\nThis also allows you to use different unique identifiers for different data types by keying off of the `__typename` property attached to every object typed by GraphQL.  For example:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => {\n    switch (object.__typename) {\n      case 'foo': return object.key; // use `key` as the primary key\n      case 'bar': return object.blah; // use `blah` as the priamry key\n      default: return object.id || object._id; // fall back to `id` and `_id` for all other types\n    }\n  }\n});\n```\n\n<h2 id=\"direct\">Direct Cache Access</h2>\n\nTo interact directly with your cache, you can use the Apollo Client class methods readQuery, readFragment, writeQuery, and writeFragment. These methods are available to us via the [`DataProxy` interface](https://github.com/apollographql/apollo-client/blob/master/packages/apollo-cache/src/types/DataProxy.ts). Accessing these methods will vary slightly based on your view layer implementation. If you are using React, you can wrap your component in the `withApollo` higher order component, which will give you access to `this.props.client`. From there, you can use the methods to control your data.\n\nAny code demonstration in the following sections will assume that we have already initialized an instance of  `ApolloClient` and that we have imported the `gql` tag from `graphql-tag`.\n\n<h3 id=\"readquery\">readQuery</h3>\n\nThe `readQuery` method is very similar to the [`query` method on `ApolloClient`][] except that `readQuery` will _never_ make a request to your GraphQL server. The `query` method, on the other hand, may send a request to your server if the appropriate data is not in your cache whereas `readQuery` will throw an error if the data is not in your cache. `readQuery` will _always_ read from the cache. You can use `readQuery` by giving it a GraphQL query like so:\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo {\n      todo(id: 5) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n});\n```\n\nIf all of the data needed to fulfill this read is in Apollo Client’s normalized data cache then a data object will be returned in the shape of the query you wanted to read. If not all of the data needed to fulfill this read is in Apollo Client’s cache then an error will be thrown instead, so make sure to only read data that you know you have!\n\nYou can also pass variables into `readQuery`.\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo($id: Int!) {\n      todo(id: $id) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n  variables: {\n    id: 5,\n  },\n});\n```\n\n<h3 id=\"readfragment\">readFragment</h3>\n\nThis method allows you great flexibility around the data in your cache. Whereas `readQuery` only allowed you to read data from your root query type, `readFragment` allows you to read data from _any node you have queried_. This is incredibly powerful. You use this method as follows:\n\n```js\nconst todo = client.readFragment({\n  id: ..., // `id` is any id that could be returned by `dataIdFromObject`.\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\nThe first argument is the id of the data you want to read from the cache. That id must be a value that was returned by the `dataIdFromObject` function you defined when initializing `ApolloClient`. So for example if you initialized `ApolloClient` like so:\n\n```js\nconst client = new ApolloClient({\n  ...,\n  dataIdFromObject: object => object.id,\n});\n```\n\n…and you requested a todo before with an id of `5`, then you can read that todo out of your cache with the following:\n\n```js\nconst todo = client.readFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\n> **Note:** Most people add a `__typename` to the id in `dataIdFromObject`. If you do this then don’t forget to add the `__typename` when you are reading a fragment as well. So for example your id may be `Todo_5` and not just `5`.\n\nIf a todo with that id does not exist in the cache you will get `null` back. If a todo of that id does exist in the cache, but that todo does not have the `text` field then an error will be thrown.\n\nThe beauty of `readFragment` is that the todo could have come from anywhere! The todo could have been selected as a singleton (`{ todo(id: 5) { ... } }`), the todo could have come from a list of todos (`{ todos { ... } }`), or the todo could have come from a mutation (`mutation { createTodo { ... } }`). As long as at some point your GraphQL server gave you a todo with the provided id and fields `id`, `text`, and `completed` you can read it from the cache at any part of your code.\n\n<h3 id=\"writequery-and-writefragment\">writeQuery` and `writeFragment</h3>\n\nNot only can you read arbitrary data from the Apollo Client cache, but you can also write any data that you would like to the cache. The methods you use to do this are `writeQuery` and `writeFragment`. They will allow you to change data in your local cache, but it is important to remember that *they will not change any data on your server*. If you reload your environment then changes made with `writeQuery` and `writeFragment` will disappear.\n\nThese methods have the same signature as their `readQuery` and `readFragment` counterparts except they also require an additional `data` variable. So for example, if you wanted to update the `completed` flag locally for your todo with id `'5'` you could execute the following:\n\n```js\nclient.writeFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      completed\n    }\n  `,\n  data: {\n    completed: true,\n  },\n});\n```\n\nAny subscriber to the Apollo Client store will instantly see this update and render new UI accordingly.\n\n> **Note:** Again, remember that using `writeQuery` or `writeFragment` only changes data *locally*. If you reload your environment then changes made with these methods will no longer exist.\n\nOr if you wanted to add a new todo to a list fetched from the server, you could use `readQuery` and `writeQuery` together.\n\n```js\nconst query = gql`\n  query MyTodoAppQuery {\n    todos {\n      id\n      text\n      completed\n    }\n  }\n`;\n\nconst data = client.readQuery({ query });\n\nconst myNewTodo = {\n  id: '6',\n  text: 'Start using Apollo Client.',\n  completed: false,\n};\n\nclient.writeQuery({\n  query,\n  data: {\n    todos: [...data.todos, myNewTodo],\n  },\n});\n```\n\n<h2 id=\"recipes\">Recipes</h2>\n\nHere are some common situations where you would need to access the cache directly. If you're manipulating the cache in an interesting way and would like your example to be featured, please send in a pull request!\n\n<h3 id=\"server\">Server side rendering</h3>\n\nFirst, you will need to initialize an `InMemoryCache` on the server and create an instance of `ApolloClient`. In the initial serialized HTML payload from the server, you should include a script tag that extracts the data from the cache.\n\n```js\n`<script>\n  window.__APOLLO_STATE__=${JSON.stringify(cache.extract())}\n</script>`\n```\n\nOn the client, you can rehydrate the cache using the initial data passed from the server:\n\n```js\ncache: new Cache().restore(window.__APOLLO_STATE__)\n```\n\nIf you would like to learn more about server side rendering, please check our our more in depth guide [here].\n<!---\nTODO (PEGGY): Add link to SSR\n-->\n\n<h3 id=\"server\">Updating the cache after a mutation</h3>\n\nBeing able to read and write to the Apollo cache from anywhere in your application gives you a lot of power over your data. However, there is one place where we most often want to update our cached data: after a mutation. As such, Apollo Client has optimized the experience for updating your cache with the read and write methods after a mutation with the `update` function. Let us say that we have the following GraphQL mutation:\n\n```graphql\nmutation TodoCreateMutation($text: String!) {\n  createTodo(text: $text) {\n    id\n    text\n    completed\n  }\n}\n```\n\nWe may also have the following GraphQL query:\n\n```graphql\nquery TodoAppQuery {\n  todos {\n    id\n    text\n    completed\n  }\n}\n```\n\nAt the end of our mutation we want our query to include the new todo like we had sent our `TodoAppQuery` a second time after the mutation finished without actually sending the query. To do this we can use the `update` function provided as an option of the `client.mutate` method. To update your cache with the mutation just write code that looks like:\n\n```js\n// We assume that the GraphQL operations `TodoCreateMutation` and\n// `TodoAppQuery` have already been defined using the `gql` tag.\n\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    // Read the data from our cache for this query.\n    const data = proxy.readQuery({ query: TodoAppQuery });\n\n    // Add our todo from the mutation to the end.\n    data.todos.push(createTodo);\n\n    // Write our data back to the cache.\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nThe first `proxy` argument is an instance of [`DataProxy`][] has the same four methods that we just learned exist on the Apollo Client: `readQuery`, `readFragment`, `writeQuery`, and `writeFragment`. The reason we call them on a `proxy` object here instead of on our `client` instance is that we can easily apply optimistic updates (which we will demonstrate in a bit). The `proxy` object also provides an isolated transaction which shields you from any other mutations going on at the same time, and the `proxy` object also batches writes together until the very end.\n\nIf you provide an `optimisticResponse` option to the mutation then the `update` function will be run twice. Once immediately after you call `client.mutate` with the data from `optimisticResponse`. After the mutation successfully executes against the server the changes made in the first call to `update` will be rolled back and `update` will be called with the *actual* data returned by the mutation and not just the optimistic response.\n\nPutting it all together:\n\n```js\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  optimisticResponse: {\n    id: -1, // -1 is a temporary id for the optimistic response.\n    text,\n    completed: false,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    const data = proxy.readQuery({ query: TodoAppQuery });\n    data.todos.push(createTodo);\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nAs you can see the `update` function on `client.mutate` provides extra change management functionality specific to the use case of a mutation while still providing you the powerful data control APIs that are available on `client`.\n\nThe `update` function is not a good place for side-effects as it may be called multiple times. Also, you may not call any of the methods on `proxy` asynchronously.\n\n",
      "readmeFilename": "README.md",
      "_id": "apollo-cache-inmemory@1.3.12-beta.1",
      "_npmVersion": "6.5.0",
      "_nodeVersion": "8.14.1",
      "_npmUser": {
        "name": "benjamn",
        "email": "ben@benjamn.com"
      },
      "dist": {
        "integrity": "sha512-7PISimltNjbsoQmInTkD8yW0yT6aC4EZSOhFra61FZQU7vDMUfLFEtF8xzRCddvgUjVTLuNXDgNkU0VovSXc4w==",
        "shasum": "609d93c33fa2729f367c36cdf9d3bd5683b4ea45",
        "tarball": "https://registry.npmjs.org/apollo-cache-inmemory/-/apollo-cache-inmemory-1.3.12-beta.1.tgz",
        "fileCount": 61,
        "unpackedSize": 315131,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJcGpPOCRA9TVsSAnZWagAAc4sQAJga5Sjxe+gRPhfdgnsg\nkNLQmKmCz0X2hLyPvu8322Pbw/NBqgxPSJcU7436oK5vei3tsOlBPkEZTahT\nH+kINvSzRzeYk1nT8oD1Jev4EB5KEczh51eKQXnYq/e+FN8G0Tzk9x/jPuK8\n/ggJewreVh9MnMYclznUvbLrtb4/6H60ILqv13XLL7cu3R1NLWNdP9qjgNSB\nru5Rd66CpyDnEBBvazhW9NqrYjiaw711POrJ6/6jcbL+gOC4aZxWSYmqauKe\n+0fLzdi4yTAfSUeuOWSZWHZ0jw80sXLzefxYYAXDjKeOkI+oHTe8e6rh5ejo\nxay+9gdRjk1dYwysQJCrmI0HxIg+Q4S6Lw+sANdn1Au4gR+ekQ705cJEnaL5\nD1ozz7umXfZNSTTgTHjz14Es9ZSxlvQX6rxpxJooB6+km4rcURZ9E3cGMEqD\nhfYKwvSnglivVc1ptRbmAtn22YKRZfijgLuJTK3aaY2+GskqNw350n3KwUgb\nSkkUgK7EIq1N4JSpwrZv4X2cptLAasrY8YVFARfAyaug8c95P2pSuaNuE9MR\nmlNhyo62rUBSUyzQoKvj7PXfkEXQJ+UfLFexbG5ebbrFXUiWieWnPyPJFdRg\neprtw1/i/owsYf7mWSW/VTWgi4scTkuJw9LZrvighQda4Kjnr4m6qjP2qKYf\nv8hU\r\n=3XMF\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIHSN0rMH+Sxd4V6ezgMFQK9Ht14VtbWBddV8FOk+UUePAiEAzBFhLnRdY2jXDjfYhNC1eYZr64PMAnybh30cXTm/Vcc="
          }
        ]
      },
      "maintainers": [
        {
          "email": "npm@apollographql.com",
          "name": "apollo-bot"
        },
        {
          "email": "ben@benjamn.com",
          "name": "benjamn"
        },
        {
          "email": "james@meteor.com",
          "name": "jbaxleyiii"
        },
        {
          "email": "peggyrayzis@gmail.com",
          "name": "peggyrayzis"
        }
      ],
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/apollo-cache-inmemory_1.3.12-beta.1_1545245645388_0.27343663563757925"
      },
      "_hasShrinkwrap": false
    },
    "1.3.12": {
      "name": "apollo-cache-inmemory",
      "version": "1.3.12",
      "description": "Core abstract of Caching layer for Apollo Client",
      "author": {
        "name": "James Baxley",
        "email": "james@meteor.com"
      },
      "contributors": [
        {
          "name": "James Baxley",
          "email": "james@meteor.com"
        },
        {
          "name": "Jonas Helfer",
          "email": "jonas@helfer.email"
        },
        {
          "name": "Sashko Stubailo",
          "email": "sashko@stubailo.com"
        },
        {
          "name": "James Burgess",
          "email": "jamesmillerburgess@gmail.com"
        },
        {
          "name": "Bazyli Brzóska",
          "email": "bazyli.brzoska@gmail.com"
        }
      ],
      "license": "MIT",
      "main": "./lib/bundle.umd.js",
      "module": "./lib/index.js",
      "jsnext:main": "./lib/index.js",
      "typings": "./lib/index.d.ts",
      "sideEffects": [
        "./lib/fixPolyfills.js"
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/apollographql/apollo-client.git"
      },
      "bugs": {
        "url": "https://github.com/apollographql/apollo-client/issues"
      },
      "homepage": "https://github.com/apollographql/apollo-client#readme",
      "scripts": {
        "prepare": "npm run build",
        "coverage": "jest --coverage",
        "test": "jest",
        "lint": "tslint -c \"../../config/tslint.json\" -p tsconfig.json src/*.ts",
        "prebuild": "npm run clean",
        "build": "tsc -p .",
        "postbuild": "npm run bundle",
        "bundle": "../../node_modules/rollup/bin/rollup -c rollup.config.js",
        "watch": "tsc -w -p .",
        "clean": "rm -rf coverage/* && rm -rf lib/*",
        "prepublishOnly": "npm run build",
        "minify": "../../node_modules/uglify-js/bin/uglifyjs -c -m -o ./lib/bundle.min.js -- ./lib/bundle.umd.js",
        "filesize": "npm run minify"
      },
      "dependencies": {
        "apollo-cache": "^1.1.22",
        "apollo-utilities": "^1.0.27",
        "optimism": "^0.6.8"
      },
      "peerDependencies": {
        "graphql": "0.11.7 || ^0.12.0 || ^0.13.0 || ^14.0.0"
      },
      "jest": {
        "transform": {
          ".(ts|tsx)": "ts-jest"
        },
        "testRegex": "(/__tests__/.*|\\.(test|spec))\\.(ts|tsx|js)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "json"
        ],
        "testURL": "http://localhost"
      },
      "gitHead": "4c78a05160c4b0f236eeae99ed7ea4d27c8332e4",
      "_resolved": "",
      "_integrity": "",
      "_from": "file:apollo-cache-inmemory-1.3.12.tgz",
      "_id": "apollo-cache-inmemory@1.3.12",
      "_npmVersion": "6.5.0",
      "_nodeVersion": "8.14.1",
      "_npmUser": {
        "name": "benjamn",
        "email": "ben@benjamn.com"
      },
      "dist": {
        "integrity": "sha512-jxWcW64QoYQZ09UH6v3syvCCl3MWr6bsxT3wYYL6ORi8svdJUpnNrHTcv5qXqJYVg/a+NHhfEt+eGjJUG2ytXA==",
        "shasum": "cf7ef7c15730d0b6787d79047d5c06087ac31991",
        "tarball": "https://registry.npmjs.org/apollo-cache-inmemory/-/apollo-cache-inmemory-1.3.12.tgz",
        "fileCount": 62,
        "unpackedSize": 316279,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJcGp4nCRA9TVsSAnZWagAAtwkP/jOUe614Bt2XYCFZ880A\nMMYnIy9mWpGv51bZHKE4Qj6bri86UvN9fT0Twek8jgUf0SmNOguRKRfjDfxL\nreXYEPwIiegBYMVLidw6Xir/7xYVfz3eLNZrP2ceK6MPdPeJCZrdI1Gps3mU\ncrU7xhw98zpdr0SSTMdlXHGNTE97zXERKtlIagL4ViRiCU1rzTWOrsE2uNfr\nuNtC4SM5aWGNN7H8VujSyQuwJWvFjMR+4SxJsTHv/QDAI52lGZVNLsgVS1vx\nOFfprimGMxfMYzkQfwy/YrVwo3sqqbqC896OqUgS67I9F8KZSPK6fQ9epob1\nE2i9Ywil7Vuar2oEZhhMxDleNByj4KRyH1CbD9QIUASQxgBU0YyDlnYU5T6y\nwkCUexGoYcRdEebZhY6Tpb+t/FHJIlYlZ0Xm2yTR13j1ORuxfZzkrwAVFsFx\nM9Nf4j3xj7GeZb3VpfLdFpNSCq74DLB86nAtx2beCFiOw2kYKbUJ73Hlzbm0\nQIWIJ1ywLtwFJaYBCJ9uhSmYHHm6PmYkZJNKJf7cHeW0Ecr4A/JYnDmmTH2d\nvkmgpubfcWKF7iULWlaidEOPONHFAYRWPQre4rawWFrMKCyJeOpY/ISog9zg\nLBGylWKtv45fcDjL682VbnNw1bZcUOhQ5BuZnjjxCshBCZHR9TUyaNsMfcs6\n+XXR\r\n=rDrD\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIQDiGJFSKOGbZqEie1wgnIj0w5PL2fA3ybPfqFROQh9lVAIgDFwT0MnZQBjsxDydpDI6h3t51SdqnEP9tilgaaUGySk="
          }
        ]
      },
      "maintainers": [
        {
          "email": "npm@apollographql.com",
          "name": "apollo-bot"
        },
        {
          "email": "ben@benjamn.com",
          "name": "benjamn"
        },
        {
          "email": "james@meteor.com",
          "name": "jbaxleyiii"
        },
        {
          "email": "peggyrayzis@gmail.com",
          "name": "peggyrayzis"
        }
      ],
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/apollo-cache-inmemory_1.3.12_1545248294648_0.310346556955964"
      },
      "_hasShrinkwrap": false
    },
    "1.4.0-alpha.3": {
      "name": "apollo-cache-inmemory",
      "version": "1.4.0-alpha.3",
      "description": "Core abstract of Caching layer for Apollo Client",
      "author": {
        "name": "James Baxley",
        "email": "james@meteor.com"
      },
      "contributors": [
        {
          "name": "James Baxley",
          "email": "james@meteor.com"
        },
        {
          "name": "Jonas Helfer",
          "email": "jonas@helfer.email"
        },
        {
          "name": "Sashko Stubailo",
          "email": "sashko@stubailo.com"
        },
        {
          "name": "James Burgess",
          "email": "jamesmillerburgess@gmail.com"
        },
        {
          "name": "Bazyli Brzóska",
          "email": "bazyli.brzoska@gmail.com"
        }
      ],
      "license": "MIT",
      "main": "./lib/bundle.umd.js",
      "module": "./lib/index.js",
      "jsnext:main": "./lib/index.js",
      "typings": "./lib/index.d.ts",
      "sideEffects": [
        "./lib/fixPolyfills.js"
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/apollographql/apollo-client.git"
      },
      "bugs": {
        "url": "https://github.com/apollographql/apollo-client/issues"
      },
      "homepage": "https://github.com/apollographql/apollo-client#readme",
      "scripts": {
        "prepare": "npm run build",
        "coverage": "jest --coverage",
        "test": "jest",
        "lint": "tslint -c \"../../config/tslint.json\" -p tsconfig.json src/*.ts",
        "prebuild": "npm run clean",
        "build": "tsc -p .",
        "postbuild": "npm run bundle",
        "bundle": "../../node_modules/rollup/bin/rollup -c rollup.config.js",
        "watch": "tsc -w -p .",
        "clean": "rm -rf coverage/* && rm -rf lib/*",
        "prepublishOnly": "npm run build",
        "minify": "../../node_modules/uglify-js/bin/uglifyjs -c -m -o ./lib/bundle.min.js -- ./lib/bundle.umd.js",
        "filesize": "npm run minify"
      },
      "dependencies": {
        "apollo-cache": "^1.2.0-alpha.3",
        "apollo-utilities": "^1.1.0-alpha.3",
        "optimism": "^0.6.8"
      },
      "peerDependencies": {
        "graphql": "0.11.7 || ^0.12.0 || ^0.13.0 || ^14.0.0"
      },
      "jest": {
        "transform": {
          ".(ts|tsx)": "ts-jest"
        },
        "testRegex": "(/__tests__/.*|\\.(test|spec))\\.(ts|tsx|js)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "json"
        ],
        "testURL": "http://localhost"
      },
      "gitHead": "44927d0674e8b06486aa76f325e9e5e6cd2c4887",
      "readme": "---\ntitle: InMemoryCache\ndescription: An explanation of `apollo-cache-inmemory`\n---\n\n`apollo-cache-inmemory` is the recommended cache implementation for Apollo Client 2.0. `InMemoryCache` is a normalized data store that supports all of Apollo Client 1.0's features without the dependency on Redux.\n\nIn some instances, you may need to manipulate the cache directly, such as updating the store after a mutation. We'll cover some common use cases [here](#recipes).\n\n<h2 id=\"installation\">Installation</h2>\n\n```\nnpm install apollo-cache-inmemory --save\n```\n\nAfter installing the package, you'll want to initialize the cache constructor. Then, you can pass in your newly created cache to ApolloClient.\n\n```js\nimport { InMemoryCache } from 'apollo-cache-inmemory';\nimport { HttpLink } from 'apollo-link-http';\nimport ApolloClient from 'apollo-client';\n\nconst cache = new InMemoryCache();\n\nconst client = new ApolloClient({\n  link: new HttpLink(),\n  cache\n});\n```\n\n<h2 id=\"configuration\">Configuration</h2>\n\nThe `InMemoryCache` constructor takes an optional config object with properties to customize your cache:\n\n- addTypename: A boolean to determine whether to add __typename to the document (default: `true`)\n- dataIdFromObject: A function that takes a data object and returns a unique identifier to be used when normalizing the data in the store. Learn more about how to customize `dataIdFromObject` in the [Normalization](#normalization) section.\n- fragmentMatcher: By default, the `InMemoryCache` uses a heuristic fragment matcher. If you are using fragments on unions and interfaces, you will need to use an `IntrospectionFragmentMatcher`. For more information, please read [our guide to setting up fragment matching for unions & interfaces](https://www.apollographql.com/docs/react/advanced/fragments.html#fragment-matcher).\n\n<h2 id=\"normalization\">Normalization</h2>\n\nThe `InMemoryCache` normalizes your data before saving it to the store by splitting the result into individual objects, creating a unique identifier for each object, and storing those objects in a flattened data structure. By default, `InMemoryCache` will attempt to use the commonly found primary keys of `id` and `_id` for the unique identifier if they exist along with `__typename` on an object.\n\nIf `id` and `_id` are not specified, or if `__typename` is not specified, `InMemoryCache` will fall back to the path to the object in the query, such as `ROOT_QUERY.allPeople.0` for the first record returned on the `allPeople` root query.\n\nThis \"getter\" behavior for unique identifiers can be configured manually via the `dataIdFromObject` option passed to the `InMemoryCache` constructor, so you can pick which field is used if some of your data follows unorthodox primary key conventions.\n\nFor example, if you wanted to key off of the `key` field for all of your data, you could configure `dataIdFromObject` like so:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => object.key\n});\n```\n\nThis also allows you to use different unique identifiers for different data types by keying off of the `__typename` property attached to every object typed by GraphQL.  For example:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => {\n    switch (object.__typename) {\n      case 'foo': return object.key; // use `key` as the primary key\n      case 'bar': return object.blah; // use `blah` as the priamry key\n      default: return object.id || object._id; // fall back to `id` and `_id` for all other types\n    }\n  }\n});\n```\n\n<h2 id=\"direct\">Direct Cache Access</h2>\n\nTo interact directly with your cache, you can use the Apollo Client class methods readQuery, readFragment, writeQuery, and writeFragment. These methods are available to us via the [`DataProxy` interface](https://github.com/apollographql/apollo-client/blob/master/packages/apollo-cache/src/types/DataProxy.ts). Accessing these methods will vary slightly based on your view layer implementation. If you are using React, you can wrap your component in the `withApollo` higher order component, which will give you access to `this.props.client`. From there, you can use the methods to control your data.\n\nAny code demonstration in the following sections will assume that we have already initialized an instance of  `ApolloClient` and that we have imported the `gql` tag from `graphql-tag`.\n\n<h3 id=\"readquery\">readQuery</h3>\n\nThe `readQuery` method is very similar to the [`query` method on `ApolloClient`][] except that `readQuery` will _never_ make a request to your GraphQL server. The `query` method, on the other hand, may send a request to your server if the appropriate data is not in your cache whereas `readQuery` will throw an error if the data is not in your cache. `readQuery` will _always_ read from the cache. You can use `readQuery` by giving it a GraphQL query like so:\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo {\n      todo(id: 5) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n});\n```\n\nIf all of the data needed to fulfill this read is in Apollo Client’s normalized data cache then a data object will be returned in the shape of the query you wanted to read. If not all of the data needed to fulfill this read is in Apollo Client’s cache then an error will be thrown instead, so make sure to only read data that you know you have!\n\nYou can also pass variables into `readQuery`.\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo($id: Int!) {\n      todo(id: $id) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n  variables: {\n    id: 5,\n  },\n});\n```\n\n<h3 id=\"readfragment\">readFragment</h3>\n\nThis method allows you great flexibility around the data in your cache. Whereas `readQuery` only allowed you to read data from your root query type, `readFragment` allows you to read data from _any node you have queried_. This is incredibly powerful. You use this method as follows:\n\n```js\nconst todo = client.readFragment({\n  id: ..., // `id` is any id that could be returned by `dataIdFromObject`.\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\nThe first argument is the id of the data you want to read from the cache. That id must be a value that was returned by the `dataIdFromObject` function you defined when initializing `ApolloClient`. So for example if you initialized `ApolloClient` like so:\n\n```js\nconst client = new ApolloClient({\n  ...,\n  dataIdFromObject: object => object.id,\n});\n```\n\n…and you requested a todo before with an id of `5`, then you can read that todo out of your cache with the following:\n\n```js\nconst todo = client.readFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\n> **Note:** Most people add a `__typename` to the id in `dataIdFromObject`. If you do this then don’t forget to add the `__typename` when you are reading a fragment as well. So for example your id may be `Todo_5` and not just `5`.\n\nIf a todo with that id does not exist in the cache you will get `null` back. If a todo of that id does exist in the cache, but that todo does not have the `text` field then an error will be thrown.\n\nThe beauty of `readFragment` is that the todo could have come from anywhere! The todo could have been selected as a singleton (`{ todo(id: 5) { ... } }`), the todo could have come from a list of todos (`{ todos { ... } }`), or the todo could have come from a mutation (`mutation { createTodo { ... } }`). As long as at some point your GraphQL server gave you a todo with the provided id and fields `id`, `text`, and `completed` you can read it from the cache at any part of your code.\n\n<h3 id=\"writequery-and-writefragment\">writeQuery` and `writeFragment</h3>\n\nNot only can you read arbitrary data from the Apollo Client cache, but you can also write any data that you would like to the cache. The methods you use to do this are `writeQuery` and `writeFragment`. They will allow you to change data in your local cache, but it is important to remember that *they will not change any data on your server*. If you reload your environment then changes made with `writeQuery` and `writeFragment` will disappear.\n\nThese methods have the same signature as their `readQuery` and `readFragment` counterparts except they also require an additional `data` variable. So for example, if you wanted to update the `completed` flag locally for your todo with id `'5'` you could execute the following:\n\n```js\nclient.writeFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      completed\n    }\n  `,\n  data: {\n    completed: true,\n  },\n});\n```\n\nAny subscriber to the Apollo Client store will instantly see this update and render new UI accordingly.\n\n> **Note:** Again, remember that using `writeQuery` or `writeFragment` only changes data *locally*. If you reload your environment then changes made with these methods will no longer exist.\n\nOr if you wanted to add a new todo to a list fetched from the server, you could use `readQuery` and `writeQuery` together.\n\n```js\nconst query = gql`\n  query MyTodoAppQuery {\n    todos {\n      id\n      text\n      completed\n    }\n  }\n`;\n\nconst data = client.readQuery({ query });\n\nconst myNewTodo = {\n  id: '6',\n  text: 'Start using Apollo Client.',\n  completed: false,\n};\n\nclient.writeQuery({\n  query,\n  data: {\n    todos: [...data.todos, myNewTodo],\n  },\n});\n```\n\n<h2 id=\"recipes\">Recipes</h2>\n\nHere are some common situations where you would need to access the cache directly. If you're manipulating the cache in an interesting way and would like your example to be featured, please send in a pull request!\n\n<h3 id=\"server\">Server side rendering</h3>\n\nFirst, you will need to initialize an `InMemoryCache` on the server and create an instance of `ApolloClient`. In the initial serialized HTML payload from the server, you should include a script tag that extracts the data from the cache.\n\n```js\n`<script>\n  window.__APOLLO_STATE__=${JSON.stringify(cache.extract())}\n</script>`\n```\n\nOn the client, you can rehydrate the cache using the initial data passed from the server:\n\n```js\ncache: new Cache().restore(window.__APOLLO_STATE__)\n```\n\nIf you would like to learn more about server side rendering, please check our our more in depth guide [here].\n<!---\nTODO (PEGGY): Add link to SSR\n-->\n\n<h3 id=\"server\">Updating the cache after a mutation</h3>\n\nBeing able to read and write to the Apollo cache from anywhere in your application gives you a lot of power over your data. However, there is one place where we most often want to update our cached data: after a mutation. As such, Apollo Client has optimized the experience for updating your cache with the read and write methods after a mutation with the `update` function. Let us say that we have the following GraphQL mutation:\n\n```graphql\nmutation TodoCreateMutation($text: String!) {\n  createTodo(text: $text) {\n    id\n    text\n    completed\n  }\n}\n```\n\nWe may also have the following GraphQL query:\n\n```graphql\nquery TodoAppQuery {\n  todos {\n    id\n    text\n    completed\n  }\n}\n```\n\nAt the end of our mutation we want our query to include the new todo like we had sent our `TodoAppQuery` a second time after the mutation finished without actually sending the query. To do this we can use the `update` function provided as an option of the `client.mutate` method. To update your cache with the mutation just write code that looks like:\n\n```js\n// We assume that the GraphQL operations `TodoCreateMutation` and\n// `TodoAppQuery` have already been defined using the `gql` tag.\n\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    // Read the data from our cache for this query.\n    const data = proxy.readQuery({ query: TodoAppQuery });\n\n    // Add our todo from the mutation to the end.\n    data.todos.push(createTodo);\n\n    // Write our data back to the cache.\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nThe first `proxy` argument is an instance of [`DataProxy`][] has the same four methods that we just learned exist on the Apollo Client: `readQuery`, `readFragment`, `writeQuery`, and `writeFragment`. The reason we call them on a `proxy` object here instead of on our `client` instance is that we can easily apply optimistic updates (which we will demonstrate in a bit). The `proxy` object also provides an isolated transaction which shields you from any other mutations going on at the same time, and the `proxy` object also batches writes together until the very end.\n\nIf you provide an `optimisticResponse` option to the mutation then the `update` function will be run twice. Once immediately after you call `client.mutate` with the data from `optimisticResponse`. After the mutation successfully executes against the server the changes made in the first call to `update` will be rolled back and `update` will be called with the *actual* data returned by the mutation and not just the optimistic response.\n\nPutting it all together:\n\n```js\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  optimisticResponse: {\n    id: -1, // -1 is a temporary id for the optimistic response.\n    text,\n    completed: false,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    const data = proxy.readQuery({ query: TodoAppQuery });\n    data.todos.push(createTodo);\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nAs you can see the `update` function on `client.mutate` provides extra change management functionality specific to the use case of a mutation while still providing you the powerful data control APIs that are available on `client`.\n\nThe `update` function is not a good place for side-effects as it may be called multiple times. Also, you may not call any of the methods on `proxy` asynchronously.\n\n",
      "readmeFilename": "README.md",
      "_id": "apollo-cache-inmemory@1.4.0-alpha.3",
      "_nodeVersion": "8.12.0",
      "_npmVersion": "lerna/3.8.1/node@v8.12.0+x64 (darwin)",
      "dist": {
        "integrity": "sha512-EExDRVK18c1nU06F2a1dKZaEtNlhG8qcp89Cz0oWuRzGsbCz3hfl8doq4YQYTDvAXPyVb8zDSDVpi2NblKyL3g==",
        "shasum": "122ac7535dec742c5532a4d701026bc2af11cd42",
        "tarball": "https://registry.npmjs.org/apollo-cache-inmemory/-/apollo-cache-inmemory-1.4.0-alpha.3.tgz",
        "fileCount": 62,
        "unpackedSize": 318522,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJcO+O8CRA9TVsSAnZWagAAJ0EP/iahyW+BKYULAKT70pMl\nyiM9jpZ+/xo3oIeJWDYYKVSJhPZ2qL3ihY70vVYJp7Iu6LRP7UdEqIXzDdnJ\n+nkRDKasjMEnT2zUQFedPOW7vFlZXCYk0FviZ5WZliVNXsZ+A9+FCD6syxy5\nG/uYZPy6JsdLUDQy2ssFOXWfMXK6DdKNb8mXwpMI6TGk93UzPD3nYPY62fr2\noM2ytDyCXNlNA4dF9W3+hgE0DoVsSw7A7i/NXeGBxOvCNTTY7dLkd5bZPB7u\nixDytOHvN0+XybkBI0vbIYPUUiDWS4q5jepxp010gXFvUh4wVK33BdvdtScA\nmNrw+qR791NeOgdVM0xUlrpMvAzsx4RN8dYjAU+ugs8lLUimQBgocY0B90k7\nRW09NJARXvDkCOkI4KBC2QusWgHGUcx48tIFp9d7CbbpiG6sf2z53E0GzZOu\nZXuRNBl+yxuk7VfhYqQkk0Sr0phMRGmbS6mSqyeac1UU1LVT2OuA5NJM8kXl\nWLkPl1BVqy1zNygsSzXLW/XIwDSxfe3zPaRialVBMr9KoRHPg6PtIMEbHPsE\nml96VYckjFXlsNjzXSTKkHofaKxBma3TTwQ2e4DiecaPev2W9oPr5Q4EZai2\nH+CfxobMwRsgAsIy/T7MXAIcxbFGKYquhKlUmyTrjCMz+1UbmSa3PUYD13M3\nLITx\r\n=0KhX\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIG0bSwPrSbJZplv4WCbnrDzqwKFH1tf22fPe9wB1Aix0AiEAgUUDSYgZ5PJO5ODpTxIzGepOaOebA0xpsepjL+sDLDw="
          }
        ]
      },
      "maintainers": [
        {
          "email": "npm@apollographql.com",
          "name": "apollo-bot"
        },
        {
          "email": "ben@benjamn.com",
          "name": "benjamn"
        },
        {
          "email": "james@meteor.com",
          "name": "jbaxleyiii"
        },
        {
          "email": "peggyrayzis@gmail.com",
          "name": "peggyrayzis"
        }
      ],
      "_npmUser": {
        "name": "apollo-bot",
        "email": "npm@apollographql.com"
      },
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/apollo-cache-inmemory_1.4.0-alpha.3_1547428795957_0.3239179655376505"
      },
      "_hasShrinkwrap": false
    },
    "1.4.0-alpha.4": {
      "name": "apollo-cache-inmemory",
      "version": "1.4.0-alpha.4",
      "description": "Core abstract of Caching layer for Apollo Client",
      "author": {
        "name": "James Baxley",
        "email": "james@meteor.com"
      },
      "contributors": [
        {
          "name": "James Baxley",
          "email": "james@meteor.com"
        },
        {
          "name": "Jonas Helfer",
          "email": "jonas@helfer.email"
        },
        {
          "name": "Sashko Stubailo",
          "email": "sashko@stubailo.com"
        },
        {
          "name": "James Burgess",
          "email": "jamesmillerburgess@gmail.com"
        },
        {
          "name": "Bazyli Brzóska",
          "email": "bazyli.brzoska@gmail.com"
        }
      ],
      "license": "MIT",
      "main": "./lib/bundle.umd.js",
      "module": "./lib/index.js",
      "jsnext:main": "./lib/index.js",
      "typings": "./lib/index.d.ts",
      "sideEffects": [
        "./lib/fixPolyfills.js"
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/apollographql/apollo-client.git"
      },
      "bugs": {
        "url": "https://github.com/apollographql/apollo-client/issues"
      },
      "homepage": "https://github.com/apollographql/apollo-client#readme",
      "scripts": {
        "prepare": "npm run build",
        "coverage": "jest --coverage",
        "test": "jest",
        "lint": "tslint -c \"../../config/tslint.json\" -p tsconfig.json src/*.ts",
        "prebuild": "npm run clean",
        "build": "tsc -p .",
        "postbuild": "npm run bundle",
        "bundle": "../../node_modules/rollup/bin/rollup -c rollup.config.js",
        "watch": "tsc -w -p .",
        "clean": "rm -rf coverage/* && rm -rf lib/*",
        "prepublishOnly": "npm run build",
        "minify": "../../node_modules/uglify-js/bin/uglifyjs -c -m -o ./lib/bundle.min.js -- ./lib/bundle.umd.js",
        "filesize": "npm run minify"
      },
      "dependencies": {
        "apollo-cache": "^1.2.0-alpha.4",
        "apollo-utilities": "^1.1.0-alpha.3",
        "optimism": "^0.6.8"
      },
      "peerDependencies": {
        "graphql": "0.11.7 || ^0.12.0 || ^0.13.0 || ^14.0.0"
      },
      "jest": {
        "transform": {
          ".(ts|tsx)": "ts-jest"
        },
        "testRegex": "(/__tests__/.*|\\.(test|spec))\\.(ts|tsx|js)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "json"
        ],
        "testURL": "http://localhost"
      },
      "gitHead": "6bf7f68d92e44cebf3578a4abf6fcdb83a9fb86f",
      "readme": "---\ntitle: InMemoryCache\ndescription: An explanation of `apollo-cache-inmemory`\n---\n\n`apollo-cache-inmemory` is the recommended cache implementation for Apollo Client 2.0. `InMemoryCache` is a normalized data store that supports all of Apollo Client 1.0's features without the dependency on Redux.\n\nIn some instances, you may need to manipulate the cache directly, such as updating the store after a mutation. We'll cover some common use cases [here](#recipes).\n\n<h2 id=\"installation\">Installation</h2>\n\n```\nnpm install apollo-cache-inmemory --save\n```\n\nAfter installing the package, you'll want to initialize the cache constructor. Then, you can pass in your newly created cache to ApolloClient.\n\n```js\nimport { InMemoryCache } from 'apollo-cache-inmemory';\nimport { HttpLink } from 'apollo-link-http';\nimport ApolloClient from 'apollo-client';\n\nconst cache = new InMemoryCache();\n\nconst client = new ApolloClient({\n  link: new HttpLink(),\n  cache\n});\n```\n\n<h2 id=\"configuration\">Configuration</h2>\n\nThe `InMemoryCache` constructor takes an optional config object with properties to customize your cache:\n\n- addTypename: A boolean to determine whether to add __typename to the document (default: `true`)\n- dataIdFromObject: A function that takes a data object and returns a unique identifier to be used when normalizing the data in the store. Learn more about how to customize `dataIdFromObject` in the [Normalization](#normalization) section.\n- fragmentMatcher: By default, the `InMemoryCache` uses a heuristic fragment matcher. If you are using fragments on unions and interfaces, you will need to use an `IntrospectionFragmentMatcher`. For more information, please read [our guide to setting up fragment matching for unions & interfaces](https://www.apollographql.com/docs/react/advanced/fragments.html#fragment-matcher).\n\n<h2 id=\"normalization\">Normalization</h2>\n\nThe `InMemoryCache` normalizes your data before saving it to the store by splitting the result into individual objects, creating a unique identifier for each object, and storing those objects in a flattened data structure. By default, `InMemoryCache` will attempt to use the commonly found primary keys of `id` and `_id` for the unique identifier if they exist along with `__typename` on an object.\n\nIf `id` and `_id` are not specified, or if `__typename` is not specified, `InMemoryCache` will fall back to the path to the object in the query, such as `ROOT_QUERY.allPeople.0` for the first record returned on the `allPeople` root query.\n\nThis \"getter\" behavior for unique identifiers can be configured manually via the `dataIdFromObject` option passed to the `InMemoryCache` constructor, so you can pick which field is used if some of your data follows unorthodox primary key conventions.\n\nFor example, if you wanted to key off of the `key` field for all of your data, you could configure `dataIdFromObject` like so:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => object.key\n});\n```\n\nThis also allows you to use different unique identifiers for different data types by keying off of the `__typename` property attached to every object typed by GraphQL.  For example:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => {\n    switch (object.__typename) {\n      case 'foo': return object.key; // use `key` as the primary key\n      case 'bar': return object.blah; // use `blah` as the priamry key\n      default: return object.id || object._id; // fall back to `id` and `_id` for all other types\n    }\n  }\n});\n```\n\n<h2 id=\"direct\">Direct Cache Access</h2>\n\nTo interact directly with your cache, you can use the Apollo Client class methods readQuery, readFragment, writeQuery, and writeFragment. These methods are available to us via the [`DataProxy` interface](https://github.com/apollographql/apollo-client/blob/master/packages/apollo-cache/src/types/DataProxy.ts). Accessing these methods will vary slightly based on your view layer implementation. If you are using React, you can wrap your component in the `withApollo` higher order component, which will give you access to `this.props.client`. From there, you can use the methods to control your data.\n\nAny code demonstration in the following sections will assume that we have already initialized an instance of  `ApolloClient` and that we have imported the `gql` tag from `graphql-tag`.\n\n<h3 id=\"readquery\">readQuery</h3>\n\nThe `readQuery` method is very similar to the [`query` method on `ApolloClient`][] except that `readQuery` will _never_ make a request to your GraphQL server. The `query` method, on the other hand, may send a request to your server if the appropriate data is not in your cache whereas `readQuery` will throw an error if the data is not in your cache. `readQuery` will _always_ read from the cache. You can use `readQuery` by giving it a GraphQL query like so:\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo {\n      todo(id: 5) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n});\n```\n\nIf all of the data needed to fulfill this read is in Apollo Client’s normalized data cache then a data object will be returned in the shape of the query you wanted to read. If not all of the data needed to fulfill this read is in Apollo Client’s cache then an error will be thrown instead, so make sure to only read data that you know you have!\n\nYou can also pass variables into `readQuery`.\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo($id: Int!) {\n      todo(id: $id) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n  variables: {\n    id: 5,\n  },\n});\n```\n\n<h3 id=\"readfragment\">readFragment</h3>\n\nThis method allows you great flexibility around the data in your cache. Whereas `readQuery` only allowed you to read data from your root query type, `readFragment` allows you to read data from _any node you have queried_. This is incredibly powerful. You use this method as follows:\n\n```js\nconst todo = client.readFragment({\n  id: ..., // `id` is any id that could be returned by `dataIdFromObject`.\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\nThe first argument is the id of the data you want to read from the cache. That id must be a value that was returned by the `dataIdFromObject` function you defined when initializing `ApolloClient`. So for example if you initialized `ApolloClient` like so:\n\n```js\nconst client = new ApolloClient({\n  ...,\n  dataIdFromObject: object => object.id,\n});\n```\n\n…and you requested a todo before with an id of `5`, then you can read that todo out of your cache with the following:\n\n```js\nconst todo = client.readFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\n> **Note:** Most people add a `__typename` to the id in `dataIdFromObject`. If you do this then don’t forget to add the `__typename` when you are reading a fragment as well. So for example your id may be `Todo_5` and not just `5`.\n\nIf a todo with that id does not exist in the cache you will get `null` back. If a todo of that id does exist in the cache, but that todo does not have the `text` field then an error will be thrown.\n\nThe beauty of `readFragment` is that the todo could have come from anywhere! The todo could have been selected as a singleton (`{ todo(id: 5) { ... } }`), the todo could have come from a list of todos (`{ todos { ... } }`), or the todo could have come from a mutation (`mutation { createTodo { ... } }`). As long as at some point your GraphQL server gave you a todo with the provided id and fields `id`, `text`, and `completed` you can read it from the cache at any part of your code.\n\n<h3 id=\"writequery-and-writefragment\">writeQuery` and `writeFragment</h3>\n\nNot only can you read arbitrary data from the Apollo Client cache, but you can also write any data that you would like to the cache. The methods you use to do this are `writeQuery` and `writeFragment`. They will allow you to change data in your local cache, but it is important to remember that *they will not change any data on your server*. If you reload your environment then changes made with `writeQuery` and `writeFragment` will disappear.\n\nThese methods have the same signature as their `readQuery` and `readFragment` counterparts except they also require an additional `data` variable. So for example, if you wanted to update the `completed` flag locally for your todo with id `'5'` you could execute the following:\n\n```js\nclient.writeFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      completed\n    }\n  `,\n  data: {\n    completed: true,\n  },\n});\n```\n\nAny subscriber to the Apollo Client store will instantly see this update and render new UI accordingly.\n\n> **Note:** Again, remember that using `writeQuery` or `writeFragment` only changes data *locally*. If you reload your environment then changes made with these methods will no longer exist.\n\nOr if you wanted to add a new todo to a list fetched from the server, you could use `readQuery` and `writeQuery` together.\n\n```js\nconst query = gql`\n  query MyTodoAppQuery {\n    todos {\n      id\n      text\n      completed\n    }\n  }\n`;\n\nconst data = client.readQuery({ query });\n\nconst myNewTodo = {\n  id: '6',\n  text: 'Start using Apollo Client.',\n  completed: false,\n};\n\nclient.writeQuery({\n  query,\n  data: {\n    todos: [...data.todos, myNewTodo],\n  },\n});\n```\n\n<h2 id=\"recipes\">Recipes</h2>\n\nHere are some common situations where you would need to access the cache directly. If you're manipulating the cache in an interesting way and would like your example to be featured, please send in a pull request!\n\n<h3 id=\"server\">Server side rendering</h3>\n\nFirst, you will need to initialize an `InMemoryCache` on the server and create an instance of `ApolloClient`. In the initial serialized HTML payload from the server, you should include a script tag that extracts the data from the cache.\n\n```js\n`<script>\n  window.__APOLLO_STATE__=${JSON.stringify(cache.extract())}\n</script>`\n```\n\nOn the client, you can rehydrate the cache using the initial data passed from the server:\n\n```js\ncache: new Cache().restore(window.__APOLLO_STATE__)\n```\n\nIf you would like to learn more about server side rendering, please check our our more in depth guide [here].\n<!---\nTODO (PEGGY): Add link to SSR\n-->\n\n<h3 id=\"server\">Updating the cache after a mutation</h3>\n\nBeing able to read and write to the Apollo cache from anywhere in your application gives you a lot of power over your data. However, there is one place where we most often want to update our cached data: after a mutation. As such, Apollo Client has optimized the experience for updating your cache with the read and write methods after a mutation with the `update` function. Let us say that we have the following GraphQL mutation:\n\n```graphql\nmutation TodoCreateMutation($text: String!) {\n  createTodo(text: $text) {\n    id\n    text\n    completed\n  }\n}\n```\n\nWe may also have the following GraphQL query:\n\n```graphql\nquery TodoAppQuery {\n  todos {\n    id\n    text\n    completed\n  }\n}\n```\n\nAt the end of our mutation we want our query to include the new todo like we had sent our `TodoAppQuery` a second time after the mutation finished without actually sending the query. To do this we can use the `update` function provided as an option of the `client.mutate` method. To update your cache with the mutation just write code that looks like:\n\n```js\n// We assume that the GraphQL operations `TodoCreateMutation` and\n// `TodoAppQuery` have already been defined using the `gql` tag.\n\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    // Read the data from our cache for this query.\n    const data = proxy.readQuery({ query: TodoAppQuery });\n\n    // Add our todo from the mutation to the end.\n    data.todos.push(createTodo);\n\n    // Write our data back to the cache.\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nThe first `proxy` argument is an instance of [`DataProxy`][] has the same four methods that we just learned exist on the Apollo Client: `readQuery`, `readFragment`, `writeQuery`, and `writeFragment`. The reason we call them on a `proxy` object here instead of on our `client` instance is that we can easily apply optimistic updates (which we will demonstrate in a bit). The `proxy` object also provides an isolated transaction which shields you from any other mutations going on at the same time, and the `proxy` object also batches writes together until the very end.\n\nIf you provide an `optimisticResponse` option to the mutation then the `update` function will be run twice. Once immediately after you call `client.mutate` with the data from `optimisticResponse`. After the mutation successfully executes against the server the changes made in the first call to `update` will be rolled back and `update` will be called with the *actual* data returned by the mutation and not just the optimistic response.\n\nPutting it all together:\n\n```js\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  optimisticResponse: {\n    id: -1, // -1 is a temporary id for the optimistic response.\n    text,\n    completed: false,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    const data = proxy.readQuery({ query: TodoAppQuery });\n    data.todos.push(createTodo);\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nAs you can see the `update` function on `client.mutate` provides extra change management functionality specific to the use case of a mutation while still providing you the powerful data control APIs that are available on `client`.\n\nThe `update` function is not a good place for side-effects as it may be called multiple times. Also, you may not call any of the methods on `proxy` asynchronously.\n\n",
      "readmeFilename": "README.md",
      "_id": "apollo-cache-inmemory@1.4.0-alpha.4",
      "_nodeVersion": "8.12.0",
      "_npmVersion": "lerna/3.8.1/node@v8.12.0+x64 (darwin)",
      "dist": {
        "integrity": "sha512-Af2LU7uVZR3YwezzaAh73Uqj5mCc1IrrGaAhTDDi/HtwzScc6feZWT1kspphc8BGmZyyleezYYrMYZwZ5DOoeg==",
        "shasum": "8c896a88ffaa7f57402e95298dcfcc219e845d8c",
        "tarball": "https://registry.npmjs.org/apollo-cache-inmemory/-/apollo-cache-inmemory-1.4.0-alpha.4.tgz",
        "fileCount": 62,
        "unpackedSize": 318522,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJcO+hsCRA9TVsSAnZWagAA5G0QAJiiXQXKTrSkaqiZsFkr\nGG6+/9kwca2w4MVoRfXe9O2a9WHl2My1tDtCphRpr1xYx/g02xsWyDzXlyMm\nBxXHYJRNEU6tDTgZEPnB8+jJmTfsWjTiv80JJiJpuG79Nq83pi7Fz3DQ/ICI\nYXVJMKj4SrmYA1qeopxjX8cbYjgCiNiPHzarsVPNUt5zLkFjzOXajuJGOoCj\nvir9+EGDAYZZLBeeSVgoGiiJsFp6dKhC4GoZxb5KchY+RTaLI6oTFHjUmoD5\nfjLQEnY+EFj/Max6oodxrGrQ3Kt9PuobKrZIlUT39hBIyBijTMZ4HV4r8i5z\nRe6mkBwoYi8L6sl5lWASOs0lP7JVY94nQVfxFWx3bVBfrZ1g+V+Ot+aL5jbA\nJUbZ1UJJgMPRNl5v8a0f+27YtuY3I+PnhmROiNwGGROuWxQyAu9z2PEpXfuM\nq2Hbx61oJa3q7INxHpBI+tXOKYWpTorcdjYvT236x1N1N30FTpnggSw5sJrG\nZ0xtxRGGd1AY2Gf1ER1j3cTu/zXj7sTOeAStW51jF+y5B3lNqX3hoEJc7GRg\nX8cuZd7t80jcFBTc/VmONKfXibx+FD968o+8IyWeIV8gIrvSL3tnQ7GY1mqJ\ntujun/GY4BAcJ89DiVRGJClsWYsjQWzFUhJjcCYTv7Lwjc9iuDWdqeBpSbm8\nkbEg\r\n=AkxV\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEYCIQDx5/rJ0kVgycoVJwfxCc0cwAmeIHAPV+Nw+ofjuyPKuQIhAKeRCuI3LZDZZbONtl/bXZWf8SMDlg66Pz+9Jp4Y0ey+"
          }
        ]
      },
      "maintainers": [
        {
          "email": "npm@apollographql.com",
          "name": "apollo-bot"
        },
        {
          "email": "ben@benjamn.com",
          "name": "benjamn"
        },
        {
          "email": "james@meteor.com",
          "name": "jbaxleyiii"
        },
        {
          "email": "peggyrayzis@gmail.com",
          "name": "peggyrayzis"
        }
      ],
      "_npmUser": {
        "name": "apollo-bot",
        "email": "npm@apollographql.com"
      },
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/apollo-cache-inmemory_1.4.0-alpha.4_1547429996051_0.21526013997795146"
      },
      "_hasShrinkwrap": false
    },
    "1.4.0-alpha.5": {
      "name": "apollo-cache-inmemory",
      "version": "1.4.0-alpha.5",
      "description": "Core abstract of Caching layer for Apollo Client",
      "author": {
        "name": "James Baxley",
        "email": "james@meteor.com"
      },
      "contributors": [
        {
          "name": "James Baxley",
          "email": "james@meteor.com"
        },
        {
          "name": "Jonas Helfer",
          "email": "jonas@helfer.email"
        },
        {
          "name": "Sashko Stubailo",
          "email": "sashko@stubailo.com"
        },
        {
          "name": "James Burgess",
          "email": "jamesmillerburgess@gmail.com"
        },
        {
          "name": "Bazyli Brzóska",
          "email": "bazyli.brzoska@gmail.com"
        }
      ],
      "license": "MIT",
      "main": "./lib/bundle.umd.js",
      "module": "./lib/index.js",
      "jsnext:main": "./lib/index.js",
      "typings": "./lib/index.d.ts",
      "sideEffects": [
        "./lib/fixPolyfills.js"
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/apollographql/apollo-client.git"
      },
      "bugs": {
        "url": "https://github.com/apollographql/apollo-client/issues"
      },
      "homepage": "https://github.com/apollographql/apollo-client#readme",
      "scripts": {
        "prepare": "npm run build",
        "coverage": "jest --coverage",
        "test": "jest",
        "lint": "tslint -c \"../../config/tslint.json\" -p tsconfig.json src/*.ts",
        "prebuild": "npm run clean",
        "build": "tsc -p .",
        "postbuild": "npm run bundle",
        "bundle": "../../node_modules/rollup/bin/rollup -c rollup.config.js",
        "watch": "tsc -w -p .",
        "clean": "rm -rf coverage/* && rm -rf lib/*",
        "prepublishOnly": "npm run build",
        "minify": "../../node_modules/uglify-js/bin/uglifyjs -c -m -o ./lib/bundle.min.js -- ./lib/bundle.umd.js",
        "filesize": "npm run minify"
      },
      "dependencies": {
        "apollo-cache": "^1.2.0-alpha.5",
        "apollo-utilities": "^1.1.0-alpha.5",
        "optimism": "^0.6.8"
      },
      "peerDependencies": {
        "graphql": "0.11.7 || ^0.12.0 || ^0.13.0 || ^14.0.0"
      },
      "jest": {
        "transform": {
          ".(ts|tsx)": "ts-jest"
        },
        "testRegex": "(/__tests__/.*|\\.(test|spec))\\.(ts|tsx|js)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "json"
        ],
        "testURL": "http://localhost"
      },
      "gitHead": "a6678b338c97aed4772d21e94467b60070cc5982",
      "readme": "---\ntitle: InMemoryCache\ndescription: An explanation of `apollo-cache-inmemory`\n---\n\n`apollo-cache-inmemory` is the recommended cache implementation for Apollo Client 2.0. `InMemoryCache` is a normalized data store that supports all of Apollo Client 1.0's features without the dependency on Redux.\n\nIn some instances, you may need to manipulate the cache directly, such as updating the store after a mutation. We'll cover some common use cases [here](#recipes).\n\n<h2 id=\"installation\">Installation</h2>\n\n```\nnpm install apollo-cache-inmemory --save\n```\n\nAfter installing the package, you'll want to initialize the cache constructor. Then, you can pass in your newly created cache to ApolloClient.\n\n```js\nimport { InMemoryCache } from 'apollo-cache-inmemory';\nimport { HttpLink } from 'apollo-link-http';\nimport ApolloClient from 'apollo-client';\n\nconst cache = new InMemoryCache();\n\nconst client = new ApolloClient({\n  link: new HttpLink(),\n  cache\n});\n```\n\n<h2 id=\"configuration\">Configuration</h2>\n\nThe `InMemoryCache` constructor takes an optional config object with properties to customize your cache:\n\n- addTypename: A boolean to determine whether to add __typename to the document (default: `true`)\n- dataIdFromObject: A function that takes a data object and returns a unique identifier to be used when normalizing the data in the store. Learn more about how to customize `dataIdFromObject` in the [Normalization](#normalization) section.\n- fragmentMatcher: By default, the `InMemoryCache` uses a heuristic fragment matcher. If you are using fragments on unions and interfaces, you will need to use an `IntrospectionFragmentMatcher`. For more information, please read [our guide to setting up fragment matching for unions & interfaces](https://www.apollographql.com/docs/react/advanced/fragments.html#fragment-matcher).\n\n<h2 id=\"normalization\">Normalization</h2>\n\nThe `InMemoryCache` normalizes your data before saving it to the store by splitting the result into individual objects, creating a unique identifier for each object, and storing those objects in a flattened data structure. By default, `InMemoryCache` will attempt to use the commonly found primary keys of `id` and `_id` for the unique identifier if they exist along with `__typename` on an object.\n\nIf `id` and `_id` are not specified, or if `__typename` is not specified, `InMemoryCache` will fall back to the path to the object in the query, such as `ROOT_QUERY.allPeople.0` for the first record returned on the `allPeople` root query.\n\nThis \"getter\" behavior for unique identifiers can be configured manually via the `dataIdFromObject` option passed to the `InMemoryCache` constructor, so you can pick which field is used if some of your data follows unorthodox primary key conventions.\n\nFor example, if you wanted to key off of the `key` field for all of your data, you could configure `dataIdFromObject` like so:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => object.key\n});\n```\n\nThis also allows you to use different unique identifiers for different data types by keying off of the `__typename` property attached to every object typed by GraphQL.  For example:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => {\n    switch (object.__typename) {\n      case 'foo': return object.key; // use `key` as the primary key\n      case 'bar': return object.blah; // use `blah` as the priamry key\n      default: return object.id || object._id; // fall back to `id` and `_id` for all other types\n    }\n  }\n});\n```\n\n<h2 id=\"direct\">Direct Cache Access</h2>\n\nTo interact directly with your cache, you can use the Apollo Client class methods readQuery, readFragment, writeQuery, and writeFragment. These methods are available to us via the [`DataProxy` interface](https://github.com/apollographql/apollo-client/blob/master/packages/apollo-cache/src/types/DataProxy.ts). Accessing these methods will vary slightly based on your view layer implementation. If you are using React, you can wrap your component in the `withApollo` higher order component, which will give you access to `this.props.client`. From there, you can use the methods to control your data.\n\nAny code demonstration in the following sections will assume that we have already initialized an instance of  `ApolloClient` and that we have imported the `gql` tag from `graphql-tag`.\n\n<h3 id=\"readquery\">readQuery</h3>\n\nThe `readQuery` method is very similar to the [`query` method on `ApolloClient`][] except that `readQuery` will _never_ make a request to your GraphQL server. The `query` method, on the other hand, may send a request to your server if the appropriate data is not in your cache whereas `readQuery` will throw an error if the data is not in your cache. `readQuery` will _always_ read from the cache. You can use `readQuery` by giving it a GraphQL query like so:\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo {\n      todo(id: 5) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n});\n```\n\nIf all of the data needed to fulfill this read is in Apollo Client’s normalized data cache then a data object will be returned in the shape of the query you wanted to read. If not all of the data needed to fulfill this read is in Apollo Client’s cache then an error will be thrown instead, so make sure to only read data that you know you have!\n\nYou can also pass variables into `readQuery`.\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo($id: Int!) {\n      todo(id: $id) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n  variables: {\n    id: 5,\n  },\n});\n```\n\n<h3 id=\"readfragment\">readFragment</h3>\n\nThis method allows you great flexibility around the data in your cache. Whereas `readQuery` only allowed you to read data from your root query type, `readFragment` allows you to read data from _any node you have queried_. This is incredibly powerful. You use this method as follows:\n\n```js\nconst todo = client.readFragment({\n  id: ..., // `id` is any id that could be returned by `dataIdFromObject`.\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\nThe first argument is the id of the data you want to read from the cache. That id must be a value that was returned by the `dataIdFromObject` function you defined when initializing `ApolloClient`. So for example if you initialized `ApolloClient` like so:\n\n```js\nconst client = new ApolloClient({\n  ...,\n  dataIdFromObject: object => object.id,\n});\n```\n\n…and you requested a todo before with an id of `5`, then you can read that todo out of your cache with the following:\n\n```js\nconst todo = client.readFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\n> **Note:** Most people add a `__typename` to the id in `dataIdFromObject`. If you do this then don’t forget to add the `__typename` when you are reading a fragment as well. So for example your id may be `Todo_5` and not just `5`.\n\nIf a todo with that id does not exist in the cache you will get `null` back. If a todo of that id does exist in the cache, but that todo does not have the `text` field then an error will be thrown.\n\nThe beauty of `readFragment` is that the todo could have come from anywhere! The todo could have been selected as a singleton (`{ todo(id: 5) { ... } }`), the todo could have come from a list of todos (`{ todos { ... } }`), or the todo could have come from a mutation (`mutation { createTodo { ... } }`). As long as at some point your GraphQL server gave you a todo with the provided id and fields `id`, `text`, and `completed` you can read it from the cache at any part of your code.\n\n<h3 id=\"writequery-and-writefragment\">writeQuery` and `writeFragment</h3>\n\nNot only can you read arbitrary data from the Apollo Client cache, but you can also write any data that you would like to the cache. The methods you use to do this are `writeQuery` and `writeFragment`. They will allow you to change data in your local cache, but it is important to remember that *they will not change any data on your server*. If you reload your environment then changes made with `writeQuery` and `writeFragment` will disappear.\n\nThese methods have the same signature as their `readQuery` and `readFragment` counterparts except they also require an additional `data` variable. So for example, if you wanted to update the `completed` flag locally for your todo with id `'5'` you could execute the following:\n\n```js\nclient.writeFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      completed\n    }\n  `,\n  data: {\n    completed: true,\n  },\n});\n```\n\nAny subscriber to the Apollo Client store will instantly see this update and render new UI accordingly.\n\n> **Note:** Again, remember that using `writeQuery` or `writeFragment` only changes data *locally*. If you reload your environment then changes made with these methods will no longer exist.\n\nOr if you wanted to add a new todo to a list fetched from the server, you could use `readQuery` and `writeQuery` together.\n\n```js\nconst query = gql`\n  query MyTodoAppQuery {\n    todos {\n      id\n      text\n      completed\n    }\n  }\n`;\n\nconst data = client.readQuery({ query });\n\nconst myNewTodo = {\n  id: '6',\n  text: 'Start using Apollo Client.',\n  completed: false,\n};\n\nclient.writeQuery({\n  query,\n  data: {\n    todos: [...data.todos, myNewTodo],\n  },\n});\n```\n\n<h2 id=\"recipes\">Recipes</h2>\n\nHere are some common situations where you would need to access the cache directly. If you're manipulating the cache in an interesting way and would like your example to be featured, please send in a pull request!\n\n<h3 id=\"server\">Server side rendering</h3>\n\nFirst, you will need to initialize an `InMemoryCache` on the server and create an instance of `ApolloClient`. In the initial serialized HTML payload from the server, you should include a script tag that extracts the data from the cache.\n\n```js\n`<script>\n  window.__APOLLO_STATE__=${JSON.stringify(cache.extract())}\n</script>`\n```\n\nOn the client, you can rehydrate the cache using the initial data passed from the server:\n\n```js\ncache: new Cache().restore(window.__APOLLO_STATE__)\n```\n\nIf you would like to learn more about server side rendering, please check our our more in depth guide [here].\n<!---\nTODO (PEGGY): Add link to SSR\n-->\n\n<h3 id=\"server\">Updating the cache after a mutation</h3>\n\nBeing able to read and write to the Apollo cache from anywhere in your application gives you a lot of power over your data. However, there is one place where we most often want to update our cached data: after a mutation. As such, Apollo Client has optimized the experience for updating your cache with the read and write methods after a mutation with the `update` function. Let us say that we have the following GraphQL mutation:\n\n```graphql\nmutation TodoCreateMutation($text: String!) {\n  createTodo(text: $text) {\n    id\n    text\n    completed\n  }\n}\n```\n\nWe may also have the following GraphQL query:\n\n```graphql\nquery TodoAppQuery {\n  todos {\n    id\n    text\n    completed\n  }\n}\n```\n\nAt the end of our mutation we want our query to include the new todo like we had sent our `TodoAppQuery` a second time after the mutation finished without actually sending the query. To do this we can use the `update` function provided as an option of the `client.mutate` method. To update your cache with the mutation just write code that looks like:\n\n```js\n// We assume that the GraphQL operations `TodoCreateMutation` and\n// `TodoAppQuery` have already been defined using the `gql` tag.\n\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    // Read the data from our cache for this query.\n    const data = proxy.readQuery({ query: TodoAppQuery });\n\n    // Add our todo from the mutation to the end.\n    data.todos.push(createTodo);\n\n    // Write our data back to the cache.\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nThe first `proxy` argument is an instance of [`DataProxy`][] has the same four methods that we just learned exist on the Apollo Client: `readQuery`, `readFragment`, `writeQuery`, and `writeFragment`. The reason we call them on a `proxy` object here instead of on our `client` instance is that we can easily apply optimistic updates (which we will demonstrate in a bit). The `proxy` object also provides an isolated transaction which shields you from any other mutations going on at the same time, and the `proxy` object also batches writes together until the very end.\n\nIf you provide an `optimisticResponse` option to the mutation then the `update` function will be run twice. Once immediately after you call `client.mutate` with the data from `optimisticResponse`. After the mutation successfully executes against the server the changes made in the first call to `update` will be rolled back and `update` will be called with the *actual* data returned by the mutation and not just the optimistic response.\n\nPutting it all together:\n\n```js\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  optimisticResponse: {\n    id: -1, // -1 is a temporary id for the optimistic response.\n    text,\n    completed: false,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    const data = proxy.readQuery({ query: TodoAppQuery });\n    data.todos.push(createTodo);\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nAs you can see the `update` function on `client.mutate` provides extra change management functionality specific to the use case of a mutation while still providing you the powerful data control APIs that are available on `client`.\n\nThe `update` function is not a good place for side-effects as it may be called multiple times. Also, you may not call any of the methods on `proxy` asynchronously.\n\n",
      "readmeFilename": "README.md",
      "_id": "apollo-cache-inmemory@1.4.0-alpha.5",
      "_nodeVersion": "8.12.0",
      "_npmVersion": "lerna/3.8.1/node@v8.12.0+x64 (darwin)",
      "dist": {
        "integrity": "sha512-P11zgQu/TCsxrh/xwhJFlekzB+d0q0T387HCAKn4ySghG46Zs3lVc9JK8F//SsAtfOCHI8ENDMLbRG5p+WXGqA==",
        "shasum": "25aa88a59b0b97ae221c8832794d0f8914aa82b3",
        "tarball": "https://registry.npmjs.org/apollo-cache-inmemory/-/apollo-cache-inmemory-1.4.0-alpha.5.tgz",
        "fileCount": 62,
        "unpackedSize": 318522,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJcO+l4CRA9TVsSAnZWagAAP+4P/3dqh4Zn3+ZKIN6704BX\nDnWgE2tHN4dNO4Y42VWLMT4O5c0N1sycGAODx85bKGsD+Eo6ielNr8nM8oFr\nwXHOhRBad0aJa6Qp1S1Z9Hpt3v/2JDbcB6fgAYygKiMUc7qFkkEu15HmAWi+\n8wQEs9ohQu5HAkXXKnrRvOccZfP/LA3zNFZ9LZmgUFkVpIXkg69meXcphbLW\nMVIYeXL39W4i/+jFSJuEQp8rjV71H9DsfjOEnqwUFaBKXcK7U/QTR9qFNcMI\n5Krz56NyA8SO9o7bsemp8zUWVzfAEhvwifJQ3DNDASg7DAKKQ9YCWjA8Nkz4\naXh4S5vcbyGznNb0l/GkvXRXvC9SLtT7Ld36JYowrqKQ8Vu0DLR6M5FZcqxH\nxt3bOy0dvcdXgJl6IV4F0KIp1Z8MpEr7Pl7X1qeYMFU//HSSQNhbyZAns7we\nhzkPahSx0PmPyJ+SsKXlzTaZrP+J+Wifq8Y0jwx3tEa2eU2DG0EHlTRAXwl9\n9Ufa8fwT3gGKIupTHXoRGtYwZ/6QuouswkleOhFVhI72yuyrBHh5MlxGPxdt\nHtQObeIFx15newnKlJyeqKgezaxDgCEzQBlerlkKBDCk5F/wVNs4Npl5yTpU\n5M+XFNCH7Yisl5APAJWpww1iNwgS34CgQ80Fi6xQt3ltGFIrQdNj8yuAHXLG\nDGrA\r\n=591v\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEYCIQDH6g0Q5A57+HyvOEiQ8COKRavoTdX+z/3So9/8skhHiwIhALI7ndH5z/A+G0C+FWUMWNA6zRmAuc6vXL5f8CbrLGLK"
          }
        ]
      },
      "maintainers": [
        {
          "email": "npm@apollographql.com",
          "name": "apollo-bot"
        },
        {
          "email": "ben@benjamn.com",
          "name": "benjamn"
        },
        {
          "email": "james@meteor.com",
          "name": "jbaxleyiii"
        },
        {
          "email": "peggyrayzis@gmail.com",
          "name": "peggyrayzis"
        }
      ],
      "_npmUser": {
        "name": "apollo-bot",
        "email": "npm@apollographql.com"
      },
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/apollo-cache-inmemory_1.4.0-alpha.5_1547430263533_0.4697917299117318"
      },
      "_hasShrinkwrap": false
    },
    "1.4.0-alpha.7": {
      "name": "apollo-cache-inmemory",
      "version": "1.4.0-alpha.7",
      "description": "Core abstract of Caching layer for Apollo Client",
      "author": {
        "name": "James Baxley",
        "email": "james@meteor.com"
      },
      "contributors": [
        {
          "name": "James Baxley",
          "email": "james@meteor.com"
        },
        {
          "name": "Jonas Helfer",
          "email": "jonas@helfer.email"
        },
        {
          "name": "Sashko Stubailo",
          "email": "sashko@stubailo.com"
        },
        {
          "name": "James Burgess",
          "email": "jamesmillerburgess@gmail.com"
        },
        {
          "name": "Bazyli Brzóska",
          "email": "bazyli.brzoska@gmail.com"
        }
      ],
      "license": "MIT",
      "main": "./lib/bundle.umd.js",
      "module": "./lib/index.js",
      "jsnext:main": "./lib/index.js",
      "typings": "./lib/index.d.ts",
      "sideEffects": [
        "./lib/fixPolyfills.js"
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/apollographql/apollo-client.git"
      },
      "bugs": {
        "url": "https://github.com/apollographql/apollo-client/issues"
      },
      "homepage": "https://github.com/apollographql/apollo-client#readme",
      "scripts": {
        "prepare": "npm run build",
        "coverage": "jest --coverage",
        "test": "jest",
        "lint": "tslint -c \"../../config/tslint.json\" -p tsconfig.json src/*.ts",
        "prebuild": "npm run clean",
        "build": "tsc -p .",
        "postbuild": "npm run bundle",
        "bundle": "../../node_modules/rollup/bin/rollup -c rollup.config.js",
        "watch": "tsc -w -p .",
        "clean": "rm -rf coverage/* && rm -rf lib/*",
        "prepublishOnly": "npm run build",
        "minify": "../../node_modules/uglify-js/bin/uglifyjs -c -m -o ./lib/bundle.min.js -- ./lib/bundle.umd.js",
        "filesize": "npm run minify"
      },
      "dependencies": {
        "apollo-cache": "^1.2.0-alpha.7",
        "apollo-utilities": "^1.1.0-alpha.7",
        "optimism": "^0.6.8"
      },
      "peerDependencies": {
        "graphql": "0.11.7 || ^0.12.0 || ^0.13.0 || ^14.0.0"
      },
      "jest": {
        "transform": {
          ".(ts|tsx)": "ts-jest"
        },
        "testRegex": "(/__tests__/.*|\\.(test|spec))\\.(ts|tsx|js)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "json"
        ],
        "testURL": "http://localhost"
      },
      "gitHead": "2d3e19a31d3fb2054980211e5a6d357f7726bcbe",
      "readme": "---\ntitle: InMemoryCache\ndescription: An explanation of `apollo-cache-inmemory`\n---\n\n`apollo-cache-inmemory` is the recommended cache implementation for Apollo Client 2.0. `InMemoryCache` is a normalized data store that supports all of Apollo Client 1.0's features without the dependency on Redux.\n\nIn some instances, you may need to manipulate the cache directly, such as updating the store after a mutation. We'll cover some common use cases [here](#recipes).\n\n<h2 id=\"installation\">Installation</h2>\n\n```\nnpm install apollo-cache-inmemory --save\n```\n\nAfter installing the package, you'll want to initialize the cache constructor. Then, you can pass in your newly created cache to ApolloClient.\n\n```js\nimport { InMemoryCache } from 'apollo-cache-inmemory';\nimport { HttpLink } from 'apollo-link-http';\nimport ApolloClient from 'apollo-client';\n\nconst cache = new InMemoryCache();\n\nconst client = new ApolloClient({\n  link: new HttpLink(),\n  cache\n});\n```\n\n<h2 id=\"configuration\">Configuration</h2>\n\nThe `InMemoryCache` constructor takes an optional config object with properties to customize your cache:\n\n- addTypename: A boolean to determine whether to add __typename to the document (default: `true`)\n- dataIdFromObject: A function that takes a data object and returns a unique identifier to be used when normalizing the data in the store. Learn more about how to customize `dataIdFromObject` in the [Normalization](#normalization) section.\n- fragmentMatcher: By default, the `InMemoryCache` uses a heuristic fragment matcher. If you are using fragments on unions and interfaces, you will need to use an `IntrospectionFragmentMatcher`. For more information, please read [our guide to setting up fragment matching for unions & interfaces](https://www.apollographql.com/docs/react/advanced/fragments.html#fragment-matcher).\n\n<h2 id=\"normalization\">Normalization</h2>\n\nThe `InMemoryCache` normalizes your data before saving it to the store by splitting the result into individual objects, creating a unique identifier for each object, and storing those objects in a flattened data structure. By default, `InMemoryCache` will attempt to use the commonly found primary keys of `id` and `_id` for the unique identifier if they exist along with `__typename` on an object.\n\nIf `id` and `_id` are not specified, or if `__typename` is not specified, `InMemoryCache` will fall back to the path to the object in the query, such as `ROOT_QUERY.allPeople.0` for the first record returned on the `allPeople` root query.\n\nThis \"getter\" behavior for unique identifiers can be configured manually via the `dataIdFromObject` option passed to the `InMemoryCache` constructor, so you can pick which field is used if some of your data follows unorthodox primary key conventions.\n\nFor example, if you wanted to key off of the `key` field for all of your data, you could configure `dataIdFromObject` like so:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => object.key\n});\n```\n\nThis also allows you to use different unique identifiers for different data types by keying off of the `__typename` property attached to every object typed by GraphQL.  For example:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => {\n    switch (object.__typename) {\n      case 'foo': return object.key; // use `key` as the primary key\n      case 'bar': return object.blah; // use `blah` as the priamry key\n      default: return object.id || object._id; // fall back to `id` and `_id` for all other types\n    }\n  }\n});\n```\n\n<h2 id=\"direct\">Direct Cache Access</h2>\n\nTo interact directly with your cache, you can use the Apollo Client class methods readQuery, readFragment, writeQuery, and writeFragment. These methods are available to us via the [`DataProxy` interface](https://github.com/apollographql/apollo-client/blob/master/packages/apollo-cache/src/types/DataProxy.ts). Accessing these methods will vary slightly based on your view layer implementation. If you are using React, you can wrap your component in the `withApollo` higher order component, which will give you access to `this.props.client`. From there, you can use the methods to control your data.\n\nAny code demonstration in the following sections will assume that we have already initialized an instance of  `ApolloClient` and that we have imported the `gql` tag from `graphql-tag`.\n\n<h3 id=\"readquery\">readQuery</h3>\n\nThe `readQuery` method is very similar to the [`query` method on `ApolloClient`][] except that `readQuery` will _never_ make a request to your GraphQL server. The `query` method, on the other hand, may send a request to your server if the appropriate data is not in your cache whereas `readQuery` will throw an error if the data is not in your cache. `readQuery` will _always_ read from the cache. You can use `readQuery` by giving it a GraphQL query like so:\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo {\n      todo(id: 5) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n});\n```\n\nIf all of the data needed to fulfill this read is in Apollo Client’s normalized data cache then a data object will be returned in the shape of the query you wanted to read. If not all of the data needed to fulfill this read is in Apollo Client’s cache then an error will be thrown instead, so make sure to only read data that you know you have!\n\nYou can also pass variables into `readQuery`.\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo($id: Int!) {\n      todo(id: $id) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n  variables: {\n    id: 5,\n  },\n});\n```\n\n<h3 id=\"readfragment\">readFragment</h3>\n\nThis method allows you great flexibility around the data in your cache. Whereas `readQuery` only allowed you to read data from your root query type, `readFragment` allows you to read data from _any node you have queried_. This is incredibly powerful. You use this method as follows:\n\n```js\nconst todo = client.readFragment({\n  id: ..., // `id` is any id that could be returned by `dataIdFromObject`.\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\nThe first argument is the id of the data you want to read from the cache. That id must be a value that was returned by the `dataIdFromObject` function you defined when initializing `ApolloClient`. So for example if you initialized `ApolloClient` like so:\n\n```js\nconst client = new ApolloClient({\n  ...,\n  dataIdFromObject: object => object.id,\n});\n```\n\n…and you requested a todo before with an id of `5`, then you can read that todo out of your cache with the following:\n\n```js\nconst todo = client.readFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\n> **Note:** Most people add a `__typename` to the id in `dataIdFromObject`. If you do this then don’t forget to add the `__typename` when you are reading a fragment as well. So for example your id may be `Todo_5` and not just `5`.\n\nIf a todo with that id does not exist in the cache you will get `null` back. If a todo of that id does exist in the cache, but that todo does not have the `text` field then an error will be thrown.\n\nThe beauty of `readFragment` is that the todo could have come from anywhere! The todo could have been selected as a singleton (`{ todo(id: 5) { ... } }`), the todo could have come from a list of todos (`{ todos { ... } }`), or the todo could have come from a mutation (`mutation { createTodo { ... } }`). As long as at some point your GraphQL server gave you a todo with the provided id and fields `id`, `text`, and `completed` you can read it from the cache at any part of your code.\n\n<h3 id=\"writequery-and-writefragment\">writeQuery` and `writeFragment</h3>\n\nNot only can you read arbitrary data from the Apollo Client cache, but you can also write any data that you would like to the cache. The methods you use to do this are `writeQuery` and `writeFragment`. They will allow you to change data in your local cache, but it is important to remember that *they will not change any data on your server*. If you reload your environment then changes made with `writeQuery` and `writeFragment` will disappear.\n\nThese methods have the same signature as their `readQuery` and `readFragment` counterparts except they also require an additional `data` variable. So for example, if you wanted to update the `completed` flag locally for your todo with id `'5'` you could execute the following:\n\n```js\nclient.writeFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      completed\n    }\n  `,\n  data: {\n    completed: true,\n  },\n});\n```\n\nAny subscriber to the Apollo Client store will instantly see this update and render new UI accordingly.\n\n> **Note:** Again, remember that using `writeQuery` or `writeFragment` only changes data *locally*. If you reload your environment then changes made with these methods will no longer exist.\n\nOr if you wanted to add a new todo to a list fetched from the server, you could use `readQuery` and `writeQuery` together.\n\n```js\nconst query = gql`\n  query MyTodoAppQuery {\n    todos {\n      id\n      text\n      completed\n    }\n  }\n`;\n\nconst data = client.readQuery({ query });\n\nconst myNewTodo = {\n  id: '6',\n  text: 'Start using Apollo Client.',\n  completed: false,\n};\n\nclient.writeQuery({\n  query,\n  data: {\n    todos: [...data.todos, myNewTodo],\n  },\n});\n```\n\n<h2 id=\"recipes\">Recipes</h2>\n\nHere are some common situations where you would need to access the cache directly. If you're manipulating the cache in an interesting way and would like your example to be featured, please send in a pull request!\n\n<h3 id=\"server\">Server side rendering</h3>\n\nFirst, you will need to initialize an `InMemoryCache` on the server and create an instance of `ApolloClient`. In the initial serialized HTML payload from the server, you should include a script tag that extracts the data from the cache.\n\n```js\n`<script>\n  window.__APOLLO_STATE__=${JSON.stringify(cache.extract())}\n</script>`\n```\n\nOn the client, you can rehydrate the cache using the initial data passed from the server:\n\n```js\ncache: new Cache().restore(window.__APOLLO_STATE__)\n```\n\nIf you would like to learn more about server side rendering, please check our our more in depth guide [here].\n<!---\nTODO (PEGGY): Add link to SSR\n-->\n\n<h3 id=\"server\">Updating the cache after a mutation</h3>\n\nBeing able to read and write to the Apollo cache from anywhere in your application gives you a lot of power over your data. However, there is one place where we most often want to update our cached data: after a mutation. As such, Apollo Client has optimized the experience for updating your cache with the read and write methods after a mutation with the `update` function. Let us say that we have the following GraphQL mutation:\n\n```graphql\nmutation TodoCreateMutation($text: String!) {\n  createTodo(text: $text) {\n    id\n    text\n    completed\n  }\n}\n```\n\nWe may also have the following GraphQL query:\n\n```graphql\nquery TodoAppQuery {\n  todos {\n    id\n    text\n    completed\n  }\n}\n```\n\nAt the end of our mutation we want our query to include the new todo like we had sent our `TodoAppQuery` a second time after the mutation finished without actually sending the query. To do this we can use the `update` function provided as an option of the `client.mutate` method. To update your cache with the mutation just write code that looks like:\n\n```js\n// We assume that the GraphQL operations `TodoCreateMutation` and\n// `TodoAppQuery` have already been defined using the `gql` tag.\n\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    // Read the data from our cache for this query.\n    const data = proxy.readQuery({ query: TodoAppQuery });\n\n    // Add our todo from the mutation to the end.\n    data.todos.push(createTodo);\n\n    // Write our data back to the cache.\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nThe first `proxy` argument is an instance of [`DataProxy`][] has the same four methods that we just learned exist on the Apollo Client: `readQuery`, `readFragment`, `writeQuery`, and `writeFragment`. The reason we call them on a `proxy` object here instead of on our `client` instance is that we can easily apply optimistic updates (which we will demonstrate in a bit). The `proxy` object also provides an isolated transaction which shields you from any other mutations going on at the same time, and the `proxy` object also batches writes together until the very end.\n\nIf you provide an `optimisticResponse` option to the mutation then the `update` function will be run twice. Once immediately after you call `client.mutate` with the data from `optimisticResponse`. After the mutation successfully executes against the server the changes made in the first call to `update` will be rolled back and `update` will be called with the *actual* data returned by the mutation and not just the optimistic response.\n\nPutting it all together:\n\n```js\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  optimisticResponse: {\n    id: -1, // -1 is a temporary id for the optimistic response.\n    text,\n    completed: false,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    const data = proxy.readQuery({ query: TodoAppQuery });\n    data.todos.push(createTodo);\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nAs you can see the `update` function on `client.mutate` provides extra change management functionality specific to the use case of a mutation while still providing you the powerful data control APIs that are available on `client`.\n\nThe `update` function is not a good place for side-effects as it may be called multiple times. Also, you may not call any of the methods on `proxy` asynchronously.\n\n",
      "readmeFilename": "README.md",
      "_id": "apollo-cache-inmemory@1.4.0-alpha.7",
      "_nodeVersion": "8.12.0",
      "_npmVersion": "lerna/3.8.1/node@v8.12.0+x64 (darwin)",
      "dist": {
        "integrity": "sha512-JR3Gi6vH0gxIGnZtLgnCmzMN4KNodofNFJ7HWMQ/mQQG9xI7M01+Z0WyHvEzcWaWG5e6/t2tLRKXqSdVQ5gJsA==",
        "shasum": "1bf055eb8c335b547f126a782bca9f8bbe7aeb14",
        "tarball": "https://registry.npmjs.org/apollo-cache-inmemory/-/apollo-cache-inmemory-1.4.0-alpha.7.tgz",
        "fileCount": 62,
        "unpackedSize": 318522,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJcO+wvCRA9TVsSAnZWagAAi8AQAKJKR23cZfH1GzP4NIIW\n5da3hl70OdJNEp4tyuZiMmPm6qoIk0x5i7rITJvjplbblWpHEk69GIluzdem\neen2gqn7KmpX+w19khAjOZT5+u/4DELJPB5Irjp61hWF3JeQ+CPBbc1sdcsh\nJPRZT4QCWKZ1Z13qY28ObRg7hu6oWzXtjcMGPsdhggDINU+XKour/PwncxzG\nj12W4XYQNoisX02+XhqQ8Yy4c5LPT4Q7aQNUBxwZ39VK7OeDjpev2M7lHNY1\nkfrGcW5LEj70Kd67BrbFsb8p1uCABhougmm+M6bXUzEldhgyVkWaCA+gXlEv\npqQ2tzWaPY2grwyJp6JEo8dc506cjxsJ6YnB8r6b1bYIC21t73ISM3U7xrTU\n88YAnU+xLtrdiMm767ooR/2+sJQ07GDFWxXwlTM8ccA50DawCp+JQY56lRTK\nH2PLN8RUbjywIFmLmSV6+PVK4qp12aOpskTilhCtvJ39Qluz0V6G8/vouODD\nBbHQWjDtZRACrxMC7FBy/q9IBWErYFNHvrntt6zrocKq1VJC4ZjpOz4lRZkl\nAt2TKFYSFY0xEaH3SGv5jVl7Dcc8WmxVekiRJWOCpx4K0fz9VmU1HXevfYCb\nXMUExXTsBO12XohooCg7JbQKEukgyJjOleMTLdhaHBOIddkedC4mSWwmnFCa\nCKOL\r\n=0U4i\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEQCIDAt4sY5pY7zcBQ1d8uIrh43yJvQuZv0NdGMg+QRzE+2AiAEVr1YPNeg1Aw8l9QzM9EMQwHmljHJbau+gvnOm18+Gg=="
          }
        ]
      },
      "maintainers": [
        {
          "email": "npm@apollographql.com",
          "name": "apollo-bot"
        },
        {
          "email": "ben@benjamn.com",
          "name": "benjamn"
        },
        {
          "email": "james@meteor.com",
          "name": "jbaxleyiii"
        },
        {
          "email": "peggyrayzis@gmail.com",
          "name": "peggyrayzis"
        }
      ],
      "_npmUser": {
        "name": "apollo-bot",
        "email": "npm@apollographql.com"
      },
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/apollo-cache-inmemory_1.4.0-alpha.7_1547430958373_0.5396837786837534"
      },
      "_hasShrinkwrap": false
    },
    "1.4.0-alpha.8": {
      "name": "apollo-cache-inmemory",
      "version": "1.4.0-alpha.8",
      "description": "Core abstract of Caching layer for Apollo Client",
      "author": {
        "name": "James Baxley",
        "email": "james@meteor.com"
      },
      "contributors": [
        {
          "name": "James Baxley",
          "email": "james@meteor.com"
        },
        {
          "name": "Jonas Helfer",
          "email": "jonas@helfer.email"
        },
        {
          "name": "Sashko Stubailo",
          "email": "sashko@stubailo.com"
        },
        {
          "name": "James Burgess",
          "email": "jamesmillerburgess@gmail.com"
        },
        {
          "name": "Bazyli Brzóska",
          "email": "bazyli.brzoska@gmail.com"
        }
      ],
      "license": "MIT",
      "main": "./lib/bundle.umd.js",
      "module": "./lib/index.js",
      "jsnext:main": "./lib/index.js",
      "typings": "./lib/index.d.ts",
      "sideEffects": [
        "./lib/fixPolyfills.js"
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/apollographql/apollo-client.git"
      },
      "bugs": {
        "url": "https://github.com/apollographql/apollo-client/issues"
      },
      "homepage": "https://github.com/apollographql/apollo-client#readme",
      "scripts": {
        "prepare": "npm run build",
        "coverage": "jest --coverage",
        "test": "jest",
        "lint": "tslint -c \"../../config/tslint.json\" -p tsconfig.json src/*.ts",
        "prebuild": "npm run clean",
        "build": "tsc -p .",
        "postbuild": "npm run bundle",
        "bundle": "../../node_modules/rollup/bin/rollup -c rollup.config.js",
        "watch": "tsc -w -p .",
        "clean": "rm -rf coverage/* && rm -rf lib/*",
        "prepublishOnly": "npm run build",
        "minify": "../../node_modules/uglify-js/bin/uglifyjs -c -m -o ./lib/bundle.min.js -- ./lib/bundle.umd.js",
        "filesize": "npm run minify"
      },
      "dependencies": {
        "apollo-cache": "^1.2.0-alpha.8",
        "apollo-utilities": "^1.1.0-alpha.9",
        "optimism": "^0.6.8"
      },
      "peerDependencies": {
        "graphql": "0.11.7 || ^0.12.0 || ^0.13.0 || ^14.0.0"
      },
      "jest": {
        "transform": {
          ".(ts|tsx)": "ts-jest"
        },
        "testRegex": "(/__tests__/.*|\\.(test|spec))\\.(ts|tsx|js)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "json"
        ],
        "testURL": "http://localhost"
      },
      "gitHead": "3280afccf6c057a9aa716cc834a2714a03b98da9",
      "readme": "---\ntitle: InMemoryCache\ndescription: An explanation of `apollo-cache-inmemory`\n---\n\n`apollo-cache-inmemory` is the recommended cache implementation for Apollo Client 2.0. `InMemoryCache` is a normalized data store that supports all of Apollo Client 1.0's features without the dependency on Redux.\n\nIn some instances, you may need to manipulate the cache directly, such as updating the store after a mutation. We'll cover some common use cases [here](#recipes).\n\n<h2 id=\"installation\">Installation</h2>\n\n```\nnpm install apollo-cache-inmemory --save\n```\n\nAfter installing the package, you'll want to initialize the cache constructor. Then, you can pass in your newly created cache to ApolloClient.\n\n```js\nimport { InMemoryCache } from 'apollo-cache-inmemory';\nimport { HttpLink } from 'apollo-link-http';\nimport ApolloClient from 'apollo-client';\n\nconst cache = new InMemoryCache();\n\nconst client = new ApolloClient({\n  link: new HttpLink(),\n  cache\n});\n```\n\n<h2 id=\"configuration\">Configuration</h2>\n\nThe `InMemoryCache` constructor takes an optional config object with properties to customize your cache:\n\n- addTypename: A boolean to determine whether to add __typename to the document (default: `true`)\n- dataIdFromObject: A function that takes a data object and returns a unique identifier to be used when normalizing the data in the store. Learn more about how to customize `dataIdFromObject` in the [Normalization](#normalization) section.\n- fragmentMatcher: By default, the `InMemoryCache` uses a heuristic fragment matcher. If you are using fragments on unions and interfaces, you will need to use an `IntrospectionFragmentMatcher`. For more information, please read [our guide to setting up fragment matching for unions & interfaces](https://www.apollographql.com/docs/react/advanced/fragments.html#fragment-matcher).\n\n<h2 id=\"normalization\">Normalization</h2>\n\nThe `InMemoryCache` normalizes your data before saving it to the store by splitting the result into individual objects, creating a unique identifier for each object, and storing those objects in a flattened data structure. By default, `InMemoryCache` will attempt to use the commonly found primary keys of `id` and `_id` for the unique identifier if they exist along with `__typename` on an object.\n\nIf `id` and `_id` are not specified, or if `__typename` is not specified, `InMemoryCache` will fall back to the path to the object in the query, such as `ROOT_QUERY.allPeople.0` for the first record returned on the `allPeople` root query.\n\nThis \"getter\" behavior for unique identifiers can be configured manually via the `dataIdFromObject` option passed to the `InMemoryCache` constructor, so you can pick which field is used if some of your data follows unorthodox primary key conventions.\n\nFor example, if you wanted to key off of the `key` field for all of your data, you could configure `dataIdFromObject` like so:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => object.key\n});\n```\n\nThis also allows you to use different unique identifiers for different data types by keying off of the `__typename` property attached to every object typed by GraphQL.  For example:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => {\n    switch (object.__typename) {\n      case 'foo': return object.key; // use `key` as the primary key\n      case 'bar': return object.blah; // use `blah` as the priamry key\n      default: return object.id || object._id; // fall back to `id` and `_id` for all other types\n    }\n  }\n});\n```\n\n<h2 id=\"direct\">Direct Cache Access</h2>\n\nTo interact directly with your cache, you can use the Apollo Client class methods readQuery, readFragment, writeQuery, and writeFragment. These methods are available to us via the [`DataProxy` interface](https://github.com/apollographql/apollo-client/blob/master/packages/apollo-cache/src/types/DataProxy.ts). Accessing these methods will vary slightly based on your view layer implementation. If you are using React, you can wrap your component in the `withApollo` higher order component, which will give you access to `this.props.client`. From there, you can use the methods to control your data.\n\nAny code demonstration in the following sections will assume that we have already initialized an instance of  `ApolloClient` and that we have imported the `gql` tag from `graphql-tag`.\n\n<h3 id=\"readquery\">readQuery</h3>\n\nThe `readQuery` method is very similar to the [`query` method on `ApolloClient`][] except that `readQuery` will _never_ make a request to your GraphQL server. The `query` method, on the other hand, may send a request to your server if the appropriate data is not in your cache whereas `readQuery` will throw an error if the data is not in your cache. `readQuery` will _always_ read from the cache. You can use `readQuery` by giving it a GraphQL query like so:\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo {\n      todo(id: 5) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n});\n```\n\nIf all of the data needed to fulfill this read is in Apollo Client’s normalized data cache then a data object will be returned in the shape of the query you wanted to read. If not all of the data needed to fulfill this read is in Apollo Client’s cache then an error will be thrown instead, so make sure to only read data that you know you have!\n\nYou can also pass variables into `readQuery`.\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo($id: Int!) {\n      todo(id: $id) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n  variables: {\n    id: 5,\n  },\n});\n```\n\n<h3 id=\"readfragment\">readFragment</h3>\n\nThis method allows you great flexibility around the data in your cache. Whereas `readQuery` only allowed you to read data from your root query type, `readFragment` allows you to read data from _any node you have queried_. This is incredibly powerful. You use this method as follows:\n\n```js\nconst todo = client.readFragment({\n  id: ..., // `id` is any id that could be returned by `dataIdFromObject`.\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\nThe first argument is the id of the data you want to read from the cache. That id must be a value that was returned by the `dataIdFromObject` function you defined when initializing `ApolloClient`. So for example if you initialized `ApolloClient` like so:\n\n```js\nconst client = new ApolloClient({\n  ...,\n  dataIdFromObject: object => object.id,\n});\n```\n\n…and you requested a todo before with an id of `5`, then you can read that todo out of your cache with the following:\n\n```js\nconst todo = client.readFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\n> **Note:** Most people add a `__typename` to the id in `dataIdFromObject`. If you do this then don’t forget to add the `__typename` when you are reading a fragment as well. So for example your id may be `Todo_5` and not just `5`.\n\nIf a todo with that id does not exist in the cache you will get `null` back. If a todo of that id does exist in the cache, but that todo does not have the `text` field then an error will be thrown.\n\nThe beauty of `readFragment` is that the todo could have come from anywhere! The todo could have been selected as a singleton (`{ todo(id: 5) { ... } }`), the todo could have come from a list of todos (`{ todos { ... } }`), or the todo could have come from a mutation (`mutation { createTodo { ... } }`). As long as at some point your GraphQL server gave you a todo with the provided id and fields `id`, `text`, and `completed` you can read it from the cache at any part of your code.\n\n<h3 id=\"writequery-and-writefragment\">writeQuery` and `writeFragment</h3>\n\nNot only can you read arbitrary data from the Apollo Client cache, but you can also write any data that you would like to the cache. The methods you use to do this are `writeQuery` and `writeFragment`. They will allow you to change data in your local cache, but it is important to remember that *they will not change any data on your server*. If you reload your environment then changes made with `writeQuery` and `writeFragment` will disappear.\n\nThese methods have the same signature as their `readQuery` and `readFragment` counterparts except they also require an additional `data` variable. So for example, if you wanted to update the `completed` flag locally for your todo with id `'5'` you could execute the following:\n\n```js\nclient.writeFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      completed\n    }\n  `,\n  data: {\n    completed: true,\n  },\n});\n```\n\nAny subscriber to the Apollo Client store will instantly see this update and render new UI accordingly.\n\n> **Note:** Again, remember that using `writeQuery` or `writeFragment` only changes data *locally*. If you reload your environment then changes made with these methods will no longer exist.\n\nOr if you wanted to add a new todo to a list fetched from the server, you could use `readQuery` and `writeQuery` together.\n\n```js\nconst query = gql`\n  query MyTodoAppQuery {\n    todos {\n      id\n      text\n      completed\n    }\n  }\n`;\n\nconst data = client.readQuery({ query });\n\nconst myNewTodo = {\n  id: '6',\n  text: 'Start using Apollo Client.',\n  completed: false,\n};\n\nclient.writeQuery({\n  query,\n  data: {\n    todos: [...data.todos, myNewTodo],\n  },\n});\n```\n\n<h2 id=\"recipes\">Recipes</h2>\n\nHere are some common situations where you would need to access the cache directly. If you're manipulating the cache in an interesting way and would like your example to be featured, please send in a pull request!\n\n<h3 id=\"server\">Server side rendering</h3>\n\nFirst, you will need to initialize an `InMemoryCache` on the server and create an instance of `ApolloClient`. In the initial serialized HTML payload from the server, you should include a script tag that extracts the data from the cache.\n\n```js\n`<script>\n  window.__APOLLO_STATE__=${JSON.stringify(cache.extract())}\n</script>`\n```\n\nOn the client, you can rehydrate the cache using the initial data passed from the server:\n\n```js\ncache: new Cache().restore(window.__APOLLO_STATE__)\n```\n\nIf you would like to learn more about server side rendering, please check our our more in depth guide [here].\n<!---\nTODO (PEGGY): Add link to SSR\n-->\n\n<h3 id=\"server\">Updating the cache after a mutation</h3>\n\nBeing able to read and write to the Apollo cache from anywhere in your application gives you a lot of power over your data. However, there is one place where we most often want to update our cached data: after a mutation. As such, Apollo Client has optimized the experience for updating your cache with the read and write methods after a mutation with the `update` function. Let us say that we have the following GraphQL mutation:\n\n```graphql\nmutation TodoCreateMutation($text: String!) {\n  createTodo(text: $text) {\n    id\n    text\n    completed\n  }\n}\n```\n\nWe may also have the following GraphQL query:\n\n```graphql\nquery TodoAppQuery {\n  todos {\n    id\n    text\n    completed\n  }\n}\n```\n\nAt the end of our mutation we want our query to include the new todo like we had sent our `TodoAppQuery` a second time after the mutation finished without actually sending the query. To do this we can use the `update` function provided as an option of the `client.mutate` method. To update your cache with the mutation just write code that looks like:\n\n```js\n// We assume that the GraphQL operations `TodoCreateMutation` and\n// `TodoAppQuery` have already been defined using the `gql` tag.\n\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    // Read the data from our cache for this query.\n    const data = proxy.readQuery({ query: TodoAppQuery });\n\n    // Add our todo from the mutation to the end.\n    data.todos.push(createTodo);\n\n    // Write our data back to the cache.\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nThe first `proxy` argument is an instance of [`DataProxy`][] has the same four methods that we just learned exist on the Apollo Client: `readQuery`, `readFragment`, `writeQuery`, and `writeFragment`. The reason we call them on a `proxy` object here instead of on our `client` instance is that we can easily apply optimistic updates (which we will demonstrate in a bit). The `proxy` object also provides an isolated transaction which shields you from any other mutations going on at the same time, and the `proxy` object also batches writes together until the very end.\n\nIf you provide an `optimisticResponse` option to the mutation then the `update` function will be run twice. Once immediately after you call `client.mutate` with the data from `optimisticResponse`. After the mutation successfully executes against the server the changes made in the first call to `update` will be rolled back and `update` will be called with the *actual* data returned by the mutation and not just the optimistic response.\n\nPutting it all together:\n\n```js\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  optimisticResponse: {\n    id: -1, // -1 is a temporary id for the optimistic response.\n    text,\n    completed: false,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    const data = proxy.readQuery({ query: TodoAppQuery });\n    data.todos.push(createTodo);\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nAs you can see the `update` function on `client.mutate` provides extra change management functionality specific to the use case of a mutation while still providing you the powerful data control APIs that are available on `client`.\n\nThe `update` function is not a good place for side-effects as it may be called multiple times. Also, you may not call any of the methods on `proxy` asynchronously.\n\n",
      "readmeFilename": "README.md",
      "_id": "apollo-cache-inmemory@1.4.0-alpha.8",
      "_nodeVersion": "8.12.0",
      "_npmVersion": "lerna/3.8.1/node@v8.12.0+x64 (darwin)",
      "dist": {
        "integrity": "sha512-lmefgdczOGZRxzZ+SrE/gs4TLqda3wBD+bLU/PoicJAFWqyIcoGLoykUbox6xErbKHAdmJMlJgUxSmn0ZFuYpw==",
        "shasum": "f6c072cbb42495d423c4b985728e8a0f52c8ad20",
        "tarball": "https://registry.npmjs.org/apollo-cache-inmemory/-/apollo-cache-inmemory-1.4.0-alpha.8.tgz",
        "fileCount": 62,
        "unpackedSize": 318624,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJcPKA2CRA9TVsSAnZWagAADuUP/1ezyqRDcXEbvn7EK1GS\nwY7uV7cAjgA3esMoUBsQjxvU4OpvCEA/coXq+mgy2cJVbSexJ2PfeHyMObXr\nTgJmMgv7tcqBLSQNCZzL8eQpGaolLhaRFRB2mvDt+1Hy7b9kxfqc9bLgvJj0\n0b4URH0IJrNs4k0MZ75qnjVZeby4GtOyP6WkXxAXnFCioUscHc1I0+3eNCBF\nc0u6zT1YOTDgobhh0/HV4gRPmEWpH+rN9r0OTMdyQKdk6Bh5mI7bsK3HE3Ul\nK4cHrvS5oXbgrL02DPRpLLP7bvKQUEay+QBiCEhqex9SMlB8tvD/FXbEVeCL\nkdHO6oXjJ9M/A9+5pckuVwVJDtjXB0S8vFVY3vB1t1gdcg5DRFkc7WN1FJhr\n+y7QD8STX+Z1+JlE1QD7BXdLMJcmnLlV3O6A+375l/joWwA4Cf3gsTO27+EW\nMSODRc8+bwyGur+xhTSpMqwFKj3zzuwTGrN9e48UsohpwavxdFauJFAMfetH\n1dOUsAizhbB3fV4HjkZ2iotFPy1X9D452xZrqwaD4HaD1kXdsM6rhsxzgBtA\nSmgqU4Q9+qMcG13CVG3FLzxfQpSpZBlVOLKksgsFR+OlA2/QrcBFbCBrqmOk\ntpIFfzLnDUVZqMnnbwM6uWSTuLFMOz/Za5GcYIrCSAtstT674qxlsGYiJg3b\nUPrw\r\n=Mtdj\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCICbi6ZZYXI+XvcofxNVQ/DHZf6NvqLPkKoiQsaRnbNTgAiEAnL7+q1Mda8m2tkDt1FrvMq1J9uehEyiQk0xWnqdsMwQ="
          }
        ]
      },
      "maintainers": [
        {
          "email": "npm@apollographql.com",
          "name": "apollo-bot"
        },
        {
          "email": "ben@benjamn.com",
          "name": "benjamn"
        },
        {
          "email": "james@meteor.com",
          "name": "jbaxleyiii"
        },
        {
          "email": "peggyrayzis@gmail.com",
          "name": "peggyrayzis"
        }
      ],
      "_npmUser": {
        "name": "apollo-bot",
        "email": "npm@apollographql.com"
      },
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/apollo-cache-inmemory_1.4.0-alpha.8_1547477046102_0.5410248784860157"
      },
      "_hasShrinkwrap": false
    },
    "1.4.0-alpha.10": {
      "name": "apollo-cache-inmemory",
      "version": "1.4.0-alpha.10",
      "description": "Core abstract of Caching layer for Apollo Client",
      "author": {
        "name": "James Baxley",
        "email": "james@meteor.com"
      },
      "contributors": [
        {
          "name": "James Baxley",
          "email": "james@meteor.com"
        },
        {
          "name": "Jonas Helfer",
          "email": "jonas@helfer.email"
        },
        {
          "name": "Sashko Stubailo",
          "email": "sashko@stubailo.com"
        },
        {
          "name": "James Burgess",
          "email": "jamesmillerburgess@gmail.com"
        },
        {
          "name": "Bazyli Brzóska",
          "email": "bazyli.brzoska@gmail.com"
        }
      ],
      "license": "MIT",
      "main": "./lib/bundle.umd.js",
      "module": "./lib/index.js",
      "jsnext:main": "./lib/index.js",
      "typings": "./lib/index.d.ts",
      "sideEffects": [
        "./lib/fixPolyfills.js"
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/apollographql/apollo-client.git"
      },
      "bugs": {
        "url": "https://github.com/apollographql/apollo-client/issues"
      },
      "homepage": "https://github.com/apollographql/apollo-client#readme",
      "scripts": {
        "prepare": "npm run build",
        "coverage": "jest --coverage",
        "test": "jest",
        "lint": "tslint -c \"../../config/tslint.json\" -p tsconfig.json src/*.ts",
        "prebuild": "npm run clean",
        "build": "tsc -p .",
        "postbuild": "npm run bundle",
        "bundle": "../../node_modules/rollup/bin/rollup -c rollup.config.js",
        "watch": "tsc -w -p .",
        "clean": "rm -rf coverage/* && rm -rf lib/*",
        "prepublishOnly": "npm run build",
        "minify": "../../node_modules/uglify-js/bin/uglifyjs -c -m -o ./lib/bundle.min.js -- ./lib/bundle.umd.js",
        "filesize": "npm run minify"
      },
      "dependencies": {
        "apollo-cache": "^1.2.0-alpha.8",
        "apollo-utilities": "^1.1.0-alpha.9",
        "optimism": "^0.6.8"
      },
      "peerDependencies": {
        "graphql": "0.11.7 || ^0.12.0 || ^0.13.0 || ^14.0.0"
      },
      "jest": {
        "transform": {
          ".(ts|tsx)": "ts-jest"
        },
        "testRegex": "(/__tests__/.*|\\.(test|spec))\\.(ts|tsx|js)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "json"
        ],
        "testURL": "http://localhost"
      },
      "gitHead": "e424cc917907a900e1a89b86b879d2b5e1e089b6",
      "readme": "---\ntitle: InMemoryCache\ndescription: An explanation of `apollo-cache-inmemory`\n---\n\n`apollo-cache-inmemory` is the recommended cache implementation for Apollo Client 2.0. `InMemoryCache` is a normalized data store that supports all of Apollo Client 1.0's features without the dependency on Redux.\n\nIn some instances, you may need to manipulate the cache directly, such as updating the store after a mutation. We'll cover some common use cases [here](#recipes).\n\n<h2 id=\"installation\">Installation</h2>\n\n```\nnpm install apollo-cache-inmemory --save\n```\n\nAfter installing the package, you'll want to initialize the cache constructor. Then, you can pass in your newly created cache to ApolloClient.\n\n```js\nimport { InMemoryCache } from 'apollo-cache-inmemory';\nimport { HttpLink } from 'apollo-link-http';\nimport ApolloClient from 'apollo-client';\n\nconst cache = new InMemoryCache();\n\nconst client = new ApolloClient({\n  link: new HttpLink(),\n  cache\n});\n```\n\n<h2 id=\"configuration\">Configuration</h2>\n\nThe `InMemoryCache` constructor takes an optional config object with properties to customize your cache:\n\n- addTypename: A boolean to determine whether to add __typename to the document (default: `true`)\n- dataIdFromObject: A function that takes a data object and returns a unique identifier to be used when normalizing the data in the store. Learn more about how to customize `dataIdFromObject` in the [Normalization](#normalization) section.\n- fragmentMatcher: By default, the `InMemoryCache` uses a heuristic fragment matcher. If you are using fragments on unions and interfaces, you will need to use an `IntrospectionFragmentMatcher`. For more information, please read [our guide to setting up fragment matching for unions & interfaces](https://www.apollographql.com/docs/react/advanced/fragments.html#fragment-matcher).\n\n<h2 id=\"normalization\">Normalization</h2>\n\nThe `InMemoryCache` normalizes your data before saving it to the store by splitting the result into individual objects, creating a unique identifier for each object, and storing those objects in a flattened data structure. By default, `InMemoryCache` will attempt to use the commonly found primary keys of `id` and `_id` for the unique identifier if they exist along with `__typename` on an object.\n\nIf `id` and `_id` are not specified, or if `__typename` is not specified, `InMemoryCache` will fall back to the path to the object in the query, such as `ROOT_QUERY.allPeople.0` for the first record returned on the `allPeople` root query.\n\nThis \"getter\" behavior for unique identifiers can be configured manually via the `dataIdFromObject` option passed to the `InMemoryCache` constructor, so you can pick which field is used if some of your data follows unorthodox primary key conventions.\n\nFor example, if you wanted to key off of the `key` field for all of your data, you could configure `dataIdFromObject` like so:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => object.key\n});\n```\n\nThis also allows you to use different unique identifiers for different data types by keying off of the `__typename` property attached to every object typed by GraphQL.  For example:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => {\n    switch (object.__typename) {\n      case 'foo': return object.key; // use `key` as the primary key\n      case 'bar': return object.blah; // use `blah` as the priamry key\n      default: return object.id || object._id; // fall back to `id` and `_id` for all other types\n    }\n  }\n});\n```\n\n<h2 id=\"direct\">Direct Cache Access</h2>\n\nTo interact directly with your cache, you can use the Apollo Client class methods readQuery, readFragment, writeQuery, and writeFragment. These methods are available to us via the [`DataProxy` interface](https://github.com/apollographql/apollo-client/blob/master/packages/apollo-cache/src/types/DataProxy.ts). Accessing these methods will vary slightly based on your view layer implementation. If you are using React, you can wrap your component in the `withApollo` higher order component, which will give you access to `this.props.client`. From there, you can use the methods to control your data.\n\nAny code demonstration in the following sections will assume that we have already initialized an instance of  `ApolloClient` and that we have imported the `gql` tag from `graphql-tag`.\n\n<h3 id=\"readquery\">readQuery</h3>\n\nThe `readQuery` method is very similar to the [`query` method on `ApolloClient`][] except that `readQuery` will _never_ make a request to your GraphQL server. The `query` method, on the other hand, may send a request to your server if the appropriate data is not in your cache whereas `readQuery` will throw an error if the data is not in your cache. `readQuery` will _always_ read from the cache. You can use `readQuery` by giving it a GraphQL query like so:\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo {\n      todo(id: 5) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n});\n```\n\nIf all of the data needed to fulfill this read is in Apollo Client’s normalized data cache then a data object will be returned in the shape of the query you wanted to read. If not all of the data needed to fulfill this read is in Apollo Client’s cache then an error will be thrown instead, so make sure to only read data that you know you have!\n\nYou can also pass variables into `readQuery`.\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo($id: Int!) {\n      todo(id: $id) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n  variables: {\n    id: 5,\n  },\n});\n```\n\n<h3 id=\"readfragment\">readFragment</h3>\n\nThis method allows you great flexibility around the data in your cache. Whereas `readQuery` only allowed you to read data from your root query type, `readFragment` allows you to read data from _any node you have queried_. This is incredibly powerful. You use this method as follows:\n\n```js\nconst todo = client.readFragment({\n  id: ..., // `id` is any id that could be returned by `dataIdFromObject`.\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\nThe first argument is the id of the data you want to read from the cache. That id must be a value that was returned by the `dataIdFromObject` function you defined when initializing `ApolloClient`. So for example if you initialized `ApolloClient` like so:\n\n```js\nconst client = new ApolloClient({\n  ...,\n  dataIdFromObject: object => object.id,\n});\n```\n\n…and you requested a todo before with an id of `5`, then you can read that todo out of your cache with the following:\n\n```js\nconst todo = client.readFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\n> **Note:** Most people add a `__typename` to the id in `dataIdFromObject`. If you do this then don’t forget to add the `__typename` when you are reading a fragment as well. So for example your id may be `Todo_5` and not just `5`.\n\nIf a todo with that id does not exist in the cache you will get `null` back. If a todo of that id does exist in the cache, but that todo does not have the `text` field then an error will be thrown.\n\nThe beauty of `readFragment` is that the todo could have come from anywhere! The todo could have been selected as a singleton (`{ todo(id: 5) { ... } }`), the todo could have come from a list of todos (`{ todos { ... } }`), or the todo could have come from a mutation (`mutation { createTodo { ... } }`). As long as at some point your GraphQL server gave you a todo with the provided id and fields `id`, `text`, and `completed` you can read it from the cache at any part of your code.\n\n<h3 id=\"writequery-and-writefragment\">writeQuery` and `writeFragment</h3>\n\nNot only can you read arbitrary data from the Apollo Client cache, but you can also write any data that you would like to the cache. The methods you use to do this are `writeQuery` and `writeFragment`. They will allow you to change data in your local cache, but it is important to remember that *they will not change any data on your server*. If you reload your environment then changes made with `writeQuery` and `writeFragment` will disappear.\n\nThese methods have the same signature as their `readQuery` and `readFragment` counterparts except they also require an additional `data` variable. So for example, if you wanted to update the `completed` flag locally for your todo with id `'5'` you could execute the following:\n\n```js\nclient.writeFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      completed\n    }\n  `,\n  data: {\n    completed: true,\n  },\n});\n```\n\nAny subscriber to the Apollo Client store will instantly see this update and render new UI accordingly.\n\n> **Note:** Again, remember that using `writeQuery` or `writeFragment` only changes data *locally*. If you reload your environment then changes made with these methods will no longer exist.\n\nOr if you wanted to add a new todo to a list fetched from the server, you could use `readQuery` and `writeQuery` together.\n\n```js\nconst query = gql`\n  query MyTodoAppQuery {\n    todos {\n      id\n      text\n      completed\n    }\n  }\n`;\n\nconst data = client.readQuery({ query });\n\nconst myNewTodo = {\n  id: '6',\n  text: 'Start using Apollo Client.',\n  completed: false,\n};\n\nclient.writeQuery({\n  query,\n  data: {\n    todos: [...data.todos, myNewTodo],\n  },\n});\n```\n\n<h2 id=\"recipes\">Recipes</h2>\n\nHere are some common situations where you would need to access the cache directly. If you're manipulating the cache in an interesting way and would like your example to be featured, please send in a pull request!\n\n<h3 id=\"server\">Server side rendering</h3>\n\nFirst, you will need to initialize an `InMemoryCache` on the server and create an instance of `ApolloClient`. In the initial serialized HTML payload from the server, you should include a script tag that extracts the data from the cache.\n\n```js\n`<script>\n  window.__APOLLO_STATE__=${JSON.stringify(cache.extract())}\n</script>`\n```\n\nOn the client, you can rehydrate the cache using the initial data passed from the server:\n\n```js\ncache: new Cache().restore(window.__APOLLO_STATE__)\n```\n\nIf you would like to learn more about server side rendering, please check our our more in depth guide [here].\n<!---\nTODO (PEGGY): Add link to SSR\n-->\n\n<h3 id=\"server\">Updating the cache after a mutation</h3>\n\nBeing able to read and write to the Apollo cache from anywhere in your application gives you a lot of power over your data. However, there is one place where we most often want to update our cached data: after a mutation. As such, Apollo Client has optimized the experience for updating your cache with the read and write methods after a mutation with the `update` function. Let us say that we have the following GraphQL mutation:\n\n```graphql\nmutation TodoCreateMutation($text: String!) {\n  createTodo(text: $text) {\n    id\n    text\n    completed\n  }\n}\n```\n\nWe may also have the following GraphQL query:\n\n```graphql\nquery TodoAppQuery {\n  todos {\n    id\n    text\n    completed\n  }\n}\n```\n\nAt the end of our mutation we want our query to include the new todo like we had sent our `TodoAppQuery` a second time after the mutation finished without actually sending the query. To do this we can use the `update` function provided as an option of the `client.mutate` method. To update your cache with the mutation just write code that looks like:\n\n```js\n// We assume that the GraphQL operations `TodoCreateMutation` and\n// `TodoAppQuery` have already been defined using the `gql` tag.\n\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    // Read the data from our cache for this query.\n    const data = proxy.readQuery({ query: TodoAppQuery });\n\n    // Add our todo from the mutation to the end.\n    data.todos.push(createTodo);\n\n    // Write our data back to the cache.\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nThe first `proxy` argument is an instance of [`DataProxy`][] has the same four methods that we just learned exist on the Apollo Client: `readQuery`, `readFragment`, `writeQuery`, and `writeFragment`. The reason we call them on a `proxy` object here instead of on our `client` instance is that we can easily apply optimistic updates (which we will demonstrate in a bit). The `proxy` object also provides an isolated transaction which shields you from any other mutations going on at the same time, and the `proxy` object also batches writes together until the very end.\n\nIf you provide an `optimisticResponse` option to the mutation then the `update` function will be run twice. Once immediately after you call `client.mutate` with the data from `optimisticResponse`. After the mutation successfully executes against the server the changes made in the first call to `update` will be rolled back and `update` will be called with the *actual* data returned by the mutation and not just the optimistic response.\n\nPutting it all together:\n\n```js\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  optimisticResponse: {\n    id: -1, // -1 is a temporary id for the optimistic response.\n    text,\n    completed: false,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    const data = proxy.readQuery({ query: TodoAppQuery });\n    data.todos.push(createTodo);\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nAs you can see the `update` function on `client.mutate` provides extra change management functionality specific to the use case of a mutation while still providing you the powerful data control APIs that are available on `client`.\n\nThe `update` function is not a good place for side-effects as it may be called multiple times. Also, you may not call any of the methods on `proxy` asynchronously.\n\n",
      "readmeFilename": "README.md",
      "_id": "apollo-cache-inmemory@1.4.0-alpha.10",
      "_nodeVersion": "8.12.0",
      "_npmVersion": "lerna/3.8.1/node@v8.12.0+x64 (darwin)",
      "dist": {
        "integrity": "sha512-6Gx/o7EdubbEhPyaicisBlaMg1mtKu1ucN+Kk4Mwy0BBUSad+K/lPxwKx9mRVv8+AWYetyGC0tIQRRCLoBblnA==",
        "shasum": "44ba2324e230d12692026924d16d1d3420294bca",
        "tarball": "https://registry.npmjs.org/apollo-cache-inmemory/-/apollo-cache-inmemory-1.4.0-alpha.10.tgz",
        "fileCount": 62,
        "unpackedSize": 318523,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJcPLVyCRA9TVsSAnZWagAAfu0P/2J25EBU8XXnF9fUtU0h\nTqYP4lvROFiErCwVjZ+LtZ61Lwb0I8SrHzmMwpvyMk58vIwu2lKpxDg784U6\nbKLsMLOK6tQaePfoqLfEghZLupoye0EmiG8z62Ony3bIyVULwKALOptr+IUE\nKQGvl6+xIIE3rl+zrGBWd5yd8M29GsYSrItAiDpSW/nuFmuaNTyZcboa36MR\njg/85GQaQ80mHEmOQ7+t3fBtlHc7q7qqVKWeh/5o/RoVmmVRAi3NAjS9rYeU\nVHINahwgGLtRFf/LN410sW65iUHg60uKDpiXl+MdlxwFx18WgDQgx49Jl0MY\nLJbgfI3YEYnFOh5ag+9sRa124gfCQ+5gT2oddjjlX6IlzGuEWcnBcHMeSFBc\ntMZGlzBbCpsF3LY33RndEJzNdDOCNmsRfKtYg+y0qlD0myz5XcMeQXFxWvBz\nVwLVecxmsBxlGLmu31GSHQfjGQtMal3wlZpy1pUmexze5MuP3V3mafeyAee9\n1L/7WoV+FoeNzl+Nc9nrQ0ZdbWkylWbtI4K+Tw+v9l/xD8wypKCN2EImOR1s\n+HzLz1Kjp9aVMGpgqbkiGkHYeimRUt7dIt8xH5I2Mo6usid6f8NsWwqn8OMg\npx++husUV/L6lo/19BjfsPHMCLKr3i3g2cuODrBOvoXAknOAu6ulAKqpt3u+\nHnoN\r\n=MG6W\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEYCIQCwpIojk2BXGawG5u+m9gEOWfp0pdxxmYnvf1TNPfKKbQIhAO8HaQ5NygFYg31jchFJoy2zTJe/sDCvHAOloiM6EThI"
          }
        ]
      },
      "maintainers": [
        {
          "email": "npm@apollographql.com",
          "name": "apollo-bot"
        },
        {
          "email": "ben@benjamn.com",
          "name": "benjamn"
        },
        {
          "email": "james@meteor.com",
          "name": "jbaxleyiii"
        },
        {
          "email": "peggyrayzis@gmail.com",
          "name": "peggyrayzis"
        }
      ],
      "_npmUser": {
        "name": "apollo-bot",
        "email": "npm@apollographql.com"
      },
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/apollo-cache-inmemory_1.4.0-alpha.10_1547482481381_0.08432341021123269"
      },
      "_hasShrinkwrap": false
    },
    "1.4.0-alpha.11": {
      "name": "apollo-cache-inmemory",
      "version": "1.4.0-alpha.11",
      "description": "Core abstract of Caching layer for Apollo Client",
      "author": {
        "name": "James Baxley",
        "email": "james@meteor.com"
      },
      "contributors": [
        {
          "name": "James Baxley",
          "email": "james@meteor.com"
        },
        {
          "name": "Jonas Helfer",
          "email": "jonas@helfer.email"
        },
        {
          "name": "Sashko Stubailo",
          "email": "sashko@stubailo.com"
        },
        {
          "name": "James Burgess",
          "email": "jamesmillerburgess@gmail.com"
        },
        {
          "name": "Bazyli Brzóska",
          "email": "bazyli.brzoska@gmail.com"
        }
      ],
      "license": "MIT",
      "main": "./lib/bundle.umd.js",
      "module": "./lib/index.js",
      "jsnext:main": "./lib/index.js",
      "typings": "./lib/index.d.ts",
      "sideEffects": [
        "./lib/fixPolyfills.js"
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/apollographql/apollo-client.git"
      },
      "bugs": {
        "url": "https://github.com/apollographql/apollo-client/issues"
      },
      "homepage": "https://github.com/apollographql/apollo-client#readme",
      "scripts": {
        "prepare": "npm run build",
        "coverage": "jest --coverage",
        "test": "jest",
        "lint": "tslint -c \"../../config/tslint.json\" -p tsconfig.json src/*.ts",
        "prebuild": "npm run clean",
        "build": "tsc -p .",
        "postbuild": "npm run bundle",
        "bundle": "../../node_modules/rollup/bin/rollup -c rollup.config.js",
        "watch": "tsc -w -p .",
        "clean": "rm -rf coverage/* && rm -rf lib/*",
        "prepublishOnly": "npm run build",
        "minify": "../../node_modules/uglify-js/bin/uglifyjs -c -m -o ./lib/bundle.min.js -- ./lib/bundle.umd.js",
        "filesize": "npm run minify"
      },
      "dependencies": {
        "apollo-cache": "^1.2.0-alpha.8",
        "apollo-utilities": "^1.1.0-alpha.9",
        "optimism": "^0.6.8"
      },
      "peerDependencies": {
        "graphql": "0.11.7 || ^0.12.0 || ^0.13.0 || ^14.0.0"
      },
      "jest": {
        "transform": {
          ".(ts|tsx)": "ts-jest"
        },
        "testRegex": "(/__tests__/.*|\\.(test|spec))\\.(ts|tsx|js)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "json"
        ],
        "testURL": "http://localhost"
      },
      "gitHead": "60a1b9990558a5c84bcf1de2bbe25ecd5f5cfe15",
      "readme": "---\ntitle: InMemoryCache\ndescription: An explanation of `apollo-cache-inmemory`\n---\n\n`apollo-cache-inmemory` is the recommended cache implementation for Apollo Client 2.0. `InMemoryCache` is a normalized data store that supports all of Apollo Client 1.0's features without the dependency on Redux.\n\nIn some instances, you may need to manipulate the cache directly, such as updating the store after a mutation. We'll cover some common use cases [here](#recipes).\n\n<h2 id=\"installation\">Installation</h2>\n\n```\nnpm install apollo-cache-inmemory --save\n```\n\nAfter installing the package, you'll want to initialize the cache constructor. Then, you can pass in your newly created cache to ApolloClient.\n\n```js\nimport { InMemoryCache } from 'apollo-cache-inmemory';\nimport { HttpLink } from 'apollo-link-http';\nimport ApolloClient from 'apollo-client';\n\nconst cache = new InMemoryCache();\n\nconst client = new ApolloClient({\n  link: new HttpLink(),\n  cache\n});\n```\n\n<h2 id=\"configuration\">Configuration</h2>\n\nThe `InMemoryCache` constructor takes an optional config object with properties to customize your cache:\n\n- addTypename: A boolean to determine whether to add __typename to the document (default: `true`)\n- dataIdFromObject: A function that takes a data object and returns a unique identifier to be used when normalizing the data in the store. Learn more about how to customize `dataIdFromObject` in the [Normalization](#normalization) section.\n- fragmentMatcher: By default, the `InMemoryCache` uses a heuristic fragment matcher. If you are using fragments on unions and interfaces, you will need to use an `IntrospectionFragmentMatcher`. For more information, please read [our guide to setting up fragment matching for unions & interfaces](https://www.apollographql.com/docs/react/advanced/fragments.html#fragment-matcher).\n\n<h2 id=\"normalization\">Normalization</h2>\n\nThe `InMemoryCache` normalizes your data before saving it to the store by splitting the result into individual objects, creating a unique identifier for each object, and storing those objects in a flattened data structure. By default, `InMemoryCache` will attempt to use the commonly found primary keys of `id` and `_id` for the unique identifier if they exist along with `__typename` on an object.\n\nIf `id` and `_id` are not specified, or if `__typename` is not specified, `InMemoryCache` will fall back to the path to the object in the query, such as `ROOT_QUERY.allPeople.0` for the first record returned on the `allPeople` root query.\n\nThis \"getter\" behavior for unique identifiers can be configured manually via the `dataIdFromObject` option passed to the `InMemoryCache` constructor, so you can pick which field is used if some of your data follows unorthodox primary key conventions.\n\nFor example, if you wanted to key off of the `key` field for all of your data, you could configure `dataIdFromObject` like so:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => object.key\n});\n```\n\nThis also allows you to use different unique identifiers for different data types by keying off of the `__typename` property attached to every object typed by GraphQL.  For example:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => {\n    switch (object.__typename) {\n      case 'foo': return object.key; // use `key` as the primary key\n      case 'bar': return object.blah; // use `blah` as the priamry key\n      default: return object.id || object._id; // fall back to `id` and `_id` for all other types\n    }\n  }\n});\n```\n\n<h2 id=\"direct\">Direct Cache Access</h2>\n\nTo interact directly with your cache, you can use the Apollo Client class methods readQuery, readFragment, writeQuery, and writeFragment. These methods are available to us via the [`DataProxy` interface](https://github.com/apollographql/apollo-client/blob/master/packages/apollo-cache/src/types/DataProxy.ts). Accessing these methods will vary slightly based on your view layer implementation. If you are using React, you can wrap your component in the `withApollo` higher order component, which will give you access to `this.props.client`. From there, you can use the methods to control your data.\n\nAny code demonstration in the following sections will assume that we have already initialized an instance of  `ApolloClient` and that we have imported the `gql` tag from `graphql-tag`.\n\n<h3 id=\"readquery\">readQuery</h3>\n\nThe `readQuery` method is very similar to the [`query` method on `ApolloClient`][] except that `readQuery` will _never_ make a request to your GraphQL server. The `query` method, on the other hand, may send a request to your server if the appropriate data is not in your cache whereas `readQuery` will throw an error if the data is not in your cache. `readQuery` will _always_ read from the cache. You can use `readQuery` by giving it a GraphQL query like so:\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo {\n      todo(id: 5) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n});\n```\n\nIf all of the data needed to fulfill this read is in Apollo Client’s normalized data cache then a data object will be returned in the shape of the query you wanted to read. If not all of the data needed to fulfill this read is in Apollo Client’s cache then an error will be thrown instead, so make sure to only read data that you know you have!\n\nYou can also pass variables into `readQuery`.\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo($id: Int!) {\n      todo(id: $id) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n  variables: {\n    id: 5,\n  },\n});\n```\n\n<h3 id=\"readfragment\">readFragment</h3>\n\nThis method allows you great flexibility around the data in your cache. Whereas `readQuery` only allowed you to read data from your root query type, `readFragment` allows you to read data from _any node you have queried_. This is incredibly powerful. You use this method as follows:\n\n```js\nconst todo = client.readFragment({\n  id: ..., // `id` is any id that could be returned by `dataIdFromObject`.\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\nThe first argument is the id of the data you want to read from the cache. That id must be a value that was returned by the `dataIdFromObject` function you defined when initializing `ApolloClient`. So for example if you initialized `ApolloClient` like so:\n\n```js\nconst client = new ApolloClient({\n  ...,\n  dataIdFromObject: object => object.id,\n});\n```\n\n…and you requested a todo before with an id of `5`, then you can read that todo out of your cache with the following:\n\n```js\nconst todo = client.readFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\n> **Note:** Most people add a `__typename` to the id in `dataIdFromObject`. If you do this then don’t forget to add the `__typename` when you are reading a fragment as well. So for example your id may be `Todo_5` and not just `5`.\n\nIf a todo with that id does not exist in the cache you will get `null` back. If a todo of that id does exist in the cache, but that todo does not have the `text` field then an error will be thrown.\n\nThe beauty of `readFragment` is that the todo could have come from anywhere! The todo could have been selected as a singleton (`{ todo(id: 5) { ... } }`), the todo could have come from a list of todos (`{ todos { ... } }`), or the todo could have come from a mutation (`mutation { createTodo { ... } }`). As long as at some point your GraphQL server gave you a todo with the provided id and fields `id`, `text`, and `completed` you can read it from the cache at any part of your code.\n\n<h3 id=\"writequery-and-writefragment\">writeQuery` and `writeFragment</h3>\n\nNot only can you read arbitrary data from the Apollo Client cache, but you can also write any data that you would like to the cache. The methods you use to do this are `writeQuery` and `writeFragment`. They will allow you to change data in your local cache, but it is important to remember that *they will not change any data on your server*. If you reload your environment then changes made with `writeQuery` and `writeFragment` will disappear.\n\nThese methods have the same signature as their `readQuery` and `readFragment` counterparts except they also require an additional `data` variable. So for example, if you wanted to update the `completed` flag locally for your todo with id `'5'` you could execute the following:\n\n```js\nclient.writeFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      completed\n    }\n  `,\n  data: {\n    completed: true,\n  },\n});\n```\n\nAny subscriber to the Apollo Client store will instantly see this update and render new UI accordingly.\n\n> **Note:** Again, remember that using `writeQuery` or `writeFragment` only changes data *locally*. If you reload your environment then changes made with these methods will no longer exist.\n\nOr if you wanted to add a new todo to a list fetched from the server, you could use `readQuery` and `writeQuery` together.\n\n```js\nconst query = gql`\n  query MyTodoAppQuery {\n    todos {\n      id\n      text\n      completed\n    }\n  }\n`;\n\nconst data = client.readQuery({ query });\n\nconst myNewTodo = {\n  id: '6',\n  text: 'Start using Apollo Client.',\n  completed: false,\n};\n\nclient.writeQuery({\n  query,\n  data: {\n    todos: [...data.todos, myNewTodo],\n  },\n});\n```\n\n<h2 id=\"recipes\">Recipes</h2>\n\nHere are some common situations where you would need to access the cache directly. If you're manipulating the cache in an interesting way and would like your example to be featured, please send in a pull request!\n\n<h3 id=\"server\">Server side rendering</h3>\n\nFirst, you will need to initialize an `InMemoryCache` on the server and create an instance of `ApolloClient`. In the initial serialized HTML payload from the server, you should include a script tag that extracts the data from the cache.\n\n```js\n`<script>\n  window.__APOLLO_STATE__=${JSON.stringify(cache.extract())}\n</script>`\n```\n\nOn the client, you can rehydrate the cache using the initial data passed from the server:\n\n```js\ncache: new Cache().restore(window.__APOLLO_STATE__)\n```\n\nIf you would like to learn more about server side rendering, please check our our more in depth guide [here].\n<!---\nTODO (PEGGY): Add link to SSR\n-->\n\n<h3 id=\"server\">Updating the cache after a mutation</h3>\n\nBeing able to read and write to the Apollo cache from anywhere in your application gives you a lot of power over your data. However, there is one place where we most often want to update our cached data: after a mutation. As such, Apollo Client has optimized the experience for updating your cache with the read and write methods after a mutation with the `update` function. Let us say that we have the following GraphQL mutation:\n\n```graphql\nmutation TodoCreateMutation($text: String!) {\n  createTodo(text: $text) {\n    id\n    text\n    completed\n  }\n}\n```\n\nWe may also have the following GraphQL query:\n\n```graphql\nquery TodoAppQuery {\n  todos {\n    id\n    text\n    completed\n  }\n}\n```\n\nAt the end of our mutation we want our query to include the new todo like we had sent our `TodoAppQuery` a second time after the mutation finished without actually sending the query. To do this we can use the `update` function provided as an option of the `client.mutate` method. To update your cache with the mutation just write code that looks like:\n\n```js\n// We assume that the GraphQL operations `TodoCreateMutation` and\n// `TodoAppQuery` have already been defined using the `gql` tag.\n\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    // Read the data from our cache for this query.\n    const data = proxy.readQuery({ query: TodoAppQuery });\n\n    // Add our todo from the mutation to the end.\n    data.todos.push(createTodo);\n\n    // Write our data back to the cache.\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nThe first `proxy` argument is an instance of [`DataProxy`][] has the same four methods that we just learned exist on the Apollo Client: `readQuery`, `readFragment`, `writeQuery`, and `writeFragment`. The reason we call them on a `proxy` object here instead of on our `client` instance is that we can easily apply optimistic updates (which we will demonstrate in a bit). The `proxy` object also provides an isolated transaction which shields you from any other mutations going on at the same time, and the `proxy` object also batches writes together until the very end.\n\nIf you provide an `optimisticResponse` option to the mutation then the `update` function will be run twice. Once immediately after you call `client.mutate` with the data from `optimisticResponse`. After the mutation successfully executes against the server the changes made in the first call to `update` will be rolled back and `update` will be called with the *actual* data returned by the mutation and not just the optimistic response.\n\nPutting it all together:\n\n```js\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  optimisticResponse: {\n    id: -1, // -1 is a temporary id for the optimistic response.\n    text,\n    completed: false,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    const data = proxy.readQuery({ query: TodoAppQuery });\n    data.todos.push(createTodo);\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nAs you can see the `update` function on `client.mutate` provides extra change management functionality specific to the use case of a mutation while still providing you the powerful data control APIs that are available on `client`.\n\nThe `update` function is not a good place for side-effects as it may be called multiple times. Also, you may not call any of the methods on `proxy` asynchronously.\n",
      "readmeFilename": "README.md",
      "_id": "apollo-cache-inmemory@1.4.0-alpha.11",
      "_nodeVersion": "8.12.0",
      "_npmVersion": "lerna/3.8.1/node@v8.12.0+x64 (darwin)",
      "dist": {
        "integrity": "sha512-wKr7seAZUSH9BFPv8jECyeiEFtT7FDMiYG2xvyzDG25Ods5wHrywZyr0yO+2KmfEfXofd20aVwrwa7RkYqvSTQ==",
        "shasum": "6f691168870344fb92532a84eeb70676822b8609",
        "tarball": "https://registry.npmjs.org/apollo-cache-inmemory/-/apollo-cache-inmemory-1.4.0-alpha.11.tgz",
        "fileCount": 62,
        "unpackedSize": 318522,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJcPLg/CRA9TVsSAnZWagAAz9UP/2aWIj7ooYfC2RZ2D6Hd\nKi9GTOVL7HFRkatUPE157K1H7/6cGiZXF3BWnrXRlXWxnWHQqB95YlgOfmzO\njcjYWS7+J9Kv+hRfJoQ209KhDmAevYQ79Ssp2whdJDG2x8xvLbOH+Yda7j0u\nXjrQKbxCn0Nw//jFG2prXGEMChDvcQ78iWaNzCdcMBb2cxwT5J+5j0f72t/i\naJ8v+yIr2H0gnIkELRLeUwA5QOMaU0CBu9LVNvnCfPHYFPBLoYm+u2cuK6v+\nn4UDL4jKZLvk8cP7fFUeVhn0UTtER5jrB0/2eO6ljlOYnyDObQbiYyF6V26E\nUZy17Z/58WMyoP5GsiwQJAjly94nJv/uxzD7olHcPxqwqq0Ou6ZqqqnzdOuX\nnqJ+p+xOd31JJAD5VeqWtjnlhk7vSNxZbwFSbVnIEjAyo9bDL37Ue0UErzs5\nid5SyvEK+EHkJnBnFuqKuXbF5CH9dp0OwqKmUSwTqjPbZg3nhKiGz5MZ8NXM\n5yMigXRY2nM6hPgMpq1Tl2G/m+Co0YH+9Rucf6jad4WrcqaNConFpheil/KP\nEGLOkYFulNzrsSBzR6q9H0psoS1xlw3DUKWIin3MpKPtakY9uPkot2xVQWYY\nw9L29xMv8Lh94S+7RzwGb0NfnGdsLIu+NGyWAy1shVUSyi8vkaJQAlLYQ/CH\nZAGJ\r\n=laCq\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEYCIQCwURI+ZcbZHqSOurej+fEYHwQ6aDud/nfQ5iVZ2V2isAIhAIslpqkXj3qwJbJcW6WPkzNyxkhKfIb17KM95cqcl11I"
          }
        ]
      },
      "maintainers": [
        {
          "email": "npm@apollographql.com",
          "name": "apollo-bot"
        },
        {
          "email": "ben@benjamn.com",
          "name": "benjamn"
        },
        {
          "email": "james@meteor.com",
          "name": "jbaxleyiii"
        },
        {
          "email": "peggyrayzis@gmail.com",
          "name": "peggyrayzis"
        }
      ],
      "_npmUser": {
        "name": "apollo-bot",
        "email": "npm@apollographql.com"
      },
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/apollo-cache-inmemory_1.4.0-alpha.11_1547483199169_0.41574619583692507"
      },
      "_hasShrinkwrap": false
    },
    "1.4.0-alpha.12": {
      "name": "apollo-cache-inmemory",
      "version": "1.4.0-alpha.12",
      "description": "Core abstract of Caching layer for Apollo Client",
      "author": {
        "name": "James Baxley",
        "email": "james@meteor.com"
      },
      "contributors": [
        {
          "name": "James Baxley",
          "email": "james@meteor.com"
        },
        {
          "name": "Jonas Helfer",
          "email": "jonas@helfer.email"
        },
        {
          "name": "Sashko Stubailo",
          "email": "sashko@stubailo.com"
        },
        {
          "name": "James Burgess",
          "email": "jamesmillerburgess@gmail.com"
        },
        {
          "name": "Bazyli Brzóska",
          "email": "bazyli.brzoska@gmail.com"
        }
      ],
      "license": "MIT",
      "main": "./lib/bundle.umd.js",
      "module": "./lib/index.js",
      "jsnext:main": "./lib/index.js",
      "typings": "./lib/index.d.ts",
      "sideEffects": [
        "./lib/fixPolyfills.js"
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/apollographql/apollo-client.git"
      },
      "bugs": {
        "url": "https://github.com/apollographql/apollo-client/issues"
      },
      "homepage": "https://github.com/apollographql/apollo-client#readme",
      "scripts": {
        "prepare": "npm run build",
        "coverage": "jest --coverage",
        "test": "jest",
        "lint": "tslint -c \"../../config/tslint.json\" -p tsconfig.json src/*.ts",
        "prebuild": "npm run clean",
        "build": "tsc -p .",
        "postbuild": "npm run bundle",
        "bundle": "../../node_modules/rollup/bin/rollup -c rollup.config.js",
        "watch": "tsc -w -p .",
        "clean": "rm -rf coverage/* && rm -rf lib/*",
        "prepublishOnly": "npm run build",
        "minify": "../../node_modules/uglify-js/bin/uglifyjs -c -m -o ./lib/bundle.min.js -- ./lib/bundle.umd.js",
        "filesize": "npm run minify"
      },
      "dependencies": {
        "apollo-cache": "^1.2.0-alpha.9",
        "apollo-utilities": "^1.1.0-alpha.10",
        "optimism": "^0.6.8"
      },
      "peerDependencies": {
        "graphql": "0.11.7 || ^0.12.0 || ^0.13.0 || ^14.0.0"
      },
      "jest": {
        "transform": {
          ".(ts|tsx)": "ts-jest"
        },
        "testRegex": "(/__tests__/.*|\\.(test|spec))\\.(ts|tsx|js)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "json"
        ],
        "testURL": "http://localhost"
      },
      "gitHead": "51e7d9af321668f188d66bc27aa4122bea96d2be",
      "readme": "---\ntitle: InMemoryCache\ndescription: An explanation of `apollo-cache-inmemory`\n---\n\n`apollo-cache-inmemory` is the recommended cache implementation for Apollo Client 2.0. `InMemoryCache` is a normalized data store that supports all of Apollo Client 1.0's features without the dependency on Redux.\n\nIn some instances, you may need to manipulate the cache directly, such as updating the store after a mutation. We'll cover some common use cases [here](#recipes).\n\n<h2 id=\"installation\">Installation</h2>\n\n```\nnpm install apollo-cache-inmemory --save\n```\n\nAfter installing the package, you'll want to initialize the cache constructor. Then, you can pass in your newly created cache to ApolloClient.\n\n```js\nimport { InMemoryCache } from 'apollo-cache-inmemory';\nimport { HttpLink } from 'apollo-link-http';\nimport ApolloClient from 'apollo-client';\n\nconst cache = new InMemoryCache();\n\nconst client = new ApolloClient({\n  link: new HttpLink(),\n  cache\n});\n```\n\n<h2 id=\"configuration\">Configuration</h2>\n\nThe `InMemoryCache` constructor takes an optional config object with properties to customize your cache:\n\n- addTypename: A boolean to determine whether to add __typename to the document (default: `true`)\n- dataIdFromObject: A function that takes a data object and returns a unique identifier to be used when normalizing the data in the store. Learn more about how to customize `dataIdFromObject` in the [Normalization](#normalization) section.\n- fragmentMatcher: By default, the `InMemoryCache` uses a heuristic fragment matcher. If you are using fragments on unions and interfaces, you will need to use an `IntrospectionFragmentMatcher`. For more information, please read [our guide to setting up fragment matching for unions & interfaces](https://www.apollographql.com/docs/react/advanced/fragments.html#fragment-matcher).\n\n<h2 id=\"normalization\">Normalization</h2>\n\nThe `InMemoryCache` normalizes your data before saving it to the store by splitting the result into individual objects, creating a unique identifier for each object, and storing those objects in a flattened data structure. By default, `InMemoryCache` will attempt to use the commonly found primary keys of `id` and `_id` for the unique identifier if they exist along with `__typename` on an object.\n\nIf `id` and `_id` are not specified, or if `__typename` is not specified, `InMemoryCache` will fall back to the path to the object in the query, such as `ROOT_QUERY.allPeople.0` for the first record returned on the `allPeople` root query.\n\nThis \"getter\" behavior for unique identifiers can be configured manually via the `dataIdFromObject` option passed to the `InMemoryCache` constructor, so you can pick which field is used if some of your data follows unorthodox primary key conventions.\n\nFor example, if you wanted to key off of the `key` field for all of your data, you could configure `dataIdFromObject` like so:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => object.key\n});\n```\n\nThis also allows you to use different unique identifiers for different data types by keying off of the `__typename` property attached to every object typed by GraphQL.  For example:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => {\n    switch (object.__typename) {\n      case 'foo': return object.key; // use `key` as the primary key\n      case 'bar': return object.blah; // use `blah` as the priamry key\n      default: return object.id || object._id; // fall back to `id` and `_id` for all other types\n    }\n  }\n});\n```\n\n<h2 id=\"direct\">Direct Cache Access</h2>\n\nTo interact directly with your cache, you can use the Apollo Client class methods readQuery, readFragment, writeQuery, and writeFragment. These methods are available to us via the [`DataProxy` interface](https://github.com/apollographql/apollo-client/blob/master/packages/apollo-cache/src/types/DataProxy.ts). Accessing these methods will vary slightly based on your view layer implementation. If you are using React, you can wrap your component in the `withApollo` higher order component, which will give you access to `this.props.client`. From there, you can use the methods to control your data.\n\nAny code demonstration in the following sections will assume that we have already initialized an instance of  `ApolloClient` and that we have imported the `gql` tag from `graphql-tag`.\n\n<h3 id=\"readquery\">readQuery</h3>\n\nThe `readQuery` method is very similar to the [`query` method on `ApolloClient`][] except that `readQuery` will _never_ make a request to your GraphQL server. The `query` method, on the other hand, may send a request to your server if the appropriate data is not in your cache whereas `readQuery` will throw an error if the data is not in your cache. `readQuery` will _always_ read from the cache. You can use `readQuery` by giving it a GraphQL query like so:\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo {\n      todo(id: 5) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n});\n```\n\nIf all of the data needed to fulfill this read is in Apollo Client’s normalized data cache then a data object will be returned in the shape of the query you wanted to read. If not all of the data needed to fulfill this read is in Apollo Client’s cache then an error will be thrown instead, so make sure to only read data that you know you have!\n\nYou can also pass variables into `readQuery`.\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo($id: Int!) {\n      todo(id: $id) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n  variables: {\n    id: 5,\n  },\n});\n```\n\n<h3 id=\"readfragment\">readFragment</h3>\n\nThis method allows you great flexibility around the data in your cache. Whereas `readQuery` only allowed you to read data from your root query type, `readFragment` allows you to read data from _any node you have queried_. This is incredibly powerful. You use this method as follows:\n\n```js\nconst todo = client.readFragment({\n  id: ..., // `id` is any id that could be returned by `dataIdFromObject`.\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\nThe first argument is the id of the data you want to read from the cache. That id must be a value that was returned by the `dataIdFromObject` function you defined when initializing `ApolloClient`. So for example if you initialized `ApolloClient` like so:\n\n```js\nconst client = new ApolloClient({\n  ...,\n  dataIdFromObject: object => object.id,\n});\n```\n\n…and you requested a todo before with an id of `5`, then you can read that todo out of your cache with the following:\n\n```js\nconst todo = client.readFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\n> **Note:** Most people add a `__typename` to the id in `dataIdFromObject`. If you do this then don’t forget to add the `__typename` when you are reading a fragment as well. So for example your id may be `Todo_5` and not just `5`.\n\nIf a todo with that id does not exist in the cache you will get `null` back. If a todo of that id does exist in the cache, but that todo does not have the `text` field then an error will be thrown.\n\nThe beauty of `readFragment` is that the todo could have come from anywhere! The todo could have been selected as a singleton (`{ todo(id: 5) { ... } }`), the todo could have come from a list of todos (`{ todos { ... } }`), or the todo could have come from a mutation (`mutation { createTodo { ... } }`). As long as at some point your GraphQL server gave you a todo with the provided id and fields `id`, `text`, and `completed` you can read it from the cache at any part of your code.\n\n<h3 id=\"writequery-and-writefragment\">writeQuery` and `writeFragment</h3>\n\nNot only can you read arbitrary data from the Apollo Client cache, but you can also write any data that you would like to the cache. The methods you use to do this are `writeQuery` and `writeFragment`. They will allow you to change data in your local cache, but it is important to remember that *they will not change any data on your server*. If you reload your environment then changes made with `writeQuery` and `writeFragment` will disappear.\n\nThese methods have the same signature as their `readQuery` and `readFragment` counterparts except they also require an additional `data` variable. So for example, if you wanted to update the `completed` flag locally for your todo with id `'5'` you could execute the following:\n\n```js\nclient.writeFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      completed\n    }\n  `,\n  data: {\n    completed: true,\n  },\n});\n```\n\nAny subscriber to the Apollo Client store will instantly see this update and render new UI accordingly.\n\n> **Note:** Again, remember that using `writeQuery` or `writeFragment` only changes data *locally*. If you reload your environment then changes made with these methods will no longer exist.\n\nOr if you wanted to add a new todo to a list fetched from the server, you could use `readQuery` and `writeQuery` together.\n\n```js\nconst query = gql`\n  query MyTodoAppQuery {\n    todos {\n      id\n      text\n      completed\n    }\n  }\n`;\n\nconst data = client.readQuery({ query });\n\nconst myNewTodo = {\n  id: '6',\n  text: 'Start using Apollo Client.',\n  completed: false,\n};\n\nclient.writeQuery({\n  query,\n  data: {\n    todos: [...data.todos, myNewTodo],\n  },\n});\n```\n\n<h2 id=\"recipes\">Recipes</h2>\n\nHere are some common situations where you would need to access the cache directly. If you're manipulating the cache in an interesting way and would like your example to be featured, please send in a pull request!\n\n<h3 id=\"server\">Server side rendering</h3>\n\nFirst, you will need to initialize an `InMemoryCache` on the server and create an instance of `ApolloClient`. In the initial serialized HTML payload from the server, you should include a script tag that extracts the data from the cache.\n\n```js\n`<script>\n  window.__APOLLO_STATE__=${JSON.stringify(cache.extract())}\n</script>`\n```\n\nOn the client, you can rehydrate the cache using the initial data passed from the server:\n\n```js\ncache: new Cache().restore(window.__APOLLO_STATE__)\n```\n\nIf you would like to learn more about server side rendering, please check our our more in depth guide [here].\n<!---\nTODO (PEGGY): Add link to SSR\n-->\n\n<h3 id=\"server\">Updating the cache after a mutation</h3>\n\nBeing able to read and write to the Apollo cache from anywhere in your application gives you a lot of power over your data. However, there is one place where we most often want to update our cached data: after a mutation. As such, Apollo Client has optimized the experience for updating your cache with the read and write methods after a mutation with the `update` function. Let us say that we have the following GraphQL mutation:\n\n```graphql\nmutation TodoCreateMutation($text: String!) {\n  createTodo(text: $text) {\n    id\n    text\n    completed\n  }\n}\n```\n\nWe may also have the following GraphQL query:\n\n```graphql\nquery TodoAppQuery {\n  todos {\n    id\n    text\n    completed\n  }\n}\n```\n\nAt the end of our mutation we want our query to include the new todo like we had sent our `TodoAppQuery` a second time after the mutation finished without actually sending the query. To do this we can use the `update` function provided as an option of the `client.mutate` method. To update your cache with the mutation just write code that looks like:\n\n```js\n// We assume that the GraphQL operations `TodoCreateMutation` and\n// `TodoAppQuery` have already been defined using the `gql` tag.\n\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    // Read the data from our cache for this query.\n    const data = proxy.readQuery({ query: TodoAppQuery });\n\n    // Add our todo from the mutation to the end.\n    data.todos.push(createTodo);\n\n    // Write our data back to the cache.\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nThe first `proxy` argument is an instance of [`DataProxy`][] has the same four methods that we just learned exist on the Apollo Client: `readQuery`, `readFragment`, `writeQuery`, and `writeFragment`. The reason we call them on a `proxy` object here instead of on our `client` instance is that we can easily apply optimistic updates (which we will demonstrate in a bit). The `proxy` object also provides an isolated transaction which shields you from any other mutations going on at the same time, and the `proxy` object also batches writes together until the very end.\n\nIf you provide an `optimisticResponse` option to the mutation then the `update` function will be run twice. Once immediately after you call `client.mutate` with the data from `optimisticResponse`. After the mutation successfully executes against the server the changes made in the first call to `update` will be rolled back and `update` will be called with the *actual* data returned by the mutation and not just the optimistic response.\n\nPutting it all together:\n\n```js\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  optimisticResponse: {\n    id: -1, // -1 is a temporary id for the optimistic response.\n    text,\n    completed: false,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    const data = proxy.readQuery({ query: TodoAppQuery });\n    data.todos.push(createTodo);\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nAs you can see the `update` function on `client.mutate` provides extra change management functionality specific to the use case of a mutation while still providing you the powerful data control APIs that are available on `client`.\n\nThe `update` function is not a good place for side-effects as it may be called multiple times. Also, you may not call any of the methods on `proxy` asynchronously.\n",
      "readmeFilename": "README.md",
      "_id": "apollo-cache-inmemory@1.4.0-alpha.12",
      "_nodeVersion": "8.12.0",
      "_npmVersion": "lerna/3.8.1/node@v8.12.0+x64 (darwin)",
      "dist": {
        "integrity": "sha512-4QvD1p4ncnuL0XuPMxxQSLA4Dg5kTL6JBo+Wo+PDRvTNDCTDgm+rWUgEmpMMTbvCPuofmjiBT7meLusgezYtYg==",
        "shasum": "fae34249e2f9e8bdc17082506aeebd32aac85c85",
        "tarball": "https://registry.npmjs.org/apollo-cache-inmemory/-/apollo-cache-inmemory-1.4.0-alpha.12.tgz",
        "fileCount": 62,
        "unpackedSize": 318523,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJcPMY5CRA9TVsSAnZWagAAhDgP+wVLIYFzH2uhellm5BAU\njOuygzgtGfL/Kc3WMjPLMH4Z77ZK6RQHfltGdVxfA9jj7XUJKtRNQZAvX0b2\nyF+WoRrhVcUhizlhFuh24yZqEfscR/PDLfwnAZtIzjLy0oHqhs/Xly2tpzY/\nV3W3zkJEE42pvlpx8Z/XrjRkYFaCbasi+AHVPNpsSwiC2lZ0EzhRTPqnp0rg\ntDekMA9Wc+Nammo/F07IUVh+7fKtjpcZMvNz/T4fe+hfl+KGKEFQjuAoZ2jR\njH41yjI8d8IcHhnQB3rSzjGPxqwRV5btExXySeU0CEa5dDU1O4n0ZJ9RjLED\nDcJHT67EaMQy/Byav/mdlEif36FiYiQTibjFiZdUkmtg0U5R2Y5ZGo0my87r\n34+MLGIkTq2R4jpVncyNsq/cC5JYKOnC7a9tvYSC7hqSEOipOQWnEhZgvJPS\nc7i5v9QWhqYJqIxh1rL7G87XkEzv7MXohg/wyrSFxGYuculhmxDb3ORWivet\n10iMKGi4Dzx5fQ3C+fmx0vFGJFcDa6eAEfJ/UjRfiTHKa4ay7QWUbEci3SWq\n3pbfMTI2IGiUpj6igN4Q2gv+iYejjWMI7gSUXiVi6bB47QkPbRy6ZBMRPGv9\nF+SEoE5m5MQ6lQwwYUtmAzEvDd+TeLK0r3XBnycUuxg1USBlnl1Yzo41rZiN\n5jJD\r\n=38Is\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEYCIQDScP9iGE44Y69S4Vm8VxHhjY7kWM2OfDGJc+beU7oJUQIhALTUSr3GEmRg/YZEU24SUZCncjPBCgo9fuTeq5tpSfMc"
          }
        ]
      },
      "maintainers": [
        {
          "email": "npm@apollographql.com",
          "name": "apollo-bot"
        },
        {
          "email": "ben@benjamn.com",
          "name": "benjamn"
        },
        {
          "email": "james@meteor.com",
          "name": "jbaxleyiii"
        },
        {
          "email": "peggyrayzis@gmail.com",
          "name": "peggyrayzis"
        }
      ],
      "_npmUser": {
        "name": "apollo-bot",
        "email": "npm@apollographql.com"
      },
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/apollo-cache-inmemory_1.4.0-alpha.12_1547486777037_0.1840013545647221"
      },
      "_hasShrinkwrap": false
    },
    "1.4.0": {
      "name": "apollo-cache-inmemory",
      "version": "1.4.0",
      "description": "Core abstract of Caching layer for Apollo Client",
      "author": {
        "name": "James Baxley",
        "email": "james@meteor.com"
      },
      "contributors": [
        {
          "name": "James Baxley",
          "email": "james@meteor.com"
        },
        {
          "name": "Jonas Helfer",
          "email": "jonas@helfer.email"
        },
        {
          "name": "Sashko Stubailo",
          "email": "sashko@stubailo.com"
        },
        {
          "name": "James Burgess",
          "email": "jamesmillerburgess@gmail.com"
        },
        {
          "name": "Bazyli Brzóska",
          "email": "bazyli.brzoska@gmail.com"
        }
      ],
      "license": "MIT",
      "main": "./lib/bundle.umd.js",
      "module": "./lib/index.js",
      "jsnext:main": "./lib/index.js",
      "typings": "./lib/index.d.ts",
      "sideEffects": [
        "./lib/fixPolyfills.js"
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/apollographql/apollo-client.git"
      },
      "bugs": {
        "url": "https://github.com/apollographql/apollo-client/issues"
      },
      "homepage": "https://github.com/apollographql/apollo-client#readme",
      "scripts": {
        "prepare": "npm run build",
        "coverage": "jest --coverage",
        "test": "jest",
        "lint": "tslint -c \"../../config/tslint.json\" -p tsconfig.json src/*.ts",
        "prebuild": "npm run clean",
        "build": "tsc -p .",
        "postbuild": "npm run bundle",
        "bundle": "../../node_modules/rollup/bin/rollup -c rollup.config.js",
        "watch": "tsc -w -p .",
        "clean": "rm -rf coverage/* && rm -rf lib/*",
        "prepublishOnly": "npm run build",
        "minify": "../../node_modules/uglify-js/bin/uglifyjs -c -m -o ./lib/bundle.min.js -- ./lib/bundle.umd.js",
        "filesize": "npm run minify"
      },
      "dependencies": {
        "apollo-cache": "^1.1.23",
        "apollo-utilities": "^1.1.0",
        "optimism": "^0.6.8"
      },
      "peerDependencies": {
        "graphql": "0.11.7 || ^0.12.0 || ^0.13.0 || ^14.0.0"
      },
      "jest": {
        "transform": {
          ".(ts|tsx)": "ts-jest"
        },
        "testRegex": "(/__tests__/.*|\\.(test|spec))\\.(ts|tsx|js)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "json"
        ],
        "testURL": "http://localhost"
      },
      "gitHead": "449788f7e2030e41776535fc50efd72b313c2cc7",
      "_id": "apollo-cache-inmemory@1.4.0",
      "_nodeVersion": "8.15.0",
      "_npmVersion": "lerna/3.10.5/node@v8.15.0+x64 (darwin)",
      "_npmUser": {
        "name": "benjamn",
        "email": "ben@benjamn.com"
      },
      "dist": {
        "integrity": "sha512-gqwiZCApG+hRXEbtDrNIUtNcKKeO3RTih4mydJZRJpFp+PgBf8AZ2z4/uTJFFijmR9krmUWdCRfW1Aesb5+Ktg==",
        "shasum": "8bcb1de8d1950dcdbd42f9af6d16fccca8e9e9ca",
        "tarball": "https://registry.npmjs.org/apollo-cache-inmemory/-/apollo-cache-inmemory-1.4.0.tgz",
        "fileCount": 58,
        "unpackedSize": 301817,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJcQOMTCRA9TVsSAnZWagAAxZ8P/RpClcahSp5m88qfFbgS\nYEFG3X4z2t5983tmHfL28lY9b6+qBnrZBtlUWw6OZHOZzLCl3b6yE72e5ptv\nrcGbGbe31t61DldlMzK86nGBTYYijWtmnhMpQy9CTmRNwgkDh2kAN1sVoCjx\n8SAoili0kdUcu2bxNobe+mn/dOk9ylylRNKfZvFTpBWPnhd7QOYWl9hZA/Z4\nT5siKQBHIc6mv7mX57pkXo2ibARPd55GLfacp0N4BEqAQCIUC2ucCWtZEY41\nRlvW1b1UyxyipFnS17lq/djsHzn69hnoK8dK8XPGPZUzA9gYSxbTymM2t+3a\nBuaUESVlyXSMBEljQEy9KJO1d8pBXj9Cxm/21wsuLWTxb71WnOF2JA4p7m95\nEs6I4Y1dBVX9pgeukx8zrNHBmicBTsAO2XnuqC96cp+FE97HApmRQ0Xs0NzF\nT6Wqv3gHM5Ag3WRIaVTyVq0prjcrwrv6KbIxWrBhAVW/h4hEclR4i569Zot1\nJTz0uNwxvFw27Ag3WYpdu4lqD2ELWPo0V0LapC0FagQWu6VPN8elg1fOWn4X\nicYllaCTrf+Ciq0IfkXvF2Xv7UWmJttsO096I7XO9yt7Hexkrmqb2zULwLhh\nOLFSEHHjjWQHcPdvCWDO4X1cvL22oKbMAECfBz4peYuzZFck9ovOIQZMvITN\nRmXt\r\n=ha4G\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIQCLaCL7bZwc5dgAponi0cYq1+qQx/KFLTr9KTkqnOsLbAIgQNEyp/o1HKuwAYpj35F72QUNRSYvqMjkinqAp2dvGFQ="
          }
        ]
      },
      "maintainers": [
        {
          "email": "npm@apollographql.com",
          "name": "apollo-bot"
        },
        {
          "email": "ben@benjamn.com",
          "name": "benjamn"
        },
        {
          "email": "james@meteor.com",
          "name": "jbaxleyiii"
        },
        {
          "email": "peggyrayzis@gmail.com",
          "name": "peggyrayzis"
        }
      ],
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/apollo-cache-inmemory_1.4.0_1547756306670_0.20907273590300313"
      },
      "_hasShrinkwrap": false
    },
    "1.4.1": {
      "name": "apollo-cache-inmemory",
      "version": "1.4.1",
      "description": "Core abstract of Caching layer for Apollo Client",
      "author": {
        "name": "James Baxley",
        "email": "james@meteor.com"
      },
      "contributors": [
        {
          "name": "James Baxley",
          "email": "james@meteor.com"
        },
        {
          "name": "Jonas Helfer",
          "email": "jonas@helfer.email"
        },
        {
          "name": "Sashko Stubailo",
          "email": "sashko@stubailo.com"
        },
        {
          "name": "James Burgess",
          "email": "jamesmillerburgess@gmail.com"
        },
        {
          "name": "Bazyli Brzóska",
          "email": "bazyli.brzoska@gmail.com"
        }
      ],
      "license": "MIT",
      "main": "./lib/bundle.umd.js",
      "module": "./lib/index.js",
      "jsnext:main": "./lib/index.js",
      "typings": "./lib/index.d.ts",
      "sideEffects": [
        "./lib/fixPolyfills.js"
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/apollographql/apollo-client.git"
      },
      "bugs": {
        "url": "https://github.com/apollographql/apollo-client/issues"
      },
      "homepage": "https://github.com/apollographql/apollo-client#readme",
      "scripts": {
        "prepare": "npm run build",
        "coverage": "jest --coverage",
        "test": "jest",
        "lint": "tslint -c \"../../config/tslint.json\" -p tsconfig.json src/*.ts",
        "prebuild": "npm run clean",
        "build": "tsc -p .",
        "postbuild": "npm run bundle",
        "bundle": "../../node_modules/rollup/bin/rollup -c rollup.config.js",
        "watch": "tsc -w -p .",
        "clean": "rm -rf coverage/* && rm -rf lib/*",
        "prepublishOnly": "npm run build",
        "minify": "../../node_modules/uglify-js/bin/uglifyjs -c -m -o ./lib/bundle.min.js -- ./lib/bundle.umd.js",
        "filesize": "npm run minify"
      },
      "dependencies": {
        "apollo-cache": "^1.1.24",
        "apollo-utilities": "^1.1.1",
        "optimism": "^0.6.9"
      },
      "peerDependencies": {
        "graphql": "0.11.7 || ^0.12.0 || ^0.13.0 || ^14.0.0"
      },
      "jest": {
        "transform": {
          ".(ts|tsx)": "ts-jest"
        },
        "testRegex": "(/__tests__/.*|\\.(test|spec))\\.(ts|tsx|js)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "json"
        ],
        "testURL": "http://localhost"
      },
      "gitHead": "decc8fae87249d496608ffa3f46a38b5e635517b",
      "_id": "apollo-cache-inmemory@1.4.1",
      "_nodeVersion": "8.15.0",
      "_npmVersion": "lerna/3.10.5/node@v8.15.0+x64 (darwin)",
      "_npmUser": {
        "name": "benjamn",
        "email": "ben@benjamn.com"
      },
      "dist": {
        "integrity": "sha512-kF5J7k4RxzQpmb34PlIQ1/2jT+MFDyhQDvx5T/flIeg1HRZtWEPq3pOK1cEy8Tw1ITkJbeYNQJ6TP9JDCCj7RA==",
        "shasum": "91211742d61305fb4e2a6fc2272a66b2c651b7f3",
        "tarball": "https://registry.npmjs.org/apollo-cache-inmemory/-/apollo-cache-inmemory-1.4.1.tgz",
        "fileCount": 54,
        "unpackedSize": 282041,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJcQgwqCRA9TVsSAnZWagAAh1YP/i1hLSU04mW0rdJWn1GR\nxt/tLTOqwjSRWxxUaAlaz0ZQmEK4Rcw++jtcSM3vUAtcCRjHwVVil2x4w6Fo\nov4fgXloc6TWQdJYcbsHDWIV4QGyxbH9/Of72iwUzzpqu+Vv87r0Zgd9BwiL\n45TfobmxdAs+2fXklm57z6bZfQgdUD81GaNIaAMN3HNhyuFxF+yRr2l3jdjV\nJcAGtbmmk59JG+p8NTrw7CuMbwtizZ6MaefWL3S6r/sowo2xawZILNme4S0i\na3w+GSBV7P7TzgXJdeCCXWeD6/TRHkFXwAFPMxFRNp3hGgQNetVkuMTlNRJD\nCROIfmualTPMrNAb2+fSCItiZ23cMXHO/O11HEPyGOq0QLV2GRH/2Hmt0FWo\nGDY9bSMTJ5V7ptNiD3T6RDbPXJouDq+upW+9ED7CGYj0DRembbnu21e5l9wQ\n1i6xnlBLoMXomZuVhBsckgRM3E87HwxfdcvK54CzdhLYm4YKsqIVR0D89oCL\nBEVqw9BOJKhLVv+hsBdmKeJ7sFsu4Y5zsjzh1FFiDbYIkAEKoQetnEaMbz0G\nNsa2pp1Wd++1q98A/+U4dNxU3Ift6ACJT7eHgyj609Mi5ZkdjLh73qhdjiek\nMCx79gOePQMZlyIqfcI8dm8qMLTS+r/UiDDZC/thRpYiLzomxst25pBbAn6H\naGvb\r\n=cE8T\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIQDRnmf5BCe6bLpMMXfVKQ3IHOcrN1MK/kLQkHD+R5BaCwIgZrXIpDvoKrLPTnstDJZsX831GF11dPa6+N5l5FFRB50="
          }
        ]
      },
      "maintainers": [
        {
          "email": "npm@apollographql.com",
          "name": "apollo-bot"
        },
        {
          "email": "ben@benjamn.com",
          "name": "benjamn"
        },
        {
          "email": "james@meteor.com",
          "name": "jbaxleyiii"
        },
        {
          "email": "peggyrayzis@gmail.com",
          "name": "peggyrayzis"
        }
      ],
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/apollo-cache-inmemory_1.4.1_1547832361330_0.7414484506738086"
      },
      "_hasShrinkwrap": false
    },
    "1.4.2": {
      "name": "apollo-cache-inmemory",
      "version": "1.4.2",
      "description": "Core abstract of Caching layer for Apollo Client",
      "author": {
        "name": "James Baxley",
        "email": "james@meteor.com"
      },
      "contributors": [
        {
          "name": "James Baxley",
          "email": "james@meteor.com"
        },
        {
          "name": "Jonas Helfer",
          "email": "jonas@helfer.email"
        },
        {
          "name": "Sashko Stubailo",
          "email": "sashko@stubailo.com"
        },
        {
          "name": "James Burgess",
          "email": "jamesmillerburgess@gmail.com"
        },
        {
          "name": "Bazyli Brzóska",
          "email": "bazyli.brzoska@gmail.com"
        }
      ],
      "license": "MIT",
      "main": "./lib/bundle.umd.js",
      "module": "./lib/index.js",
      "jsnext:main": "./lib/index.js",
      "typings": "./lib/index.d.ts",
      "sideEffects": [
        "./lib/fixPolyfills.js"
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/apollographql/apollo-client.git"
      },
      "bugs": {
        "url": "https://github.com/apollographql/apollo-client/issues"
      },
      "homepage": "https://github.com/apollographql/apollo-client#readme",
      "scripts": {
        "prepare": "npm run build",
        "coverage": "jest --coverage",
        "test": "jest",
        "lint": "tslint -c \"../../config/tslint.json\" -p tsconfig.json src/*.ts",
        "prebuild": "npm run clean",
        "build": "tsc -p .",
        "postbuild": "npm run bundle",
        "bundle": "../../node_modules/rollup/bin/rollup -c rollup.config.js",
        "watch": "tsc -w -p .",
        "clean": "rm -rf coverage/* && rm -rf lib/*",
        "prepublishOnly": "npm run build",
        "minify": "../../node_modules/uglify-js/bin/uglifyjs -c -m -o ./lib/bundle.min.js -- ./lib/bundle.umd.js",
        "filesize": "npm run minify"
      },
      "dependencies": {
        "apollo-cache": "^1.1.25",
        "apollo-utilities": "^1.1.2",
        "optimism": "^0.6.9",
        "tslib": "^1.9.3"
      },
      "peerDependencies": {
        "graphql": "0.11.7 || ^0.12.0 || ^0.13.0 || ^14.0.0"
      },
      "jest": {
        "transform": {
          ".(ts|tsx)": "ts-jest"
        },
        "testRegex": "(/__tests__/.*|\\.(test|spec))\\.(ts|tsx|js)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "json"
        ],
        "testURL": "http://localhost"
      },
      "gitHead": "42a474ce983964a3eb3fc4b1e5d90ebacffeb739",
      "_id": "apollo-cache-inmemory@1.4.2",
      "_nodeVersion": "8.15.0",
      "_npmVersion": "lerna/3.10.5/node@v8.15.0+x64 (darwin)",
      "_npmUser": {
        "name": "benjamn",
        "email": "ben@benjamn.com"
      },
      "dist": {
        "integrity": "sha512-fDVmj5j1e3W+inyuSwjIcMgbQ4edcFgmiKTBMFAEKAq0jg33X7FrbDX8JT2t5Vuf75Mva50JDlt5wXdu7C6WuA==",
        "shasum": "c91aeb4adff45cdc7872d603cbff055fa9cd5021",
        "tarball": "https://registry.npmjs.org/apollo-cache-inmemory/-/apollo-cache-inmemory-1.4.2.tgz",
        "fileCount": 54,
        "unpackedSize": 282058,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJcQlCVCRA9TVsSAnZWagAAxt8QAITnm+U4VYQwa8UztH9W\nY8l/AT7cVaALvFWtL8t6OouBjaN9reSLO+WFDEEUo3uBmGKksyKjcw9pK0c/\ntMQwmKKFqYf+3e0tFtMcK1jWP52h2qkTRrs9DqTqSqB0+mvRmdnkN8o3rdzm\nwljMZgacG9PtA6gx++kDkslaNVh4CpSZFzmTIlj9Mgt6kFwU6iEBfKfl1NU6\nZvDNV4Qr+Kih3FNunIoAHx5BQoqhD9EIq/VaYAomMjajfLqD6WCgJTQEVIlz\nhJGwB/5e4vg26LJqGetHJKrU9hl1cdWGUyzelNdCxf+ENtafw8O7jXp/xI86\nsPXJ24cNv9IR44Gia7aAhT2NJGEHjk19zJP8SKkMnzGJZ+Y+IxIZ+S7eWVuS\np5UzfRgTj+uYzjR5d1KiloPpBcbhv7gGGNFeEM74EKjvMAwvRYulnsr1vXKW\nzBM9pZakkOjLvUvVNedYNC0/pKU52Rz2MVIa7yOtZ57x6XcPJKKRSd0kRoi3\nwQ54NjrOuyC1p4Vx8wa+ml644mlI6WdKzxNY9YQclnv3YMnAxuN8qSHhnAac\nXxeayTSZ6XjN/LzIiBO771ruZ2ASGmZKKKUi4eUEPejsOwkijT2A7sFVJHpT\n5wkEPyPlAOBoYv+POp2ZuPT/u/mjGnPxVX6jMUswe9GGKsZWRFh254kUA7lt\nmavd\r\n=onsN\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIQDbj8lX/1YlmvRwiNaqfNpQx+1VkmEscKSaqwtHxL4xmQIgMFb/KIcDYYlnF4G6rMbz3STpWNlbauIAmUuYMh5peGQ="
          }
        ]
      },
      "maintainers": [
        {
          "email": "npm@apollographql.com",
          "name": "apollo-bot"
        },
        {
          "email": "ben@benjamn.com",
          "name": "benjamn"
        },
        {
          "email": "james@meteor.com",
          "name": "jbaxleyiii"
        },
        {
          "email": "peggyrayzis@gmail.com",
          "name": "peggyrayzis"
        }
      ],
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/apollo-cache-inmemory_1.4.2_1547849876969_0.8249212043885217"
      },
      "_hasShrinkwrap": false
    },
    "1.5.0-beta.0": {
      "name": "apollo-cache-inmemory",
      "version": "1.5.0-beta.0",
      "description": "Core abstract of Caching layer for Apollo Client",
      "author": {
        "name": "James Baxley",
        "email": "james@meteor.com"
      },
      "contributors": [
        {
          "name": "James Baxley",
          "email": "james@meteor.com"
        },
        {
          "name": "Jonas Helfer",
          "email": "jonas@helfer.email"
        },
        {
          "name": "Sashko Stubailo",
          "email": "sashko@stubailo.com"
        },
        {
          "name": "James Burgess",
          "email": "jamesmillerburgess@gmail.com"
        },
        {
          "name": "Bazyli Brzóska",
          "email": "bazyli.brzoska@gmail.com"
        }
      ],
      "license": "MIT",
      "main": "./lib/bundle.umd.js",
      "module": "./lib/index.js",
      "jsnext:main": "./lib/index.js",
      "typings": "./lib/index.d.ts",
      "sideEffects": [
        "./lib/fixPolyfills.js"
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/apollographql/apollo-client.git"
      },
      "bugs": {
        "url": "https://github.com/apollographql/apollo-client/issues"
      },
      "homepage": "https://github.com/apollographql/apollo-client#readme",
      "scripts": {
        "prepare": "npm run build",
        "coverage": "jest --coverage",
        "test": "jest",
        "lint": "tslint -c \"../../config/tslint.json\" -p tsconfig.json src/*.ts",
        "prebuild": "npm run clean",
        "build": "tsc -p .",
        "postbuild": "npm run bundle",
        "bundle": "../../node_modules/rollup/bin/rollup -c rollup.config.js",
        "watch": "tsc -w -p .",
        "clean": "rm -rf coverage/* && rm -rf lib/*",
        "prepublishOnly": "npm run build",
        "minify": "../../node_modules/uglify-js/bin/uglifyjs -c -m -o ./lib/bundle.min.js -- ./lib/bundle.umd.js",
        "filesize": "npm run minify"
      },
      "dependencies": {
        "apollo-cache": "^1.2.0-beta.0",
        "apollo-utilities": "^1.2.0-beta.0",
        "optimism": "^0.6.9",
        "tslib": "^1.9.3"
      },
      "peerDependencies": {
        "graphql": "0.11.7 || ^0.12.0 || ^0.13.0 || ^14.0.0"
      },
      "jest": {
        "transform": {
          ".(ts|tsx)": "ts-jest"
        },
        "testRegex": "(/__tests__/.*|\\.(test|spec))\\.(ts|tsx|js)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "json"
        ],
        "testURL": "http://localhost"
      },
      "gitHead": "b49a7e851b5637eb9bf3784781fd2c8881a2d2d8",
      "readme": "---\ntitle: InMemoryCache\ndescription: An explanation of `apollo-cache-inmemory`\n---\n\n`apollo-cache-inmemory` is the recommended cache implementation for Apollo Client 2.0. `InMemoryCache` is a normalized data store that supports all of Apollo Client 1.0's features without the dependency on Redux.\n\nIn some instances, you may need to manipulate the cache directly, such as updating the store after a mutation. We'll cover some common use cases [here](#recipes).\n\n<h2 id=\"installation\">Installation</h2>\n\n```\nnpm install apollo-cache-inmemory --save\n```\n\nAfter installing the package, you'll want to initialize the cache constructor. Then, you can pass in your newly created cache to ApolloClient.\n\n```js\nimport { InMemoryCache } from 'apollo-cache-inmemory';\nimport { HttpLink } from 'apollo-link-http';\nimport ApolloClient from 'apollo-client';\n\nconst cache = new InMemoryCache();\n\nconst client = new ApolloClient({\n  link: new HttpLink(),\n  cache\n});\n```\n\n<h2 id=\"configuration\">Configuration</h2>\n\nThe `InMemoryCache` constructor takes an optional config object with properties to customize your cache:\n\n- addTypename: A boolean to determine whether to add __typename to the document (default: `true`)\n- dataIdFromObject: A function that takes a data object and returns a unique identifier to be used when normalizing the data in the store. Learn more about how to customize `dataIdFromObject` in the [Normalization](#normalization) section.\n- fragmentMatcher: By default, the `InMemoryCache` uses a heuristic fragment matcher. If you are using fragments on unions and interfaces, you will need to use an `IntrospectionFragmentMatcher`. For more information, please read [our guide to setting up fragment matching for unions & interfaces](https://www.apollographql.com/docs/react/advanced/fragments.html#fragment-matcher).\n\n<h2 id=\"normalization\">Normalization</h2>\n\nThe `InMemoryCache` normalizes your data before saving it to the store by splitting the result into individual objects, creating a unique identifier for each object, and storing those objects in a flattened data structure. By default, `InMemoryCache` will attempt to use the commonly found primary keys of `id` and `_id` for the unique identifier if they exist along with `__typename` on an object.\n\nIf `id` and `_id` are not specified, or if `__typename` is not specified, `InMemoryCache` will fall back to the path to the object in the query, such as `ROOT_QUERY.allPeople.0` for the first record returned on the `allPeople` root query.\n\nThis \"getter\" behavior for unique identifiers can be configured manually via the `dataIdFromObject` option passed to the `InMemoryCache` constructor, so you can pick which field is used if some of your data follows unorthodox primary key conventions.\n\nFor example, if you wanted to key off of the `key` field for all of your data, you could configure `dataIdFromObject` like so:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => object.key\n});\n```\n\nThis also allows you to use different unique identifiers for different data types by keying off of the `__typename` property attached to every object typed by GraphQL.  For example:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => {\n    switch (object.__typename) {\n      case 'foo': return object.key; // use `key` as the primary key\n      case 'bar': return object.blah; // use `blah` as the priamry key\n      default: return object.id || object._id; // fall back to `id` and `_id` for all other types\n    }\n  }\n});\n```\n\n<h2 id=\"direct\">Direct Cache Access</h2>\n\nTo interact directly with your cache, you can use the Apollo Client class methods readQuery, readFragment, writeQuery, and writeFragment. These methods are available to us via the [`DataProxy` interface](https://github.com/apollographql/apollo-client/blob/master/packages/apollo-cache/src/types/DataProxy.ts). Accessing these methods will vary slightly based on your view layer implementation. If you are using React, you can wrap your component in the `withApollo` higher order component, which will give you access to `this.props.client`. From there, you can use the methods to control your data.\n\nAny code demonstration in the following sections will assume that we have already initialized an instance of  `ApolloClient` and that we have imported the `gql` tag from `graphql-tag`.\n\n<h3 id=\"readquery\">readQuery</h3>\n\nThe `readQuery` method is very similar to the [`query` method on `ApolloClient`][] except that `readQuery` will _never_ make a request to your GraphQL server. The `query` method, on the other hand, may send a request to your server if the appropriate data is not in your cache whereas `readQuery` will throw an error if the data is not in your cache. `readQuery` will _always_ read from the cache. You can use `readQuery` by giving it a GraphQL query like so:\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo {\n      todo(id: 5) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n});\n```\n\nIf all of the data needed to fulfill this read is in Apollo Client’s normalized data cache then a data object will be returned in the shape of the query you wanted to read. If not all of the data needed to fulfill this read is in Apollo Client’s cache then an error will be thrown instead, so make sure to only read data that you know you have!\n\nYou can also pass variables into `readQuery`.\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo($id: Int!) {\n      todo(id: $id) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n  variables: {\n    id: 5,\n  },\n});\n```\n\n<h3 id=\"readfragment\">readFragment</h3>\n\nThis method allows you great flexibility around the data in your cache. Whereas `readQuery` only allowed you to read data from your root query type, `readFragment` allows you to read data from _any node you have queried_. This is incredibly powerful. You use this method as follows:\n\n```js\nconst todo = client.readFragment({\n  id: ..., // `id` is any id that could be returned by `dataIdFromObject`.\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\nThe first argument is the id of the data you want to read from the cache. That id must be a value that was returned by the `dataIdFromObject` function you defined when initializing `ApolloClient`. So for example if you initialized `ApolloClient` like so:\n\n```js\nconst client = new ApolloClient({\n  ...,\n  dataIdFromObject: object => object.id,\n});\n```\n\n…and you requested a todo before with an id of `5`, then you can read that todo out of your cache with the following:\n\n```js\nconst todo = client.readFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\n> **Note:** Most people add a `__typename` to the id in `dataIdFromObject`. If you do this then don’t forget to add the `__typename` when you are reading a fragment as well. So for example your id may be `Todo_5` and not just `5`.\n\nIf a todo with that id does not exist in the cache you will get `null` back. If a todo of that id does exist in the cache, but that todo does not have the `text` field then an error will be thrown.\n\nThe beauty of `readFragment` is that the todo could have come from anywhere! The todo could have been selected as a singleton (`{ todo(id: 5) { ... } }`), the todo could have come from a list of todos (`{ todos { ... } }`), or the todo could have come from a mutation (`mutation { createTodo { ... } }`). As long as at some point your GraphQL server gave you a todo with the provided id and fields `id`, `text`, and `completed` you can read it from the cache at any part of your code.\n\n<h3 id=\"writequery-and-writefragment\">writeQuery` and `writeFragment</h3>\n\nNot only can you read arbitrary data from the Apollo Client cache, but you can also write any data that you would like to the cache. The methods you use to do this are `writeQuery` and `writeFragment`. They will allow you to change data in your local cache, but it is important to remember that *they will not change any data on your server*. If you reload your environment then changes made with `writeQuery` and `writeFragment` will disappear.\n\nThese methods have the same signature as their `readQuery` and `readFragment` counterparts except they also require an additional `data` variable. So for example, if you wanted to update the `completed` flag locally for your todo with id `'5'` you could execute the following:\n\n```js\nclient.writeFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      completed\n    }\n  `,\n  data: {\n    completed: true,\n  },\n});\n```\n\nAny subscriber to the Apollo Client store will instantly see this update and render new UI accordingly.\n\n> **Note:** Again, remember that using `writeQuery` or `writeFragment` only changes data *locally*. If you reload your environment then changes made with these methods will no longer exist.\n\nOr if you wanted to add a new todo to a list fetched from the server, you could use `readQuery` and `writeQuery` together.\n\n```js\nconst query = gql`\n  query MyTodoAppQuery {\n    todos {\n      id\n      text\n      completed\n    }\n  }\n`;\n\nconst data = client.readQuery({ query });\n\nconst myNewTodo = {\n  id: '6',\n  text: 'Start using Apollo Client.',\n  completed: false,\n};\n\nclient.writeQuery({\n  query,\n  data: {\n    todos: [...data.todos, myNewTodo],\n  },\n});\n```\n\n<h2 id=\"recipes\">Recipes</h2>\n\nHere are some common situations where you would need to access the cache directly. If you're manipulating the cache in an interesting way and would like your example to be featured, please send in a pull request!\n\n<h3 id=\"server\">Server side rendering</h3>\n\nFirst, you will need to initialize an `InMemoryCache` on the server and create an instance of `ApolloClient`. In the initial serialized HTML payload from the server, you should include a script tag that extracts the data from the cache.\n\n```js\n`<script>\n  window.__APOLLO_STATE__=${JSON.stringify(cache.extract())}\n</script>`\n```\n\nOn the client, you can rehydrate the cache using the initial data passed from the server:\n\n```js\ncache: new Cache().restore(window.__APOLLO_STATE__)\n```\n\nIf you would like to learn more about server side rendering, please check our our more in depth guide [here].\n<!---\nTODO (PEGGY): Add link to SSR\n-->\n\n<h3 id=\"server\">Updating the cache after a mutation</h3>\n\nBeing able to read and write to the Apollo cache from anywhere in your application gives you a lot of power over your data. However, there is one place where we most often want to update our cached data: after a mutation. As such, Apollo Client has optimized the experience for updating your cache with the read and write methods after a mutation with the `update` function. Let us say that we have the following GraphQL mutation:\n\n```graphql\nmutation TodoCreateMutation($text: String!) {\n  createTodo(text: $text) {\n    id\n    text\n    completed\n  }\n}\n```\n\nWe may also have the following GraphQL query:\n\n```graphql\nquery TodoAppQuery {\n  todos {\n    id\n    text\n    completed\n  }\n}\n```\n\nAt the end of our mutation we want our query to include the new todo like we had sent our `TodoAppQuery` a second time after the mutation finished without actually sending the query. To do this we can use the `update` function provided as an option of the `client.mutate` method. To update your cache with the mutation just write code that looks like:\n\n```js\n// We assume that the GraphQL operations `TodoCreateMutation` and\n// `TodoAppQuery` have already been defined using the `gql` tag.\n\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    // Read the data from our cache for this query.\n    const data = proxy.readQuery({ query: TodoAppQuery });\n\n    // Add our todo from the mutation to the end.\n    data.todos.push(createTodo);\n\n    // Write our data back to the cache.\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nThe first `proxy` argument is an instance of [`DataProxy`][] has the same four methods that we just learned exist on the Apollo Client: `readQuery`, `readFragment`, `writeQuery`, and `writeFragment`. The reason we call them on a `proxy` object here instead of on our `client` instance is that we can easily apply optimistic updates (which we will demonstrate in a bit). The `proxy` object also provides an isolated transaction which shields you from any other mutations going on at the same time, and the `proxy` object also batches writes together until the very end.\n\nIf you provide an `optimisticResponse` option to the mutation then the `update` function will be run twice. Once immediately after you call `client.mutate` with the data from `optimisticResponse`. After the mutation successfully executes against the server the changes made in the first call to `update` will be rolled back and `update` will be called with the *actual* data returned by the mutation and not just the optimistic response.\n\nPutting it all together:\n\n```js\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  optimisticResponse: {\n    id: -1, // -1 is a temporary id for the optimistic response.\n    text,\n    completed: false,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    const data = proxy.readQuery({ query: TodoAppQuery });\n    data.todos.push(createTodo);\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nAs you can see the `update` function on `client.mutate` provides extra change management functionality specific to the use case of a mutation while still providing you the powerful data control APIs that are available on `client`.\n\nThe `update` function is not a good place for side-effects as it may be called multiple times. Also, you may not call any of the methods on `proxy` asynchronously.\n\n",
      "readmeFilename": "README.md",
      "_id": "apollo-cache-inmemory@1.5.0-beta.0",
      "_nodeVersion": "8.12.0",
      "_npmVersion": "lerna/3.10.7/node@v8.12.0+x64 (darwin)",
      "dist": {
        "integrity": "sha512-fUhM4l1rBI/4ITMIniaUNL1Ktirf0iH6nKzvnQV7W0noPSOI1zSOibgQ1fpS/vr194QkU+bD3DbrCd7OeRXcag==",
        "shasum": "a3bbcb05e48f62e53cdf076a62647bd7fba9b112",
        "tarball": "https://registry.npmjs.org/apollo-cache-inmemory/-/apollo-cache-inmemory-1.5.0-beta.0.tgz",
        "fileCount": 54,
        "unpackedSize": 276156,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJcVIBXCRA9TVsSAnZWagAArGEP+wf/f2xPVBN5mOtGw1xO\n098vh6IE1sXho7jUfhoYHvOvFawTSCii4ZNwfivx0NRtpedYovaTlzrtEBK6\nGECKFJ0r+Vdbr4PgN2kNuybCoW5T4PoZ/uu4ceyr2lzh+t6kp9r8Z5Xp0OQk\n9xtgJqBBLSBuSW2Bo+vltJDCK16PvPq36nqneuRmlfX6US4KitU0i6CjWLC5\npU1v1kV05xP26wXrfQrsTdtlKM14X9u/Sq6P8H3vLwJ02w7reNi8jhFVrfgA\nmzQLXPQEnvfzVS+Et6m0Cn3oQrdj6Unb+LsS63QM5h1VyQW2WlFOMujUICDH\nrk6kMvBT6aA+VqXXFgYjE8MNXZ3j/r0ZOhRwzhHhN0PU6PAuh2p2Rb4B6Ie3\nlhZbHM9Wz56We8Z8gFJYiz36B5g4J0/kwCZsDAHB+YL7MNJLvEGuuFvaqLW6\nkOcfvxiyyYAkURfP2L84EhsYw3aRecgsLhb55hO8FAIsIJFGnE6jpV7KJSDs\nBOgGSyN3KETMAWGvvh0C4dZvM1r21gUHXMX4SdpVsgHz3meis9tdIwaTst8B\nknfhiq3wC9mEEBtgsyigHl+EkrpOv6mkVt09xK4U+qgAZDxxxDH1/Qb/YiS0\nMpEsLnrr1yWt8gqzpVxWbPzAuXPNiBQjCQf6oQOTwlKTUAKzANzH9mCQ7zPO\n7Gjk\r\n=4Tjl\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEQCID+2HkbGu5R5RQP8hJO6VgDYs7vrXT3JM72q11G/fsS+AiBPsq9dd3vpo6rKgP7XpGEJHim5tP5oNBGH568c4fyCxA=="
          }
        ]
      },
      "maintainers": [
        {
          "email": "npm@apollographql.com",
          "name": "apollo-bot"
        },
        {
          "email": "ben@benjamn.com",
          "name": "benjamn"
        },
        {
          "email": "james@meteor.com",
          "name": "jbaxleyiii"
        },
        {
          "email": "peggyrayzis@gmail.com",
          "name": "peggyrayzis"
        }
      ],
      "_npmUser": {
        "name": "apollo-bot",
        "email": "npm@apollographql.com"
      },
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/apollo-cache-inmemory_1.5.0-beta.0_1549041750106_0.49093976952775886"
      },
      "_hasShrinkwrap": false
    },
    "1.5.0-beta.1": {
      "name": "apollo-cache-inmemory",
      "version": "1.5.0-beta.1",
      "description": "Core abstract of Caching layer for Apollo Client",
      "author": {
        "name": "James Baxley",
        "email": "james@meteor.com"
      },
      "contributors": [
        {
          "name": "James Baxley",
          "email": "james@meteor.com"
        },
        {
          "name": "Jonas Helfer",
          "email": "jonas@helfer.email"
        },
        {
          "name": "Sashko Stubailo",
          "email": "sashko@stubailo.com"
        },
        {
          "name": "James Burgess",
          "email": "jamesmillerburgess@gmail.com"
        },
        {
          "name": "Bazyli Brzóska",
          "email": "bazyli.brzoska@gmail.com"
        }
      ],
      "license": "MIT",
      "main": "./lib/bundle.cjs.js",
      "module": "./lib/bundle.esm.js",
      "typings": "./lib/index.d.ts",
      "sideEffects": [
        "./lib/fixPolyfills.js"
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/apollographql/apollo-client.git"
      },
      "bugs": {
        "url": "https://github.com/apollographql/apollo-client/issues"
      },
      "homepage": "https://github.com/apollographql/apollo-client#readme",
      "scripts": {
        "prepare": "npm run build",
        "coverage": "jest --coverage",
        "test": "tsc -p tsconfig.json --noEmit && jest",
        "lint": "tslint -c \"../../config/tslint.json\" -p tsconfig.json src/*.ts",
        "prebuild": "npm run clean",
        "build": "tsc -b .",
        "postbuild": "npm run bundle",
        "bundle": "../../node_modules/rollup/bin/rollup -c rollup.config.js",
        "watch": "tsc -w -p .",
        "clean": "rm -rf coverage/* lib/*",
        "prepublishOnly": "npm run build"
      },
      "dependencies": {
        "apollo-cache": "^1.2.0-beta.1",
        "apollo-utilities": "^1.2.0-beta.1",
        "optimism": "^0.6.9",
        "ts-invariant": "^0.2.1",
        "tslib": "^1.9.3"
      },
      "peerDependencies": {
        "graphql": "0.11.7 || ^0.12.0 || ^0.13.0 || ^14.0.0"
      },
      "gitHead": "ada6057dc4a30ec07b7e8ef2f68e9372e16e1e12",
      "readme": "---\ntitle: InMemoryCache\ndescription: An explanation of `apollo-cache-inmemory`\n---\n\n`apollo-cache-inmemory` is the recommended cache implementation for Apollo Client 2.0. `InMemoryCache` is a normalized data store that supports all of Apollo Client 1.0's features without the dependency on Redux.\n\nIn some instances, you may need to manipulate the cache directly, such as updating the store after a mutation. We'll cover some common use cases [here](#recipes).\n\n<h2 id=\"installation\">Installation</h2>\n\n```\nnpm install apollo-cache-inmemory --save\n```\n\nAfter installing the package, you'll want to initialize the cache constructor. Then, you can pass in your newly created cache to ApolloClient.\n\n```js\nimport { InMemoryCache } from 'apollo-cache-inmemory';\nimport { HttpLink } from 'apollo-link-http';\nimport ApolloClient from 'apollo-client';\n\nconst cache = new InMemoryCache();\n\nconst client = new ApolloClient({\n  link: new HttpLink(),\n  cache\n});\n```\n\n<h2 id=\"configuration\">Configuration</h2>\n\nThe `InMemoryCache` constructor takes an optional config object with properties to customize your cache:\n\n- addTypename: A boolean to determine whether to add __typename to the document (default: `true`)\n- dataIdFromObject: A function that takes a data object and returns a unique identifier to be used when normalizing the data in the store. Learn more about how to customize `dataIdFromObject` in the [Normalization](#normalization) section.\n- fragmentMatcher: By default, the `InMemoryCache` uses a heuristic fragment matcher. If you are using fragments on unions and interfaces, you will need to use an `IntrospectionFragmentMatcher`. For more information, please read [our guide to setting up fragment matching for unions & interfaces](https://www.apollographql.com/docs/react/advanced/fragments.html#fragment-matcher).\n\n<h2 id=\"normalization\">Normalization</h2>\n\nThe `InMemoryCache` normalizes your data before saving it to the store by splitting the result into individual objects, creating a unique identifier for each object, and storing those objects in a flattened data structure. By default, `InMemoryCache` will attempt to use the commonly found primary keys of `id` and `_id` for the unique identifier if they exist along with `__typename` on an object.\n\nIf `id` and `_id` are not specified, or if `__typename` is not specified, `InMemoryCache` will fall back to the path to the object in the query, such as `ROOT_QUERY.allPeople.0` for the first record returned on the `allPeople` root query.\n\nThis \"getter\" behavior for unique identifiers can be configured manually via the `dataIdFromObject` option passed to the `InMemoryCache` constructor, so you can pick which field is used if some of your data follows unorthodox primary key conventions.\n\nFor example, if you wanted to key off of the `key` field for all of your data, you could configure `dataIdFromObject` like so:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => object.key\n});\n```\n\nThis also allows you to use different unique identifiers for different data types by keying off of the `__typename` property attached to every object typed by GraphQL.  For example:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => {\n    switch (object.__typename) {\n      case 'foo': return object.key; // use `key` as the primary key\n      case 'bar': return object.blah; // use `blah` as the priamry key\n      default: return object.id || object._id; // fall back to `id` and `_id` for all other types\n    }\n  }\n});\n```\n\n<h2 id=\"direct\">Direct Cache Access</h2>\n\nTo interact directly with your cache, you can use the Apollo Client class methods readQuery, readFragment, writeQuery, and writeFragment. These methods are available to us via the [`DataProxy` interface](https://github.com/apollographql/apollo-client/blob/master/packages/apollo-cache/src/types/DataProxy.ts). Accessing these methods will vary slightly based on your view layer implementation. If you are using React, you can wrap your component in the `withApollo` higher order component, which will give you access to `this.props.client`. From there, you can use the methods to control your data.\n\nAny code demonstration in the following sections will assume that we have already initialized an instance of  `ApolloClient` and that we have imported the `gql` tag from `graphql-tag`.\n\n<h3 id=\"readquery\">readQuery</h3>\n\nThe `readQuery` method is very similar to the [`query` method on `ApolloClient`][] except that `readQuery` will _never_ make a request to your GraphQL server. The `query` method, on the other hand, may send a request to your server if the appropriate data is not in your cache whereas `readQuery` will throw an error if the data is not in your cache. `readQuery` will _always_ read from the cache. You can use `readQuery` by giving it a GraphQL query like so:\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo {\n      todo(id: 5) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n});\n```\n\nIf all of the data needed to fulfill this read is in Apollo Client’s normalized data cache then a data object will be returned in the shape of the query you wanted to read. If not all of the data needed to fulfill this read is in Apollo Client’s cache then an error will be thrown instead, so make sure to only read data that you know you have!\n\nYou can also pass variables into `readQuery`.\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo($id: Int!) {\n      todo(id: $id) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n  variables: {\n    id: 5,\n  },\n});\n```\n\n<h3 id=\"readfragment\">readFragment</h3>\n\nThis method allows you great flexibility around the data in your cache. Whereas `readQuery` only allowed you to read data from your root query type, `readFragment` allows you to read data from _any node you have queried_. This is incredibly powerful. You use this method as follows:\n\n```js\nconst todo = client.readFragment({\n  id: ..., // `id` is any id that could be returned by `dataIdFromObject`.\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\nThe first argument is the id of the data you want to read from the cache. That id must be a value that was returned by the `dataIdFromObject` function you defined when initializing `ApolloClient`. So for example if you initialized `ApolloClient` like so:\n\n```js\nconst client = new ApolloClient({\n  ...,\n  dataIdFromObject: object => object.id,\n});\n```\n\n…and you requested a todo before with an id of `5`, then you can read that todo out of your cache with the following:\n\n```js\nconst todo = client.readFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\n> **Note:** Most people add a `__typename` to the id in `dataIdFromObject`. If you do this then don’t forget to add the `__typename` when you are reading a fragment as well. So for example your id may be `Todo_5` and not just `5`.\n\nIf a todo with that id does not exist in the cache you will get `null` back. If a todo of that id does exist in the cache, but that todo does not have the `text` field then an error will be thrown.\n\nThe beauty of `readFragment` is that the todo could have come from anywhere! The todo could have been selected as a singleton (`{ todo(id: 5) { ... } }`), the todo could have come from a list of todos (`{ todos { ... } }`), or the todo could have come from a mutation (`mutation { createTodo { ... } }`). As long as at some point your GraphQL server gave you a todo with the provided id and fields `id`, `text`, and `completed` you can read it from the cache at any part of your code.\n\n<h3 id=\"writequery-and-writefragment\">writeQuery` and `writeFragment</h3>\n\nNot only can you read arbitrary data from the Apollo Client cache, but you can also write any data that you would like to the cache. The methods you use to do this are `writeQuery` and `writeFragment`. They will allow you to change data in your local cache, but it is important to remember that *they will not change any data on your server*. If you reload your environment then changes made with `writeQuery` and `writeFragment` will disappear.\n\nThese methods have the same signature as their `readQuery` and `readFragment` counterparts except they also require an additional `data` variable. So for example, if you wanted to update the `completed` flag locally for your todo with id `'5'` you could execute the following:\n\n```js\nclient.writeFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      completed\n    }\n  `,\n  data: {\n    completed: true,\n  },\n});\n```\n\nAny subscriber to the Apollo Client store will instantly see this update and render new UI accordingly.\n\n> **Note:** Again, remember that using `writeQuery` or `writeFragment` only changes data *locally*. If you reload your environment then changes made with these methods will no longer exist.\n\nOr if you wanted to add a new todo to a list fetched from the server, you could use `readQuery` and `writeQuery` together.\n\n```js\nconst query = gql`\n  query MyTodoAppQuery {\n    todos {\n      id\n      text\n      completed\n    }\n  }\n`;\n\nconst data = client.readQuery({ query });\n\nconst myNewTodo = {\n  id: '6',\n  text: 'Start using Apollo Client.',\n  completed: false,\n};\n\nclient.writeQuery({\n  query,\n  data: {\n    todos: [...data.todos, myNewTodo],\n  },\n});\n```\n\n<h2 id=\"recipes\">Recipes</h2>\n\nHere are some common situations where you would need to access the cache directly. If you're manipulating the cache in an interesting way and would like your example to be featured, please send in a pull request!\n\n<h3 id=\"server\">Server side rendering</h3>\n\nFirst, you will need to initialize an `InMemoryCache` on the server and create an instance of `ApolloClient`. In the initial serialized HTML payload from the server, you should include a script tag that extracts the data from the cache.\n\n```js\n`<script>\n  window.__APOLLO_STATE__=${JSON.stringify(cache.extract())}\n</script>`\n```\n\nOn the client, you can rehydrate the cache using the initial data passed from the server:\n\n```js\ncache: new Cache().restore(window.__APOLLO_STATE__)\n```\n\nIf you would like to learn more about server side rendering, please check our our more in depth guide [here].\n<!---\nTODO (PEGGY): Add link to SSR\n-->\n\n<h3 id=\"server\">Updating the cache after a mutation</h3>\n\nBeing able to read and write to the Apollo cache from anywhere in your application gives you a lot of power over your data. However, there is one place where we most often want to update our cached data: after a mutation. As such, Apollo Client has optimized the experience for updating your cache with the read and write methods after a mutation with the `update` function. Let us say that we have the following GraphQL mutation:\n\n```graphql\nmutation TodoCreateMutation($text: String!) {\n  createTodo(text: $text) {\n    id\n    text\n    completed\n  }\n}\n```\n\nWe may also have the following GraphQL query:\n\n```graphql\nquery TodoAppQuery {\n  todos {\n    id\n    text\n    completed\n  }\n}\n```\n\nAt the end of our mutation we want our query to include the new todo like we had sent our `TodoAppQuery` a second time after the mutation finished without actually sending the query. To do this we can use the `update` function provided as an option of the `client.mutate` method. To update your cache with the mutation just write code that looks like:\n\n```js\n// We assume that the GraphQL operations `TodoCreateMutation` and\n// `TodoAppQuery` have already been defined using the `gql` tag.\n\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    // Read the data from our cache for this query.\n    const data = proxy.readQuery({ query: TodoAppQuery });\n\n    // Add our todo from the mutation to the end.\n    data.todos.push(createTodo);\n\n    // Write our data back to the cache.\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nThe first `proxy` argument is an instance of [`DataProxy`][] has the same four methods that we just learned exist on the Apollo Client: `readQuery`, `readFragment`, `writeQuery`, and `writeFragment`. The reason we call them on a `proxy` object here instead of on our `client` instance is that we can easily apply optimistic updates (which we will demonstrate in a bit). The `proxy` object also provides an isolated transaction which shields you from any other mutations going on at the same time, and the `proxy` object also batches writes together until the very end.\n\nIf you provide an `optimisticResponse` option to the mutation then the `update` function will be run twice. Once immediately after you call `client.mutate` with the data from `optimisticResponse`. After the mutation successfully executes against the server the changes made in the first call to `update` will be rolled back and `update` will be called with the *actual* data returned by the mutation and not just the optimistic response.\n\nPutting it all together:\n\n```js\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  optimisticResponse: {\n    id: -1, // -1 is a temporary id for the optimistic response.\n    text,\n    completed: false,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    const data = proxy.readQuery({ query: TodoAppQuery });\n    data.todos.push(createTodo);\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nAs you can see the `update` function on `client.mutate` provides extra change management functionality specific to the use case of a mutation while still providing you the powerful data control APIs that are available on `client`.\n\nThe `update` function is not a good place for side-effects as it may be called multiple times. Also, you may not call any of the methods on `proxy` asynchronously.\n\n",
      "readmeFilename": "README.md",
      "_id": "apollo-cache-inmemory@1.5.0-beta.1",
      "_nodeVersion": "8.12.0",
      "_npmVersion": "lerna/3.10.8/node@v8.12.0+x64 (darwin)",
      "dist": {
        "integrity": "sha512-pO39ROFGi/VZ8cVdjHCMJHqd55x31YgNtOvNOgrDF3VIE3kVTLOxF00ctMJvqzCp3Q2rbTmLo3d+MaGMZFTmHA==",
        "shasum": "cb46ce5b832cf8efe5b0871e3a5ac4bb291e9bef",
        "tarball": "https://registry.npmjs.org/apollo-cache-inmemory/-/apollo-cache-inmemory-1.5.0-beta.1.tgz",
        "fileCount": 60,
        "unpackedSize": 536597,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJcXIXBCRA9TVsSAnZWagAAFoEP/31tNTunwm6Ll8uNh0GP\ntWUwMioGHH2DdcFoXZ0TGOkkN44MbmVWJcAFkfJYJWjYVbr0ZkQH/3JwWm6c\na+Mb7DcV/ii3GfNNCG+qUUV0XtuxKlRB2QtIgahc31mok7azlyvfHhQ1GGrx\ndEM5QnFeIsakVrLQBomIK9qA3XJqqGC6p1L4mO6a77DI298TdStrU8VrhEYr\n3wQvwic85jpP86xgJOzNFCDxbJgfionhNNBP1SpCiiIXpRAgqvn32YlFUi1d\ncVKtzocUBe9TDctuCOnbe3IaYosSPkudU6+b/wFnXnKZ8tfWricsuYVgeopP\n6axd4MXjt4e18rihFjRiKO01dnDept1oOPP6VR6o6KB7xTYsxDvuKkqwxeae\n8EwR8+cowEIfPGwVHhw8TcoknWPtg4um3ln+8OAeeWQEOMQHQW47sj+VD58J\noOmxauNwPCaFwh3uMczmTLH0ToSMZBT7NpXXoFeH5SmyVuRmVipOVeHQPwtz\nidKHqpTYkSfmxMRCOM5MvH537U4GYEQTTsyzNPM0eqFM9cA89RaAmnjogZ/Q\nk0jgjCH5g7c0nXlm0uwe55cqAl2hFPu7ssRqOaPgwWqZDOgmGizbDNqBHQnr\naIkojqIy6ypf7YwN5C1rc5eHCIc1gm//9GJuetkc1qV/+z0kA5uSrv1nqhZi\nvCd7\r\n=a3/D\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIQCEIX2o7AqxipkaKxsXcauD0o+r8t99hLW2r1hsx0U2ewIgYlo6Fz/JVPUN2TNPQMdzkmhY5Qync6x1zg+SjEMGLc4="
          }
        ]
      },
      "maintainers": [
        {
          "email": "npm@apollographql.com",
          "name": "apollo-bot"
        },
        {
          "email": "ben@benjamn.com",
          "name": "benjamn"
        },
        {
          "email": "james@meteor.com",
          "name": "jbaxleyiii"
        },
        {
          "email": "peggyrayzis@gmail.com",
          "name": "peggyrayzis"
        }
      ],
      "_npmUser": {
        "name": "apollo-bot",
        "email": "npm@apollographql.com"
      },
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/apollo-cache-inmemory_1.5.0-beta.1_1549567424586_0.5883113370260256"
      },
      "_hasShrinkwrap": false
    },
    "1.4.3": {
      "name": "apollo-cache-inmemory",
      "version": "1.4.3",
      "description": "Core abstract of Caching layer for Apollo Client",
      "author": {
        "name": "James Baxley",
        "email": "james@meteor.com"
      },
      "contributors": [
        {
          "name": "James Baxley",
          "email": "james@meteor.com"
        },
        {
          "name": "Jonas Helfer",
          "email": "jonas@helfer.email"
        },
        {
          "name": "Sashko Stubailo",
          "email": "sashko@stubailo.com"
        },
        {
          "name": "James Burgess",
          "email": "jamesmillerburgess@gmail.com"
        },
        {
          "name": "Bazyli Brzóska",
          "email": "bazyli.brzoska@gmail.com"
        }
      ],
      "license": "MIT",
      "main": "./lib/bundle.umd.js",
      "module": "./lib/index.js",
      "jsnext:main": "./lib/index.js",
      "typings": "./lib/index.d.ts",
      "sideEffects": [
        "./lib/fixPolyfills.js"
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/apollographql/apollo-client.git"
      },
      "bugs": {
        "url": "https://github.com/apollographql/apollo-client/issues"
      },
      "homepage": "https://github.com/apollographql/apollo-client#readme",
      "scripts": {
        "prepare": "npm run build",
        "coverage": "jest --coverage",
        "test": "jest",
        "lint": "tslint -c \"../../config/tslint.json\" -p tsconfig.json src/*.ts",
        "prebuild": "npm run clean",
        "build": "tsc -p .",
        "postbuild": "npm run bundle",
        "bundle": "../../node_modules/rollup/bin/rollup -c rollup.config.js",
        "watch": "tsc -w -p .",
        "clean": "rm -rf coverage/* && rm -rf lib/*",
        "prepublishOnly": "npm run build",
        "minify": "../../node_modules/uglify-js/bin/uglifyjs -c -m -o ./lib/bundle.min.js -- ./lib/bundle.umd.js",
        "filesize": "npm run minify"
      },
      "dependencies": {
        "apollo-cache": "^1.1.26",
        "apollo-utilities": "^1.1.3",
        "optimism": "^0.6.9",
        "tslib": "^1.9.3"
      },
      "peerDependencies": {
        "graphql": "0.11.7 || ^0.12.0 || ^0.13.0 || ^14.0.0"
      },
      "jest": {
        "transform": {
          ".(ts|tsx)": "ts-jest"
        },
        "testRegex": "(/__tests__/.*|\\.(test|spec))\\.(ts|tsx|js)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "json"
        ],
        "testURL": "http://localhost"
      },
      "gitHead": "5217dba186279b20f540f2c01dd773a101a34608",
      "_id": "apollo-cache-inmemory@1.4.3",
      "_nodeVersion": "8.15.0",
      "_npmVersion": "lerna/3.11.1/node@v8.15.0+x64 (darwin)",
      "_npmUser": {
        "name": "apollo-bot",
        "email": "npm@apollographql.com"
      },
      "dist": {
        "integrity": "sha512-p9KGtEZ9Mlb+FS0UEaxR8WvKOijYV0c+TXlhC/XZ3/ltYvP1zL3b1ozSOLGR9SawN2895Fc7QDV5nzPpihV0rA==",
        "shasum": "aded4fb8b3de9e2fb2573a6c03591b07ef98ed36",
        "tarball": "https://registry.npmjs.org/apollo-cache-inmemory/-/apollo-cache-inmemory-1.4.3.tgz",
        "fileCount": 54,
        "unpackedSize": 282058,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJcZF0LCRA9TVsSAnZWagAAfHMP/3Xx00E3GQooTboxjFU8\nAGRC+X0+eZam0yUVWCaY643ZQx6WAGb4T/JM7n/hKH413RshJCG28JTGrgoS\neDxocu1stoKEJGQ2mYn3bBBNOR5kKBLDMVAt3qJ8LNeyEpiqiiXNR/9Pe8ZA\nntsmlG18hvmWhYzgNt4+GgVX+pVkRYCge+2S+E8rQjAfaeu1MfZnZdvr9mc9\n6PbDXMl5+Q+LSw9zkNLrXHTojsTBevIddX6mjdGMGs5Acc1AMYOokNrPKYI2\nWAu8erMFh0/rVB35nr7DduGxanDTKdzIpCc63j11LMCxf9RK0V6bcOo94DUR\nSWnUgdKuZTv/P1Zoa/JzWOwxnVzjYKTQw0OuUlP+kEVDQSYYJFJ5I8mZVaXv\nJtQNavhz6WYUygeHxC/YuI2gfDv6g1seR0E5XwkuQT8YKPeV+Ato15Nzhpzf\nSX2cic9aFzX8Er/ts5HFiHafJ2xrmACwEA5eGTWn6/a9Nd14C6HwIiRfn4Ug\nNqcmVhhHYjVBazmiWllax1I0mPOKb6Bo/pUuKzRni7v30eZMjHw4HZjFUHKo\ni8oEBnIIvZm0OY52QWxyMKtFHIJRRyRCgbWZeEC/x28eENcya4hVKdB7XQtV\nTymcI17YqETk0+MnDPNIYCWYwZBXChgdmRxQrdmy1VfOkbKoc0zsgwq6Fw4S\nFgOy\r\n=dFjx\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEYCIQCshIum7pEZ6mbCxL5K6rpBf11dGO73aR89nK29w/lcfQIhAJh6us+3NZu7d6s9g/kWBjibmlKc0ZifkVdPDgNJ31W2"
          }
        ]
      },
      "maintainers": [
        {
          "email": "npm@apollographql.com",
          "name": "apollo-bot"
        },
        {
          "email": "ben@benjamn.com",
          "name": "benjamn"
        },
        {
          "email": "james@meteor.com",
          "name": "jbaxleyiii"
        },
        {
          "email": "peggyrayzis@gmail.com",
          "name": "peggyrayzis"
        }
      ],
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/apollo-cache-inmemory_1.4.3_1550081290385_0.7594952594452995"
      },
      "_hasShrinkwrap": false
    },
    "1.5.0-rc.0": {
      "name": "apollo-cache-inmemory",
      "version": "1.5.0-rc.0",
      "description": "Core abstract of Caching layer for Apollo Client",
      "author": {
        "name": "James Baxley",
        "email": "james@meteor.com"
      },
      "contributors": [
        {
          "name": "James Baxley",
          "email": "james@meteor.com"
        },
        {
          "name": "Jonas Helfer",
          "email": "jonas@helfer.email"
        },
        {
          "name": "Sashko Stubailo",
          "email": "sashko@stubailo.com"
        },
        {
          "name": "James Burgess",
          "email": "jamesmillerburgess@gmail.com"
        },
        {
          "name": "Bazyli Brzóska",
          "email": "bazyli.brzoska@gmail.com"
        }
      ],
      "license": "MIT",
      "main": "./lib/bundle.cjs.js",
      "module": "./lib/bundle.esm.js",
      "typings": "./lib/index.d.ts",
      "sideEffects": [
        "./lib/fixPolyfills.js"
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/apollographql/apollo-client.git"
      },
      "bugs": {
        "url": "https://github.com/apollographql/apollo-client/issues"
      },
      "homepage": "https://github.com/apollographql/apollo-client#readme",
      "scripts": {
        "prepare": "npm run build",
        "coverage": "jest --coverage",
        "test": "tsc -p tsconfig.json --noEmit && jest",
        "lint": "tslint -c \"../../config/tslint.json\" -p tsconfig.json src/*.ts",
        "prebuild": "npm run clean",
        "build": "tsc -b .",
        "postbuild": "npm run bundle",
        "bundle": "../../node_modules/rollup/bin/rollup -c rollup.config.js",
        "watch": "tsc -w -p .",
        "clean": "rm -rf coverage/* lib/*",
        "prepublishOnly": "npm run build"
      },
      "dependencies": {
        "apollo-cache": "^1.2.0-rc.0",
        "apollo-utilities": "^1.2.0-beta.1",
        "optimism": "^0.6.9",
        "ts-invariant": "^0.2.1",
        "tslib": "^1.9.3"
      },
      "peerDependencies": {
        "graphql": "0.11.7 || ^0.12.0 || ^0.13.0 || ^14.0.0"
      },
      "gitHead": "d6b456687202ec2f0ae3ffd7f528d0ca0657f984",
      "readme": "---\ntitle: InMemoryCache\ndescription: An explanation of `apollo-cache-inmemory`\n---\n\n`apollo-cache-inmemory` is the recommended cache implementation for Apollo Client 2.0. `InMemoryCache` is a normalized data store that supports all of Apollo Client 1.0's features without the dependency on Redux.\n\nIn some instances, you may need to manipulate the cache directly, such as updating the store after a mutation. We'll cover some common use cases [here](#recipes).\n\n<h2 id=\"installation\">Installation</h2>\n\n```\nnpm install apollo-cache-inmemory --save\n```\n\nAfter installing the package, you'll want to initialize the cache constructor. Then, you can pass in your newly created cache to ApolloClient.\n\n```js\nimport { InMemoryCache } from 'apollo-cache-inmemory';\nimport { HttpLink } from 'apollo-link-http';\nimport ApolloClient from 'apollo-client';\n\nconst cache = new InMemoryCache();\n\nconst client = new ApolloClient({\n  link: new HttpLink(),\n  cache\n});\n```\n\n<h2 id=\"configuration\">Configuration</h2>\n\nThe `InMemoryCache` constructor takes an optional config object with properties to customize your cache:\n\n- addTypename: A boolean to determine whether to add __typename to the document (default: `true`)\n- dataIdFromObject: A function that takes a data object and returns a unique identifier to be used when normalizing the data in the store. Learn more about how to customize `dataIdFromObject` in the [Normalization](#normalization) section.\n- fragmentMatcher: By default, the `InMemoryCache` uses a heuristic fragment matcher. If you are using fragments on unions and interfaces, you will need to use an `IntrospectionFragmentMatcher`. For more information, please read [our guide to setting up fragment matching for unions & interfaces](https://www.apollographql.com/docs/react/advanced/fragments.html#fragment-matcher).\n\n<h2 id=\"normalization\">Normalization</h2>\n\nThe `InMemoryCache` normalizes your data before saving it to the store by splitting the result into individual objects, creating a unique identifier for each object, and storing those objects in a flattened data structure. By default, `InMemoryCache` will attempt to use the commonly found primary keys of `id` and `_id` for the unique identifier if they exist along with `__typename` on an object.\n\nIf `id` and `_id` are not specified, or if `__typename` is not specified, `InMemoryCache` will fall back to the path to the object in the query, such as `ROOT_QUERY.allPeople.0` for the first record returned on the `allPeople` root query.\n\nThis \"getter\" behavior for unique identifiers can be configured manually via the `dataIdFromObject` option passed to the `InMemoryCache` constructor, so you can pick which field is used if some of your data follows unorthodox primary key conventions.\n\nFor example, if you wanted to key off of the `key` field for all of your data, you could configure `dataIdFromObject` like so:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => object.key\n});\n```\n\nThis also allows you to use different unique identifiers for different data types by keying off of the `__typename` property attached to every object typed by GraphQL.  For example:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => {\n    switch (object.__typename) {\n      case 'foo': return object.key; // use `key` as the primary key\n      case 'bar': return object.blah; // use `blah` as the priamry key\n      default: return object.id || object._id; // fall back to `id` and `_id` for all other types\n    }\n  }\n});\n```\n\n<h2 id=\"direct\">Direct Cache Access</h2>\n\nTo interact directly with your cache, you can use the Apollo Client class methods readQuery, readFragment, writeQuery, and writeFragment. These methods are available to us via the [`DataProxy` interface](https://github.com/apollographql/apollo-client/blob/master/packages/apollo-cache/src/types/DataProxy.ts). Accessing these methods will vary slightly based on your view layer implementation. If you are using React, you can wrap your component in the `withApollo` higher order component, which will give you access to `this.props.client`. From there, you can use the methods to control your data.\n\nAny code demonstration in the following sections will assume that we have already initialized an instance of  `ApolloClient` and that we have imported the `gql` tag from `graphql-tag`.\n\n<h3 id=\"readquery\">readQuery</h3>\n\nThe `readQuery` method is very similar to the [`query` method on `ApolloClient`][] except that `readQuery` will _never_ make a request to your GraphQL server. The `query` method, on the other hand, may send a request to your server if the appropriate data is not in your cache whereas `readQuery` will throw an error if the data is not in your cache. `readQuery` will _always_ read from the cache. You can use `readQuery` by giving it a GraphQL query like so:\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo {\n      todo(id: 5) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n});\n```\n\nIf all of the data needed to fulfill this read is in Apollo Client’s normalized data cache then a data object will be returned in the shape of the query you wanted to read. If not all of the data needed to fulfill this read is in Apollo Client’s cache then an error will be thrown instead, so make sure to only read data that you know you have!\n\nYou can also pass variables into `readQuery`.\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo($id: Int!) {\n      todo(id: $id) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n  variables: {\n    id: 5,\n  },\n});\n```\n\n<h3 id=\"readfragment\">readFragment</h3>\n\nThis method allows you great flexibility around the data in your cache. Whereas `readQuery` only allowed you to read data from your root query type, `readFragment` allows you to read data from _any node you have queried_. This is incredibly powerful. You use this method as follows:\n\n```js\nconst todo = client.readFragment({\n  id: ..., // `id` is any id that could be returned by `dataIdFromObject`.\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\nThe first argument is the id of the data you want to read from the cache. That id must be a value that was returned by the `dataIdFromObject` function you defined when initializing `ApolloClient`. So for example if you initialized `ApolloClient` like so:\n\n```js\nconst client = new ApolloClient({\n  ...,\n  dataIdFromObject: object => object.id,\n});\n```\n\n…and you requested a todo before with an id of `5`, then you can read that todo out of your cache with the following:\n\n```js\nconst todo = client.readFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\n> **Note:** Most people add a `__typename` to the id in `dataIdFromObject`. If you do this then don’t forget to add the `__typename` when you are reading a fragment as well. So for example your id may be `Todo_5` and not just `5`.\n\nIf a todo with that id does not exist in the cache you will get `null` back. If a todo of that id does exist in the cache, but that todo does not have the `text` field then an error will be thrown.\n\nThe beauty of `readFragment` is that the todo could have come from anywhere! The todo could have been selected as a singleton (`{ todo(id: 5) { ... } }`), the todo could have come from a list of todos (`{ todos { ... } }`), or the todo could have come from a mutation (`mutation { createTodo { ... } }`). As long as at some point your GraphQL server gave you a todo with the provided id and fields `id`, `text`, and `completed` you can read it from the cache at any part of your code.\n\n<h3 id=\"writequery-and-writefragment\">writeQuery` and `writeFragment</h3>\n\nNot only can you read arbitrary data from the Apollo Client cache, but you can also write any data that you would like to the cache. The methods you use to do this are `writeQuery` and `writeFragment`. They will allow you to change data in your local cache, but it is important to remember that *they will not change any data on your server*. If you reload your environment then changes made with `writeQuery` and `writeFragment` will disappear.\n\nThese methods have the same signature as their `readQuery` and `readFragment` counterparts except they also require an additional `data` variable. So for example, if you wanted to update the `completed` flag locally for your todo with id `'5'` you could execute the following:\n\n```js\nclient.writeFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      completed\n    }\n  `,\n  data: {\n    completed: true,\n  },\n});\n```\n\nAny subscriber to the Apollo Client store will instantly see this update and render new UI accordingly.\n\n> **Note:** Again, remember that using `writeQuery` or `writeFragment` only changes data *locally*. If you reload your environment then changes made with these methods will no longer exist.\n\nOr if you wanted to add a new todo to a list fetched from the server, you could use `readQuery` and `writeQuery` together.\n\n```js\nconst query = gql`\n  query MyTodoAppQuery {\n    todos {\n      id\n      text\n      completed\n    }\n  }\n`;\n\nconst data = client.readQuery({ query });\n\nconst myNewTodo = {\n  id: '6',\n  text: 'Start using Apollo Client.',\n  completed: false,\n};\n\nclient.writeQuery({\n  query,\n  data: {\n    todos: [...data.todos, myNewTodo],\n  },\n});\n```\n\n<h2 id=\"recipes\">Recipes</h2>\n\nHere are some common situations where you would need to access the cache directly. If you're manipulating the cache in an interesting way and would like your example to be featured, please send in a pull request!\n\n<h3 id=\"server\">Server side rendering</h3>\n\nFirst, you will need to initialize an `InMemoryCache` on the server and create an instance of `ApolloClient`. In the initial serialized HTML payload from the server, you should include a script tag that extracts the data from the cache.\n\n```js\n`<script>\n  window.__APOLLO_STATE__=${JSON.stringify(cache.extract())}\n</script>`\n```\n\nOn the client, you can rehydrate the cache using the initial data passed from the server:\n\n```js\ncache: new Cache().restore(window.__APOLLO_STATE__)\n```\n\nIf you would like to learn more about server side rendering, please check our our more in depth guide [here].\n<!---\nTODO (PEGGY): Add link to SSR\n-->\n\n<h3 id=\"server\">Updating the cache after a mutation</h3>\n\nBeing able to read and write to the Apollo cache from anywhere in your application gives you a lot of power over your data. However, there is one place where we most often want to update our cached data: after a mutation. As such, Apollo Client has optimized the experience for updating your cache with the read and write methods after a mutation with the `update` function. Let us say that we have the following GraphQL mutation:\n\n```graphql\nmutation TodoCreateMutation($text: String!) {\n  createTodo(text: $text) {\n    id\n    text\n    completed\n  }\n}\n```\n\nWe may also have the following GraphQL query:\n\n```graphql\nquery TodoAppQuery {\n  todos {\n    id\n    text\n    completed\n  }\n}\n```\n\nAt the end of our mutation we want our query to include the new todo like we had sent our `TodoAppQuery` a second time after the mutation finished without actually sending the query. To do this we can use the `update` function provided as an option of the `client.mutate` method. To update your cache with the mutation just write code that looks like:\n\n```js\n// We assume that the GraphQL operations `TodoCreateMutation` and\n// `TodoAppQuery` have already been defined using the `gql` tag.\n\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    // Read the data from our cache for this query.\n    const data = proxy.readQuery({ query: TodoAppQuery });\n\n    // Add our todo from the mutation to the end.\n    data.todos.push(createTodo);\n\n    // Write our data back to the cache.\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nThe first `proxy` argument is an instance of [`DataProxy`][] has the same four methods that we just learned exist on the Apollo Client: `readQuery`, `readFragment`, `writeQuery`, and `writeFragment`. The reason we call them on a `proxy` object here instead of on our `client` instance is that we can easily apply optimistic updates (which we will demonstrate in a bit). The `proxy` object also provides an isolated transaction which shields you from any other mutations going on at the same time, and the `proxy` object also batches writes together until the very end.\n\nIf you provide an `optimisticResponse` option to the mutation then the `update` function will be run twice. Once immediately after you call `client.mutate` with the data from `optimisticResponse`. After the mutation successfully executes against the server the changes made in the first call to `update` will be rolled back and `update` will be called with the *actual* data returned by the mutation and not just the optimistic response.\n\nPutting it all together:\n\n```js\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  optimisticResponse: {\n    id: -1, // -1 is a temporary id for the optimistic response.\n    text,\n    completed: false,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    const data = proxy.readQuery({ query: TodoAppQuery });\n    data.todos.push(createTodo);\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nAs you can see the `update` function on `client.mutate` provides extra change management functionality specific to the use case of a mutation while still providing you the powerful data control APIs that are available on `client`.\n\nThe `update` function is not a good place for side-effects as it may be called multiple times. Also, you may not call any of the methods on `proxy` asynchronously.\n\n",
      "readmeFilename": "README.md",
      "_id": "apollo-cache-inmemory@1.5.0-rc.0",
      "_nodeVersion": "8.12.0",
      "_npmVersion": "lerna/3.13.0/node@v8.12.0+x64 (darwin)",
      "dist": {
        "integrity": "sha512-u38GO0HGZa0VNYJBW/M6is5/CA2VDFBf/ogHWJUP5mwvAIIdLqZMkWQzjRQYrb7CLLCAdssKyDwuMs+2o0jXoQ==",
        "shasum": "11d4d3b1d9529362955d00e30220176181002be9",
        "tarball": "https://registry.npmjs.org/apollo-cache-inmemory/-/apollo-cache-inmemory-1.5.0-rc.0.tgz",
        "fileCount": 60,
        "unpackedSize": 536611,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJcbvuqCRA9TVsSAnZWagAAKBEQAIsnUQ/ULIqn+2gzBGju\nnp0d7GLeS8t4XWiEVHbQEYKRq8ti1cBkpeMGfmKeTGjLTaxczgilVelYQgov\nRoPD6VE5Y6pQF8VEXfE3Mmi3LkVrJF5KDQdTi0AZ/sRhjI4TxCoc9oiN7cot\nzdiv6REYeurP6+5YswbXxY6Vd+e3P97APFxWv6g0H5Jjdw87+TXMBL3p+u0Q\nskvBf0AG2bi65/akLLAVvBx+Lp8pm2a7KccdrlIgFUUauGvU/sdpjF0IBGXV\nHhk312JqoTsAfN4PP0RVd7cWBVhjOjHeLY58AaL7qgxzqxlyo/AhcZY9tFrH\nYJEUrvJx53+CR7qmmDeBjq/ZDPzQXlkHOWKthiQ/GPw0JP8oPYvaV7WyoCxw\n8licag8ofb7K6WCmIlk3ycmogYVhBJQRItxxjGMyt96Kmob1mmsbEQD5+CwJ\nAcihe4oiGrJWEk+u/e2kkY06rv8PfeAWobcczNUDng6WwvVSuKOHAWS0xC8v\nPthM8VLlGDp/Vt/o/U6tgpzVWdgJZrdj7imBJacJpnx8+EA8Il27WG4Lwuge\nvGVdI86K2HGyI9qdNJoJeguDzKTjy5Mwkf1JMD5Tbuw9BUjzDGFJI/vJTGTY\n6s332lFWpVQ0La50tq95jEMkYSvqa6EUIVlQEuCr/tSGtSYmPSS3JuwI/r55\nr+JQ\r\n=K+Er\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEQCIB7t3iJ8HPfimJF4b+Uo44dXQKRf5u2OBVFmc6UWMmCiAiBHs4HfTEGQeDff/G63K/9auWKO/4qUtj1x7hdE5L2B3A=="
          }
        ]
      },
      "maintainers": [
        {
          "email": "npm@apollographql.com",
          "name": "apollo-bot"
        },
        {
          "email": "ben@benjamn.com",
          "name": "benjamn"
        },
        {
          "email": "james@meteor.com",
          "name": "jbaxleyiii"
        },
        {
          "email": "peggyrayzis@gmail.com",
          "name": "peggyrayzis"
        }
      ],
      "_npmUser": {
        "name": "apollo-bot",
        "email": "npm@apollographql.com"
      },
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/apollo-cache-inmemory_1.5.0-rc.0_1550777257753_0.3522095142597097"
      },
      "_hasShrinkwrap": false
    },
    "1.5.0-rc.1": {
      "name": "apollo-cache-inmemory",
      "version": "1.5.0-rc.1",
      "description": "Core abstract of Caching layer for Apollo Client",
      "author": {
        "name": "James Baxley",
        "email": "james@meteor.com"
      },
      "contributors": [
        {
          "name": "James Baxley",
          "email": "james@meteor.com"
        },
        {
          "name": "Jonas Helfer",
          "email": "jonas@helfer.email"
        },
        {
          "name": "Sashko Stubailo",
          "email": "sashko@stubailo.com"
        },
        {
          "name": "James Burgess",
          "email": "jamesmillerburgess@gmail.com"
        },
        {
          "name": "Bazyli Brzóska",
          "email": "bazyli.brzoska@gmail.com"
        }
      ],
      "license": "MIT",
      "main": "./lib/bundle.cjs.js",
      "module": "./lib/bundle.esm.js",
      "typings": "./lib/index.d.ts",
      "sideEffects": [
        "./lib/fixPolyfills.js"
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/apollographql/apollo-client.git"
      },
      "bugs": {
        "url": "https://github.com/apollographql/apollo-client/issues"
      },
      "homepage": "https://github.com/apollographql/apollo-client#readme",
      "scripts": {
        "prepare": "npm run build",
        "coverage": "jest --coverage",
        "test": "tsc -p tsconfig.json --noEmit && jest",
        "lint": "tslint -c \"../../config/tslint.json\" -p tsconfig.json src/*.ts",
        "prebuild": "npm run clean",
        "build": "tsc -b .",
        "postbuild": "npm run bundle",
        "bundle": "../../node_modules/rollup/bin/rollup -c rollup.config.js",
        "watch": "tsc -w -p .",
        "clean": "rm -rf coverage/* lib/*",
        "prepublishOnly": "npm run build"
      },
      "dependencies": {
        "apollo-cache": "^1.2.0-rc.1",
        "apollo-utilities": "^1.2.0-rc.1",
        "optimism": "^0.6.9",
        "ts-invariant": "^0.2.1",
        "tslib": "^1.9.3"
      },
      "peerDependencies": {
        "graphql": "0.11.7 || ^0.12.0 || ^0.13.0 || ^14.0.0"
      },
      "gitHead": "559a94807cc9a2ae28ecc51ca412857b63f726b6",
      "readme": "---\ntitle: InMemoryCache\ndescription: An explanation of `apollo-cache-inmemory`\n---\n\n`apollo-cache-inmemory` is the recommended cache implementation for Apollo Client 2.0. `InMemoryCache` is a normalized data store that supports all of Apollo Client 1.0's features without the dependency on Redux.\n\nIn some instances, you may need to manipulate the cache directly, such as updating the store after a mutation. We'll cover some common use cases [here](#recipes).\n\n<h2 id=\"installation\">Installation</h2>\n\n```\nnpm install apollo-cache-inmemory --save\n```\n\nAfter installing the package, you'll want to initialize the cache constructor. Then, you can pass in your newly created cache to ApolloClient.\n\n```js\nimport { InMemoryCache } from 'apollo-cache-inmemory';\nimport { HttpLink } from 'apollo-link-http';\nimport ApolloClient from 'apollo-client';\n\nconst cache = new InMemoryCache();\n\nconst client = new ApolloClient({\n  link: new HttpLink(),\n  cache\n});\n```\n\n<h2 id=\"configuration\">Configuration</h2>\n\nThe `InMemoryCache` constructor takes an optional config object with properties to customize your cache:\n\n- addTypename: A boolean to determine whether to add __typename to the document (default: `true`)\n- dataIdFromObject: A function that takes a data object and returns a unique identifier to be used when normalizing the data in the store. Learn more about how to customize `dataIdFromObject` in the [Normalization](#normalization) section.\n- fragmentMatcher: By default, the `InMemoryCache` uses a heuristic fragment matcher. If you are using fragments on unions and interfaces, you will need to use an `IntrospectionFragmentMatcher`. For more information, please read [our guide to setting up fragment matching for unions & interfaces](https://www.apollographql.com/docs/react/advanced/fragments.html#fragment-matcher).\n\n<h2 id=\"normalization\">Normalization</h2>\n\nThe `InMemoryCache` normalizes your data before saving it to the store by splitting the result into individual objects, creating a unique identifier for each object, and storing those objects in a flattened data structure. By default, `InMemoryCache` will attempt to use the commonly found primary keys of `id` and `_id` for the unique identifier if they exist along with `__typename` on an object.\n\nIf `id` and `_id` are not specified, or if `__typename` is not specified, `InMemoryCache` will fall back to the path to the object in the query, such as `ROOT_QUERY.allPeople.0` for the first record returned on the `allPeople` root query.\n\nThis \"getter\" behavior for unique identifiers can be configured manually via the `dataIdFromObject` option passed to the `InMemoryCache` constructor, so you can pick which field is used if some of your data follows unorthodox primary key conventions.\n\nFor example, if you wanted to key off of the `key` field for all of your data, you could configure `dataIdFromObject` like so:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => object.key\n});\n```\n\nThis also allows you to use different unique identifiers for different data types by keying off of the `__typename` property attached to every object typed by GraphQL.  For example:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => {\n    switch (object.__typename) {\n      case 'foo': return object.key; // use `key` as the primary key\n      case 'bar': return object.blah; // use `blah` as the priamry key\n      default: return object.id || object._id; // fall back to `id` and `_id` for all other types\n    }\n  }\n});\n```\n\n<h2 id=\"direct\">Direct Cache Access</h2>\n\nTo interact directly with your cache, you can use the Apollo Client class methods readQuery, readFragment, writeQuery, and writeFragment. These methods are available to us via the [`DataProxy` interface](https://github.com/apollographql/apollo-client/blob/master/packages/apollo-cache/src/types/DataProxy.ts). Accessing these methods will vary slightly based on your view layer implementation. If you are using React, you can wrap your component in the `withApollo` higher order component, which will give you access to `this.props.client`. From there, you can use the methods to control your data.\n\nAny code demonstration in the following sections will assume that we have already initialized an instance of  `ApolloClient` and that we have imported the `gql` tag from `graphql-tag`.\n\n<h3 id=\"readquery\">readQuery</h3>\n\nThe `readQuery` method is very similar to the [`query` method on `ApolloClient`][] except that `readQuery` will _never_ make a request to your GraphQL server. The `query` method, on the other hand, may send a request to your server if the appropriate data is not in your cache whereas `readQuery` will throw an error if the data is not in your cache. `readQuery` will _always_ read from the cache. You can use `readQuery` by giving it a GraphQL query like so:\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo {\n      todo(id: 5) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n});\n```\n\nIf all of the data needed to fulfill this read is in Apollo Client’s normalized data cache then a data object will be returned in the shape of the query you wanted to read. If not all of the data needed to fulfill this read is in Apollo Client’s cache then an error will be thrown instead, so make sure to only read data that you know you have!\n\nYou can also pass variables into `readQuery`.\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo($id: Int!) {\n      todo(id: $id) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n  variables: {\n    id: 5,\n  },\n});\n```\n\n<h3 id=\"readfragment\">readFragment</h3>\n\nThis method allows you great flexibility around the data in your cache. Whereas `readQuery` only allowed you to read data from your root query type, `readFragment` allows you to read data from _any node you have queried_. This is incredibly powerful. You use this method as follows:\n\n```js\nconst todo = client.readFragment({\n  id: ..., // `id` is any id that could be returned by `dataIdFromObject`.\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\nThe first argument is the id of the data you want to read from the cache. That id must be a value that was returned by the `dataIdFromObject` function you defined when initializing `ApolloClient`. So for example if you initialized `ApolloClient` like so:\n\n```js\nconst client = new ApolloClient({\n  ...,\n  dataIdFromObject: object => object.id,\n});\n```\n\n…and you requested a todo before with an id of `5`, then you can read that todo out of your cache with the following:\n\n```js\nconst todo = client.readFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\n> **Note:** Most people add a `__typename` to the id in `dataIdFromObject`. If you do this then don’t forget to add the `__typename` when you are reading a fragment as well. So for example your id may be `Todo_5` and not just `5`.\n\nIf a todo with that id does not exist in the cache you will get `null` back. If a todo of that id does exist in the cache, but that todo does not have the `text` field then an error will be thrown.\n\nThe beauty of `readFragment` is that the todo could have come from anywhere! The todo could have been selected as a singleton (`{ todo(id: 5) { ... } }`), the todo could have come from a list of todos (`{ todos { ... } }`), or the todo could have come from a mutation (`mutation { createTodo { ... } }`). As long as at some point your GraphQL server gave you a todo with the provided id and fields `id`, `text`, and `completed` you can read it from the cache at any part of your code.\n\n<h3 id=\"writequery-and-writefragment\">writeQuery` and `writeFragment</h3>\n\nNot only can you read arbitrary data from the Apollo Client cache, but you can also write any data that you would like to the cache. The methods you use to do this are `writeQuery` and `writeFragment`. They will allow you to change data in your local cache, but it is important to remember that *they will not change any data on your server*. If you reload your environment then changes made with `writeQuery` and `writeFragment` will disappear.\n\nThese methods have the same signature as their `readQuery` and `readFragment` counterparts except they also require an additional `data` variable. So for example, if you wanted to update the `completed` flag locally for your todo with id `'5'` you could execute the following:\n\n```js\nclient.writeFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      completed\n    }\n  `,\n  data: {\n    completed: true,\n  },\n});\n```\n\nAny subscriber to the Apollo Client store will instantly see this update and render new UI accordingly.\n\n> **Note:** Again, remember that using `writeQuery` or `writeFragment` only changes data *locally*. If you reload your environment then changes made with these methods will no longer exist.\n\nOr if you wanted to add a new todo to a list fetched from the server, you could use `readQuery` and `writeQuery` together.\n\n```js\nconst query = gql`\n  query MyTodoAppQuery {\n    todos {\n      id\n      text\n      completed\n    }\n  }\n`;\n\nconst data = client.readQuery({ query });\n\nconst myNewTodo = {\n  id: '6',\n  text: 'Start using Apollo Client.',\n  completed: false,\n};\n\nclient.writeQuery({\n  query,\n  data: {\n    todos: [...data.todos, myNewTodo],\n  },\n});\n```\n\n<h2 id=\"recipes\">Recipes</h2>\n\nHere are some common situations where you would need to access the cache directly. If you're manipulating the cache in an interesting way and would like your example to be featured, please send in a pull request!\n\n<h3 id=\"server\">Server side rendering</h3>\n\nFirst, you will need to initialize an `InMemoryCache` on the server and create an instance of `ApolloClient`. In the initial serialized HTML payload from the server, you should include a script tag that extracts the data from the cache.\n\n```js\n`<script>\n  window.__APOLLO_STATE__=${JSON.stringify(cache.extract())}\n</script>`\n```\n\nOn the client, you can rehydrate the cache using the initial data passed from the server:\n\n```js\ncache: new Cache().restore(window.__APOLLO_STATE__)\n```\n\nIf you would like to learn more about server side rendering, please check our our more in depth guide [here].\n<!---\nTODO (PEGGY): Add link to SSR\n-->\n\n<h3 id=\"server\">Updating the cache after a mutation</h3>\n\nBeing able to read and write to the Apollo cache from anywhere in your application gives you a lot of power over your data. However, there is one place where we most often want to update our cached data: after a mutation. As such, Apollo Client has optimized the experience for updating your cache with the read and write methods after a mutation with the `update` function. Let us say that we have the following GraphQL mutation:\n\n```graphql\nmutation TodoCreateMutation($text: String!) {\n  createTodo(text: $text) {\n    id\n    text\n    completed\n  }\n}\n```\n\nWe may also have the following GraphQL query:\n\n```graphql\nquery TodoAppQuery {\n  todos {\n    id\n    text\n    completed\n  }\n}\n```\n\nAt the end of our mutation we want our query to include the new todo like we had sent our `TodoAppQuery` a second time after the mutation finished without actually sending the query. To do this we can use the `update` function provided as an option of the `client.mutate` method. To update your cache with the mutation just write code that looks like:\n\n```js\n// We assume that the GraphQL operations `TodoCreateMutation` and\n// `TodoAppQuery` have already been defined using the `gql` tag.\n\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    // Read the data from our cache for this query.\n    const data = proxy.readQuery({ query: TodoAppQuery });\n\n    // Add our todo from the mutation to the end.\n    data.todos.push(createTodo);\n\n    // Write our data back to the cache.\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nThe first `proxy` argument is an instance of [`DataProxy`][] has the same four methods that we just learned exist on the Apollo Client: `readQuery`, `readFragment`, `writeQuery`, and `writeFragment`. The reason we call them on a `proxy` object here instead of on our `client` instance is that we can easily apply optimistic updates (which we will demonstrate in a bit). The `proxy` object also provides an isolated transaction which shields you from any other mutations going on at the same time, and the `proxy` object also batches writes together until the very end.\n\nIf you provide an `optimisticResponse` option to the mutation then the `update` function will be run twice. Once immediately after you call `client.mutate` with the data from `optimisticResponse`. After the mutation successfully executes against the server the changes made in the first call to `update` will be rolled back and `update` will be called with the *actual* data returned by the mutation and not just the optimistic response.\n\nPutting it all together:\n\n```js\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  optimisticResponse: {\n    id: -1, // -1 is a temporary id for the optimistic response.\n    text,\n    completed: false,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    const data = proxy.readQuery({ query: TodoAppQuery });\n    data.todos.push(createTodo);\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nAs you can see the `update` function on `client.mutate` provides extra change management functionality specific to the use case of a mutation while still providing you the powerful data control APIs that are available on `client`.\n\nThe `update` function is not a good place for side-effects as it may be called multiple times. Also, you may not call any of the methods on `proxy` asynchronously.\n\n",
      "readmeFilename": "README.md",
      "_id": "apollo-cache-inmemory@1.5.0-rc.1",
      "_nodeVersion": "8.12.0",
      "_npmVersion": "lerna/3.13.0/node@v8.12.0+x64 (darwin)",
      "dist": {
        "integrity": "sha512-lQnd/gdIGNA8Pp0pTv1XuEGWKAy9EfJERM7XVEZu0Uxpdh1j53K8O79cpBbokd/IAfLQnkZZxxG7R7C/VOctRA==",
        "shasum": "85db999efcce7ff97c273f3e8b8e88a25f543e0f",
        "tarball": "https://registry.npmjs.org/apollo-cache-inmemory/-/apollo-cache-inmemory-1.5.0-rc.1.tgz",
        "fileCount": 60,
        "unpackedSize": 536609,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJcbwgRCRA9TVsSAnZWagAA81gP/35AWE7qXdLtGUrUqGgQ\n620OjzZ0z2XEccClK4P4o7fbgKmEY6i6FM7NpwcBqy4R2CSeHC2hKg94MsUP\n06RzD7d/buOeZ4+YoRvA9Qe/megtCeGpjQd3dgGTVkcgswlTWPfDCN1hXTog\nudG302zqyB5QEvslt85d4KO+gz7bQK6XRL8RCni1pammhPQgD1Y++vAsPGES\n5ih8MFPKicXaagoXfilwVuOfMF1yGP1z2iMPA0srqBkHjjxZlZTPNsEI2g25\nBiEkJ2c83020FwrhWR02sIVoqeCl6abKMBTpmanaQIzlkTs84lh6ZiXRVyQ9\nreWaiYOBqvAf79iIyHfD6pOYHKUamFpC1KUYuboroXbFFSg6Gy1kmzMX5stY\nFJZv0AM/6CcNMip2Af6zs6CuBi+iXGdsN4wQho2WdaZAT/5UbroUCrZzCW3z\ndZqBPlYuzYuhNF5w8TYpVcR2R2s7alUMC3Hbq5jEO7O1eEV9v5fwCXUCjmt6\nRTlTn5EBldKTJbY3/oVg37BfcQfU6t0ridJXD+b/HW23FoDdzjbedSuBMn4A\nImTx/EDuSXt68cl4mjhrQhlM3NehyVbIhqIOzf3+I/QpoDtuEB0C/dw8+eU8\nthbOM0H4d2bN6A3OkJHfWOs2D6sgMtMlBykWC9aBqldxMwe1elBVccUbODuZ\nG0VF\r\n=kcsc\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEYCIQCm8bVbrfrznEOnYf83R/UCoUFXRuUubsc92rwaUcGcJwIhAMHoALRJjv/4KqewqbVnPpzG6Ti3E11naAA/8j4nRuZN"
          }
        ]
      },
      "maintainers": [
        {
          "email": "npm@apollographql.com",
          "name": "apollo-bot"
        },
        {
          "email": "ben@benjamn.com",
          "name": "benjamn"
        },
        {
          "email": "james@meteor.com",
          "name": "jbaxleyiii"
        },
        {
          "email": "peggyrayzis@gmail.com",
          "name": "peggyrayzis"
        }
      ],
      "_npmUser": {
        "name": "apollo-bot",
        "email": "npm@apollographql.com"
      },
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/apollo-cache-inmemory_1.5.0-rc.1_1550780433214_0.5533200811545469"
      },
      "_hasShrinkwrap": false
    },
    "1.5.0-rc.2": {
      "name": "apollo-cache-inmemory",
      "version": "1.5.0-rc.2",
      "description": "Core abstract of Caching layer for Apollo Client",
      "author": {
        "name": "James Baxley",
        "email": "james@meteor.com"
      },
      "contributors": [
        {
          "name": "James Baxley",
          "email": "james@meteor.com"
        },
        {
          "name": "Jonas Helfer",
          "email": "jonas@helfer.email"
        },
        {
          "name": "Sashko Stubailo",
          "email": "sashko@stubailo.com"
        },
        {
          "name": "James Burgess",
          "email": "jamesmillerburgess@gmail.com"
        },
        {
          "name": "Bazyli Brzóska",
          "email": "bazyli.brzoska@gmail.com"
        }
      ],
      "license": "MIT",
      "main": "./lib/bundle.cjs.js",
      "module": "./lib/bundle.esm.js",
      "typings": "./lib/index.d.ts",
      "sideEffects": [
        "./lib/fixPolyfills.js"
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/apollographql/apollo-client.git"
      },
      "bugs": {
        "url": "https://github.com/apollographql/apollo-client/issues"
      },
      "homepage": "https://github.com/apollographql/apollo-client#readme",
      "scripts": {
        "prepare": "npm run build",
        "coverage": "jest --coverage",
        "test": "tsc -p tsconfig.json --noEmit && jest",
        "lint": "tslint -c \"../../config/tslint.json\" -p tsconfig.json src/*.ts",
        "prebuild": "npm run clean",
        "build": "tsc -b .",
        "postbuild": "npm run bundle",
        "bundle": "../../node_modules/rollup/bin/rollup -c rollup.config.js",
        "watch": "../../node_modules/tsc-watch/index.js --onSuccess \"npm run postbuild\"",
        "clean": "rm -rf coverage/* lib/*",
        "prepublishOnly": "npm run build"
      },
      "dependencies": {
        "apollo-cache": "^1.2.0-rc.2",
        "apollo-utilities": "^1.2.0-rc.2",
        "optimism": "^0.6.9",
        "ts-invariant": "^0.2.1",
        "tslib": "^1.9.3"
      },
      "peerDependencies": {
        "graphql": "0.11.7 || ^0.12.0 || ^0.13.0 || ^14.0.0"
      },
      "gitHead": "8f13d4ac9c50fa294e807bbd948851292da6a5b8",
      "readme": "---\ntitle: InMemoryCache\ndescription: An explanation of `apollo-cache-inmemory`\n---\n\n`apollo-cache-inmemory` is the recommended cache implementation for Apollo Client 2.0. `InMemoryCache` is a normalized data store that supports all of Apollo Client 1.0's features without the dependency on Redux.\n\nIn some instances, you may need to manipulate the cache directly, such as updating the store after a mutation. We'll cover some common use cases [here](#recipes).\n\n<h2 id=\"installation\">Installation</h2>\n\n```\nnpm install apollo-cache-inmemory --save\n```\n\nAfter installing the package, you'll want to initialize the cache constructor. Then, you can pass in your newly created cache to ApolloClient.\n\n```js\nimport { InMemoryCache } from 'apollo-cache-inmemory';\nimport { HttpLink } from 'apollo-link-http';\nimport ApolloClient from 'apollo-client';\n\nconst cache = new InMemoryCache();\n\nconst client = new ApolloClient({\n  link: new HttpLink(),\n  cache\n});\n```\n\n<h2 id=\"configuration\">Configuration</h2>\n\nThe `InMemoryCache` constructor takes an optional config object with properties to customize your cache:\n\n- addTypename: A boolean to determine whether to add __typename to the document (default: `true`)\n- dataIdFromObject: A function that takes a data object and returns a unique identifier to be used when normalizing the data in the store. Learn more about how to customize `dataIdFromObject` in the [Normalization](#normalization) section.\n- fragmentMatcher: By default, the `InMemoryCache` uses a heuristic fragment matcher. If you are using fragments on unions and interfaces, you will need to use an `IntrospectionFragmentMatcher`. For more information, please read [our guide to setting up fragment matching for unions & interfaces](https://www.apollographql.com/docs/react/advanced/fragments.html#fragment-matcher).\n\n<h2 id=\"normalization\">Normalization</h2>\n\nThe `InMemoryCache` normalizes your data before saving it to the store by splitting the result into individual objects, creating a unique identifier for each object, and storing those objects in a flattened data structure. By default, `InMemoryCache` will attempt to use the commonly found primary keys of `id` and `_id` for the unique identifier if they exist along with `__typename` on an object.\n\nIf `id` and `_id` are not specified, or if `__typename` is not specified, `InMemoryCache` will fall back to the path to the object in the query, such as `ROOT_QUERY.allPeople.0` for the first record returned on the `allPeople` root query.\n\nThis \"getter\" behavior for unique identifiers can be configured manually via the `dataIdFromObject` option passed to the `InMemoryCache` constructor, so you can pick which field is used if some of your data follows unorthodox primary key conventions.\n\nFor example, if you wanted to key off of the `key` field for all of your data, you could configure `dataIdFromObject` like so:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => object.key\n});\n```\n\nThis also allows you to use different unique identifiers for different data types by keying off of the `__typename` property attached to every object typed by GraphQL.  For example:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => {\n    switch (object.__typename) {\n      case 'foo': return object.key; // use `key` as the primary key\n      case 'bar': return object.blah; // use `blah` as the priamry key\n      default: return object.id || object._id; // fall back to `id` and `_id` for all other types\n    }\n  }\n});\n```\n\n<h2 id=\"direct\">Direct Cache Access</h2>\n\nTo interact directly with your cache, you can use the Apollo Client class methods readQuery, readFragment, writeQuery, and writeFragment. These methods are available to us via the [`DataProxy` interface](https://github.com/apollographql/apollo-client/blob/master/packages/apollo-cache/src/types/DataProxy.ts). Accessing these methods will vary slightly based on your view layer implementation. If you are using React, you can wrap your component in the `withApollo` higher order component, which will give you access to `this.props.client`. From there, you can use the methods to control your data.\n\nAny code demonstration in the following sections will assume that we have already initialized an instance of  `ApolloClient` and that we have imported the `gql` tag from `graphql-tag`.\n\n<h3 id=\"readquery\">readQuery</h3>\n\nThe `readQuery` method is very similar to the [`query` method on `ApolloClient`][] except that `readQuery` will _never_ make a request to your GraphQL server. The `query` method, on the other hand, may send a request to your server if the appropriate data is not in your cache whereas `readQuery` will throw an error if the data is not in your cache. `readQuery` will _always_ read from the cache. You can use `readQuery` by giving it a GraphQL query like so:\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo {\n      todo(id: 5) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n});\n```\n\nIf all of the data needed to fulfill this read is in Apollo Client’s normalized data cache then a data object will be returned in the shape of the query you wanted to read. If not all of the data needed to fulfill this read is in Apollo Client’s cache then an error will be thrown instead, so make sure to only read data that you know you have!\n\nYou can also pass variables into `readQuery`.\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo($id: Int!) {\n      todo(id: $id) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n  variables: {\n    id: 5,\n  },\n});\n```\n\n<h3 id=\"readfragment\">readFragment</h3>\n\nThis method allows you great flexibility around the data in your cache. Whereas `readQuery` only allowed you to read data from your root query type, `readFragment` allows you to read data from _any node you have queried_. This is incredibly powerful. You use this method as follows:\n\n```js\nconst todo = client.readFragment({\n  id: ..., // `id` is any id that could be returned by `dataIdFromObject`.\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\nThe first argument is the id of the data you want to read from the cache. That id must be a value that was returned by the `dataIdFromObject` function you defined when initializing `ApolloClient`. So for example if you initialized `ApolloClient` like so:\n\n```js\nconst client = new ApolloClient({\n  ...,\n  dataIdFromObject: object => object.id,\n});\n```\n\n…and you requested a todo before with an id of `5`, then you can read that todo out of your cache with the following:\n\n```js\nconst todo = client.readFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\n> **Note:** Most people add a `__typename` to the id in `dataIdFromObject`. If you do this then don’t forget to add the `__typename` when you are reading a fragment as well. So for example your id may be `Todo_5` and not just `5`.\n\nIf a todo with that id does not exist in the cache you will get `null` back. If a todo of that id does exist in the cache, but that todo does not have the `text` field then an error will be thrown.\n\nThe beauty of `readFragment` is that the todo could have come from anywhere! The todo could have been selected as a singleton (`{ todo(id: 5) { ... } }`), the todo could have come from a list of todos (`{ todos { ... } }`), or the todo could have come from a mutation (`mutation { createTodo { ... } }`). As long as at some point your GraphQL server gave you a todo with the provided id and fields `id`, `text`, and `completed` you can read it from the cache at any part of your code.\n\n<h3 id=\"writequery-and-writefragment\">writeQuery` and `writeFragment</h3>\n\nNot only can you read arbitrary data from the Apollo Client cache, but you can also write any data that you would like to the cache. The methods you use to do this are `writeQuery` and `writeFragment`. They will allow you to change data in your local cache, but it is important to remember that *they will not change any data on your server*. If you reload your environment then changes made with `writeQuery` and `writeFragment` will disappear.\n\nThese methods have the same signature as their `readQuery` and `readFragment` counterparts except they also require an additional `data` variable. So for example, if you wanted to update the `completed` flag locally for your todo with id `'5'` you could execute the following:\n\n```js\nclient.writeFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      completed\n    }\n  `,\n  data: {\n    completed: true,\n  },\n});\n```\n\nAny subscriber to the Apollo Client store will instantly see this update and render new UI accordingly.\n\n> **Note:** Again, remember that using `writeQuery` or `writeFragment` only changes data *locally*. If you reload your environment then changes made with these methods will no longer exist.\n\nOr if you wanted to add a new todo to a list fetched from the server, you could use `readQuery` and `writeQuery` together.\n\n```js\nconst query = gql`\n  query MyTodoAppQuery {\n    todos {\n      id\n      text\n      completed\n    }\n  }\n`;\n\nconst data = client.readQuery({ query });\n\nconst myNewTodo = {\n  id: '6',\n  text: 'Start using Apollo Client.',\n  completed: false,\n};\n\nclient.writeQuery({\n  query,\n  data: {\n    todos: [...data.todos, myNewTodo],\n  },\n});\n```\n\n<h2 id=\"recipes\">Recipes</h2>\n\nHere are some common situations where you would need to access the cache directly. If you're manipulating the cache in an interesting way and would like your example to be featured, please send in a pull request!\n\n<h3 id=\"server\">Server side rendering</h3>\n\nFirst, you will need to initialize an `InMemoryCache` on the server and create an instance of `ApolloClient`. In the initial serialized HTML payload from the server, you should include a script tag that extracts the data from the cache.\n\n```js\n`<script>\n  window.__APOLLO_STATE__=${JSON.stringify(cache.extract())}\n</script>`\n```\n\nOn the client, you can rehydrate the cache using the initial data passed from the server:\n\n```js\ncache: new Cache().restore(window.__APOLLO_STATE__)\n```\n\nIf you would like to learn more about server side rendering, please check our our more in depth guide [here].\n<!---\nTODO (PEGGY): Add link to SSR\n-->\n\n<h3 id=\"server\">Updating the cache after a mutation</h3>\n\nBeing able to read and write to the Apollo cache from anywhere in your application gives you a lot of power over your data. However, there is one place where we most often want to update our cached data: after a mutation. As such, Apollo Client has optimized the experience for updating your cache with the read and write methods after a mutation with the `update` function. Let us say that we have the following GraphQL mutation:\n\n```graphql\nmutation TodoCreateMutation($text: String!) {\n  createTodo(text: $text) {\n    id\n    text\n    completed\n  }\n}\n```\n\nWe may also have the following GraphQL query:\n\n```graphql\nquery TodoAppQuery {\n  todos {\n    id\n    text\n    completed\n  }\n}\n```\n\nAt the end of our mutation we want our query to include the new todo like we had sent our `TodoAppQuery` a second time after the mutation finished without actually sending the query. To do this we can use the `update` function provided as an option of the `client.mutate` method. To update your cache with the mutation just write code that looks like:\n\n```js\n// We assume that the GraphQL operations `TodoCreateMutation` and\n// `TodoAppQuery` have already been defined using the `gql` tag.\n\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    // Read the data from our cache for this query.\n    const data = proxy.readQuery({ query: TodoAppQuery });\n\n    // Add our todo from the mutation to the end.\n    data.todos.push(createTodo);\n\n    // Write our data back to the cache.\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nThe first `proxy` argument is an instance of [`DataProxy`][] has the same four methods that we just learned exist on the Apollo Client: `readQuery`, `readFragment`, `writeQuery`, and `writeFragment`. The reason we call them on a `proxy` object here instead of on our `client` instance is that we can easily apply optimistic updates (which we will demonstrate in a bit). The `proxy` object also provides an isolated transaction which shields you from any other mutations going on at the same time, and the `proxy` object also batches writes together until the very end.\n\nIf you provide an `optimisticResponse` option to the mutation then the `update` function will be run twice. Once immediately after you call `client.mutate` with the data from `optimisticResponse`. After the mutation successfully executes against the server the changes made in the first call to `update` will be rolled back and `update` will be called with the *actual* data returned by the mutation and not just the optimistic response.\n\nPutting it all together:\n\n```js\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  optimisticResponse: {\n    id: -1, // -1 is a temporary id for the optimistic response.\n    text,\n    completed: false,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    const data = proxy.readQuery({ query: TodoAppQuery });\n    data.todos.push(createTodo);\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nAs you can see the `update` function on `client.mutate` provides extra change management functionality specific to the use case of a mutation while still providing you the powerful data control APIs that are available on `client`.\n\nThe `update` function is not a good place for side-effects as it may be called multiple times. Also, you may not call any of the methods on `proxy` asynchronously.\n\n",
      "readmeFilename": "README.md",
      "_id": "apollo-cache-inmemory@1.5.0-rc.2",
      "_nodeVersion": "8.12.0",
      "_npmVersion": "lerna/3.13.0/node@v8.12.0+x64 (darwin)",
      "dist": {
        "integrity": "sha512-Yr1QrzPBA9qPR/KLka92l7W7TwIWEnCBgLnnwDit0/PDeDIYcL61kUwWstXzPJyjewsCsIE+3+qAAH1HsbHxNg==",
        "shasum": "37cbdf7eab9581f27c4145a5915f90d9e5ba8c83",
        "tarball": "https://registry.npmjs.org/apollo-cache-inmemory/-/apollo-cache-inmemory-1.5.0-rc.2.tgz",
        "fileCount": 60,
        "unpackedSize": 536669,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJcc+AACRA9TVsSAnZWagAADPIP/iS9pR16EGNhtzL9/ycM\nMeviTgokdZ3R+dzOe24gEA/dscIE1xPwqFipOSgLTQu38KH9TitbvU4gkNzp\nFD70Yi2NyglxsZbKnuPEHtZA/BUxopbbel0/P39EbYjpmFGYYBFkwDcWe3Z9\nvm4sDGyXJZXckhn+P4v4Ku8Bv+UUFB7rG6zCR/JcSrBtlHlkyrNFz97/0Lar\nEjQGJ1HpXbIXtX9/Nkh1B+W4jXsGn6DYqtF7RqZjSrCTs01DS5eAIhXTi7pT\nGop7tjsUotNtFuXKDY4YrlUOE/d36qvUO3ck9r7nhy6kStItr30jtELCYgqg\nPlW1TjVjmy4VrEeJK45bO6S2lOww+glxBXwzKpfXpiyGqyXwWkyOA7BDnOPH\nCXYg9z/rvMHLUzaJckhF9MNGQ3wKGZrtvgVqxetUvqB3AnbvyKYn8xylRwFD\nYOgwJCwR8NIXVnmPEKLHFO4DdaT6+MflhNsvll8+4s5lnoccCD/XgMacW8Hq\nYdTu/JkcKcDE9i99ACsEG2JQZoUz2eOnm+MTGclBjjS4r2OeOUa/EBHX9+AL\nbdo2hvQigAfSgfYDsAzIzfwTPLnHwgLz33uL2eVs55uhUoFCDa/OIVQPLC8S\nvUN6b9Baihw3tUD2/2Ws7DoDERGpRDjGczC8ovA2xQUB2vdn6VLxVo3A0fwP\nQpoy\r\n=S94q\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIDSW7rOgOSy7QUzyRmb6/4HFN2WCMlHMvLTD/mXN/bOxAiEAqzFtRUcdOKNxwwd+osWEA0dXjlxGhuszjt8QhqEMySE="
          }
        ]
      },
      "maintainers": [
        {
          "email": "npm@apollographql.com",
          "name": "apollo-bot"
        },
        {
          "email": "ben@benjamn.com",
          "name": "benjamn"
        },
        {
          "email": "james@meteor.com",
          "name": "jbaxleyiii"
        },
        {
          "email": "peggyrayzis@gmail.com",
          "name": "peggyrayzis"
        }
      ],
      "_npmUser": {
        "name": "apollo-bot",
        "email": "npm@apollographql.com"
      },
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/apollo-cache-inmemory_1.5.0-rc.2_1551097855856_0.2435833836727681"
      },
      "_hasShrinkwrap": false
    },
    "1.5.0": {
      "name": "apollo-cache-inmemory",
      "version": "1.5.0",
      "description": "Core abstract of Caching layer for Apollo Client",
      "author": {
        "name": "James Baxley",
        "email": "james@meteor.com"
      },
      "contributors": [
        {
          "name": "James Baxley",
          "email": "james@meteor.com"
        },
        {
          "name": "Jonas Helfer",
          "email": "jonas@helfer.email"
        },
        {
          "name": "Sashko Stubailo",
          "email": "sashko@stubailo.com"
        },
        {
          "name": "James Burgess",
          "email": "jamesmillerburgess@gmail.com"
        },
        {
          "name": "Bazyli Brzóska",
          "email": "bazyli.brzoska@gmail.com"
        }
      ],
      "license": "MIT",
      "main": "./lib/bundle.cjs.js",
      "module": "./lib/bundle.esm.js",
      "typings": "./lib/index.d.ts",
      "sideEffects": [
        "./lib/fixPolyfills.js"
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/apollographql/apollo-client.git"
      },
      "bugs": {
        "url": "https://github.com/apollographql/apollo-client/issues"
      },
      "homepage": "https://github.com/apollographql/apollo-client#readme",
      "scripts": {
        "prepare": "npm run build",
        "coverage": "jest --coverage",
        "test": "tsc -p tsconfig.json --noEmit && jest",
        "lint": "tslint -c \"../../config/tslint.json\" -p tsconfig.json src/*.ts",
        "prebuild": "npm run clean",
        "build": "tsc -b .",
        "postbuild": "npm run bundle",
        "bundle": "../../node_modules/rollup/bin/rollup -c rollup.config.js",
        "watch": "../../node_modules/tsc-watch/index.js --onSuccess \"npm run postbuild\"",
        "clean": "rm -rf coverage/* lib/*",
        "prepublishOnly": "npm run build"
      },
      "dependencies": {
        "apollo-cache": "^1.2.0",
        "apollo-utilities": "^1.2.0",
        "optimism": "^0.6.9",
        "ts-invariant": "^0.2.1",
        "tslib": "^1.9.3"
      },
      "peerDependencies": {
        "graphql": "0.11.7 || ^0.12.0 || ^0.13.0 || ^14.0.0"
      },
      "gitHead": "bc740e09d1b40d2186933e4793d8d66ae8e627ef",
      "_id": "apollo-cache-inmemory@1.5.0",
      "_nodeVersion": "8.12.0",
      "_npmVersion": "lerna/3.13.0/node@v8.12.0+x64 (darwin)",
      "dist": {
        "integrity": "sha512-hyg8R7G3XOfZhl8fQLs0vGEwi2rr8PuEIiumCY4qmwviaGsmwjs/Dm63cyeMm3Sfu05vzFQkwMdBf5u7xBg3cQ==",
        "shasum": "90b1a38f744762ab47c415b9d7b2d32fbd803088",
        "tarball": "https://registry.npmjs.org/apollo-cache-inmemory/-/apollo-cache-inmemory-1.5.0.tgz",
        "fileCount": 60,
        "unpackedSize": 536654,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJcdZZVCRA9TVsSAnZWagAAm8UQAI1LcwfdK8x1iz4dG5x1\nzS0LjvYZQSDpVI5f7Ipq+ph5q/xR4+R6qib2I/4Cb6+tP+iLc2Y0QiENE3pI\nPUwxoRRtzgC7e7C6bHsyyXyWOmUJyzQzkO6KPe+3Wbtla8dOeIsewEv3Rvgu\nxOfiCGENp6q3uz5bVKkBY96hUjvgfMXChWHoq7DnooOBL1/Zq+TxJaR/cW93\nCLRpAgcS8nI0210KuHSTT6lWJCgoT0Nyj8od4NBWo+PNnRL+cVW7hS5/TEHC\nrzFnKE62uJjy1F3HyxW0JkhywcPmTEnfTNtU39nXbbna2+BGpzTHG0NHT/t7\nFmHrvudFKWOmA6f1DuE+gU8IDdK28u1/cWX1cYeRIPuWhCfC9hMV9ta5x4JU\nlB0Uerr6Pz0L5dgEAHyiZOrMiHVumF70+CMhSeMeg+e6aenDLVhS3v5DAnzC\nmOsQD2GC4G7NvcDmVywQ7749W3VDaQXnrmTHr94WcLINueIzLf+m+pRe6PH4\nPKjx9mjw45bkudMHapmhAHdBeuC47EOByT/NhLUy6CsdIqTCR0I5kP2H+zIz\nrEHZyfovvMmnPxxDOlxk4n3LRZB9vI+Ke1RTDCaO0oV5RcjUBtcCglEwpI+z\n5BiUCzi1GdTSPuS+SNCURLe0++e0Y3cY1rYVI4szr95PFzOBr+8nGPa90o5j\n7Rli\r\n=1kFe\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEQCIHyu5ITKpw+w6WJukfuyn/6oZ+yWu2jAzJ2vZ5w/FdwGAiA7MlYQsjYeV5eNs0sPRL7pbfY4ENm7oAxhaNd7FwkWpA=="
          }
        ]
      },
      "maintainers": [
        {
          "email": "npm@apollographql.com",
          "name": "apollo-bot"
        },
        {
          "email": "ben@benjamn.com",
          "name": "benjamn"
        },
        {
          "email": "james@meteor.com",
          "name": "jbaxleyiii"
        },
        {
          "email": "peggyrayzis@gmail.com",
          "name": "peggyrayzis"
        }
      ],
      "_npmUser": {
        "name": "apollo-bot",
        "email": "npm@apollographql.com"
      },
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/apollo-cache-inmemory_1.5.0_1551210068775_0.8669057749322195"
      },
      "_hasShrinkwrap": false
    },
    "1.5.1": {
      "name": "apollo-cache-inmemory",
      "version": "1.5.1",
      "description": "Core abstract of Caching layer for Apollo Client",
      "author": {
        "name": "James Baxley",
        "email": "james@meteor.com"
      },
      "contributors": [
        {
          "name": "James Baxley",
          "email": "james@meteor.com"
        },
        {
          "name": "Jonas Helfer",
          "email": "jonas@helfer.email"
        },
        {
          "name": "Sashko Stubailo",
          "email": "sashko@stubailo.com"
        },
        {
          "name": "James Burgess",
          "email": "jamesmillerburgess@gmail.com"
        },
        {
          "name": "Bazyli Brzóska",
          "email": "bazyli.brzoska@gmail.com"
        }
      ],
      "license": "MIT",
      "main": "./lib/bundle.cjs.js",
      "module": "./lib/bundle.esm.js",
      "typings": "./lib/index.d.ts",
      "sideEffects": [
        "./lib/fixPolyfills.js"
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/apollographql/apollo-client.git"
      },
      "bugs": {
        "url": "https://github.com/apollographql/apollo-client/issues"
      },
      "homepage": "https://github.com/apollographql/apollo-client#readme",
      "scripts": {
        "prepare": "npm run build",
        "coverage": "jest --coverage",
        "test": "tsc -p tsconfig.json --noEmit && jest",
        "lint": "tslint -c \"../../config/tslint.json\" -p tsconfig.json src/*.ts",
        "prebuild": "npm run clean",
        "build": "tsc -b .",
        "postbuild": "npm run bundle",
        "bundle": "../../node_modules/rollup/bin/rollup -c rollup.config.js",
        "watch": "../../node_modules/tsc-watch/index.js --onSuccess \"npm run postbuild\"",
        "clean": "rm -rf coverage/* lib/*",
        "prepublishOnly": "npm run build"
      },
      "dependencies": {
        "apollo-cache": "^1.2.1",
        "apollo-utilities": "^1.2.1",
        "optimism": "^0.6.9",
        "ts-invariant": "^0.2.1",
        "tslib": "^1.9.3"
      },
      "peerDependencies": {
        "graphql": "0.11.7 || ^0.12.0 || ^0.13.0 || ^14.0.0"
      },
      "gitHead": "fda77c22a43a472843954903b43bf875b2ed9d60",
      "_id": "apollo-cache-inmemory@1.5.1",
      "_nodeVersion": "8.12.0",
      "_npmVersion": "lerna/3.13.0/node@v8.12.0+x64 (darwin)",
      "dist": {
        "integrity": "sha512-D3bdpPmWfaKQkWy8lfwUg+K8OBITo3sx0BHLs1B/9vIdOIZ7JNCKq3EUcAgAfInomJUdN0QG1yOfi8M8hxkN1g==",
        "shasum": "265d1ee67b0bf0aca9c37629d410bfae44e62953",
        "tarball": "https://registry.npmjs.org/apollo-cache-inmemory/-/apollo-cache-inmemory-1.5.1.tgz",
        "fileCount": 60,
        "unpackedSize": 536654,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJcdph7CRA9TVsSAnZWagAAw68QAILITMcHEJJFnUYfdJ64\nYhxF77ecuv3+iRtl9YMTI7mJgTDJ2crM6aAB4LBJVtTi64ftI9BL3Gt6SrwO\noKuagzuX+VtT4yrF/Q7jv8fP8fKo8/md/LhaDdRX4xl/41jFvLLWtBo/AlMf\n2CX2ba+1xBrDdX1ymq0QQgWfX5VvVCIqUZEsurw2nVpYhs/JJwNylwhdKWsK\nWIH5W1+DeEAKP2Rej459zDaXv/simMLDnI4QMb1ON/02leJtCGngmfUTOhvN\nsSs2y5u+EfmRyo+JwYLmFRM2se3Zxz1qFuG9V3E+bzw4HRPt00vlo76VDLyx\nQikVjRKDC0GaGQ3deK7Uysd9nv2oh/+gxY6kpiqjvhVVCvDZrqQJYcdzUFSv\nSTP8yDoS1904Wf8A6WfHvQRTbQguBD077nKh1g1fbn5C8z119qiJqSwTdgNQ\nUgHL8Hq0JqX1g/JJfxLsIxCa4VJO5plfjGVw5f6odNqsn0FOq7efPsKTdZ5i\nIqZMw4u3nJz6Li1rlgZYxeXUtJRLwgQGrZHVnMZ0omjeUnJ9Yp3TJSfBRBSB\nU/IY+Ry5Z4cw63xHtFvSsfxAnLYIs6nvIK8DI3wED2VFusfgBGLv2oyMmoEb\n+m9DcuukSEcBPtgEdmEisK/UT389wj+y/taejnS/sqAMHec/f5zWaN/oEmoD\nkNrP\r\n=3Aaz\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEYCIQD2O0IfAgHVdMBZYN4K4kTMwiXgRnItU3wumc002rXjLgIhAPZ8RGIQztR2ZNuhcIIilRyXo934Jfcp+jDp0dVuBisj"
          }
        ]
      },
      "maintainers": [
        {
          "email": "npm@apollographql.com",
          "name": "apollo-bot"
        },
        {
          "email": "ben@benjamn.com",
          "name": "benjamn"
        },
        {
          "email": "james@meteor.com",
          "name": "jbaxleyiii"
        },
        {
          "email": "peggyrayzis@gmail.com",
          "name": "peggyrayzis"
        }
      ],
      "_npmUser": {
        "name": "apollo-bot",
        "email": "npm@apollographql.com"
      },
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/apollo-cache-inmemory_1.5.1_1551276154337_0.23705617287887293"
      },
      "_hasShrinkwrap": false
    },
    "1.6.0-beta.0": {
      "name": "apollo-cache-inmemory",
      "version": "1.6.0-beta.0",
      "description": "Core abstract of Caching layer for Apollo Client",
      "author": {
        "name": "James Baxley",
        "email": "james@meteor.com"
      },
      "contributors": [
        {
          "name": "James Baxley",
          "email": "james@meteor.com"
        },
        {
          "name": "Jonas Helfer",
          "email": "jonas@helfer.email"
        },
        {
          "name": "Sashko Stubailo",
          "email": "sashko@stubailo.com"
        },
        {
          "name": "James Burgess",
          "email": "jamesmillerburgess@gmail.com"
        },
        {
          "name": "Bazyli Brzóska",
          "email": "bazyli.brzoska@gmail.com"
        }
      ],
      "license": "MIT",
      "main": "./lib/bundle.cjs.js",
      "module": "./lib/bundle.esm.js",
      "typings": "./lib/index.d.ts",
      "sideEffects": [
        "./lib/fixPolyfills.js"
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/apollographql/apollo-client.git"
      },
      "bugs": {
        "url": "https://github.com/apollographql/apollo-client/issues"
      },
      "homepage": "https://github.com/apollographql/apollo-client#readme",
      "scripts": {
        "prepare": "npm run build",
        "coverage": "jest --coverage",
        "test": "tsc -p tsconfig.json --noEmit && jest",
        "lint": "tslint -c \"../../config/tslint.json\" -p tsconfig.json src/*.ts",
        "prebuild": "npm run clean",
        "build": "tsc -b .",
        "postbuild": "npm run bundle",
        "bundle": "../../node_modules/rollup/bin/rollup -c rollup.config.js",
        "watch": "../../node_modules/tsc-watch/index.js --onSuccess \"npm run postbuild\"",
        "clean": "rm -rf coverage/* lib/*",
        "prepublishOnly": "npm run build"
      },
      "dependencies": {
        "apollo-cache": "^1.3.0-beta.0",
        "apollo-utilities": "^1.3.0-beta.0",
        "optimism": "^0.6.9",
        "ts-invariant": "^0.3.2",
        "tslib": "^1.9.3"
      },
      "peerDependencies": {
        "graphql": "0.11.7 || ^0.12.0 || ^0.13.0 || ^14.0.0"
      },
      "gitHead": "bd691bc247621084b953ad0ca36f056b4e0ce845",
      "readme": "---\ntitle: InMemoryCache\ndescription: An explanation of `apollo-cache-inmemory`\n---\n\n`apollo-cache-inmemory` is the recommended cache implementation for Apollo Client 2.0. `InMemoryCache` is a normalized data store that supports all of Apollo Client 1.0's features without the dependency on Redux.\n\nIn some instances, you may need to manipulate the cache directly, such as updating the store after a mutation. We'll cover some common use cases [here](#recipes).\n\n<h2 id=\"installation\">Installation</h2>\n\n```\nnpm install apollo-cache-inmemory --save\n```\n\nAfter installing the package, you'll want to initialize the cache constructor. Then, you can pass in your newly created cache to ApolloClient.\n\n```js\nimport { InMemoryCache } from 'apollo-cache-inmemory';\nimport { HttpLink } from 'apollo-link-http';\nimport ApolloClient from 'apollo-client';\n\nconst cache = new InMemoryCache();\n\nconst client = new ApolloClient({\n  link: new HttpLink(),\n  cache\n});\n```\n\n<h2 id=\"configuration\">Configuration</h2>\n\nThe `InMemoryCache` constructor takes an optional config object with properties to customize your cache:\n\n- addTypename: A boolean to determine whether to add __typename to the document (default: `true`)\n- dataIdFromObject: A function that takes a data object and returns a unique identifier to be used when normalizing the data in the store. Learn more about how to customize `dataIdFromObject` in the [Normalization](#normalization) section.\n- fragmentMatcher: By default, the `InMemoryCache` uses a heuristic fragment matcher. If you are using fragments on unions and interfaces, you will need to use an `IntrospectionFragmentMatcher`. For more information, please read [our guide to setting up fragment matching for unions & interfaces](https://www.apollographql.com/docs/react/advanced/fragments.html#fragment-matcher).\n\n<h2 id=\"normalization\">Normalization</h2>\n\nThe `InMemoryCache` normalizes your data before saving it to the store by splitting the result into individual objects, creating a unique identifier for each object, and storing those objects in a flattened data structure. By default, `InMemoryCache` will attempt to use the commonly found primary keys of `id` and `_id` for the unique identifier if they exist along with `__typename` on an object.\n\nIf `id` and `_id` are not specified, or if `__typename` is not specified, `InMemoryCache` will fall back to the path to the object in the query, such as `ROOT_QUERY.allPeople.0` for the first record returned on the `allPeople` root query.\n\nThis \"getter\" behavior for unique identifiers can be configured manually via the `dataIdFromObject` option passed to the `InMemoryCache` constructor, so you can pick which field is used if some of your data follows unorthodox primary key conventions.\n\nFor example, if you wanted to key off of the `key` field for all of your data, you could configure `dataIdFromObject` like so:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => object.key\n});\n```\n\nThis also allows you to use different unique identifiers for different data types by keying off of the `__typename` property attached to every object typed by GraphQL.  For example:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => {\n    switch (object.__typename) {\n      case 'foo': return object.key; // use `key` as the primary key\n      case 'bar': return object.blah; // use `blah` as the priamry key\n      default: return object.id || object._id; // fall back to `id` and `_id` for all other types\n    }\n  }\n});\n```\n\n<h2 id=\"direct\">Direct Cache Access</h2>\n\nTo interact directly with your cache, you can use the Apollo Client class methods readQuery, readFragment, writeQuery, and writeFragment. These methods are available to us via the [`DataProxy` interface](https://github.com/apollographql/apollo-client/blob/master/packages/apollo-cache/src/types/DataProxy.ts). Accessing these methods will vary slightly based on your view layer implementation. If you are using React, you can wrap your component in the `withApollo` higher order component, which will give you access to `this.props.client`. From there, you can use the methods to control your data.\n\nAny code demonstration in the following sections will assume that we have already initialized an instance of  `ApolloClient` and that we have imported the `gql` tag from `graphql-tag`.\n\n<h3 id=\"readquery\">readQuery</h3>\n\nThe `readQuery` method is very similar to the [`query` method on `ApolloClient`][] except that `readQuery` will _never_ make a request to your GraphQL server. The `query` method, on the other hand, may send a request to your server if the appropriate data is not in your cache whereas `readQuery` will throw an error if the data is not in your cache. `readQuery` will _always_ read from the cache. You can use `readQuery` by giving it a GraphQL query like so:\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo {\n      todo(id: 5) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n});\n```\n\nIf all of the data needed to fulfill this read is in Apollo Client’s normalized data cache then a data object will be returned in the shape of the query you wanted to read. If not all of the data needed to fulfill this read is in Apollo Client’s cache then an error will be thrown instead, so make sure to only read data that you know you have!\n\nYou can also pass variables into `readQuery`.\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo($id: Int!) {\n      todo(id: $id) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n  variables: {\n    id: 5,\n  },\n});\n```\n\n<h3 id=\"readfragment\">readFragment</h3>\n\nThis method allows you great flexibility around the data in your cache. Whereas `readQuery` only allowed you to read data from your root query type, `readFragment` allows you to read data from _any node you have queried_. This is incredibly powerful. You use this method as follows:\n\n```js\nconst todo = client.readFragment({\n  id: ..., // `id` is any id that could be returned by `dataIdFromObject`.\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\nThe first argument is the id of the data you want to read from the cache. That id must be a value that was returned by the `dataIdFromObject` function you defined when initializing `ApolloClient`. So for example if you initialized `ApolloClient` like so:\n\n```js\nconst client = new ApolloClient({\n  ...,\n  dataIdFromObject: object => object.id,\n});\n```\n\n…and you requested a todo before with an id of `5`, then you can read that todo out of your cache with the following:\n\n```js\nconst todo = client.readFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\n> **Note:** Most people add a `__typename` to the id in `dataIdFromObject`. If you do this then don’t forget to add the `__typename` when you are reading a fragment as well. So for example your id may be `Todo_5` and not just `5`.\n\nIf a todo with that id does not exist in the cache you will get `null` back. If a todo of that id does exist in the cache, but that todo does not have the `text` field then an error will be thrown.\n\nThe beauty of `readFragment` is that the todo could have come from anywhere! The todo could have been selected as a singleton (`{ todo(id: 5) { ... } }`), the todo could have come from a list of todos (`{ todos { ... } }`), or the todo could have come from a mutation (`mutation { createTodo { ... } }`). As long as at some point your GraphQL server gave you a todo with the provided id and fields `id`, `text`, and `completed` you can read it from the cache at any part of your code.\n\n<h3 id=\"writequery-and-writefragment\">writeQuery` and `writeFragment</h3>\n\nNot only can you read arbitrary data from the Apollo Client cache, but you can also write any data that you would like to the cache. The methods you use to do this are `writeQuery` and `writeFragment`. They will allow you to change data in your local cache, but it is important to remember that *they will not change any data on your server*. If you reload your environment then changes made with `writeQuery` and `writeFragment` will disappear.\n\nThese methods have the same signature as their `readQuery` and `readFragment` counterparts except they also require an additional `data` variable. So for example, if you wanted to update the `completed` flag locally for your todo with id `'5'` you could execute the following:\n\n```js\nclient.writeFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      completed\n    }\n  `,\n  data: {\n    completed: true,\n  },\n});\n```\n\nAny subscriber to the Apollo Client store will instantly see this update and render new UI accordingly.\n\n> **Note:** Again, remember that using `writeQuery` or `writeFragment` only changes data *locally*. If you reload your environment then changes made with these methods will no longer exist.\n\nOr if you wanted to add a new todo to a list fetched from the server, you could use `readQuery` and `writeQuery` together.\n\n```js\nconst query = gql`\n  query MyTodoAppQuery {\n    todos {\n      id\n      text\n      completed\n    }\n  }\n`;\n\nconst data = client.readQuery({ query });\n\nconst myNewTodo = {\n  id: '6',\n  text: 'Start using Apollo Client.',\n  completed: false,\n};\n\nclient.writeQuery({\n  query,\n  data: {\n    todos: [...data.todos, myNewTodo],\n  },\n});\n```\n\n<h2 id=\"recipes\">Recipes</h2>\n\nHere are some common situations where you would need to access the cache directly. If you're manipulating the cache in an interesting way and would like your example to be featured, please send in a pull request!\n\n<h3 id=\"server\">Server side rendering</h3>\n\nFirst, you will need to initialize an `InMemoryCache` on the server and create an instance of `ApolloClient`. In the initial serialized HTML payload from the server, you should include a script tag that extracts the data from the cache.\n\n```js\n`<script>\n  window.__APOLLO_STATE__=${JSON.stringify(cache.extract())}\n</script>`\n```\n\nOn the client, you can rehydrate the cache using the initial data passed from the server:\n\n```js\ncache: new Cache().restore(window.__APOLLO_STATE__)\n```\n\nIf you would like to learn more about server side rendering, please check our our more in depth guide [here].\n<!---\nTODO (PEGGY): Add link to SSR\n-->\n\n<h3 id=\"server\">Updating the cache after a mutation</h3>\n\nBeing able to read and write to the Apollo cache from anywhere in your application gives you a lot of power over your data. However, there is one place where we most often want to update our cached data: after a mutation. As such, Apollo Client has optimized the experience for updating your cache with the read and write methods after a mutation with the `update` function. Let us say that we have the following GraphQL mutation:\n\n```graphql\nmutation TodoCreateMutation($text: String!) {\n  createTodo(text: $text) {\n    id\n    text\n    completed\n  }\n}\n```\n\nWe may also have the following GraphQL query:\n\n```graphql\nquery TodoAppQuery {\n  todos {\n    id\n    text\n    completed\n  }\n}\n```\n\nAt the end of our mutation we want our query to include the new todo like we had sent our `TodoAppQuery` a second time after the mutation finished without actually sending the query. To do this we can use the `update` function provided as an option of the `client.mutate` method. To update your cache with the mutation just write code that looks like:\n\n```js\n// We assume that the GraphQL operations `TodoCreateMutation` and\n// `TodoAppQuery` have already been defined using the `gql` tag.\n\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    // Read the data from our cache for this query.\n    const data = proxy.readQuery({ query: TodoAppQuery });\n\n    // Add our todo from the mutation to the end.\n    data.todos.push(createTodo);\n\n    // Write our data back to the cache.\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nThe first `proxy` argument is an instance of [`DataProxy`][] has the same four methods that we just learned exist on the Apollo Client: `readQuery`, `readFragment`, `writeQuery`, and `writeFragment`. The reason we call them on a `proxy` object here instead of on our `client` instance is that we can easily apply optimistic updates (which we will demonstrate in a bit). The `proxy` object also provides an isolated transaction which shields you from any other mutations going on at the same time, and the `proxy` object also batches writes together until the very end.\n\nIf you provide an `optimisticResponse` option to the mutation then the `update` function will be run twice. Once immediately after you call `client.mutate` with the data from `optimisticResponse`. After the mutation successfully executes against the server the changes made in the first call to `update` will be rolled back and `update` will be called with the *actual* data returned by the mutation and not just the optimistic response.\n\nPutting it all together:\n\n```js\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  optimisticResponse: {\n    id: -1, // -1 is a temporary id for the optimistic response.\n    text,\n    completed: false,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    const data = proxy.readQuery({ query: TodoAppQuery });\n    data.todos.push(createTodo);\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nAs you can see the `update` function on `client.mutate` provides extra change management functionality specific to the use case of a mutation while still providing you the powerful data control APIs that are available on `client`.\n\nThe `update` function is not a good place for side-effects as it may be called multiple times. Also, you may not call any of the methods on `proxy` asynchronously.\n\n",
      "readmeFilename": "README.md",
      "_id": "apollo-cache-inmemory@1.6.0-beta.0",
      "_nodeVersion": "8.15.1",
      "_npmVersion": "lerna/3.13.1/node@v8.15.1+x64 (darwin)",
      "_npmUser": {
        "name": "apollo-bot",
        "email": "npm@apollographql.com"
      },
      "dist": {
        "integrity": "sha512-rvcnR78ySCQjLsBJum3+SWOh+i76sswUh4tvi02mJf9zDetL1o82/iejnxNZzvolyAK8fkhrwg5j3hL4Ok+1Rw==",
        "shasum": "be9eb4401979fa6b99302d8dae0d330e2f3694b5",
        "tarball": "https://registry.npmjs.org/apollo-cache-inmemory/-/apollo-cache-inmemory-1.6.0-beta.0.tgz",
        "fileCount": 60,
        "unpackedSize": 543947,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJci9PWCRA9TVsSAnZWagAAP6sP/1lII+rLNEjEd3b988W9\nxn7xgLLmyEjYo3Ln44GdhmBN4BM0Ps4qNn6c7XxYDMtLTB2/a0hchUTAdfCJ\nxhg4whHbh17GFOENIIjBUU+SVxLvimUpKoKB0vbJNE2E06Oaz/N6/j/jLfEV\n4qc3deGjEUOMEkjMAdK0EWDv7WebanAc2a98dPS4+ew25OI+221SnqiiLgEK\nQS6RT2Be+gE52D4ukTlgYTkwDG4yM1AWq98QSpcjT61rypb3pB+Q1VpEhgPM\nGliMp0LAC9zl2BKYJ/hQURqqnLl08tL0XFN7h4404N7uGnYfIwrxa9EDoGXf\n8e40mBhgkAfG3bksLZCIHk0DlI71kGFQprbzudanRkVlg/vyeQQIHpf/bY1z\nlEokMkRiMuDyw0PhTmPeibdpN7qmUQfD1EA5eXsUyWb4q8cKgygHTAjIbuHY\n4ykI5v3hQBTQZz0C9ZMierVuVpX9CCqW3n2+qFoSDFc/Xd0MREKYbNDSn6/j\nclApkbgqD++DElD23rINAsWITKrCZ4l376WKqlFf8EoW/HM1i3vmd1BIBqRz\n2jJy8G9H8le8wvhqd9D4nDp1j8s20DHIy6mh6gHobQ3vweq1lYrpZz9JMgK4\n3iwXKjM61wR1UXNhcuTBo8NSzy4+GIj9fDiztEnTK51F0yCVrJx00rqgyZIx\nVifw\r\n=fToh\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEQCIEvTXncKreorUoJB851Fk5PANy//Y7bXuOYRLbOheCBZAiAdQpvV/g5WdKFt+1I5MR5I0e+onPc1SDfixSFGHdbhlQ=="
          }
        ]
      },
      "maintainers": [
        {
          "email": "npm@apollographql.com",
          "name": "apollo-bot"
        },
        {
          "email": "ben@benjamn.com",
          "name": "benjamn"
        },
        {
          "email": "james@meteor.com",
          "name": "jbaxleyiii"
        },
        {
          "email": "peggyrayzis@gmail.com",
          "name": "peggyrayzis"
        }
      ],
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/apollo-cache-inmemory_1.6.0-beta.0_1552667605444_0.45826040605909957"
      },
      "_hasShrinkwrap": false
    },
    "1.6.0-beta.1": {
      "name": "apollo-cache-inmemory",
      "version": "1.6.0-beta.1",
      "description": "Core abstract of Caching layer for Apollo Client",
      "author": {
        "name": "James Baxley",
        "email": "james@meteor.com"
      },
      "contributors": [
        {
          "name": "James Baxley",
          "email": "james@meteor.com"
        },
        {
          "name": "Jonas Helfer",
          "email": "jonas@helfer.email"
        },
        {
          "name": "Sashko Stubailo",
          "email": "sashko@stubailo.com"
        },
        {
          "name": "James Burgess",
          "email": "jamesmillerburgess@gmail.com"
        },
        {
          "name": "Bazyli Brzóska",
          "email": "bazyli.brzoska@gmail.com"
        }
      ],
      "license": "MIT",
      "main": "./lib/bundle.cjs.js",
      "module": "./lib/bundle.esm.js",
      "typings": "./lib/index.d.ts",
      "sideEffects": [
        "./lib/fixPolyfills.js"
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/apollographql/apollo-client.git"
      },
      "bugs": {
        "url": "https://github.com/apollographql/apollo-client/issues"
      },
      "homepage": "https://github.com/apollographql/apollo-client#readme",
      "scripts": {
        "prepare": "npm run build",
        "coverage": "jest --coverage",
        "test": "tsc -p tsconfig.json --noEmit && jest",
        "lint": "tslint -c \"../../config/tslint.json\" -p tsconfig.json src/*.ts",
        "prebuild": "npm run clean",
        "build": "tsc -b .",
        "postbuild": "npm run bundle",
        "bundle": "../../node_modules/rollup/bin/rollup -c rollup.config.js",
        "watch": "../../node_modules/tsc-watch/index.js --onSuccess \"npm run postbuild\"",
        "clean": "rm -rf coverage/* lib/*",
        "prepublishOnly": "npm run build"
      },
      "dependencies": {
        "apollo-cache": "^1.3.0-beta.1",
        "apollo-utilities": "^1.3.0-beta.1",
        "optimism": "^0.8.3",
        "ts-invariant": "^0.3.2",
        "tslib": "^1.9.3"
      },
      "peerDependencies": {
        "graphql": "0.11.7 || ^0.12.0 || ^0.13.0 || ^14.0.0"
      },
      "gitHead": "68169f31a4d4d41af9a90ae1fed4414255e829a3",
      "readme": "---\ntitle: InMemoryCache\ndescription: An explanation of `apollo-cache-inmemory`\n---\n\n`apollo-cache-inmemory` is the recommended cache implementation for Apollo Client 2.0. `InMemoryCache` is a normalized data store that supports all of Apollo Client 1.0's features without the dependency on Redux.\n\nIn some instances, you may need to manipulate the cache directly, such as updating the store after a mutation. We'll cover some common use cases [here](#recipes).\n\n<h2 id=\"installation\">Installation</h2>\n\n```\nnpm install apollo-cache-inmemory --save\n```\n\nAfter installing the package, you'll want to initialize the cache constructor. Then, you can pass in your newly created cache to ApolloClient.\n\n```js\nimport { InMemoryCache } from 'apollo-cache-inmemory';\nimport { HttpLink } from 'apollo-link-http';\nimport ApolloClient from 'apollo-client';\n\nconst cache = new InMemoryCache();\n\nconst client = new ApolloClient({\n  link: new HttpLink(),\n  cache\n});\n```\n\n<h2 id=\"configuration\">Configuration</h2>\n\nThe `InMemoryCache` constructor takes an optional config object with properties to customize your cache:\n\n- addTypename: A boolean to determine whether to add __typename to the document (default: `true`)\n- dataIdFromObject: A function that takes a data object and returns a unique identifier to be used when normalizing the data in the store. Learn more about how to customize `dataIdFromObject` in the [Normalization](#normalization) section.\n- fragmentMatcher: By default, the `InMemoryCache` uses a heuristic fragment matcher. If you are using fragments on unions and interfaces, you will need to use an `IntrospectionFragmentMatcher`. For more information, please read [our guide to setting up fragment matching for unions & interfaces](https://www.apollographql.com/docs/react/advanced/fragments.html#fragment-matcher).\n\n<h2 id=\"normalization\">Normalization</h2>\n\nThe `InMemoryCache` normalizes your data before saving it to the store by splitting the result into individual objects, creating a unique identifier for each object, and storing those objects in a flattened data structure. By default, `InMemoryCache` will attempt to use the commonly found primary keys of `id` and `_id` for the unique identifier if they exist along with `__typename` on an object.\n\nIf `id` and `_id` are not specified, or if `__typename` is not specified, `InMemoryCache` will fall back to the path to the object in the query, such as `ROOT_QUERY.allPeople.0` for the first record returned on the `allPeople` root query.\n\nThis \"getter\" behavior for unique identifiers can be configured manually via the `dataIdFromObject` option passed to the `InMemoryCache` constructor, so you can pick which field is used if some of your data follows unorthodox primary key conventions.\n\nFor example, if you wanted to key off of the `key` field for all of your data, you could configure `dataIdFromObject` like so:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => object.key\n});\n```\n\nThis also allows you to use different unique identifiers for different data types by keying off of the `__typename` property attached to every object typed by GraphQL.  For example:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => {\n    switch (object.__typename) {\n      case 'foo': return object.key; // use `key` as the primary key\n      case 'bar': return object.blah; // use `blah` as the priamry key\n      default: return object.id || object._id; // fall back to `id` and `_id` for all other types\n    }\n  }\n});\n```\n\n<h2 id=\"direct\">Direct Cache Access</h2>\n\nTo interact directly with your cache, you can use the Apollo Client class methods readQuery, readFragment, writeQuery, and writeFragment. These methods are available to us via the [`DataProxy` interface](https://github.com/apollographql/apollo-client/blob/master/packages/apollo-cache/src/types/DataProxy.ts). Accessing these methods will vary slightly based on your view layer implementation. If you are using React, you can wrap your component in the `withApollo` higher order component, which will give you access to `this.props.client`. From there, you can use the methods to control your data.\n\nAny code demonstration in the following sections will assume that we have already initialized an instance of  `ApolloClient` and that we have imported the `gql` tag from `graphql-tag`.\n\n<h3 id=\"readquery\">readQuery</h3>\n\nThe `readQuery` method is very similar to the [`query` method on `ApolloClient`][] except that `readQuery` will _never_ make a request to your GraphQL server. The `query` method, on the other hand, may send a request to your server if the appropriate data is not in your cache whereas `readQuery` will throw an error if the data is not in your cache. `readQuery` will _always_ read from the cache. You can use `readQuery` by giving it a GraphQL query like so:\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo {\n      todo(id: 5) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n});\n```\n\nIf all of the data needed to fulfill this read is in Apollo Client’s normalized data cache then a data object will be returned in the shape of the query you wanted to read. If not all of the data needed to fulfill this read is in Apollo Client’s cache then an error will be thrown instead, so make sure to only read data that you know you have!\n\nYou can also pass variables into `readQuery`.\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo($id: Int!) {\n      todo(id: $id) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n  variables: {\n    id: 5,\n  },\n});\n```\n\n<h3 id=\"readfragment\">readFragment</h3>\n\nThis method allows you great flexibility around the data in your cache. Whereas `readQuery` only allowed you to read data from your root query type, `readFragment` allows you to read data from _any node you have queried_. This is incredibly powerful. You use this method as follows:\n\n```js\nconst todo = client.readFragment({\n  id: ..., // `id` is any id that could be returned by `dataIdFromObject`.\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\nThe first argument is the id of the data you want to read from the cache. That id must be a value that was returned by the `dataIdFromObject` function you defined when initializing `ApolloClient`. So for example if you initialized `ApolloClient` like so:\n\n```js\nconst client = new ApolloClient({\n  ...,\n  dataIdFromObject: object => object.id,\n});\n```\n\n…and you requested a todo before with an id of `5`, then you can read that todo out of your cache with the following:\n\n```js\nconst todo = client.readFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\n> **Note:** Most people add a `__typename` to the id in `dataIdFromObject`. If you do this then don’t forget to add the `__typename` when you are reading a fragment as well. So for example your id may be `Todo_5` and not just `5`.\n\nIf a todo with that id does not exist in the cache you will get `null` back. If a todo of that id does exist in the cache, but that todo does not have the `text` field then an error will be thrown.\n\nThe beauty of `readFragment` is that the todo could have come from anywhere! The todo could have been selected as a singleton (`{ todo(id: 5) { ... } }`), the todo could have come from a list of todos (`{ todos { ... } }`), or the todo could have come from a mutation (`mutation { createTodo { ... } }`). As long as at some point your GraphQL server gave you a todo with the provided id and fields `id`, `text`, and `completed` you can read it from the cache at any part of your code.\n\n<h3 id=\"writequery-and-writefragment\">writeQuery` and `writeFragment</h3>\n\nNot only can you read arbitrary data from the Apollo Client cache, but you can also write any data that you would like to the cache. The methods you use to do this are `writeQuery` and `writeFragment`. They will allow you to change data in your local cache, but it is important to remember that *they will not change any data on your server*. If you reload your environment then changes made with `writeQuery` and `writeFragment` will disappear.\n\nThese methods have the same signature as their `readQuery` and `readFragment` counterparts except they also require an additional `data` variable. So for example, if you wanted to update the `completed` flag locally for your todo with id `'5'` you could execute the following:\n\n```js\nclient.writeFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      completed\n    }\n  `,\n  data: {\n    completed: true,\n  },\n});\n```\n\nAny subscriber to the Apollo Client store will instantly see this update and render new UI accordingly.\n\n> **Note:** Again, remember that using `writeQuery` or `writeFragment` only changes data *locally*. If you reload your environment then changes made with these methods will no longer exist.\n\nOr if you wanted to add a new todo to a list fetched from the server, you could use `readQuery` and `writeQuery` together.\n\n```js\nconst query = gql`\n  query MyTodoAppQuery {\n    todos {\n      id\n      text\n      completed\n    }\n  }\n`;\n\nconst data = client.readQuery({ query });\n\nconst myNewTodo = {\n  id: '6',\n  text: 'Start using Apollo Client.',\n  completed: false,\n};\n\nclient.writeQuery({\n  query,\n  data: {\n    todos: [...data.todos, myNewTodo],\n  },\n});\n```\n\n<h2 id=\"recipes\">Recipes</h2>\n\nHere are some common situations where you would need to access the cache directly. If you're manipulating the cache in an interesting way and would like your example to be featured, please send in a pull request!\n\n<h3 id=\"server\">Server side rendering</h3>\n\nFirst, you will need to initialize an `InMemoryCache` on the server and create an instance of `ApolloClient`. In the initial serialized HTML payload from the server, you should include a script tag that extracts the data from the cache.\n\n```js\n`<script>\n  window.__APOLLO_STATE__=${JSON.stringify(cache.extract())}\n</script>`\n```\n\nOn the client, you can rehydrate the cache using the initial data passed from the server:\n\n```js\ncache: new Cache().restore(window.__APOLLO_STATE__)\n```\n\nIf you would like to learn more about server side rendering, please check our our more in depth guide [here].\n<!---\nTODO (PEGGY): Add link to SSR\n-->\n\n<h3 id=\"server\">Updating the cache after a mutation</h3>\n\nBeing able to read and write to the Apollo cache from anywhere in your application gives you a lot of power over your data. However, there is one place where we most often want to update our cached data: after a mutation. As such, Apollo Client has optimized the experience for updating your cache with the read and write methods after a mutation with the `update` function. Let us say that we have the following GraphQL mutation:\n\n```graphql\nmutation TodoCreateMutation($text: String!) {\n  createTodo(text: $text) {\n    id\n    text\n    completed\n  }\n}\n```\n\nWe may also have the following GraphQL query:\n\n```graphql\nquery TodoAppQuery {\n  todos {\n    id\n    text\n    completed\n  }\n}\n```\n\nAt the end of our mutation we want our query to include the new todo like we had sent our `TodoAppQuery` a second time after the mutation finished without actually sending the query. To do this we can use the `update` function provided as an option of the `client.mutate` method. To update your cache with the mutation just write code that looks like:\n\n```js\n// We assume that the GraphQL operations `TodoCreateMutation` and\n// `TodoAppQuery` have already been defined using the `gql` tag.\n\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    // Read the data from our cache for this query.\n    const data = proxy.readQuery({ query: TodoAppQuery });\n\n    // Add our todo from the mutation to the end.\n    data.todos.push(createTodo);\n\n    // Write our data back to the cache.\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nThe first `proxy` argument is an instance of [`DataProxy`][] has the same four methods that we just learned exist on the Apollo Client: `readQuery`, `readFragment`, `writeQuery`, and `writeFragment`. The reason we call them on a `proxy` object here instead of on our `client` instance is that we can easily apply optimistic updates (which we will demonstrate in a bit). The `proxy` object also provides an isolated transaction which shields you from any other mutations going on at the same time, and the `proxy` object also batches writes together until the very end.\n\nIf you provide an `optimisticResponse` option to the mutation then the `update` function will be run twice. Once immediately after you call `client.mutate` with the data from `optimisticResponse`. After the mutation successfully executes against the server the changes made in the first call to `update` will be rolled back and `update` will be called with the *actual* data returned by the mutation and not just the optimistic response.\n\nPutting it all together:\n\n```js\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  optimisticResponse: {\n    id: -1, // -1 is a temporary id for the optimistic response.\n    text,\n    completed: false,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    const data = proxy.readQuery({ query: TodoAppQuery });\n    data.todos.push(createTodo);\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nAs you can see the `update` function on `client.mutate` provides extra change management functionality specific to the use case of a mutation while still providing you the powerful data control APIs that are available on `client`.\n\nThe `update` function is not a good place for side-effects as it may be called multiple times. Also, you may not call any of the methods on `proxy` asynchronously.\n\n",
      "readmeFilename": "README.md",
      "_id": "apollo-cache-inmemory@1.6.0-beta.1",
      "_nodeVersion": "8.15.1",
      "_npmVersion": "lerna/3.13.1/node@v8.15.1+x64 (darwin)",
      "_npmUser": {
        "name": "apollo-bot",
        "email": "npm@apollographql.com"
      },
      "dist": {
        "integrity": "sha512-jzkPtDqOJpq3gEIEq4PoiTxi5LuYb0SbZknAZMR9cAMGdoQYGdfaMx/0BEQKYHNBUTvSnVAIdDYPe4pu3M1cfg==",
        "shasum": "dbe640129ab2b03a5d6e5005b780e653e9fb2b02",
        "tarball": "https://registry.npmjs.org/apollo-cache-inmemory/-/apollo-cache-inmemory-1.6.0-beta.1.tgz",
        "fileCount": 56,
        "unpackedSize": 532829,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJclSHxCRA9TVsSAnZWagAAD9wP/3A2t+IarMeEie2Eba3K\noUF5M2QxxMm2Au5q44GrMF2udRpeAtexML7IfE1R4QFv/uYxjdf/YfnVz2P8\ntrXp+4NPixmTvuMuH8w07/0G76KJS6Ix5FEabCOAVDKpFoggia4fmBziksI/\n5K3oByAyiYj+d+vC9KT06JD6SOBoZtPwlfl8MMrBz3K3LTC1M0hMD1L7JsNP\ntSY6nHo7lGdc9HaC018zbrnbcIFJWNxDGN5rbHnZrW1b3vrffpOVr6089pj5\nGU8CMxFxSZha8KW28uQQiQJyZNP5dmrdjwu2W7uZNvPYnEhhH36thEyNGjw2\nZZMeDCQk534U+86tBOXaCfxumUeOK3cdz7NVZmiSXLIXMF4HYamt6HnWQ8uC\neqh5pCXrpvCgSm1+/ZyUgIVIElIU+4nxg/gnjVU1QZCuzhHz/Im1EsUIcg06\n9CSC3BIuo5yeKUxegv6VrrobJmUVK1m5BcUN528msnIuiEA833x1XZIZddiS\nWJm42CSXOrWDFdJzUmQ1YrwE+EDCa0OfzdLSIivCtGNK+HRkv/IQ2Yc1U6Li\nAMF05xs8hU5Wgi5wxEynuOWg6zebphI+Y+yR2gUzmNWBoM8V4UGgP7yzb95r\nb/UhX8fwyRUUEcdPZKXDpvs9XruJ7gy2xLROObWvES8g7KUL/C3omDSL6eI4\nqGnz\r\n=BB5c\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEQCIC5wnE6/A8/5GyzGC/4or68I5bHuaV2nVUn480Q+Mbu8AiBxxORHKVrO+qaPO8gkMXyP7v7ce3YZJ9V+aGEAPLVSoA=="
          }
        ]
      },
      "maintainers": [
        {
          "email": "npm@apollographql.com",
          "name": "apollo-bot"
        },
        {
          "email": "ben@benjamn.com",
          "name": "benjamn"
        },
        {
          "email": "james@meteor.com",
          "name": "jbaxleyiii"
        },
        {
          "email": "peggyrayzis@gmail.com",
          "name": "peggyrayzis"
        }
      ],
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/apollo-cache-inmemory_1.6.0-beta.1_1553277424945_0.017097820431067445"
      },
      "_hasShrinkwrap": false
    },
    "1.6.0-beta.4": {
      "name": "apollo-cache-inmemory",
      "version": "1.6.0-beta.4",
      "description": "Core abstract of Caching layer for Apollo Client",
      "author": {
        "name": "James Baxley",
        "email": "james@meteor.com"
      },
      "contributors": [
        {
          "name": "James Baxley",
          "email": "james@meteor.com"
        },
        {
          "name": "Jonas Helfer",
          "email": "jonas@helfer.email"
        },
        {
          "name": "Sashko Stubailo",
          "email": "sashko@stubailo.com"
        },
        {
          "name": "James Burgess",
          "email": "jamesmillerburgess@gmail.com"
        },
        {
          "name": "Bazyli Brzóska",
          "email": "bazyli.brzoska@gmail.com"
        }
      ],
      "license": "MIT",
      "main": "./lib/bundle.cjs.js",
      "module": "./lib/bundle.esm.js",
      "typings": "./lib/index.d.ts",
      "sideEffects": [
        "./lib/fixPolyfills.js"
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/apollographql/apollo-client.git"
      },
      "bugs": {
        "url": "https://github.com/apollographql/apollo-client/issues"
      },
      "homepage": "https://github.com/apollographql/apollo-client#readme",
      "scripts": {
        "prepare": "npm run build",
        "coverage": "jest --coverage",
        "test": "tsc -p tsconfig.json --noEmit && jest",
        "lint": "tslint -c \"../../config/tslint.json\" -p tsconfig.json src/*.ts",
        "prebuild": "npm run clean",
        "build": "tsc -b .",
        "postbuild": "npm run bundle",
        "bundle": "../../node_modules/rollup/bin/rollup -c rollup.config.js",
        "watch": "../../node_modules/tsc-watch/index.js --onSuccess \"npm run postbuild\"",
        "clean": "rm -rf coverage/* lib/*",
        "prepublishOnly": "npm run build"
      },
      "dependencies": {
        "apollo-cache": "^1.3.0-beta.1",
        "apollo-utilities": "^1.3.0-beta.1",
        "optimism": "^0.9.0",
        "ts-invariant": "^0.3.2",
        "tslib": "^1.9.3"
      },
      "peerDependencies": {
        "graphql": "0.11.7 || ^0.12.0 || ^0.13.0 || ^14.0.0"
      },
      "gitHead": "6c1f06d2e7fbb99790d5837dc4e0458d5e6b443a",
      "readme": "---\ntitle: InMemoryCache\ndescription: An explanation of `apollo-cache-inmemory`\n---\n\n`apollo-cache-inmemory` is the recommended cache implementation for Apollo Client 2.0. `InMemoryCache` is a normalized data store that supports all of Apollo Client 1.0's features without the dependency on Redux.\n\nIn some instances, you may need to manipulate the cache directly, such as updating the store after a mutation. We'll cover some common use cases [here](#recipes).\n\n<h2 id=\"installation\">Installation</h2>\n\n```\nnpm install apollo-cache-inmemory --save\n```\n\nAfter installing the package, you'll want to initialize the cache constructor. Then, you can pass in your newly created cache to ApolloClient.\n\n```js\nimport { InMemoryCache } from 'apollo-cache-inmemory';\nimport { HttpLink } from 'apollo-link-http';\nimport ApolloClient from 'apollo-client';\n\nconst cache = new InMemoryCache();\n\nconst client = new ApolloClient({\n  link: new HttpLink(),\n  cache\n});\n```\n\n<h2 id=\"configuration\">Configuration</h2>\n\nThe `InMemoryCache` constructor takes an optional config object with properties to customize your cache:\n\n- addTypename: A boolean to determine whether to add __typename to the document (default: `true`)\n- dataIdFromObject: A function that takes a data object and returns a unique identifier to be used when normalizing the data in the store. Learn more about how to customize `dataIdFromObject` in the [Normalization](#normalization) section.\n- fragmentMatcher: By default, the `InMemoryCache` uses a heuristic fragment matcher. If you are using fragments on unions and interfaces, you will need to use an `IntrospectionFragmentMatcher`. For more information, please read [our guide to setting up fragment matching for unions & interfaces](https://www.apollographql.com/docs/react/advanced/fragments.html#fragment-matcher).\n\n<h2 id=\"normalization\">Normalization</h2>\n\nThe `InMemoryCache` normalizes your data before saving it to the store by splitting the result into individual objects, creating a unique identifier for each object, and storing those objects in a flattened data structure. By default, `InMemoryCache` will attempt to use the commonly found primary keys of `id` and `_id` for the unique identifier if they exist along with `__typename` on an object.\n\nIf `id` and `_id` are not specified, or if `__typename` is not specified, `InMemoryCache` will fall back to the path to the object in the query, such as `ROOT_QUERY.allPeople.0` for the first record returned on the `allPeople` root query.\n\nThis \"getter\" behavior for unique identifiers can be configured manually via the `dataIdFromObject` option passed to the `InMemoryCache` constructor, so you can pick which field is used if some of your data follows unorthodox primary key conventions.\n\nFor example, if you wanted to key off of the `key` field for all of your data, you could configure `dataIdFromObject` like so:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => object.key\n});\n```\n\nThis also allows you to use different unique identifiers for different data types by keying off of the `__typename` property attached to every object typed by GraphQL.  For example:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => {\n    switch (object.__typename) {\n      case 'foo': return object.key; // use `key` as the primary key\n      case 'bar': return object.blah; // use `blah` as the priamry key\n      default: return object.id || object._id; // fall back to `id` and `_id` for all other types\n    }\n  }\n});\n```\n\n<h2 id=\"direct\">Direct Cache Access</h2>\n\nTo interact directly with your cache, you can use the Apollo Client class methods readQuery, readFragment, writeQuery, and writeFragment. These methods are available to us via the [`DataProxy` interface](https://github.com/apollographql/apollo-client/blob/master/packages/apollo-cache/src/types/DataProxy.ts). Accessing these methods will vary slightly based on your view layer implementation. If you are using React, you can wrap your component in the `withApollo` higher order component, which will give you access to `this.props.client`. From there, you can use the methods to control your data.\n\nAny code demonstration in the following sections will assume that we have already initialized an instance of  `ApolloClient` and that we have imported the `gql` tag from `graphql-tag`.\n\n<h3 id=\"readquery\">readQuery</h3>\n\nThe `readQuery` method is very similar to the [`query` method on `ApolloClient`][] except that `readQuery` will _never_ make a request to your GraphQL server. The `query` method, on the other hand, may send a request to your server if the appropriate data is not in your cache whereas `readQuery` will throw an error if the data is not in your cache. `readQuery` will _always_ read from the cache. You can use `readQuery` by giving it a GraphQL query like so:\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo {\n      todo(id: 5) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n});\n```\n\nIf all of the data needed to fulfill this read is in Apollo Client’s normalized data cache then a data object will be returned in the shape of the query you wanted to read. If not all of the data needed to fulfill this read is in Apollo Client’s cache then an error will be thrown instead, so make sure to only read data that you know you have!\n\nYou can also pass variables into `readQuery`.\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo($id: Int!) {\n      todo(id: $id) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n  variables: {\n    id: 5,\n  },\n});\n```\n\n<h3 id=\"readfragment\">readFragment</h3>\n\nThis method allows you great flexibility around the data in your cache. Whereas `readQuery` only allowed you to read data from your root query type, `readFragment` allows you to read data from _any node you have queried_. This is incredibly powerful. You use this method as follows:\n\n```js\nconst todo = client.readFragment({\n  id: ..., // `id` is any id that could be returned by `dataIdFromObject`.\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\nThe first argument is the id of the data you want to read from the cache. That id must be a value that was returned by the `dataIdFromObject` function you defined when initializing `ApolloClient`. So for example if you initialized `ApolloClient` like so:\n\n```js\nconst client = new ApolloClient({\n  ...,\n  dataIdFromObject: object => object.id,\n});\n```\n\n…and you requested a todo before with an id of `5`, then you can read that todo out of your cache with the following:\n\n```js\nconst todo = client.readFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\n> **Note:** Most people add a `__typename` to the id in `dataIdFromObject`. If you do this then don’t forget to add the `__typename` when you are reading a fragment as well. So for example your id may be `Todo_5` and not just `5`.\n\nIf a todo with that id does not exist in the cache you will get `null` back. If a todo of that id does exist in the cache, but that todo does not have the `text` field then an error will be thrown.\n\nThe beauty of `readFragment` is that the todo could have come from anywhere! The todo could have been selected as a singleton (`{ todo(id: 5) { ... } }`), the todo could have come from a list of todos (`{ todos { ... } }`), or the todo could have come from a mutation (`mutation { createTodo { ... } }`). As long as at some point your GraphQL server gave you a todo with the provided id and fields `id`, `text`, and `completed` you can read it from the cache at any part of your code.\n\n<h3 id=\"writequery-and-writefragment\">writeQuery` and `writeFragment</h3>\n\nNot only can you read arbitrary data from the Apollo Client cache, but you can also write any data that you would like to the cache. The methods you use to do this are `writeQuery` and `writeFragment`. They will allow you to change data in your local cache, but it is important to remember that *they will not change any data on your server*. If you reload your environment then changes made with `writeQuery` and `writeFragment` will disappear.\n\nThese methods have the same signature as their `readQuery` and `readFragment` counterparts except they also require an additional `data` variable. So for example, if you wanted to update the `completed` flag locally for your todo with id `'5'` you could execute the following:\n\n```js\nclient.writeFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      completed\n    }\n  `,\n  data: {\n    completed: true,\n  },\n});\n```\n\nAny subscriber to the Apollo Client store will instantly see this update and render new UI accordingly.\n\n> **Note:** Again, remember that using `writeQuery` or `writeFragment` only changes data *locally*. If you reload your environment then changes made with these methods will no longer exist.\n\nOr if you wanted to add a new todo to a list fetched from the server, you could use `readQuery` and `writeQuery` together.\n\n```js\nconst query = gql`\n  query MyTodoAppQuery {\n    todos {\n      id\n      text\n      completed\n    }\n  }\n`;\n\nconst data = client.readQuery({ query });\n\nconst myNewTodo = {\n  id: '6',\n  text: 'Start using Apollo Client.',\n  completed: false,\n};\n\nclient.writeQuery({\n  query,\n  data: {\n    todos: [...data.todos, myNewTodo],\n  },\n});\n```\n\n<h2 id=\"recipes\">Recipes</h2>\n\nHere are some common situations where you would need to access the cache directly. If you're manipulating the cache in an interesting way and would like your example to be featured, please send in a pull request!\n\n<h3 id=\"server\">Server side rendering</h3>\n\nFirst, you will need to initialize an `InMemoryCache` on the server and create an instance of `ApolloClient`. In the initial serialized HTML payload from the server, you should include a script tag that extracts the data from the cache.\n\n```js\n`<script>\n  window.__APOLLO_STATE__=${JSON.stringify(cache.extract())}\n</script>`\n```\n\nOn the client, you can rehydrate the cache using the initial data passed from the server:\n\n```js\ncache: new Cache().restore(window.__APOLLO_STATE__)\n```\n\nIf you would like to learn more about server side rendering, please check our our more in depth guide [here].\n<!---\nTODO (PEGGY): Add link to SSR\n-->\n\n<h3 id=\"server\">Updating the cache after a mutation</h3>\n\nBeing able to read and write to the Apollo cache from anywhere in your application gives you a lot of power over your data. However, there is one place where we most often want to update our cached data: after a mutation. As such, Apollo Client has optimized the experience for updating your cache with the read and write methods after a mutation with the `update` function. Let us say that we have the following GraphQL mutation:\n\n```graphql\nmutation TodoCreateMutation($text: String!) {\n  createTodo(text: $text) {\n    id\n    text\n    completed\n  }\n}\n```\n\nWe may also have the following GraphQL query:\n\n```graphql\nquery TodoAppQuery {\n  todos {\n    id\n    text\n    completed\n  }\n}\n```\n\nAt the end of our mutation we want our query to include the new todo like we had sent our `TodoAppQuery` a second time after the mutation finished without actually sending the query. To do this we can use the `update` function provided as an option of the `client.mutate` method. To update your cache with the mutation just write code that looks like:\n\n```js\n// We assume that the GraphQL operations `TodoCreateMutation` and\n// `TodoAppQuery` have already been defined using the `gql` tag.\n\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    // Read the data from our cache for this query.\n    const data = proxy.readQuery({ query: TodoAppQuery });\n\n    // Add our todo from the mutation to the end.\n    data.todos.push(createTodo);\n\n    // Write our data back to the cache.\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nThe first `proxy` argument is an instance of [`DataProxy`][] has the same four methods that we just learned exist on the Apollo Client: `readQuery`, `readFragment`, `writeQuery`, and `writeFragment`. The reason we call them on a `proxy` object here instead of on our `client` instance is that we can easily apply optimistic updates (which we will demonstrate in a bit). The `proxy` object also provides an isolated transaction which shields you from any other mutations going on at the same time, and the `proxy` object also batches writes together until the very end.\n\nIf you provide an `optimisticResponse` option to the mutation then the `update` function will be run twice. Once immediately after you call `client.mutate` with the data from `optimisticResponse`. After the mutation successfully executes against the server the changes made in the first call to `update` will be rolled back and `update` will be called with the *actual* data returned by the mutation and not just the optimistic response.\n\nPutting it all together:\n\n```js\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  optimisticResponse: {\n    id: -1, // -1 is a temporary id for the optimistic response.\n    text,\n    completed: false,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    const data = proxy.readQuery({ query: TodoAppQuery });\n    data.todos.push(createTodo);\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nAs you can see the `update` function on `client.mutate` provides extra change management functionality specific to the use case of a mutation while still providing you the powerful data control APIs that are available on `client`.\n\nThe `update` function is not a good place for side-effects as it may be called multiple times. Also, you may not call any of the methods on `proxy` asynchronously.\n\n",
      "readmeFilename": "README.md",
      "_id": "apollo-cache-inmemory@1.6.0-beta.4",
      "_nodeVersion": "8.15.1",
      "_npmVersion": "lerna/3.13.1/node@v8.15.1+x64 (darwin)",
      "_npmUser": {
        "name": "benjamn",
        "email": "ben@benjamn.com"
      },
      "dist": {
        "integrity": "sha512-LhEtQ94bPcz2j/PXrCAQgDtT10WdmacND5efoEZLT92bVRXBIkERqcqu9lc+ag83RcCQnWY1upCJNR6utcVtKw==",
        "shasum": "edda64d4772fec27590b726d59151213cfe9665e",
        "tarball": "https://registry.npmjs.org/apollo-cache-inmemory/-/apollo-cache-inmemory-1.6.0-beta.4.tgz",
        "fileCount": 56,
        "unpackedSize": 541111,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJcq31DCRA9TVsSAnZWagAALLkP/06j+R5HJxCWfmag83fy\nNj7GfztbD4VxM8fo3+759u7V+rkGhyF26AIb30YDbe4X21rep2KzFYdHvEVh\nJSy9IvUkTD/dd2V5i9FU+nNNqRm+SPOLxmrkg+QpEwmCvp2crF+joazBnyYJ\nE05v0Z1kDog3VbDF8QOdnHa5NUYBDxWJib1tU9vzBUEQkVrj2FFyaB0SArO3\nJoqFjLmkZQr+2wQ3qTIGCJlZi3il80YSwDjVxOcv7rEIntzx9L1zTGxlefvT\nP6nO2vjBU4o1FFawHbBBNLdK9O8PmcKGnqwnI2FUxIIjJSusIuh11iMq79ic\nn98O7oNawpiACwbTbBT+ZKXC3dt5r7fqAjppxcy/rlBB7gUCWoW/TynEDdSF\nkNkwYnkbgiekqQjr/r00Y1OkPyONb+SioZonpCrOczri4LyGsHJA4mln3tqc\nlkIGQUTkbWockfaWGzMdFEgyAsc+0RViwR0+zT7Y0/Pj9o4oqu301wORVR4m\nzRofbbZ8CFnk21Q2IFGO7j2VeRyeRyBzuOuRTEq8cxQesrETJqcdJEBHsTuv\nbcuCTqpsCVWfWIBhXBcRUsxfijRvRqfUHerDEYwmhRSv40ii8Km8gzWSBVu8\nsgiW9/v895Z1GRKH8gBVM1j3t+om3ZUigHjVe0nj+AWpRqtdxiEZW8JqTzkG\nW/IB\r\n=Xmn/\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEYCIQCaggfFEPM4CYfgfSJMVxIq0EXKaIK4nhrM5Y8I8JLDwwIhAOe/65MpXHYXxlUhGleiG/q2FLnz46PibqjfeuQbihBH"
          }
        ]
      },
      "maintainers": [
        {
          "email": "npm@apollographql.com",
          "name": "apollo-bot"
        },
        {
          "email": "ben@benjamn.com",
          "name": "benjamn"
        },
        {
          "email": "james@meteor.com",
          "name": "jbaxleyiii"
        },
        {
          "email": "peggyrayzis@gmail.com",
          "name": "peggyrayzis"
        }
      ],
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/apollo-cache-inmemory_1.6.0-beta.4_1554742594469_0.9787528375018835"
      },
      "_hasShrinkwrap": false
    },
    "1.6.0-beta.5": {
      "name": "apollo-cache-inmemory",
      "version": "1.6.0-beta.5",
      "description": "Core abstract of Caching layer for Apollo Client",
      "author": {
        "name": "James Baxley",
        "email": "james@meteor.com"
      },
      "contributors": [
        {
          "name": "James Baxley",
          "email": "james@meteor.com"
        },
        {
          "name": "Jonas Helfer",
          "email": "jonas@helfer.email"
        },
        {
          "name": "Sashko Stubailo",
          "email": "sashko@stubailo.com"
        },
        {
          "name": "James Burgess",
          "email": "jamesmillerburgess@gmail.com"
        },
        {
          "name": "Bazyli Brzóska",
          "email": "bazyli.brzoska@gmail.com"
        }
      ],
      "license": "MIT",
      "main": "./lib/bundle.cjs.js",
      "module": "./lib/bundle.esm.js",
      "typings": "./lib/index.d.ts",
      "sideEffects": [
        "./lib/fixPolyfills.js"
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/apollographql/apollo-client.git"
      },
      "bugs": {
        "url": "https://github.com/apollographql/apollo-client/issues"
      },
      "homepage": "https://github.com/apollographql/apollo-client#readme",
      "scripts": {
        "prepare": "npm run build",
        "coverage": "jest --coverage",
        "test": "tsc -p tsconfig.json --noEmit && jest",
        "lint": "tslint -c \"../../config/tslint.json\" -p tsconfig.json src/*.ts",
        "prebuild": "npm run clean",
        "build": "tsc -b .",
        "postbuild": "npm run bundle",
        "bundle": "../../node_modules/rollup/bin/rollup -c rollup.config.js",
        "watch": "../../node_modules/tsc-watch/index.js --onSuccess \"npm run postbuild\"",
        "clean": "rm -rf coverage/* lib/*",
        "prepublishOnly": "npm run build"
      },
      "dependencies": {
        "apollo-cache": "^1.3.0-beta.5",
        "apollo-utilities": "^1.3.0-beta.5",
        "optimism": "^0.9.0",
        "ts-invariant": "^0.4.0",
        "tslib": "^1.9.3"
      },
      "peerDependencies": {
        "graphql": "0.11.7 || ^0.12.0 || ^0.13.0 || ^14.0.0"
      },
      "gitHead": "290dcc3ffd8be2dd8509d8d662287e43a791a933",
      "readme": "---\ntitle: InMemoryCache\ndescription: An explanation of `apollo-cache-inmemory`\n---\n\n`apollo-cache-inmemory` is the recommended cache implementation for Apollo Client 2.0. `InMemoryCache` is a normalized data store that supports all of Apollo Client 1.0's features without the dependency on Redux.\n\nIn some instances, you may need to manipulate the cache directly, such as updating the store after a mutation. We'll cover some common use cases [here](#recipes).\n\n<h2 id=\"installation\">Installation</h2>\n\n```\nnpm install apollo-cache-inmemory --save\n```\n\nAfter installing the package, you'll want to initialize the cache constructor. Then, you can pass in your newly created cache to ApolloClient.\n\n```js\nimport { InMemoryCache } from 'apollo-cache-inmemory';\nimport { HttpLink } from 'apollo-link-http';\nimport ApolloClient from 'apollo-client';\n\nconst cache = new InMemoryCache();\n\nconst client = new ApolloClient({\n  link: new HttpLink(),\n  cache\n});\n```\n\n<h2 id=\"configuration\">Configuration</h2>\n\nThe `InMemoryCache` constructor takes an optional config object with properties to customize your cache:\n\n- addTypename: A boolean to determine whether to add __typename to the document (default: `true`)\n- dataIdFromObject: A function that takes a data object and returns a unique identifier to be used when normalizing the data in the store. Learn more about how to customize `dataIdFromObject` in the [Normalization](#normalization) section.\n- fragmentMatcher: By default, the `InMemoryCache` uses a heuristic fragment matcher. If you are using fragments on unions and interfaces, you will need to use an `IntrospectionFragmentMatcher`. For more information, please read [our guide to setting up fragment matching for unions & interfaces](https://www.apollographql.com/docs/react/advanced/fragments.html#fragment-matcher).\n\n<h2 id=\"normalization\">Normalization</h2>\n\nThe `InMemoryCache` normalizes your data before saving it to the store by splitting the result into individual objects, creating a unique identifier for each object, and storing those objects in a flattened data structure. By default, `InMemoryCache` will attempt to use the commonly found primary keys of `id` and `_id` for the unique identifier if they exist along with `__typename` on an object.\n\nIf `id` and `_id` are not specified, or if `__typename` is not specified, `InMemoryCache` will fall back to the path to the object in the query, such as `ROOT_QUERY.allPeople.0` for the first record returned on the `allPeople` root query.\n\nThis \"getter\" behavior for unique identifiers can be configured manually via the `dataIdFromObject` option passed to the `InMemoryCache` constructor, so you can pick which field is used if some of your data follows unorthodox primary key conventions.\n\nFor example, if you wanted to key off of the `key` field for all of your data, you could configure `dataIdFromObject` like so:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => object.key\n});\n```\n\nThis also allows you to use different unique identifiers for different data types by keying off of the `__typename` property attached to every object typed by GraphQL.  For example:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => {\n    switch (object.__typename) {\n      case 'foo': return object.key; // use `key` as the primary key\n      case 'bar': return object.blah; // use `blah` as the priamry key\n      default: return object.id || object._id; // fall back to `id` and `_id` for all other types\n    }\n  }\n});\n```\n\n<h2 id=\"direct\">Direct Cache Access</h2>\n\nTo interact directly with your cache, you can use the Apollo Client class methods readQuery, readFragment, writeQuery, and writeFragment. These methods are available to us via the [`DataProxy` interface](https://github.com/apollographql/apollo-client/blob/master/packages/apollo-cache/src/types/DataProxy.ts). Accessing these methods will vary slightly based on your view layer implementation. If you are using React, you can wrap your component in the `withApollo` higher order component, which will give you access to `this.props.client`. From there, you can use the methods to control your data.\n\nAny code demonstration in the following sections will assume that we have already initialized an instance of  `ApolloClient` and that we have imported the `gql` tag from `graphql-tag`.\n\n<h3 id=\"readquery\">readQuery</h3>\n\nThe `readQuery` method is very similar to the [`query` method on `ApolloClient`][] except that `readQuery` will _never_ make a request to your GraphQL server. The `query` method, on the other hand, may send a request to your server if the appropriate data is not in your cache whereas `readQuery` will throw an error if the data is not in your cache. `readQuery` will _always_ read from the cache. You can use `readQuery` by giving it a GraphQL query like so:\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo {\n      todo(id: 5) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n});\n```\n\nIf all of the data needed to fulfill this read is in Apollo Client’s normalized data cache then a data object will be returned in the shape of the query you wanted to read. If not all of the data needed to fulfill this read is in Apollo Client’s cache then an error will be thrown instead, so make sure to only read data that you know you have!\n\nYou can also pass variables into `readQuery`.\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo($id: Int!) {\n      todo(id: $id) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n  variables: {\n    id: 5,\n  },\n});\n```\n\n<h3 id=\"readfragment\">readFragment</h3>\n\nThis method allows you great flexibility around the data in your cache. Whereas `readQuery` only allowed you to read data from your root query type, `readFragment` allows you to read data from _any node you have queried_. This is incredibly powerful. You use this method as follows:\n\n```js\nconst todo = client.readFragment({\n  id: ..., // `id` is any id that could be returned by `dataIdFromObject`.\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\nThe first argument is the id of the data you want to read from the cache. That id must be a value that was returned by the `dataIdFromObject` function you defined when initializing `ApolloClient`. So for example if you initialized `ApolloClient` like so:\n\n```js\nconst client = new ApolloClient({\n  ...,\n  dataIdFromObject: object => object.id,\n});\n```\n\n…and you requested a todo before with an id of `5`, then you can read that todo out of your cache with the following:\n\n```js\nconst todo = client.readFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\n> **Note:** Most people add a `__typename` to the id in `dataIdFromObject`. If you do this then don’t forget to add the `__typename` when you are reading a fragment as well. So for example your id may be `Todo_5` and not just `5`.\n\nIf a todo with that id does not exist in the cache you will get `null` back. If a todo of that id does exist in the cache, but that todo does not have the `text` field then an error will be thrown.\n\nThe beauty of `readFragment` is that the todo could have come from anywhere! The todo could have been selected as a singleton (`{ todo(id: 5) { ... } }`), the todo could have come from a list of todos (`{ todos { ... } }`), or the todo could have come from a mutation (`mutation { createTodo { ... } }`). As long as at some point your GraphQL server gave you a todo with the provided id and fields `id`, `text`, and `completed` you can read it from the cache at any part of your code.\n\n<h3 id=\"writequery-and-writefragment\">writeQuery` and `writeFragment</h3>\n\nNot only can you read arbitrary data from the Apollo Client cache, but you can also write any data that you would like to the cache. The methods you use to do this are `writeQuery` and `writeFragment`. They will allow you to change data in your local cache, but it is important to remember that *they will not change any data on your server*. If you reload your environment then changes made with `writeQuery` and `writeFragment` will disappear.\n\nThese methods have the same signature as their `readQuery` and `readFragment` counterparts except they also require an additional `data` variable. So for example, if you wanted to update the `completed` flag locally for your todo with id `'5'` you could execute the following:\n\n```js\nclient.writeFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      completed\n    }\n  `,\n  data: {\n    completed: true,\n  },\n});\n```\n\nAny subscriber to the Apollo Client store will instantly see this update and render new UI accordingly.\n\n> **Note:** Again, remember that using `writeQuery` or `writeFragment` only changes data *locally*. If you reload your environment then changes made with these methods will no longer exist.\n\nOr if you wanted to add a new todo to a list fetched from the server, you could use `readQuery` and `writeQuery` together.\n\n```js\nconst query = gql`\n  query MyTodoAppQuery {\n    todos {\n      id\n      text\n      completed\n    }\n  }\n`;\n\nconst data = client.readQuery({ query });\n\nconst myNewTodo = {\n  id: '6',\n  text: 'Start using Apollo Client.',\n  completed: false,\n};\n\nclient.writeQuery({\n  query,\n  data: {\n    todos: [...data.todos, myNewTodo],\n  },\n});\n```\n\n<h2 id=\"recipes\">Recipes</h2>\n\nHere are some common situations where you would need to access the cache directly. If you're manipulating the cache in an interesting way and would like your example to be featured, please send in a pull request!\n\n<h3 id=\"server\">Server side rendering</h3>\n\nFirst, you will need to initialize an `InMemoryCache` on the server and create an instance of `ApolloClient`. In the initial serialized HTML payload from the server, you should include a script tag that extracts the data from the cache.\n\n```js\n`<script>\n  window.__APOLLO_STATE__=${JSON.stringify(cache.extract())}\n</script>`\n```\n\nOn the client, you can rehydrate the cache using the initial data passed from the server:\n\n```js\ncache: new Cache().restore(window.__APOLLO_STATE__)\n```\n\nIf you would like to learn more about server side rendering, please check our our more in depth guide [here].\n<!---\nTODO (PEGGY): Add link to SSR\n-->\n\n<h3 id=\"server\">Updating the cache after a mutation</h3>\n\nBeing able to read and write to the Apollo cache from anywhere in your application gives you a lot of power over your data. However, there is one place where we most often want to update our cached data: after a mutation. As such, Apollo Client has optimized the experience for updating your cache with the read and write methods after a mutation with the `update` function. Let us say that we have the following GraphQL mutation:\n\n```graphql\nmutation TodoCreateMutation($text: String!) {\n  createTodo(text: $text) {\n    id\n    text\n    completed\n  }\n}\n```\n\nWe may also have the following GraphQL query:\n\n```graphql\nquery TodoAppQuery {\n  todos {\n    id\n    text\n    completed\n  }\n}\n```\n\nAt the end of our mutation we want our query to include the new todo like we had sent our `TodoAppQuery` a second time after the mutation finished without actually sending the query. To do this we can use the `update` function provided as an option of the `client.mutate` method. To update your cache with the mutation just write code that looks like:\n\n```js\n// We assume that the GraphQL operations `TodoCreateMutation` and\n// `TodoAppQuery` have already been defined using the `gql` tag.\n\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    // Read the data from our cache for this query.\n    const data = proxy.readQuery({ query: TodoAppQuery });\n\n    // Add our todo from the mutation to the end.\n    data.todos.push(createTodo);\n\n    // Write our data back to the cache.\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nThe first `proxy` argument is an instance of [`DataProxy`][] has the same four methods that we just learned exist on the Apollo Client: `readQuery`, `readFragment`, `writeQuery`, and `writeFragment`. The reason we call them on a `proxy` object here instead of on our `client` instance is that we can easily apply optimistic updates (which we will demonstrate in a bit). The `proxy` object also provides an isolated transaction which shields you from any other mutations going on at the same time, and the `proxy` object also batches writes together until the very end.\n\nIf you provide an `optimisticResponse` option to the mutation then the `update` function will be run twice. Once immediately after you call `client.mutate` with the data from `optimisticResponse`. After the mutation successfully executes against the server the changes made in the first call to `update` will be rolled back and `update` will be called with the *actual* data returned by the mutation and not just the optimistic response.\n\nPutting it all together:\n\n```js\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  optimisticResponse: {\n    id: -1, // -1 is a temporary id for the optimistic response.\n    text,\n    completed: false,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    const data = proxy.readQuery({ query: TodoAppQuery });\n    data.todos.push(createTodo);\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nAs you can see the `update` function on `client.mutate` provides extra change management functionality specific to the use case of a mutation while still providing you the powerful data control APIs that are available on `client`.\n\nThe `update` function is not a good place for side-effects as it may be called multiple times. Also, you may not call any of the methods on `proxy` asynchronously.\n\n",
      "readmeFilename": "README.md",
      "_id": "apollo-cache-inmemory@1.6.0-beta.5",
      "_nodeVersion": "8.15.1",
      "_npmVersion": "lerna/3.13.2/node@v8.15.1+x64 (darwin)",
      "_npmUser": {
        "name": "benjamn",
        "email": "ben@benjamn.com"
      },
      "dist": {
        "integrity": "sha512-o4zuBy8avHRhoX0pZ+Gj20qNdITTjVPS9kgbAshhPt9wP7SXQ0oCkwL2guz8cS9D1E7CPF2raYqNd0x5aHg5xA==",
        "shasum": "d74a02bd4d04e9862629369add2ec4cc1f5c6a4f",
        "tarball": "https://registry.npmjs.org/apollo-cache-inmemory/-/apollo-cache-inmemory-1.6.0-beta.5.tgz",
        "fileCount": 56,
        "unpackedSize": 540774,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJctiwbCRA9TVsSAnZWagAAnuMP/A8x9BbmlDcsLPOEhRtW\nYGEfyVsB7gFYUVpSnXz77+8dS4SA/5QGwIyhGEsZSiYJ68tTxK05c0B4hUsc\nbHv0Dh9qbzca59jrvz4P5/eTAnxQ05OxQnguLPtRpVvIasEzLUEQv7ymuu7M\n6quWVsvQ5cVpimrIDSaZ2TYH5KsOOYQQE++mOKKFsIOGySjxUyHxls17FmO2\npJOyHI/lhR1t5oAwYQu7XbpY56VFb8r/dWs0ydsNpEk1M7KfIrVdarN7dDdN\naiQkX9nkRK0Lf30dfIfAQXYFxIIMjKyuFMPqaJU3rVZYnI1zzgyiUlzBKIsn\no7zB9KE2LvadaxCqaAwP02W34NLg6IaVVcn/1aUXfz3hvx7JtXTYlhrxLYvr\nwWWN+qibq/qnFdzHjnfoCNosQUTNGxWWqKcZG2lCE69CSMjrDn7F3wBefOff\nMlmuU3vY2lMRc4+VqIXfwOddXU3ov+9yqDam31A7NxgTVyXUiDGzvhFpR7Z+\nD8Rx9Ojt5YUjPv1NUF3u45XCSNKrg8H9G8zR/hf8M5i3LjgeS7SgzzTWKOPL\nFkpH5+SS+VzVF8tnYDTQkcvJUn7p7ALyKek8IgRz9NV91k1f//X6mvzMypfe\nxFtYOnY8UD1FNttD5ckCJRxZV91A1AJwlk6dJT5kjtQOzwp4douoPK2r6wIY\nYeTU\r\n=b6VV\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIGY7neEytEN2hYjaM61pnSUBvpdtQ4oW/Xf+1jkn5NVnAiEAmbtYD+BRqB0DYR2DEpH1HZy77C0T5K9T3x5Ufm7Gg7I="
          }
        ]
      },
      "maintainers": [
        {
          "email": "npm@apollographql.com",
          "name": "apollo-bot"
        },
        {
          "email": "ben@benjamn.com",
          "name": "benjamn"
        },
        {
          "email": "james@meteor.com",
          "name": "jbaxleyiii"
        },
        {
          "email": "peggyrayzis@gmail.com",
          "name": "peggyrayzis"
        }
      ],
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/apollo-cache-inmemory_1.6.0-beta.5_1555442715083_0.5170127646367728"
      },
      "_hasShrinkwrap": false
    },
    "1.6.0-beta.6": {
      "name": "apollo-cache-inmemory",
      "version": "1.6.0-beta.6",
      "description": "Core abstract of Caching layer for Apollo Client",
      "author": {
        "name": "James Baxley",
        "email": "james@meteor.com"
      },
      "contributors": [
        {
          "name": "James Baxley",
          "email": "james@meteor.com"
        },
        {
          "name": "Jonas Helfer",
          "email": "jonas@helfer.email"
        },
        {
          "name": "Sashko Stubailo",
          "email": "sashko@stubailo.com"
        },
        {
          "name": "James Burgess",
          "email": "jamesmillerburgess@gmail.com"
        },
        {
          "name": "Bazyli Brzóska",
          "email": "bazyli.brzoska@gmail.com"
        }
      ],
      "license": "MIT",
      "main": "./lib/bundle.cjs.js",
      "module": "./lib/bundle.esm.js",
      "typings": "./lib/index.d.ts",
      "sideEffects": [
        "./lib/fixPolyfills.js"
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/apollographql/apollo-client.git"
      },
      "bugs": {
        "url": "https://github.com/apollographql/apollo-client/issues"
      },
      "homepage": "https://github.com/apollographql/apollo-client#readme",
      "scripts": {
        "prepare": "npm run build",
        "coverage": "jest --coverage",
        "test": "tsc -p tsconfig.json --noEmit && jest",
        "lint": "tslint -c \"../../config/tslint.json\" -p tsconfig.json src/*.ts",
        "prebuild": "npm run clean",
        "build": "tsc -b .",
        "postbuild": "npm run bundle",
        "bundle": "../../node_modules/rollup/bin/rollup -c rollup.config.js",
        "watch": "../../node_modules/tsc-watch/index.js --onSuccess \"npm run postbuild\"",
        "clean": "rm -rf coverage/* lib/*",
        "prepublishOnly": "npm run build"
      },
      "dependencies": {
        "apollo-cache": "^1.3.0-beta.6",
        "apollo-utilities": "^1.3.0-beta.6",
        "optimism": "^0.9.0",
        "ts-invariant": "^0.4.0",
        "tslib": "^1.9.3"
      },
      "peerDependencies": {
        "graphql": "0.11.7 || ^0.12.0 || ^0.13.0 || ^14.0.0"
      },
      "gitHead": "570291b44a3af0beea25ee2773fc1eb3352bf05d",
      "readme": "---\ntitle: InMemoryCache\ndescription: An explanation of `apollo-cache-inmemory`\n---\n\n`apollo-cache-inmemory` is the recommended cache implementation for Apollo Client 2.0. `InMemoryCache` is a normalized data store that supports all of Apollo Client 1.0's features without the dependency on Redux.\n\nIn some instances, you may need to manipulate the cache directly, such as updating the store after a mutation. We'll cover some common use cases [here](#recipes).\n\n<h2 id=\"installation\">Installation</h2>\n\n```\nnpm install apollo-cache-inmemory --save\n```\n\nAfter installing the package, you'll want to initialize the cache constructor. Then, you can pass in your newly created cache to ApolloClient.\n\n```js\nimport { InMemoryCache } from 'apollo-cache-inmemory';\nimport { HttpLink } from 'apollo-link-http';\nimport ApolloClient from 'apollo-client';\n\nconst cache = new InMemoryCache();\n\nconst client = new ApolloClient({\n  link: new HttpLink(),\n  cache\n});\n```\n\n<h2 id=\"configuration\">Configuration</h2>\n\nThe `InMemoryCache` constructor takes an optional config object with properties to customize your cache:\n\n- addTypename: A boolean to determine whether to add __typename to the document (default: `true`)\n- dataIdFromObject: A function that takes a data object and returns a unique identifier to be used when normalizing the data in the store. Learn more about how to customize `dataIdFromObject` in the [Normalization](#normalization) section.\n- fragmentMatcher: By default, the `InMemoryCache` uses a heuristic fragment matcher. If you are using fragments on unions and interfaces, you will need to use an `IntrospectionFragmentMatcher`. For more information, please read [our guide to setting up fragment matching for unions & interfaces](https://www.apollographql.com/docs/react/advanced/fragments.html#fragment-matcher).\n\n<h2 id=\"normalization\">Normalization</h2>\n\nThe `InMemoryCache` normalizes your data before saving it to the store by splitting the result into individual objects, creating a unique identifier for each object, and storing those objects in a flattened data structure. By default, `InMemoryCache` will attempt to use the commonly found primary keys of `id` and `_id` for the unique identifier if they exist along with `__typename` on an object.\n\nIf `id` and `_id` are not specified, or if `__typename` is not specified, `InMemoryCache` will fall back to the path to the object in the query, such as `ROOT_QUERY.allPeople.0` for the first record returned on the `allPeople` root query.\n\nThis \"getter\" behavior for unique identifiers can be configured manually via the `dataIdFromObject` option passed to the `InMemoryCache` constructor, so you can pick which field is used if some of your data follows unorthodox primary key conventions.\n\nFor example, if you wanted to key off of the `key` field for all of your data, you could configure `dataIdFromObject` like so:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => object.key\n});\n```\n\nThis also allows you to use different unique identifiers for different data types by keying off of the `__typename` property attached to every object typed by GraphQL.  For example:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => {\n    switch (object.__typename) {\n      case 'foo': return object.key; // use `key` as the primary key\n      case 'bar': return object.blah; // use `blah` as the priamry key\n      default: return object.id || object._id; // fall back to `id` and `_id` for all other types\n    }\n  }\n});\n```\n\n<h2 id=\"direct\">Direct Cache Access</h2>\n\nTo interact directly with your cache, you can use the Apollo Client class methods readQuery, readFragment, writeQuery, and writeFragment. These methods are available to us via the [`DataProxy` interface](https://github.com/apollographql/apollo-client/blob/master/packages/apollo-cache/src/types/DataProxy.ts). Accessing these methods will vary slightly based on your view layer implementation. If you are using React, you can wrap your component in the `withApollo` higher order component, which will give you access to `this.props.client`. From there, you can use the methods to control your data.\n\nAny code demonstration in the following sections will assume that we have already initialized an instance of  `ApolloClient` and that we have imported the `gql` tag from `graphql-tag`.\n\n<h3 id=\"readquery\">readQuery</h3>\n\nThe `readQuery` method is very similar to the [`query` method on `ApolloClient`][] except that `readQuery` will _never_ make a request to your GraphQL server. The `query` method, on the other hand, may send a request to your server if the appropriate data is not in your cache whereas `readQuery` will throw an error if the data is not in your cache. `readQuery` will _always_ read from the cache. You can use `readQuery` by giving it a GraphQL query like so:\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo {\n      todo(id: 5) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n});\n```\n\nIf all of the data needed to fulfill this read is in Apollo Client’s normalized data cache then a data object will be returned in the shape of the query you wanted to read. If not all of the data needed to fulfill this read is in Apollo Client’s cache then an error will be thrown instead, so make sure to only read data that you know you have!\n\nYou can also pass variables into `readQuery`.\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo($id: Int!) {\n      todo(id: $id) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n  variables: {\n    id: 5,\n  },\n});\n```\n\n<h3 id=\"readfragment\">readFragment</h3>\n\nThis method allows you great flexibility around the data in your cache. Whereas `readQuery` only allowed you to read data from your root query type, `readFragment` allows you to read data from _any node you have queried_. This is incredibly powerful. You use this method as follows:\n\n```js\nconst todo = client.readFragment({\n  id: ..., // `id` is any id that could be returned by `dataIdFromObject`.\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\nThe first argument is the id of the data you want to read from the cache. That id must be a value that was returned by the `dataIdFromObject` function you defined when initializing `ApolloClient`. So for example if you initialized `ApolloClient` like so:\n\n```js\nconst client = new ApolloClient({\n  ...,\n  dataIdFromObject: object => object.id,\n});\n```\n\n…and you requested a todo before with an id of `5`, then you can read that todo out of your cache with the following:\n\n```js\nconst todo = client.readFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\n> **Note:** Most people add a `__typename` to the id in `dataIdFromObject`. If you do this then don’t forget to add the `__typename` when you are reading a fragment as well. So for example your id may be `Todo_5` and not just `5`.\n\nIf a todo with that id does not exist in the cache you will get `null` back. If a todo of that id does exist in the cache, but that todo does not have the `text` field then an error will be thrown.\n\nThe beauty of `readFragment` is that the todo could have come from anywhere! The todo could have been selected as a singleton (`{ todo(id: 5) { ... } }`), the todo could have come from a list of todos (`{ todos { ... } }`), or the todo could have come from a mutation (`mutation { createTodo { ... } }`). As long as at some point your GraphQL server gave you a todo with the provided id and fields `id`, `text`, and `completed` you can read it from the cache at any part of your code.\n\n<h3 id=\"writequery-and-writefragment\">writeQuery` and `writeFragment</h3>\n\nNot only can you read arbitrary data from the Apollo Client cache, but you can also write any data that you would like to the cache. The methods you use to do this are `writeQuery` and `writeFragment`. They will allow you to change data in your local cache, but it is important to remember that *they will not change any data on your server*. If you reload your environment then changes made with `writeQuery` and `writeFragment` will disappear.\n\nThese methods have the same signature as their `readQuery` and `readFragment` counterparts except they also require an additional `data` variable. So for example, if you wanted to update the `completed` flag locally for your todo with id `'5'` you could execute the following:\n\n```js\nclient.writeFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      completed\n    }\n  `,\n  data: {\n    completed: true,\n  },\n});\n```\n\nAny subscriber to the Apollo Client store will instantly see this update and render new UI accordingly.\n\n> **Note:** Again, remember that using `writeQuery` or `writeFragment` only changes data *locally*. If you reload your environment then changes made with these methods will no longer exist.\n\nOr if you wanted to add a new todo to a list fetched from the server, you could use `readQuery` and `writeQuery` together.\n\n```js\nconst query = gql`\n  query MyTodoAppQuery {\n    todos {\n      id\n      text\n      completed\n    }\n  }\n`;\n\nconst data = client.readQuery({ query });\n\nconst myNewTodo = {\n  id: '6',\n  text: 'Start using Apollo Client.',\n  completed: false,\n};\n\nclient.writeQuery({\n  query,\n  data: {\n    todos: [...data.todos, myNewTodo],\n  },\n});\n```\n\n<h2 id=\"recipes\">Recipes</h2>\n\nHere are some common situations where you would need to access the cache directly. If you're manipulating the cache in an interesting way and would like your example to be featured, please send in a pull request!\n\n<h3 id=\"server\">Server side rendering</h3>\n\nFirst, you will need to initialize an `InMemoryCache` on the server and create an instance of `ApolloClient`. In the initial serialized HTML payload from the server, you should include a script tag that extracts the data from the cache.\n\n```js\n`<script>\n  window.__APOLLO_STATE__=${JSON.stringify(cache.extract())}\n</script>`\n```\n\nOn the client, you can rehydrate the cache using the initial data passed from the server:\n\n```js\ncache: new Cache().restore(window.__APOLLO_STATE__)\n```\n\nIf you would like to learn more about server side rendering, please check our our more in depth guide [here].\n<!---\nTODO (PEGGY): Add link to SSR\n-->\n\n<h3 id=\"server\">Updating the cache after a mutation</h3>\n\nBeing able to read and write to the Apollo cache from anywhere in your application gives you a lot of power over your data. However, there is one place where we most often want to update our cached data: after a mutation. As such, Apollo Client has optimized the experience for updating your cache with the read and write methods after a mutation with the `update` function. Let us say that we have the following GraphQL mutation:\n\n```graphql\nmutation TodoCreateMutation($text: String!) {\n  createTodo(text: $text) {\n    id\n    text\n    completed\n  }\n}\n```\n\nWe may also have the following GraphQL query:\n\n```graphql\nquery TodoAppQuery {\n  todos {\n    id\n    text\n    completed\n  }\n}\n```\n\nAt the end of our mutation we want our query to include the new todo like we had sent our `TodoAppQuery` a second time after the mutation finished without actually sending the query. To do this we can use the `update` function provided as an option of the `client.mutate` method. To update your cache with the mutation just write code that looks like:\n\n```js\n// We assume that the GraphQL operations `TodoCreateMutation` and\n// `TodoAppQuery` have already been defined using the `gql` tag.\n\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    // Read the data from our cache for this query.\n    const data = proxy.readQuery({ query: TodoAppQuery });\n\n    // Add our todo from the mutation to the end.\n    data.todos.push(createTodo);\n\n    // Write our data back to the cache.\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nThe first `proxy` argument is an instance of [`DataProxy`][] has the same four methods that we just learned exist on the Apollo Client: `readQuery`, `readFragment`, `writeQuery`, and `writeFragment`. The reason we call them on a `proxy` object here instead of on our `client` instance is that we can easily apply optimistic updates (which we will demonstrate in a bit). The `proxy` object also provides an isolated transaction which shields you from any other mutations going on at the same time, and the `proxy` object also batches writes together until the very end.\n\nIf you provide an `optimisticResponse` option to the mutation then the `update` function will be run twice. Once immediately after you call `client.mutate` with the data from `optimisticResponse`. After the mutation successfully executes against the server the changes made in the first call to `update` will be rolled back and `update` will be called with the *actual* data returned by the mutation and not just the optimistic response.\n\nPutting it all together:\n\n```js\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  optimisticResponse: {\n    id: -1, // -1 is a temporary id for the optimistic response.\n    text,\n    completed: false,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    const data = proxy.readQuery({ query: TodoAppQuery });\n    data.todos.push(createTodo);\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nAs you can see the `update` function on `client.mutate` provides extra change management functionality specific to the use case of a mutation while still providing you the powerful data control APIs that are available on `client`.\n\nThe `update` function is not a good place for side-effects as it may be called multiple times. Also, you may not call any of the methods on `proxy` asynchronously.\n\n",
      "readmeFilename": "README.md",
      "_id": "apollo-cache-inmemory@1.6.0-beta.6",
      "_nodeVersion": "8.15.1",
      "_npmVersion": "lerna/3.13.3/node@v8.15.1+x64 (darwin)",
      "_npmUser": {
        "name": "benjamn",
        "email": "ben@benjamn.com"
      },
      "dist": {
        "integrity": "sha512-bllIM+C/Vn9csq2JxR6B+sQnjrCUJk8XbmLnsDsNRtVdTvmj1OhHzj6I/GIDLNv5Oe345kHeXXYHU3gTPBHsmw==",
        "shasum": "2ca55111ca3062ec41d739b4229169f5d2ad98e2",
        "tarball": "https://registry.npmjs.org/apollo-cache-inmemory/-/apollo-cache-inmemory-1.6.0-beta.6.tgz",
        "fileCount": 56,
        "unpackedSize": 540774,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJcvzd4CRA9TVsSAnZWagAAla0P/1TyRbkg3I7Tkk193rgq\nowW0sBlS71bJc4TVxr54cL4Odp0ODLVAXu9KjN2xsflH0zlawvmTpmYYN9cu\n8BnKix1eIlCWuEl3cBW6ayR44N38yru/5HI7jHxECU+/Bm4SrMP6c2bJkBk4\nGHnKNcd/LzBusMQqCSBlvY2JogdhAU3fwi8QKb3G6eliRKkdX79f8aJOxKH3\n+N3Sv+FVewjiu+NNPD6fCCFmpW688tk9sWWsrupaiAu4uy+z2GATOd9GWWYT\noKR8dks3tPWsrz69TBQSGoLJmn6iVAwicw0CuurPqDYHG9evOhtSDqzdnk3J\n3yzUAi6drG4QRcF9PsymXi6L34cuCJUEb8Vft7qnKpQPIhj9xx4Q3d3x5HAp\nqZJo0XjmCKYQlf4PE5UbzSLRf5T0oLfcDEbiS6wT9NHIob9SwRgyFNd4xX/b\nFTVBEOjUzQ94BM3ho/6Q/2hyx8tOnppW4rFqFy8kck2vRY6vl6QptTrOLnbZ\nl49sSL6DOHg+GeoVR+BZo59+9xtESlZRNalo/hhO3qnwX/f+XOVc2UB+e731\nSHsOazWQJ4+kQXSrWe5EIXPIUEHw0yROgu0a7ett9m0xwVj2eLttlcQnLLwp\nqJrDc2SyegpktFToXK3tGfCO9+y4bpX8az2Gyt0To2dR9CJzDI1iNoUICQ5S\nV4W9\r\n=wJ8X\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIQCfq+we9DrGZ33SZYVRf4Gp2lgqK8YBxwyfWf23wrVdPQIgWZVBJTcfr5Fwdvh4mwG8SJmTpqyfBMJboOCp0XDlC/o="
          }
        ]
      },
      "maintainers": [
        {
          "email": "npm@apollographql.com",
          "name": "apollo-bot"
        },
        {
          "email": "ben@benjamn.com",
          "name": "benjamn"
        },
        {
          "email": "james@meteor.com",
          "name": "jbaxleyiii"
        },
        {
          "email": "peggyrayzis@gmail.com",
          "name": "peggyrayzis"
        }
      ],
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/apollo-cache-inmemory_1.6.0-beta.6_1556035448094_0.1498194455337758"
      },
      "_hasShrinkwrap": false
    },
    "1.6.0-rc.1": {
      "name": "apollo-cache-inmemory",
      "version": "1.6.0-rc.1",
      "description": "Core abstract of Caching layer for Apollo Client",
      "author": {
        "name": "James Baxley",
        "email": "james@meteor.com"
      },
      "contributors": [
        {
          "name": "James Baxley",
          "email": "james@meteor.com"
        },
        {
          "name": "Jonas Helfer",
          "email": "jonas@helfer.email"
        },
        {
          "name": "Sashko Stubailo",
          "email": "sashko@stubailo.com"
        },
        {
          "name": "James Burgess",
          "email": "jamesmillerburgess@gmail.com"
        },
        {
          "name": "Bazyli Brzóska",
          "email": "bazyli.brzoska@gmail.com"
        }
      ],
      "license": "MIT",
      "main": "./lib/bundle.cjs.js",
      "module": "./lib/bundle.esm.js",
      "typings": "./lib/index.d.ts",
      "sideEffects": [
        "./lib/fixPolyfills.js"
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/apollographql/apollo-client.git"
      },
      "bugs": {
        "url": "https://github.com/apollographql/apollo-client/issues"
      },
      "homepage": "https://github.com/apollographql/apollo-client#readme",
      "scripts": {
        "prepare": "npm run build",
        "coverage": "jest --coverage",
        "test": "tsc -p tsconfig.json --noEmit && jest",
        "lint": "tslint -c \"../../config/tslint.json\" -p tsconfig.json src/*.ts",
        "prebuild": "npm run clean",
        "build": "tsc -b .",
        "postbuild": "npm run bundle",
        "bundle": "../../node_modules/rollup/bin/rollup -c rollup.config.js",
        "watch": "../../node_modules/tsc-watch/index.js --onSuccess \"npm run postbuild\"",
        "clean": "rm -rf coverage/* lib/*",
        "prepublishOnly": "npm run build"
      },
      "dependencies": {
        "apollo-cache": "^1.3.0-rc.1",
        "apollo-utilities": "^1.3.0-rc.1",
        "optimism": "^0.9.0",
        "ts-invariant": "^0.4.0",
        "tslib": "^1.9.3"
      },
      "peerDependencies": {
        "graphql": "0.11.7 || ^0.12.0 || ^0.13.0 || ^14.0.0"
      },
      "gitHead": "d33eb3ef994d8dd0bcdd9a158de91d582d99ec2e",
      "readme": "---\ntitle: InMemoryCache\ndescription: An explanation of `apollo-cache-inmemory`\n---\n\n`apollo-cache-inmemory` is the recommended cache implementation for Apollo Client 2.0. `InMemoryCache` is a normalized data store that supports all of Apollo Client 1.0's features without the dependency on Redux.\n\nIn some instances, you may need to manipulate the cache directly, such as updating the store after a mutation. We'll cover some common use cases [here](#recipes).\n\n<h2 id=\"installation\">Installation</h2>\n\n```\nnpm install apollo-cache-inmemory --save\n```\n\nAfter installing the package, you'll want to initialize the cache constructor. Then, you can pass in your newly created cache to ApolloClient.\n\n```js\nimport { InMemoryCache } from 'apollo-cache-inmemory';\nimport { HttpLink } from 'apollo-link-http';\nimport ApolloClient from 'apollo-client';\n\nconst cache = new InMemoryCache();\n\nconst client = new ApolloClient({\n  link: new HttpLink(),\n  cache\n});\n```\n\n<h2 id=\"configuration\">Configuration</h2>\n\nThe `InMemoryCache` constructor takes an optional config object with properties to customize your cache:\n\n- addTypename: A boolean to determine whether to add __typename to the document (default: `true`)\n- dataIdFromObject: A function that takes a data object and returns a unique identifier to be used when normalizing the data in the store. Learn more about how to customize `dataIdFromObject` in the [Normalization](#normalization) section.\n- fragmentMatcher: By default, the `InMemoryCache` uses a heuristic fragment matcher. If you are using fragments on unions and interfaces, you will need to use an `IntrospectionFragmentMatcher`. For more information, please read [our guide to setting up fragment matching for unions & interfaces](https://www.apollographql.com/docs/react/advanced/fragments.html#fragment-matcher).\n\n<h2 id=\"normalization\">Normalization</h2>\n\nThe `InMemoryCache` normalizes your data before saving it to the store by splitting the result into individual objects, creating a unique identifier for each object, and storing those objects in a flattened data structure. By default, `InMemoryCache` will attempt to use the commonly found primary keys of `id` and `_id` for the unique identifier if they exist along with `__typename` on an object.\n\nIf `id` and `_id` are not specified, or if `__typename` is not specified, `InMemoryCache` will fall back to the path to the object in the query, such as `ROOT_QUERY.allPeople.0` for the first record returned on the `allPeople` root query.\n\nThis \"getter\" behavior for unique identifiers can be configured manually via the `dataIdFromObject` option passed to the `InMemoryCache` constructor, so you can pick which field is used if some of your data follows unorthodox primary key conventions.\n\nFor example, if you wanted to key off of the `key` field for all of your data, you could configure `dataIdFromObject` like so:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => object.key\n});\n```\n\nThis also allows you to use different unique identifiers for different data types by keying off of the `__typename` property attached to every object typed by GraphQL.  For example:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => {\n    switch (object.__typename) {\n      case 'foo': return object.key; // use `key` as the primary key\n      case 'bar': return object.blah; // use `blah` as the priamry key\n      default: return object.id || object._id; // fall back to `id` and `_id` for all other types\n    }\n  }\n});\n```\n\n<h2 id=\"direct\">Direct Cache Access</h2>\n\nTo interact directly with your cache, you can use the Apollo Client class methods readQuery, readFragment, writeQuery, and writeFragment. These methods are available to us via the [`DataProxy` interface](https://github.com/apollographql/apollo-client/blob/master/packages/apollo-cache/src/types/DataProxy.ts). Accessing these methods will vary slightly based on your view layer implementation. If you are using React, you can wrap your component in the `withApollo` higher order component, which will give you access to `this.props.client`. From there, you can use the methods to control your data.\n\nAny code demonstration in the following sections will assume that we have already initialized an instance of  `ApolloClient` and that we have imported the `gql` tag from `graphql-tag`.\n\n<h3 id=\"readquery\">readQuery</h3>\n\nThe `readQuery` method is very similar to the [`query` method on `ApolloClient`][] except that `readQuery` will _never_ make a request to your GraphQL server. The `query` method, on the other hand, may send a request to your server if the appropriate data is not in your cache whereas `readQuery` will throw an error if the data is not in your cache. `readQuery` will _always_ read from the cache. You can use `readQuery` by giving it a GraphQL query like so:\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo {\n      todo(id: 5) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n});\n```\n\nIf all of the data needed to fulfill this read is in Apollo Client’s normalized data cache then a data object will be returned in the shape of the query you wanted to read. If not all of the data needed to fulfill this read is in Apollo Client’s cache then an error will be thrown instead, so make sure to only read data that you know you have!\n\nYou can also pass variables into `readQuery`.\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo($id: Int!) {\n      todo(id: $id) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n  variables: {\n    id: 5,\n  },\n});\n```\n\n<h3 id=\"readfragment\">readFragment</h3>\n\nThis method allows you great flexibility around the data in your cache. Whereas `readQuery` only allowed you to read data from your root query type, `readFragment` allows you to read data from _any node you have queried_. This is incredibly powerful. You use this method as follows:\n\n```js\nconst todo = client.readFragment({\n  id: ..., // `id` is any id that could be returned by `dataIdFromObject`.\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\nThe first argument is the id of the data you want to read from the cache. That id must be a value that was returned by the `dataIdFromObject` function you defined when initializing `ApolloClient`. So for example if you initialized `ApolloClient` like so:\n\n```js\nconst client = new ApolloClient({\n  ...,\n  dataIdFromObject: object => object.id,\n});\n```\n\n…and you requested a todo before with an id of `5`, then you can read that todo out of your cache with the following:\n\n```js\nconst todo = client.readFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\n> **Note:** Most people add a `__typename` to the id in `dataIdFromObject`. If you do this then don’t forget to add the `__typename` when you are reading a fragment as well. So for example your id may be `Todo_5` and not just `5`.\n\nIf a todo with that id does not exist in the cache you will get `null` back. If a todo of that id does exist in the cache, but that todo does not have the `text` field then an error will be thrown.\n\nThe beauty of `readFragment` is that the todo could have come from anywhere! The todo could have been selected as a singleton (`{ todo(id: 5) { ... } }`), the todo could have come from a list of todos (`{ todos { ... } }`), or the todo could have come from a mutation (`mutation { createTodo { ... } }`). As long as at some point your GraphQL server gave you a todo with the provided id and fields `id`, `text`, and `completed` you can read it from the cache at any part of your code.\n\n<h3 id=\"writequery-and-writefragment\">writeQuery` and `writeFragment</h3>\n\nNot only can you read arbitrary data from the Apollo Client cache, but you can also write any data that you would like to the cache. The methods you use to do this are `writeQuery` and `writeFragment`. They will allow you to change data in your local cache, but it is important to remember that *they will not change any data on your server*. If you reload your environment then changes made with `writeQuery` and `writeFragment` will disappear.\n\nThese methods have the same signature as their `readQuery` and `readFragment` counterparts except they also require an additional `data` variable. So for example, if you wanted to update the `completed` flag locally for your todo with id `'5'` you could execute the following:\n\n```js\nclient.writeFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      completed\n    }\n  `,\n  data: {\n    completed: true,\n  },\n});\n```\n\nAny subscriber to the Apollo Client store will instantly see this update and render new UI accordingly.\n\n> **Note:** Again, remember that using `writeQuery` or `writeFragment` only changes data *locally*. If you reload your environment then changes made with these methods will no longer exist.\n\nOr if you wanted to add a new todo to a list fetched from the server, you could use `readQuery` and `writeQuery` together.\n\n```js\nconst query = gql`\n  query MyTodoAppQuery {\n    todos {\n      id\n      text\n      completed\n    }\n  }\n`;\n\nconst data = client.readQuery({ query });\n\nconst myNewTodo = {\n  id: '6',\n  text: 'Start using Apollo Client.',\n  completed: false,\n};\n\nclient.writeQuery({\n  query,\n  data: {\n    todos: [...data.todos, myNewTodo],\n  },\n});\n```\n\n<h2 id=\"recipes\">Recipes</h2>\n\nHere are some common situations where you would need to access the cache directly. If you're manipulating the cache in an interesting way and would like your example to be featured, please send in a pull request!\n\n<h3 id=\"server\">Server side rendering</h3>\n\nFirst, you will need to initialize an `InMemoryCache` on the server and create an instance of `ApolloClient`. In the initial serialized HTML payload from the server, you should include a script tag that extracts the data from the cache.\n\n```js\n`<script>\n  window.__APOLLO_STATE__=${JSON.stringify(cache.extract())}\n</script>`\n```\n\nOn the client, you can rehydrate the cache using the initial data passed from the server:\n\n```js\ncache: new Cache().restore(window.__APOLLO_STATE__)\n```\n\nIf you would like to learn more about server side rendering, please check our our more in depth guide [here].\n<!---\nTODO (PEGGY): Add link to SSR\n-->\n\n<h3 id=\"server\">Updating the cache after a mutation</h3>\n\nBeing able to read and write to the Apollo cache from anywhere in your application gives you a lot of power over your data. However, there is one place where we most often want to update our cached data: after a mutation. As such, Apollo Client has optimized the experience for updating your cache with the read and write methods after a mutation with the `update` function. Let us say that we have the following GraphQL mutation:\n\n```graphql\nmutation TodoCreateMutation($text: String!) {\n  createTodo(text: $text) {\n    id\n    text\n    completed\n  }\n}\n```\n\nWe may also have the following GraphQL query:\n\n```graphql\nquery TodoAppQuery {\n  todos {\n    id\n    text\n    completed\n  }\n}\n```\n\nAt the end of our mutation we want our query to include the new todo like we had sent our `TodoAppQuery` a second time after the mutation finished without actually sending the query. To do this we can use the `update` function provided as an option of the `client.mutate` method. To update your cache with the mutation just write code that looks like:\n\n```js\n// We assume that the GraphQL operations `TodoCreateMutation` and\n// `TodoAppQuery` have already been defined using the `gql` tag.\n\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    // Read the data from our cache for this query.\n    const data = proxy.readQuery({ query: TodoAppQuery });\n\n    // Add our todo from the mutation to the end.\n    data.todos.push(createTodo);\n\n    // Write our data back to the cache.\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nThe first `proxy` argument is an instance of [`DataProxy`][] has the same four methods that we just learned exist on the Apollo Client: `readQuery`, `readFragment`, `writeQuery`, and `writeFragment`. The reason we call them on a `proxy` object here instead of on our `client` instance is that we can easily apply optimistic updates (which we will demonstrate in a bit). The `proxy` object also provides an isolated transaction which shields you from any other mutations going on at the same time, and the `proxy` object also batches writes together until the very end.\n\nIf you provide an `optimisticResponse` option to the mutation then the `update` function will be run twice. Once immediately after you call `client.mutate` with the data from `optimisticResponse`. After the mutation successfully executes against the server the changes made in the first call to `update` will be rolled back and `update` will be called with the *actual* data returned by the mutation and not just the optimistic response.\n\nPutting it all together:\n\n```js\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  optimisticResponse: {\n    id: -1, // -1 is a temporary id for the optimistic response.\n    text,\n    completed: false,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    const data = proxy.readQuery({ query: TodoAppQuery });\n    data.todos.push(createTodo);\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nAs you can see the `update` function on `client.mutate` provides extra change management functionality specific to the use case of a mutation while still providing you the powerful data control APIs that are available on `client`.\n\nThe `update` function is not a good place for side-effects as it may be called multiple times. Also, you may not call any of the methods on `proxy` asynchronously.\n\n",
      "readmeFilename": "README.md",
      "_id": "apollo-cache-inmemory@1.6.0-rc.1",
      "_nodeVersion": "8.16.0",
      "_npmVersion": "lerna/3.13.4/node@v8.16.0+x64 (darwin)",
      "_npmUser": {
        "name": "benjamn",
        "email": "ben@benjamn.com"
      },
      "dist": {
        "integrity": "sha512-hoqCrUEXALBj9gw9OCkqNuRHrIz0QxxxyPb9jR4y+Ff28D+s1Bb69yUrQD+TVUBdASD7aAC5TM4aGbLvzvc8zg==",
        "shasum": "353d0c80c7e586d671d6688342a2af7e6c2db32f",
        "tarball": "https://registry.npmjs.org/apollo-cache-inmemory/-/apollo-cache-inmemory-1.6.0-rc.1.tgz",
        "fileCount": 56,
        "unpackedSize": 540768,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJc0L/ICRA9TVsSAnZWagAAHroP/3cn041Z7LskwvtRZsTQ\nL+xhcB3/TnceYXQ0xNqf4zD5NpkaLW1uIIzXSmwKZTq6kWttz0PV1ZPScl4d\nnwUwbkK6VAP6f45N1qNbcQLgxt1UwXAi7upv3T16FJ1uj1TEwnmX/kyJdaPq\nAHr2LGOi7b/tCxNxYvdP22Opj+sIdoi/Fw68lkviJROm7yFk8+Jd074gr0Lq\nYkqanhR7fyxy27DnX9qqx7HvvlYzZGD0dTNvHIqoGPlh6hV2Q63BcypEqSkD\nZpaj5/FOVxcv0nzKoNO+FLmxkXUoYBt4QZrsEvljpPOFRTk5YoN6UUMIN//a\nyqT81dOQ1Qq6GUdl97kSeWlpHHi9XxwfCeyWv8GNDIAK2vD4DK2QvdSW/Gmy\nm/pFk5FmC+tb2R+JruG9Ty7Sc0RhOO8bnLITCMkpeyoCyoob0Bny96jJPMnb\n87xJ+tT5mQtirFbmtZ48BfDuHXkICzVXQugL6RjG1kKsTfUudmJzLtpPw2vy\n4/1mSFCT3z6y7/RJFkszTHbacV1Tbgn3TuI/PRn7u0u7+czwlL1+yUZNZXYU\nTq5dH/L3XqZhZRc6TghnxPMolxZbrNBVpNFmZxMoH49BBzaXTw4ehZ515XKX\n3Kl72oSvCc4oXDscdmoVliShM2GLksD6knJ0GAOnE0b82dCgOXSJhK1zq1WS\nJQKM\r\n=fThv\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIEPRNWzcIhSsVuDw8xJEwkXQeQpmk31VY8g1daQUvNY9AiEA0l7KiZ18Doh63G/buL7UMBQCs5GKo0feCY1ccoteKLI="
          }
        ]
      },
      "maintainers": [
        {
          "email": "npm@apollographql.com",
          "name": "apollo-bot"
        },
        {
          "email": "ben@benjamn.com",
          "name": "benjamn"
        },
        {
          "email": "james@meteor.com",
          "name": "jbaxleyiii"
        },
        {
          "email": "peggyrayzis@gmail.com",
          "name": "peggyrayzis"
        }
      ],
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/apollo-cache-inmemory_1.6.0-rc.1_1557184456082_0.17282354176161507"
      },
      "_hasShrinkwrap": false
    },
    "1.6.0-rc.2": {
      "name": "apollo-cache-inmemory",
      "version": "1.6.0-rc.2",
      "description": "Core abstract of Caching layer for Apollo Client",
      "author": {
        "name": "James Baxley",
        "email": "james@meteor.com"
      },
      "contributors": [
        {
          "name": "James Baxley",
          "email": "james@meteor.com"
        },
        {
          "name": "Jonas Helfer",
          "email": "jonas@helfer.email"
        },
        {
          "name": "Sashko Stubailo",
          "email": "sashko@stubailo.com"
        },
        {
          "name": "James Burgess",
          "email": "jamesmillerburgess@gmail.com"
        },
        {
          "name": "Bazyli Brzóska",
          "email": "bazyli.brzoska@gmail.com"
        }
      ],
      "license": "MIT",
      "main": "./lib/bundle.cjs.js",
      "module": "./lib/bundle.esm.js",
      "typings": "./lib/index.d.ts",
      "sideEffects": [
        "./lib/fixPolyfills.js"
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/apollographql/apollo-client.git"
      },
      "bugs": {
        "url": "https://github.com/apollographql/apollo-client/issues"
      },
      "homepage": "https://github.com/apollographql/apollo-client#readme",
      "scripts": {
        "prepare": "npm run build",
        "coverage": "jest --coverage",
        "test": "tsc -p tsconfig.json --noEmit && jest",
        "lint": "tslint -c \"../../config/tslint.json\" -p tsconfig.json src/*.ts",
        "prebuild": "npm run clean",
        "build": "tsc -b .",
        "postbuild": "npm run bundle",
        "bundle": "../../node_modules/rollup/bin/rollup -c rollup.config.js",
        "watch": "../../node_modules/tsc-watch/index.js --onSuccess \"npm run postbuild\"",
        "clean": "rm -rf coverage/* lib/*",
        "prepublishOnly": "npm run build"
      },
      "dependencies": {
        "apollo-cache": "^1.3.0-rc.2",
        "apollo-utilities": "^1.3.0-rc.2",
        "optimism": "^0.9.0",
        "ts-invariant": "^0.4.0",
        "tslib": "^1.9.3"
      },
      "peerDependencies": {
        "graphql": "0.11.7 || ^0.12.0 || ^0.13.0 || ^14.0.0"
      },
      "gitHead": "d5106b03c790420f73df2b95e4d7ca94092a8f18",
      "readme": "---\ntitle: InMemoryCache\ndescription: An explanation of `apollo-cache-inmemory`\n---\n\n`apollo-cache-inmemory` is the recommended cache implementation for Apollo Client 2.0. `InMemoryCache` is a normalized data store that supports all of Apollo Client 1.0's features without the dependency on Redux.\n\nIn some instances, you may need to manipulate the cache directly, such as updating the store after a mutation. We'll cover some common use cases [here](#recipes).\n\n<h2 id=\"installation\">Installation</h2>\n\n```\nnpm install apollo-cache-inmemory --save\n```\n\nAfter installing the package, you'll want to initialize the cache constructor. Then, you can pass in your newly created cache to ApolloClient.\n\n```js\nimport { InMemoryCache } from 'apollo-cache-inmemory';\nimport { HttpLink } from 'apollo-link-http';\nimport ApolloClient from 'apollo-client';\n\nconst cache = new InMemoryCache();\n\nconst client = new ApolloClient({\n  link: new HttpLink(),\n  cache\n});\n```\n\n<h2 id=\"configuration\">Configuration</h2>\n\nThe `InMemoryCache` constructor takes an optional config object with properties to customize your cache:\n\n- addTypename: A boolean to determine whether to add __typename to the document (default: `true`)\n- dataIdFromObject: A function that takes a data object and returns a unique identifier to be used when normalizing the data in the store. Learn more about how to customize `dataIdFromObject` in the [Normalization](#normalization) section.\n- fragmentMatcher: By default, the `InMemoryCache` uses a heuristic fragment matcher. If you are using fragments on unions and interfaces, you will need to use an `IntrospectionFragmentMatcher`. For more information, please read [our guide to setting up fragment matching for unions & interfaces](https://www.apollographql.com/docs/react/advanced/fragments.html#fragment-matcher).\n\n<h2 id=\"normalization\">Normalization</h2>\n\nThe `InMemoryCache` normalizes your data before saving it to the store by splitting the result into individual objects, creating a unique identifier for each object, and storing those objects in a flattened data structure. By default, `InMemoryCache` will attempt to use the commonly found primary keys of `id` and `_id` for the unique identifier if they exist along with `__typename` on an object.\n\nIf `id` and `_id` are not specified, or if `__typename` is not specified, `InMemoryCache` will fall back to the path to the object in the query, such as `ROOT_QUERY.allPeople.0` for the first record returned on the `allPeople` root query.\n\nThis \"getter\" behavior for unique identifiers can be configured manually via the `dataIdFromObject` option passed to the `InMemoryCache` constructor, so you can pick which field is used if some of your data follows unorthodox primary key conventions.\n\nFor example, if you wanted to key off of the `key` field for all of your data, you could configure `dataIdFromObject` like so:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => object.key\n});\n```\n\nThis also allows you to use different unique identifiers for different data types by keying off of the `__typename` property attached to every object typed by GraphQL.  For example:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => {\n    switch (object.__typename) {\n      case 'foo': return object.key; // use `key` as the primary key\n      case 'bar': return object.blah; // use `blah` as the priamry key\n      default: return object.id || object._id; // fall back to `id` and `_id` for all other types\n    }\n  }\n});\n```\n\n<h2 id=\"direct\">Direct Cache Access</h2>\n\nTo interact directly with your cache, you can use the Apollo Client class methods readQuery, readFragment, writeQuery, and writeFragment. These methods are available to us via the [`DataProxy` interface](https://github.com/apollographql/apollo-client/blob/master/packages/apollo-cache/src/types/DataProxy.ts). Accessing these methods will vary slightly based on your view layer implementation. If you are using React, you can wrap your component in the `withApollo` higher order component, which will give you access to `this.props.client`. From there, you can use the methods to control your data.\n\nAny code demonstration in the following sections will assume that we have already initialized an instance of  `ApolloClient` and that we have imported the `gql` tag from `graphql-tag`.\n\n<h3 id=\"readquery\">readQuery</h3>\n\nThe `readQuery` method is very similar to the [`query` method on `ApolloClient`][] except that `readQuery` will _never_ make a request to your GraphQL server. The `query` method, on the other hand, may send a request to your server if the appropriate data is not in your cache whereas `readQuery` will throw an error if the data is not in your cache. `readQuery` will _always_ read from the cache. You can use `readQuery` by giving it a GraphQL query like so:\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo {\n      todo(id: 5) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n});\n```\n\nIf all of the data needed to fulfill this read is in Apollo Client’s normalized data cache then a data object will be returned in the shape of the query you wanted to read. If not all of the data needed to fulfill this read is in Apollo Client’s cache then an error will be thrown instead, so make sure to only read data that you know you have!\n\nYou can also pass variables into `readQuery`.\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo($id: Int!) {\n      todo(id: $id) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n  variables: {\n    id: 5,\n  },\n});\n```\n\n<h3 id=\"readfragment\">readFragment</h3>\n\nThis method allows you great flexibility around the data in your cache. Whereas `readQuery` only allowed you to read data from your root query type, `readFragment` allows you to read data from _any node you have queried_. This is incredibly powerful. You use this method as follows:\n\n```js\nconst todo = client.readFragment({\n  id: ..., // `id` is any id that could be returned by `dataIdFromObject`.\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\nThe first argument is the id of the data you want to read from the cache. That id must be a value that was returned by the `dataIdFromObject` function you defined when initializing `ApolloClient`. So for example if you initialized `ApolloClient` like so:\n\n```js\nconst client = new ApolloClient({\n  ...,\n  dataIdFromObject: object => object.id,\n});\n```\n\n…and you requested a todo before with an id of `5`, then you can read that todo out of your cache with the following:\n\n```js\nconst todo = client.readFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\n> **Note:** Most people add a `__typename` to the id in `dataIdFromObject`. If you do this then don’t forget to add the `__typename` when you are reading a fragment as well. So for example your id may be `Todo_5` and not just `5`.\n\nIf a todo with that id does not exist in the cache you will get `null` back. If a todo of that id does exist in the cache, but that todo does not have the `text` field then an error will be thrown.\n\nThe beauty of `readFragment` is that the todo could have come from anywhere! The todo could have been selected as a singleton (`{ todo(id: 5) { ... } }`), the todo could have come from a list of todos (`{ todos { ... } }`), or the todo could have come from a mutation (`mutation { createTodo { ... } }`). As long as at some point your GraphQL server gave you a todo with the provided id and fields `id`, `text`, and `completed` you can read it from the cache at any part of your code.\n\n<h3 id=\"writequery-and-writefragment\">writeQuery` and `writeFragment</h3>\n\nNot only can you read arbitrary data from the Apollo Client cache, but you can also write any data that you would like to the cache. The methods you use to do this are `writeQuery` and `writeFragment`. They will allow you to change data in your local cache, but it is important to remember that *they will not change any data on your server*. If you reload your environment then changes made with `writeQuery` and `writeFragment` will disappear.\n\nThese methods have the same signature as their `readQuery` and `readFragment` counterparts except they also require an additional `data` variable. So for example, if you wanted to update the `completed` flag locally for your todo with id `'5'` you could execute the following:\n\n```js\nclient.writeFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      completed\n    }\n  `,\n  data: {\n    completed: true,\n  },\n});\n```\n\nAny subscriber to the Apollo Client store will instantly see this update and render new UI accordingly.\n\n> **Note:** Again, remember that using `writeQuery` or `writeFragment` only changes data *locally*. If you reload your environment then changes made with these methods will no longer exist.\n\nOr if you wanted to add a new todo to a list fetched from the server, you could use `readQuery` and `writeQuery` together.\n\n```js\nconst query = gql`\n  query MyTodoAppQuery {\n    todos {\n      id\n      text\n      completed\n    }\n  }\n`;\n\nconst data = client.readQuery({ query });\n\nconst myNewTodo = {\n  id: '6',\n  text: 'Start using Apollo Client.',\n  completed: false,\n};\n\nclient.writeQuery({\n  query,\n  data: {\n    todos: [...data.todos, myNewTodo],\n  },\n});\n```\n\n<h2 id=\"recipes\">Recipes</h2>\n\nHere are some common situations where you would need to access the cache directly. If you're manipulating the cache in an interesting way and would like your example to be featured, please send in a pull request!\n\n<h3 id=\"server\">Server side rendering</h3>\n\nFirst, you will need to initialize an `InMemoryCache` on the server and create an instance of `ApolloClient`. In the initial serialized HTML payload from the server, you should include a script tag that extracts the data from the cache.\n\n```js\n`<script>\n  window.__APOLLO_STATE__=${JSON.stringify(cache.extract())}\n</script>`\n```\n\nOn the client, you can rehydrate the cache using the initial data passed from the server:\n\n```js\ncache: new Cache().restore(window.__APOLLO_STATE__)\n```\n\nIf you would like to learn more about server side rendering, please check our our more in depth guide [here].\n<!---\nTODO (PEGGY): Add link to SSR\n-->\n\n<h3 id=\"server\">Updating the cache after a mutation</h3>\n\nBeing able to read and write to the Apollo cache from anywhere in your application gives you a lot of power over your data. However, there is one place where we most often want to update our cached data: after a mutation. As such, Apollo Client has optimized the experience for updating your cache with the read and write methods after a mutation with the `update` function. Let us say that we have the following GraphQL mutation:\n\n```graphql\nmutation TodoCreateMutation($text: String!) {\n  createTodo(text: $text) {\n    id\n    text\n    completed\n  }\n}\n```\n\nWe may also have the following GraphQL query:\n\n```graphql\nquery TodoAppQuery {\n  todos {\n    id\n    text\n    completed\n  }\n}\n```\n\nAt the end of our mutation we want our query to include the new todo like we had sent our `TodoAppQuery` a second time after the mutation finished without actually sending the query. To do this we can use the `update` function provided as an option of the `client.mutate` method. To update your cache with the mutation just write code that looks like:\n\n```js\n// We assume that the GraphQL operations `TodoCreateMutation` and\n// `TodoAppQuery` have already been defined using the `gql` tag.\n\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    // Read the data from our cache for this query.\n    const data = proxy.readQuery({ query: TodoAppQuery });\n\n    // Add our todo from the mutation to the end.\n    data.todos.push(createTodo);\n\n    // Write our data back to the cache.\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nThe first `proxy` argument is an instance of [`DataProxy`][] has the same four methods that we just learned exist on the Apollo Client: `readQuery`, `readFragment`, `writeQuery`, and `writeFragment`. The reason we call them on a `proxy` object here instead of on our `client` instance is that we can easily apply optimistic updates (which we will demonstrate in a bit). The `proxy` object also provides an isolated transaction which shields you from any other mutations going on at the same time, and the `proxy` object also batches writes together until the very end.\n\nIf you provide an `optimisticResponse` option to the mutation then the `update` function will be run twice. Once immediately after you call `client.mutate` with the data from `optimisticResponse`. After the mutation successfully executes against the server the changes made in the first call to `update` will be rolled back and `update` will be called with the *actual* data returned by the mutation and not just the optimistic response.\n\nPutting it all together:\n\n```js\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  optimisticResponse: {\n    id: -1, // -1 is a temporary id for the optimistic response.\n    text,\n    completed: false,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    const data = proxy.readQuery({ query: TodoAppQuery });\n    data.todos.push(createTodo);\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nAs you can see the `update` function on `client.mutate` provides extra change management functionality specific to the use case of a mutation while still providing you the powerful data control APIs that are available on `client`.\n\nThe `update` function is not a good place for side-effects as it may be called multiple times. Also, you may not call any of the methods on `proxy` asynchronously.\n\n",
      "readmeFilename": "README.md",
      "_id": "apollo-cache-inmemory@1.6.0-rc.2",
      "_nodeVersion": "8.15.1",
      "_npmVersion": "lerna/3.13.4/node@v8.15.1+x64 (darwin)",
      "_npmUser": {
        "name": "benjamn",
        "email": "ben@benjamn.com"
      },
      "dist": {
        "integrity": "sha512-2oTZ+5F6k7j4Zpw23AIOhZTPB+Y4/9VZzC7txij95t/2/jgtvTFAKBIGpnvfzReJtidUGQxT7g58LLKls79WnQ==",
        "shasum": "b70942c6cb040e66767f56cefdf50d18b88b2b50",
        "tarball": "https://registry.npmjs.org/apollo-cache-inmemory/-/apollo-cache-inmemory-1.6.0-rc.2.tgz",
        "fileCount": 56,
        "unpackedSize": 540768,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJc1cHECRA9TVsSAnZWagAA788QAJMTkyXLFIOLPcPUD2L4\n0ZWAZo4xuxLG58JMg09p2e+Mr7I39OOqkU79pFipqg5hEtesiNOFeIQ0Qap3\nQOD9RJuR7ofDspefQgfkYNspkq+PoBYbsQQHfADGwbEXEi38SWCzFnUx4wA7\n2alQNZtjeSV4ayq5FO71ejJJbBbLTMl68jbiXwiLpr9cnZA7JZ4t5gcRYm7P\nGkUmiN+2igA09XKfYlaSQGhCkcb8DGq3zoSPtazTeCtt3hT+D3LX91Rx0K6I\newb4s9kpI3Nrfb7HmQIWgyXQ5b9oATCopxqAOEPxhqciqUNqk+79hN9KkBxr\n8/zFOWkrlGhHYdiABrIO9kzKSHK2Gy7MI3rjQHsX7u+CLj6qNyOG3eY8u68L\ncbYKeCBjsyAD1n7M6TmeTaw+WhwD0IXvTBOOPJVJSCDu547QpMbBQLKlucdU\nE4q0rGD8BJ06vH5P7XZAZ3fPr0NwenZ1l1WOqVlNMwEQxMmw8+J55Fo9kA6E\n8cSv88I2BfGZmGjp586W004BiGA1vgr/TqvGaPr0GBKIqj5+GBEGGZK83Epm\ncGpDJiqycyS5kslpwymwGvueZ+2BDLOyPtuGkrHvWC1LIypi+gwISm/btYKV\nAoUq/wNwQUUlowDkTcyriJgXNAAWmB9sjn9JbyDUaXYNIrseF369G1/ms/5f\ncT/3\r\n=znIP\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEYCIQDFr/0J3II4x84TmRLI5Oilg8JUOeN51cOz2p7Gip63UgIhAJube7KC9K4l4QU4bjKP2NLQF5EXKWv5NNKUKItOxTXC"
          }
        ]
      },
      "maintainers": [
        {
          "email": "npm@apollographql.com",
          "name": "apollo-bot"
        },
        {
          "email": "ben@benjamn.com",
          "name": "benjamn"
        },
        {
          "email": "james@meteor.com",
          "name": "jbaxleyiii"
        },
        {
          "email": "peggyrayzis@gmail.com",
          "name": "peggyrayzis"
        }
      ],
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/apollo-cache-inmemory_1.6.0-rc.2_1557512644245_0.6817884932204754"
      },
      "_hasShrinkwrap": false
    },
    "1.6.0": {
      "name": "apollo-cache-inmemory",
      "version": "1.6.0",
      "description": "Core abstract of Caching layer for Apollo Client",
      "author": {
        "name": "James Baxley",
        "email": "james@meteor.com"
      },
      "contributors": [
        {
          "name": "James Baxley",
          "email": "james@meteor.com"
        },
        {
          "name": "Jonas Helfer",
          "email": "jonas@helfer.email"
        },
        {
          "name": "Sashko Stubailo",
          "email": "sashko@stubailo.com"
        },
        {
          "name": "James Burgess",
          "email": "jamesmillerburgess@gmail.com"
        },
        {
          "name": "Bazyli Brzóska",
          "email": "bazyli.brzoska@gmail.com"
        }
      ],
      "license": "MIT",
      "main": "./lib/bundle.cjs.js",
      "module": "./lib/bundle.esm.js",
      "typings": "./lib/index.d.ts",
      "sideEffects": [
        "./lib/fixPolyfills.js"
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/apollographql/apollo-client.git"
      },
      "bugs": {
        "url": "https://github.com/apollographql/apollo-client/issues"
      },
      "homepage": "https://github.com/apollographql/apollo-client#readme",
      "scripts": {
        "prepare": "npm run build",
        "coverage": "jest --coverage",
        "test": "tsc -p tsconfig.json --noEmit && jest",
        "lint": "tslint -c \"../../config/tslint.json\" -p tsconfig.json src/*.ts",
        "prebuild": "npm run clean",
        "build": "tsc -b .",
        "postbuild": "npm run bundle",
        "bundle": "../../node_modules/rollup/bin/rollup -c rollup.config.js",
        "watch": "../../node_modules/tsc-watch/index.js --onSuccess \"npm run postbuild\"",
        "clean": "rm -rf coverage/* lib/*",
        "prepublishOnly": "npm run build"
      },
      "dependencies": {
        "apollo-cache": "^1.3.0",
        "apollo-utilities": "^1.3.0",
        "optimism": "^0.9.0",
        "ts-invariant": "^0.4.0",
        "tslib": "^1.9.3"
      },
      "peerDependencies": {
        "graphql": "0.11.7 || ^0.12.0 || ^0.13.0 || ^14.0.0"
      },
      "gitHead": "6838c5b11efb7c12abe0a37ae45061bf4f28c134",
      "_id": "apollo-cache-inmemory@1.6.0",
      "_nodeVersion": "8.16.0",
      "_npmVersion": "lerna/3.14.1/node@v8.16.0+x64 (darwin)",
      "_npmUser": {
        "name": "apollo-bot",
        "email": "npm@apollographql.com"
      },
      "dist": {
        "integrity": "sha512-Mr86ucMsXnRH9YRvcuuy6kc3dtyRBuVSo8gdxp2sJVuUAtvQ6r/8E+ok2qX84em9ZBAYxoyvPnKeShhvcKiiDw==",
        "shasum": "a106cdc520f0a043be2575372d5dbb7e4790254c",
        "tarball": "https://registry.npmjs.org/apollo-cache-inmemory/-/apollo-cache-inmemory-1.6.0.tgz",
        "fileCount": 56,
        "unpackedSize": 540753,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJc5FBACRA9TVsSAnZWagAAb0sP/1QytbwiU5Ow5//Cduwj\nFSvXhx8IHRMajpNuJIQN1Bgr3BYVVayJsRv3iVQmGUcnI0huVq36uL9rmILx\n82+CZYO6oBJFEOdmfAUWmum+O9sBhHKtuZ6Rc5jDW1I+fxfxFgfpApJ4hwcn\nzUT0hxTUiPNZpjQPnxa1zpPxwDtCOCTO6N3FHOfyHOXUWqV2jL8Usn9SVBjv\nUb5kXv+W8nb0grxYMDK21TXKhhXA/m5Zev9yaz2SemCMTCCbxufIzTuAF0kM\nLJlCYhfNISqO014Pk5ZOf+xRe2/Hu3qf7QrTKh514KGzOkxZnrSbjDf//a94\ni+Noo792W3HLETHnj5LAkZBCjMV5u9dN1kJzCDp63rLywRWZ3w/sTtXekgjs\n6An7wGDIkH7ncJbH1L1xNIQ7AcusnlU6fgMNPYzgUUOdgorbT2cDDe1oKarc\ndKwzoLA/caONHydNqLgR9aRCSjRp5bnwU/KE7oC3sfQ0NiI5LUOa9idnPben\ny4p/ufRAjRiV07b7KPaSbw4kdZXtKu3iWX72sKNe8+VJAmZl/pDkWfAyyfx1\nKVSLXUj68CD4i7/CCQ0uV/txTblRtV198M7XpHMm9H6Xy3iiv42pvQUeE8Kk\n/eyrj6ygrFaKaTQVc/SKnl+IF2VIZMHMzq6TBvMiHUkJtqrRzq4UNx3BkZ0/\ndkdx\r\n=j1FC\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEYCIQDI+sAqEimW9uTZxcuW10BHPAmLPQpRevxiOHc775gvDgIhAMN8sjXcLrUnk44LUf5R5vJ21MF+08JCufZuN8D4qzmd"
          }
        ]
      },
      "maintainers": [
        {
          "email": "npm@apollographql.com",
          "name": "apollo-bot"
        },
        {
          "email": "ben@benjamn.com",
          "name": "benjamn"
        },
        {
          "email": "james@meteor.com",
          "name": "jbaxleyiii"
        },
        {
          "email": "peggyrayzis@gmail.com",
          "name": "peggyrayzis"
        }
      ],
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/apollo-cache-inmemory_1.6.0_1558466623034_0.31604591702297435"
      },
      "_hasShrinkwrap": false
    },
    "1.6.1": {
      "name": "apollo-cache-inmemory",
      "version": "1.6.1",
      "description": "Core abstract of Caching layer for Apollo Client",
      "author": {
        "name": "James Baxley",
        "email": "james@meteor.com"
      },
      "contributors": [
        {
          "name": "James Baxley",
          "email": "james@meteor.com"
        },
        {
          "name": "Jonas Helfer",
          "email": "jonas@helfer.email"
        },
        {
          "name": "Sashko Stubailo",
          "email": "sashko@stubailo.com"
        },
        {
          "name": "James Burgess",
          "email": "jamesmillerburgess@gmail.com"
        },
        {
          "name": "Bazyli Brzóska",
          "email": "bazyli.brzoska@gmail.com"
        }
      ],
      "license": "MIT",
      "main": "./lib/bundle.cjs.js",
      "module": "./lib/bundle.esm.js",
      "typings": "./lib/index.d.ts",
      "sideEffects": [
        "./lib/fixPolyfills.js"
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/apollographql/apollo-client.git"
      },
      "bugs": {
        "url": "https://github.com/apollographql/apollo-client/issues"
      },
      "homepage": "https://github.com/apollographql/apollo-client#readme",
      "scripts": {
        "prepare": "npm run build",
        "coverage": "jest --coverage",
        "test": "tsc -p tsconfig.json --noEmit && jest",
        "lint": "tslint -c \"../../config/tslint.json\" -p tsconfig.json src/*.ts",
        "prebuild": "npm run clean",
        "build": "tsc -b .",
        "postbuild": "npm run bundle",
        "bundle": "../../node_modules/rollup/bin/rollup -c rollup.config.js",
        "watch": "../../node_modules/tsc-watch/index.js --onSuccess \"npm run postbuild\"",
        "clean": "rm -rf coverage/* lib/*",
        "prepublishOnly": "npm run build"
      },
      "dependencies": {
        "apollo-cache": "^1.3.1",
        "apollo-utilities": "^1.3.1",
        "optimism": "^0.9.0",
        "ts-invariant": "^0.4.0",
        "tslib": "^1.9.3"
      },
      "peerDependencies": {
        "graphql": "0.11.7 || ^0.12.0 || ^0.13.0 || ^14.0.0"
      },
      "gitHead": "4db0a7394649d8b21eaa8d5ba06dc2c3b9ee2b3a",
      "_id": "apollo-cache-inmemory@1.6.1",
      "_nodeVersion": "8.16.0",
      "_npmVersion": "lerna/3.14.1/node@v8.16.0+x64 (darwin)",
      "_npmUser": {
        "name": "apollo-bot",
        "email": "npm@apollographql.com"
      },
      "dist": {
        "integrity": "sha512-c/WJjh9MTWcdussCTjLKufpPjTx3qOFkBPHIDOOpQ+U0B7K1PczPl9N0LaC4ir3wAWL7s4A0t2EKtoR+6UP92g==",
        "shasum": "536b6f366461f6264250041f9146363e2faa1d4c",
        "tarball": "https://registry.npmjs.org/apollo-cache-inmemory/-/apollo-cache-inmemory-1.6.1.tgz",
        "fileCount": 92,
        "unpackedSize": 860695,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJc9pIPCRA9TVsSAnZWagAA714QAJz4/ASetdcY8XxlC0I/\n3ee0FW1mwYZ0I3HeCbXV7cMsYRVT8PLKHIdLaqnS4XOUeDxcGXoM4XWJlDtj\niFgrILybrZP2NCQnFV0h05GKpiu0SKl6LB6ewAepSZEBsSorg2lIQ7oiTRgt\nl3rjeUGKP7Q59j3HiBuSEE6PzTWcR9hpQG4fFaU1tjLCvxTPATYUOYoUljLA\n1uP983+lB2YYbmsZ0ui09OiWrDwJn/MAV7yHC7etE7wOl4+xLoYHeBWTtD/s\ntuR2sn1YBHwIMnQ6UPRYGi6tXmqbBGArJHThIjiaLxZBghq68DIllenfxiEa\nTUp0CUDZysKiA1qoxC9vlA6Axfwj8+66AmxkIIpoQE5/BE//Av0wdZKCbvAc\nJ3Cm8oQuILiYeUI3tELH2W39SrKC7FiW/LyODa3AJVC2hk6s6anF2iwKUOVN\ndY5R7vAqQMNDy6Qsg58LvcJ4t8YFxAfME3slk30VNCCRpQxJWCVXOnDs1StZ\ncmBhgfuALjmjIk17PiU+jm1tn4M3SaAgHYemaLVM05WWKhFJ6mwT+UyDyNDn\nkct0ltOkrpfBhjQGYu8UZkUGOCupEdDnP23oI6VgOsH6G4Vc3Y5fNAozCBLN\n1I7glk6gWC9VuZpzcZld9y+izVqgh7SchA7FQl5P7auaRDlqu6twQA/eLh9k\n1FV8\r\n=swHt\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIFno2MePvPdXUXm6XROtJ5V/GHC3l8Ta4BZP9hE1YdKcAiEA/kf1uXHXDRXBmQMUBNBGze45NUR6AT17TmrIFrKTOi0="
          }
        ]
      },
      "maintainers": [
        {
          "email": "npm@apollographql.com",
          "name": "apollo-bot"
        },
        {
          "email": "ben@benjamn.com",
          "name": "benjamn"
        },
        {
          "email": "james@meteor.com",
          "name": "jbaxleyiii"
        },
        {
          "email": "peggyrayzis@gmail.com",
          "name": "peggyrayzis"
        }
      ],
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/apollo-cache-inmemory_1.6.1_1559663118930_0.5313910149026659"
      },
      "_hasShrinkwrap": false
    },
    "1.6.2": {
      "name": "apollo-cache-inmemory",
      "version": "1.6.2",
      "description": "Core abstract of Caching layer for Apollo Client",
      "author": {
        "name": "James Baxley",
        "email": "james@meteor.com"
      },
      "contributors": [
        {
          "name": "James Baxley",
          "email": "james@meteor.com"
        },
        {
          "name": "Jonas Helfer",
          "email": "jonas@helfer.email"
        },
        {
          "name": "Sashko Stubailo",
          "email": "sashko@stubailo.com"
        },
        {
          "name": "James Burgess",
          "email": "jamesmillerburgess@gmail.com"
        },
        {
          "name": "Bazyli Brzóska",
          "email": "bazyli.brzoska@gmail.com"
        }
      ],
      "license": "MIT",
      "main": "./lib/bundle.cjs.js",
      "module": "./lib/bundle.esm.js",
      "typings": "./lib/index.d.ts",
      "sideEffects": [
        "./lib/fixPolyfills.js"
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/apollographql/apollo-client.git"
      },
      "bugs": {
        "url": "https://github.com/apollographql/apollo-client/issues"
      },
      "homepage": "https://github.com/apollographql/apollo-client#readme",
      "scripts": {
        "prepare": "npm run build",
        "coverage": "jest --coverage",
        "test": "tsc -p tsconfig.json --noEmit && jest",
        "lint": "tslint -c \"../../config/tslint.json\" -p tsconfig.json src/*.ts",
        "prebuild": "npm run clean",
        "build": "tsc -b .",
        "postbuild": "npm run bundle",
        "bundle": "../../node_modules/rollup/bin/rollup -c rollup.config.js",
        "watch": "../../node_modules/tsc-watch/index.js --onSuccess \"npm run postbuild\"",
        "clean": "rm -rf coverage/* lib/*",
        "prepublishOnly": "npm run build"
      },
      "dependencies": {
        "apollo-cache": "^1.3.2",
        "apollo-utilities": "^1.3.2",
        "optimism": "^0.9.0",
        "ts-invariant": "^0.4.0",
        "tslib": "^1.9.3"
      },
      "peerDependencies": {
        "graphql": "0.11.7 || ^0.12.0 || ^0.13.0 || ^14.0.0"
      },
      "gitHead": "656fd9fbcf82df5cd6b9512e4c9b90b808e300ad",
      "_id": "apollo-cache-inmemory@1.6.2",
      "_nodeVersion": "8.16.0",
      "_npmVersion": "lerna/3.14.1/node@v8.16.0+x64 (darwin)",
      "_npmUser": {
        "name": "apollo-bot",
        "email": "npm@apollographql.com"
      },
      "dist": {
        "integrity": "sha512-AyCl3PGFv5Qv1w4N9vlg63GBPHXgMCekZy5mhlS042ji0GW84uTySX+r3F61ZX3+KM1vA4m9hQyctrEGiv5XjQ==",
        "shasum": "bbf2e4e1eacdf82b2d526f5c2f3b37e5acee3c5e",
        "tarball": "https://registry.npmjs.org/apollo-cache-inmemory/-/apollo-cache-inmemory-1.6.2.tgz",
        "fileCount": 92,
        "unpackedSize": 860695,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJc+Sb3CRA9TVsSAnZWagAAmX8P/3WYh6BQjd+BcP/eaAyK\n+VKK4NNkcTx7RN3dXF0A0jllw92JiRwO+/nvTaAgGZET1DJIMH8gobbQKYga\nlCWdRlioEcZbJoxXP24ZUWsB1GgjLmQGV6c38G8O9p1qOiiicQQtPyZI/HjU\nLpEM43VVePwKCGJEoKA7QINcSrBwU44pwwmi17ysR2Rt7zXgBMGqLJiG768W\n7TXdWc9PvW96L8iM+mAQv7u37K9yeIXMzr5uyya6B36Bgv9sPfh1B42a8NUg\nWT0YcA6wQieHq6OxCT9An0pzhGGYdTXeZ7uo0i9F8PTWNe1bCYNY2BLjA12k\nsFjL6NsirYYbdgdQLcsSnAbFQqfMDjqUIANQJnQFKvKh6szFhoLu9d5bnkTQ\neGSVochxOBWhRnKgsatwdmmETw488QXwwWVNR+LuWNkUHrO9vXnHZDLteIk1\nZMg9q7/oU3s1y1xDd/Xf+94385/LtL7GtNoNcEOAFrvX8k7mqRgmrzddoTSd\nDs1G/dszpZ8hMB3TXpoLZoGoEhE1RyqpvE+Eo80RUBAm8P+f4iik0pEtE4ri\nvCBmENLGX7cLqBHaP2L05m7jQIDHE3LFEXbuHUrzsacjO8hTxE0Y4XGIrcz0\nCJhhi6Zt5tu45pqh9Y8UV+5DQvWYLhwnW/JVsymOfcn5DRFtEWkx8POIFy2H\nzk8Z\r\n=yND0\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIQCXnmMLsRKCqnX+bWtwYALwvRjFkfeW7QdnQ9wO2hPKNgIgf+6/Lk/1UMEIo7PLOIQTxtB1iP/RiCDyKzwqdZ+8JT8="
          }
        ]
      },
      "maintainers": [
        {
          "email": "npm@apollographql.com",
          "name": "apollo-bot"
        },
        {
          "email": "ben@benjamn.com",
          "name": "benjamn"
        },
        {
          "email": "james@meteor.com",
          "name": "jbaxleyiii"
        },
        {
          "email": "peggyrayzis@gmail.com",
          "name": "peggyrayzis"
        }
      ],
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/apollo-cache-inmemory_1.6.2_1559832310487_0.3612511677775563"
      },
      "_hasShrinkwrap": false
    },
    "1.6.3": {
      "name": "apollo-cache-inmemory",
      "version": "1.6.3",
      "description": "Core abstract of Caching layer for Apollo Client",
      "author": {
        "name": "James Baxley",
        "email": "james@meteor.com"
      },
      "contributors": [
        {
          "name": "James Baxley",
          "email": "james@meteor.com"
        },
        {
          "name": "Jonas Helfer",
          "email": "jonas@helfer.email"
        },
        {
          "name": "Sashko Stubailo",
          "email": "sashko@stubailo.com"
        },
        {
          "name": "James Burgess",
          "email": "jamesmillerburgess@gmail.com"
        },
        {
          "name": "Bazyli Brzóska",
          "email": "bazyli.brzoska@gmail.com"
        }
      ],
      "license": "MIT",
      "main": "./lib/bundle.cjs.js",
      "module": "./lib/bundle.esm.js",
      "typings": "./lib/index.d.ts",
      "sideEffects": [
        "./lib/fixPolyfills.js"
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/apollographql/apollo-client.git"
      },
      "bugs": {
        "url": "https://github.com/apollographql/apollo-client/issues"
      },
      "homepage": "https://github.com/apollographql/apollo-client#readme",
      "scripts": {
        "prepare": "npm run build",
        "coverage": "jest --coverage",
        "test": "tsc -p tsconfig.json --noEmit && jest",
        "lint": "tslint -c \"../../config/tslint.json\" -p tsconfig.json src/*.ts",
        "prebuild": "npm run clean",
        "build": "tsc -b .",
        "postbuild": "npm run bundle",
        "bundle": "../../node_modules/rollup/bin/rollup -c rollup.config.js",
        "watch": "../../node_modules/tsc-watch/index.js --onSuccess \"npm run postbuild\"",
        "clean": "rm -rf coverage/* lib/*",
        "prepublishOnly": "npm run build"
      },
      "dependencies": {
        "apollo-cache": "^1.3.2",
        "apollo-utilities": "^1.3.2",
        "optimism": "^0.10.0",
        "ts-invariant": "^0.4.0",
        "tslib": "^1.9.3"
      },
      "peerDependencies": {
        "graphql": "0.11.7 || ^0.12.0 || ^0.13.0 || ^14.0.0"
      },
      "gitHead": "d28dea2370e292f18979f25fe15258a59e159b4d",
      "_id": "apollo-cache-inmemory@1.6.3",
      "_nodeVersion": "10.15.3",
      "_npmVersion": "lerna/3.16.4/node@v10.15.3+x64 (darwin)",
      "dist": {
        "integrity": "sha512-S4B/zQNSuYc0M/1Wq8dJDTIO9yRgU0ZwDGnmlqxGGmFombOZb9mLjylewSfQKmjNpciZ7iUIBbJ0mHlPJTzdXg==",
        "shasum": "826861d20baca4abc45f7ca7a874105905b8525d",
        "tarball": "https://registry.npmjs.org/apollo-cache-inmemory/-/apollo-cache-inmemory-1.6.3.tgz",
        "fileCount": 92,
        "unpackedSize": 851911,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJdTu+YCRA9TVsSAnZWagAAltgP+QCib0M2TsXkSTbGlVZJ\nvi2/iDacjgiQGtNt6ogsmoljoCmytrnvAmFDfhfX/OVMOVibd6jl1QsQB2mG\njstMcJM4m6GYjDTYjTSAXXr1Kbp3S4ICc83ic0P60hYHqrZYjJKBbUCzA4Wl\n9F6RTDDpfhVVvI77WRdWsJiHpBPBo3LT0o9URNu2hpJIaHSsl53gWshx25ZX\nrbyRpymsnAFheikpgu+j0VQ1VufkjdkZR7E1uAbzguoeS1J+TtG1Q/e0H0bO\nFqoeo5tAN9JFYYB5Ct5d8sC5dTYTulVlnJNpUhcfOb+P0l5rxAEpFblNKsGe\nIvuArueZaYwL68GUVmxE4EhgNqYBic/muLMJ6AyEZVvwl4tcNdCG8eZMQhVA\ngTGIGTmzQ3VVV6G2m25uUsrd5D9nwihWlJsaQSTB3jjzKrPKkekaNMNPU0nu\nZsgX0GXZghbzqHHIkSzL2yl7Ant6qXuRqUzXEjbSr+47nz2a1AuFKEzmEm/o\nNwrdqru4hbXH4Ij8LsXyc17SpDcHLP6YnM+lrzE913zvFKpLglp9uY1/CxiP\nO7EuYCXFjvt2lwvabks2l9x/YFy8hLk0jI05ynWJO1QPGDZJdmjRqaxCJgfv\nHJwP0SpZS21cN6Nz7RM202HvDcyfViBULS7QLdnbDqZnH4Q2LC+sg0Y+ng4M\nGvU3\r\n=ISVd\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIBW+ED2tXLMevrnjvAkdrrlCGLqEDuncNOXcb84NSI9ZAiEA4nUy98RZe8pHIX0G5PdCyWOigNIDAyF5vXcQVZ5g/fY="
          }
        ]
      },
      "maintainers": [
        {
          "email": "npm@apollographql.com",
          "name": "apollo-bot"
        },
        {
          "email": "ben@benjamn.com",
          "name": "benjamn"
        },
        {
          "email": "james@meteor.com",
          "name": "jbaxleyiii"
        },
        {
          "email": "peggyrayzis@gmail.com",
          "name": "peggyrayzis"
        }
      ],
      "_npmUser": {
        "name": "apollo-bot",
        "email": "npm@apollographql.com"
      },
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/apollo-cache-inmemory_1.6.3_1565454231547_0.8018078046453894"
      },
      "_hasShrinkwrap": false
    },
    "1.6.5": {
      "name": "apollo-cache-inmemory",
      "version": "1.6.5",
      "description": "Core abstract of Caching layer for Apollo Client",
      "author": {
        "name": "James Baxley",
        "email": "james@meteor.com"
      },
      "contributors": [
        {
          "name": "James Baxley",
          "email": "james@meteor.com"
        },
        {
          "name": "Jonas Helfer",
          "email": "jonas@helfer.email"
        },
        {
          "name": "Sashko Stubailo",
          "email": "sashko@stubailo.com"
        },
        {
          "name": "James Burgess",
          "email": "jamesmillerburgess@gmail.com"
        },
        {
          "name": "Bazyli Brzóska",
          "email": "bazyli.brzoska@gmail.com"
        }
      ],
      "license": "MIT",
      "main": "./lib/bundle.cjs.js",
      "module": "./lib/bundle.esm.js",
      "typings": "./lib/index.d.ts",
      "sideEffects": [
        "./lib/fixPolyfills.js"
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/apollographql/apollo-client.git"
      },
      "bugs": {
        "url": "https://github.com/apollographql/apollo-client/issues"
      },
      "homepage": "https://github.com/apollographql/apollo-client#readme",
      "scripts": {
        "prepare": "npm run build",
        "coverage": "jest --coverage",
        "test": "tsc -p tsconfig.json --noEmit && jest",
        "lint": "tslint -c \"../../config/tslint.json\" -p tsconfig.json src/*.ts",
        "prebuild": "npm run clean",
        "build": "tsc -b .",
        "postbuild": "npm run bundle",
        "bundle": "../../node_modules/rollup/bin/rollup -c rollup.config.js",
        "watch": "../../node_modules/tsc-watch/index.js --onSuccess \"npm run postbuild\"",
        "clean": "rm -rf coverage/* lib/*",
        "prepublishOnly": "npm run build"
      },
      "dependencies": {
        "apollo-cache": "^1.3.4",
        "apollo-utilities": "^1.3.3",
        "optimism": "^0.10.0",
        "ts-invariant": "^0.4.0",
        "tslib": "^1.10.0"
      },
      "peerDependencies": {
        "graphql": "0.11.7 || ^0.12.0 || ^0.13.0 || ^14.0.0"
      },
      "gitHead": "68fa57751ce201ba6b72efdbf8fdda1729c991cc",
      "_id": "apollo-cache-inmemory@1.6.5",
      "_nodeVersion": "10.15.3",
      "_npmVersion": "lerna/3.19.0/node@v10.15.3+x64 (darwin)",
      "dist": {
        "integrity": "sha512-koB76JUDJaycfejHmrXBbWIN9pRKM0Z9CJGQcBzIOtmte1JhEBSuzsOUu7NQgiXKYI4iGoMREcnaWffsosZynA==",
        "shasum": "2ccaa3827686f6ed7fb634203dbf2b8d7015856a",
        "tarball": "https://registry.npmjs.org/apollo-cache-inmemory/-/apollo-cache-inmemory-1.6.5.tgz",
        "fileCount": 92,
        "unpackedSize": 852821,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJd9MscCRA9TVsSAnZWagAAJNsP/1JeSTO4h4PgJYr20Nx8\n0wqfytNzVPOD4YUmdutA/tdA/hAx4G3dpoiwfqBMrFqpdRpIb9U/Qf7Tg0G7\n163QVTmKsdwRxvvliBDlh6p7XvtKKUQxl1LuyHFyGTRMjP1+5/ETbacYvNNT\nQTBu81WqUd25jkkkoRKY3qYpjmD65tbszH0/M7VKciE48cx2L3HkPeQHgba+\nKXSX0qmeTUfLmRIiNBumN7Ijdb1HcqyUMHVJ3k1MA+eC8MzZSVpcIWcdr8xj\nrL9ip4iahVnQFDa4lWEN5UFpg3UkBOtkwpVrNV6swqVL0rE05qny1epetrVn\n2uQ148jOImQvkc7YuoSdeOZBvwL3xvXyJIGEhLELg/GHU9r+qG/H0MLuvK+Q\nO+bJIlXmKbXhVv0vPPPuwtTlQvoFp4KIBf0cSB4i3KKq+rztpyivBXSOw7Tr\nevi67nn4BSttv7texULPoeeLiA3iSvlfmIowAVFNN9vLYyDo13lJSpLzmBbF\nzRBB6tqwR3EMbIX2gfFRiwKNtZR96VlaLBxxbWzwcTnI4vtw+vzxz318R6dB\nBw8RO8EVADjYkr7gfLWSq+BIH76O5yVLE7VgIkSbhjvB6Y5lxEkyPCYZ3RHB\nZLWRB3SdfWj5INn4fbwesTRq53a23waJlhEtXFZNyvwXPk1nAuqK1kjzNO0F\ng29p\r\n=XXD9\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIDCZWBLrpEqAPJA7BK6dXXAZYRp2QVWjEfDKhIiX12bJAiEAq4gbiC1sYyggxxPTzA+XwbkqzfCuFriG7KLUuy6kd2Y="
          }
        ]
      },
      "maintainers": [
        {
          "email": "npm@apollographql.com",
          "name": "apollo-bot"
        },
        {
          "email": "ben@benjamn.com",
          "name": "benjamn"
        },
        {
          "email": "james@meteor.com",
          "name": "jbaxleyiii"
        },
        {
          "email": "peggyrayzis@gmail.com",
          "name": "peggyrayzis"
        }
      ],
      "_npmUser": {
        "name": "apollo-bot",
        "email": "npm@apollographql.com"
      },
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/apollo-cache-inmemory_1.6.5_1576323867824_0.6994110245576564"
      },
      "_hasShrinkwrap": false
    },
    "1.6.6": {
      "name": "apollo-cache-inmemory",
      "version": "1.6.6",
      "description": "Core abstract of Caching layer for Apollo Client",
      "author": {
        "name": "James Baxley",
        "email": "james@meteor.com"
      },
      "contributors": [
        {
          "name": "James Baxley",
          "email": "james@meteor.com"
        },
        {
          "name": "Jonas Helfer",
          "email": "jonas@helfer.email"
        },
        {
          "name": "Sashko Stubailo",
          "email": "sashko@stubailo.com"
        },
        {
          "name": "James Burgess",
          "email": "jamesmillerburgess@gmail.com"
        },
        {
          "name": "Bazyli Brzóska",
          "email": "bazyli.brzoska@gmail.com"
        }
      ],
      "license": "MIT",
      "main": "./lib/bundle.cjs.js",
      "module": "./lib/bundle.esm.js",
      "typings": "./lib/index.d.ts",
      "sideEffects": [
        "./lib/fixPolyfills.js"
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/apollographql/apollo-client.git"
      },
      "bugs": {
        "url": "https://github.com/apollographql/apollo-client/issues"
      },
      "homepage": "https://github.com/apollographql/apollo-client#readme",
      "scripts": {
        "prepare": "npm run build",
        "coverage": "jest --coverage",
        "test": "tsc -p tsconfig.json --noEmit && jest",
        "lint": "tslint -c \"../../config/tslint.json\" -p tsconfig.json src/*.ts",
        "prebuild": "npm run clean",
        "build": "tsc -b .",
        "postbuild": "npm run bundle",
        "bundle": "npx rollup -c rollup.config.js",
        "watch": "../../node_modules/tsc-watch/index.js --onSuccess \"npm run postbuild\"",
        "clean": "rm -rf coverage/* lib/*",
        "prepublishOnly": "npm run build"
      },
      "dependencies": {
        "apollo-cache": "^1.3.5",
        "apollo-utilities": "^1.3.4",
        "optimism": "^0.10.0",
        "ts-invariant": "^0.4.0",
        "tslib": "^1.10.0"
      },
      "peerDependencies": {
        "graphql": "^0.11.0 || ^0.12.0 || ^0.13.0 || ^14.0.0 || ^15.0.0"
      },
      "gitHead": "d22394c419ff7d678afb5e7d4cd1df16ed803ead",
      "_id": "apollo-cache-inmemory@1.6.6",
      "_nodeVersion": "10.15.3",
      "_npmVersion": "lerna/3.20.2/node@v10.15.3+x64 (darwin)",
      "dist": {
        "integrity": "sha512-L8pToTW/+Xru2FFAhkZ1OA9q4V4nuvfoPecBM34DecAugUZEBhI2Hmpgnzq2hTKZ60LAMrlqiASm0aqAY6F8/A==",
        "shasum": "56d1f2a463a6b9db32e9fa990af16d2a008206fd",
        "tarball": "https://registry.npmjs.org/apollo-cache-inmemory/-/apollo-cache-inmemory-1.6.6.tgz",
        "fileCount": 92,
        "unpackedSize": 852807,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJetowNCRA9TVsSAnZWagAAFqQP/jML/Ft0euLdrnRUblWW\n7WZjKCXJIBGW2h+nJid105U0hMdbnVhtZVsWz/hD8aXmfVb/jSG44Rg+D8+W\nQhXVwR/7rS3ItNhSrlS71DpNLzL15BjuN5P9f6VFKo1QHpfnt02IWGQmq3jB\n7aBH7GwMvblnlPXXHa8NqidQJIl8m7siG+LjYJuOAJmBJY+ifKRLmSOoF/az\nRTz1AeKEfSAU5r3dXx1Xrc4LWbDMHpDu8vxCsTooB6dQlYeN5kGVrxh0kPAs\nJZD1zVFOUAoSgENk+tANp1rmhbPjTrQcVNlB43Opsjpt7Nl1WWWKo3o8D/Z6\niZ8ZxY70tOsVeKZIhQF1Fw490mHzcGxPi0H5LxZ1za92lRrqKbzT019MFJMT\nw57xMHDVDglJKoMww+Wz4PUFR/baYgACtpxeYDZqdpA3ING6rPFTeLCVbqNy\no6AdEAR4c8cwvCsC1RHH1vL7/bIGr5vVPCijU6m3WR0Outo/2cjdj2IMNefN\nNNlcUMXsB8DVXjbYP+8oqND3Uvw7my60KNboTGPBIfudVs+39RjfXXVoR4jt\nUwnx1GmqnuQuSsPC0ju+/0G28ZengrxUs5wv3upsn0PPJmLmjOLe3XliqHs7\n3g51wCjPCs+O3ZjaP31BmPrl+2nBCDT7glOwlLUA4V0oJNla6zBz0qLUFA1H\nRTz7\r\n=N2HO\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEYCIQCx9FlGgmFDnjlqoaSje9BBUyOWaTZtA6e71cC1fFXP4gIhAIKXWu5NKEIcAvxVj8uBOmLy8oeugjk+gNNkbRvpKmlS"
          }
        ]
      },
      "maintainers": [
        {
          "email": "npm@apollographql.com",
          "name": "apollo-bot"
        },
        {
          "email": "ben@benjamn.com",
          "name": "benjamn"
        },
        {
          "email": "james@meteor.com",
          "name": "jbaxleyiii"
        },
        {
          "email": "peggyrayzis@gmail.com",
          "name": "peggyrayzis"
        }
      ],
      "_npmUser": {
        "name": "apollo-bot",
        "email": "npm@apollographql.com"
      },
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/apollo-cache-inmemory_1.6.6_1589021708828_0.17425072913655537"
      },
      "_hasShrinkwrap": false
    }
  },
  "readme": "---\ntitle: InMemoryCache\ndescription: An explanation of `apollo-cache-inmemory`\n---\n\n`apollo-cache-inmemory` is the recommended cache implementation for Apollo Client 2.0. `InMemoryCache` is a normalized data store that supports all of Apollo Client 1.0's features without the dependency on Redux.\n\nIn some instances, you may need to manipulate the cache directly, such as updating the store after a mutation. We'll cover some common use cases [here](#recipes).\n\n<h2 id=\"installation\">Installation</h2>\n\n```\nnpm install apollo-cache-inmemory --save\n```\n\nAfter installing the package, you'll want to initialize the cache constructor. Then, you can pass in your newly created cache to ApolloClient.\n\n```js\nimport { InMemoryCache } from 'apollo-cache-inmemory';\nimport { HttpLink } from 'apollo-link-http';\nimport ApolloClient from 'apollo-client';\n\nconst cache = new InMemoryCache();\n\nconst client = new ApolloClient({\n  link: new HttpLink(),\n  cache\n});\n```\n\n<h2 id=\"configuration\">Configuration</h2>\n\nThe `InMemoryCache` constructor takes an optional config object with properties to customize your cache:\n\n- addTypename: A boolean to determine whether to add __typename to the document (default: `true`)\n- dataIdFromObject: A function that takes a data object and returns a unique identifier to be used when normalizing the data in the store. Learn more about how to customize `dataIdFromObject` in the [Normalization](#normalization) section.\n- fragmentMatcher: By default, the `InMemoryCache` uses a heuristic fragment matcher. If you are using fragments on unions and interfaces, you will need to use an `IntrospectionFragmentMatcher`. For more information, please read [our guide to setting up fragment matching for unions & interfaces](https://www.apollographql.com/docs/react/advanced/fragments.html#fragment-matcher).\n\n<h2 id=\"normalization\">Normalization</h2>\n\nThe `InMemoryCache` normalizes your data before saving it to the store by splitting the result into individual objects, creating a unique identifier for each object, and storing those objects in a flattened data structure. By default, `InMemoryCache` will attempt to use the commonly found primary keys of `id` and `_id` for the unique identifier if they exist along with `__typename` on an object.\n\nIf `id` and `_id` are not specified, or if `__typename` is not specified, `InMemoryCache` will fall back to the path to the object in the query, such as `ROOT_QUERY.allPeople.0` for the first record returned on the `allPeople` root query.\n\nThis \"getter\" behavior for unique identifiers can be configured manually via the `dataIdFromObject` option passed to the `InMemoryCache` constructor, so you can pick which field is used if some of your data follows unorthodox primary key conventions.\n\nFor example, if you wanted to key off of the `key` field for all of your data, you could configure `dataIdFromObject` like so:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => object.key\n});\n```\n\nThis also allows you to use different unique identifiers for different data types by keying off of the `__typename` property attached to every object typed by GraphQL.  For example:\n\n```js\nconst cache = new InMemoryCache({\n  dataIdFromObject: object => {\n    switch (object.__typename) {\n      case 'foo': return object.key; // use `key` as the primary key\n      case 'bar': return object.blah; // use `blah` as the priamry key\n      default: return object.id || object._id; // fall back to `id` and `_id` for all other types\n    }\n  }\n});\n```\n\n<h2 id=\"direct\">Direct Cache Access</h2>\n\nTo interact directly with your cache, you can use the Apollo Client class methods readQuery, readFragment, writeQuery, and writeFragment. These methods are available to us via the [`DataProxy` interface](https://github.com/apollographql/apollo-client/blob/master/packages/apollo-cache/src/types/DataProxy.ts). Accessing these methods will vary slightly based on your view layer implementation. If you are using React, you can wrap your component in the `withApollo` higher order component, which will give you access to `this.props.client`. From there, you can use the methods to control your data.\n\nAny code demonstration in the following sections will assume that we have already initialized an instance of  `ApolloClient` and that we have imported the `gql` tag from `graphql-tag`.\n\n<h3 id=\"readquery\">readQuery</h3>\n\nThe `readQuery` method is very similar to the [`query` method on `ApolloClient`][] except that `readQuery` will _never_ make a request to your GraphQL server. The `query` method, on the other hand, may send a request to your server if the appropriate data is not in your cache whereas `readQuery` will throw an error if the data is not in your cache. `readQuery` will _always_ read from the cache. You can use `readQuery` by giving it a GraphQL query like so:\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo {\n      todo(id: 5) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n});\n```\n\nIf all of the data needed to fulfill this read is in Apollo Client’s normalized data cache then a data object will be returned in the shape of the query you wanted to read. If not all of the data needed to fulfill this read is in Apollo Client’s cache then an error will be thrown instead, so make sure to only read data that you know you have!\n\nYou can also pass variables into `readQuery`.\n\n```js\nconst { todo } = client.readQuery({\n  query: gql`\n    query ReadTodo($id: Int!) {\n      todo(id: $id) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n  variables: {\n    id: 5,\n  },\n});\n```\n\n<h3 id=\"readfragment\">readFragment</h3>\n\nThis method allows you great flexibility around the data in your cache. Whereas `readQuery` only allowed you to read data from your root query type, `readFragment` allows you to read data from _any node you have queried_. This is incredibly powerful. You use this method as follows:\n\n```js\nconst todo = client.readFragment({\n  id: ..., // `id` is any id that could be returned by `dataIdFromObject`.\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\nThe first argument is the id of the data you want to read from the cache. That id must be a value that was returned by the `dataIdFromObject` function you defined when initializing `ApolloClient`. So for example if you initialized `ApolloClient` like so:\n\n```js\nconst client = new ApolloClient({\n  ...,\n  dataIdFromObject: object => object.id,\n});\n```\n\n…and you requested a todo before with an id of `5`, then you can read that todo out of your cache with the following:\n\n```js\nconst todo = client.readFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\n> **Note:** Most people add a `__typename` to the id in `dataIdFromObject`. If you do this then don’t forget to add the `__typename` when you are reading a fragment as well. So for example your id may be `Todo_5` and not just `5`.\n\nIf a todo with that id does not exist in the cache you will get `null` back. If a todo of that id does exist in the cache, but that todo does not have the `text` field then an error will be thrown.\n\nThe beauty of `readFragment` is that the todo could have come from anywhere! The todo could have been selected as a singleton (`{ todo(id: 5) { ... } }`), the todo could have come from a list of todos (`{ todos { ... } }`), or the todo could have come from a mutation (`mutation { createTodo { ... } }`). As long as at some point your GraphQL server gave you a todo with the provided id and fields `id`, `text`, and `completed` you can read it from the cache at any part of your code.\n\n<h3 id=\"writequery-and-writefragment\">writeQuery` and `writeFragment</h3>\n\nNot only can you read arbitrary data from the Apollo Client cache, but you can also write any data that you would like to the cache. The methods you use to do this are `writeQuery` and `writeFragment`. They will allow you to change data in your local cache, but it is important to remember that *they will not change any data on your server*. If you reload your environment then changes made with `writeQuery` and `writeFragment` will disappear.\n\nThese methods have the same signature as their `readQuery` and `readFragment` counterparts except they also require an additional `data` variable. So for example, if you wanted to update the `completed` flag locally for your todo with id `'5'` you could execute the following:\n\n```js\nclient.writeFragment({\n  id: '5',\n  fragment: gql`\n    fragment myTodo on Todo {\n      completed\n    }\n  `,\n  data: {\n    completed: true,\n  },\n});\n```\n\nAny subscriber to the Apollo Client store will instantly see this update and render new UI accordingly.\n\n> **Note:** Again, remember that using `writeQuery` or `writeFragment` only changes data *locally*. If you reload your environment then changes made with these methods will no longer exist.\n\nOr if you wanted to add a new todo to a list fetched from the server, you could use `readQuery` and `writeQuery` together.\n\n```js\nconst query = gql`\n  query MyTodoAppQuery {\n    todos {\n      id\n      text\n      completed\n    }\n  }\n`;\n\nconst data = client.readQuery({ query });\n\nconst myNewTodo = {\n  id: '6',\n  text: 'Start using Apollo Client.',\n  completed: false,\n};\n\nclient.writeQuery({\n  query,\n  data: {\n    todos: [...data.todos, myNewTodo],\n  },\n});\n```\n\n<h2 id=\"recipes\">Recipes</h2>\n\nHere are some common situations where you would need to access the cache directly. If you're manipulating the cache in an interesting way and would like your example to be featured, please send in a pull request!\n\n<h3 id=\"server\">Server side rendering</h3>\n\nFirst, you will need to initialize an `InMemoryCache` on the server and create an instance of `ApolloClient`. In the initial serialized HTML payload from the server, you should include a script tag that extracts the data from the cache.\n\n```js\n`<script>\n  window.__APOLLO_STATE__=${JSON.stringify(cache.extract())}\n</script>`\n```\n\nOn the client, you can rehydrate the cache using the initial data passed from the server:\n\n```js\ncache: new Cache().restore(window.__APOLLO_STATE__)\n```\n\nIf you would like to learn more about server side rendering, please check our our more in depth guide [here].\n<!---\nTODO (PEGGY): Add link to SSR\n-->\n\n<h3 id=\"server\">Updating the cache after a mutation</h3>\n\nBeing able to read and write to the Apollo cache from anywhere in your application gives you a lot of power over your data. However, there is one place where we most often want to update our cached data: after a mutation. As such, Apollo Client has optimized the experience for updating your cache with the read and write methods after a mutation with the `update` function. Let us say that we have the following GraphQL mutation:\n\n```graphql\nmutation TodoCreateMutation($text: String!) {\n  createTodo(text: $text) {\n    id\n    text\n    completed\n  }\n}\n```\n\nWe may also have the following GraphQL query:\n\n```graphql\nquery TodoAppQuery {\n  todos {\n    id\n    text\n    completed\n  }\n}\n```\n\nAt the end of our mutation we want our query to include the new todo like we had sent our `TodoAppQuery` a second time after the mutation finished without actually sending the query. To do this we can use the `update` function provided as an option of the `client.mutate` method. To update your cache with the mutation just write code that looks like:\n\n```js\n// We assume that the GraphQL operations `TodoCreateMutation` and\n// `TodoAppQuery` have already been defined using the `gql` tag.\n\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    // Read the data from our cache for this query.\n    const data = proxy.readQuery({ query: TodoAppQuery });\n\n    // Add our todo from the mutation to the end.\n    data.todos.push(createTodo);\n\n    // Write our data back to the cache.\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nThe first `proxy` argument is an instance of [`DataProxy`][] has the same four methods that we just learned exist on the Apollo Client: `readQuery`, `readFragment`, `writeQuery`, and `writeFragment`. The reason we call them on a `proxy` object here instead of on our `client` instance is that we can easily apply optimistic updates (which we will demonstrate in a bit). The `proxy` object also provides an isolated transaction which shields you from any other mutations going on at the same time, and the `proxy` object also batches writes together until the very end.\n\nIf you provide an `optimisticResponse` option to the mutation then the `update` function will be run twice. Once immediately after you call `client.mutate` with the data from `optimisticResponse`. After the mutation successfully executes against the server the changes made in the first call to `update` will be rolled back and `update` will be called with the *actual* data returned by the mutation and not just the optimistic response.\n\nPutting it all together:\n\n```js\nconst text = 'Hello, world!';\n\nclient.mutate({\n  mutation: TodoCreateMutation,\n  variables: {\n    text,\n  },\n  optimisticResponse: {\n    id: -1, // -1 is a temporary id for the optimistic response.\n    text,\n    completed: false,\n  },\n  update: (proxy, { data: { createTodo } }) => {\n    const data = proxy.readQuery({ query: TodoAppQuery });\n    data.todos.push(createTodo);\n    proxy.writeQuery({ query: TodoAppQuery, data });\n  },\n});\n```\n\nAs you can see the `update` function on `client.mutate` provides extra change management functionality specific to the use case of a mutation while still providing you the powerful data control APIs that are available on `client`.\n\nThe `update` function is not a good place for side-effects as it may be called multiple times. Also, you may not call any of the methods on `proxy` asynchronously.\n\n",
  "maintainers": [
    {
      "email": "npm@apollographql.com",
      "name": "apollo-bot"
    },
    {
      "email": "ben@benjamn.com",
      "name": "benjamn"
    },
    {
      "email": "james@meteor.com",
      "name": "jbaxleyiii"
    },
    {
      "email": "peggyrayzis@gmail.com",
      "name": "peggyrayzis"
    }
  ],
  "time": {
    "modified": "2022-04-11T14:43:10.793Z",
    "created": "2017-08-11T19:39:52.591Z",
    "0.1.0-0": "2017-08-11T19:39:52.591Z",
    "0.1.0-1": "2017-08-11T19:41:20.550Z",
    "0.2.0-alpha.2": "2017-09-04T03:43:14.726Z",
    "0.2.0-alpha.3": "2017-09-05T15:39:49.839Z",
    "0.2.0-alpha.4": "2017-09-07T03:44:24.708Z",
    "0.2.0-alpha.5": "2017-09-08T04:24:59.971Z",
    "0.2.0-alpha.6": "2017-09-08T17:33:39.397Z",
    "0.2.0-alpha.7": "2017-09-09T00:30:26.944Z",
    "0.2.0-alpha.8": "2017-09-12T02:50:10.246Z",
    "0.2.0-alpha.9": "2017-09-12T04:07:40.422Z",
    "0.2.0-alpha.12": "2017-09-12T16:03:58.411Z",
    "0.2.0-alpha.13": "2017-09-13T00:02:04.920Z",
    "0.2.0-beta.0": "2017-09-13T15:09:53.227Z",
    "0.2.0-beta.1": "2017-09-21T12:42:16.542Z",
    "0.2.0-beta.2": "2017-09-26T14:10:48.153Z",
    "0.2.0-beta.3": "2017-09-28T20:48:50.460Z",
    "0.2.0-beta.4": "2017-10-03T18:43:29.276Z",
    "0.2.0-beta.5": "2017-10-11T02:10:42.777Z",
    "0.2.0-beta.6": "2017-10-11T08:01:21.864Z",
    "0.2.0-rc.0": "2017-10-11T08:10:09.639Z",
    "0.2.0-rc.1": "2017-10-13T21:04:24.895Z",
    "0.2.0-rc.2": "2017-10-20T00:05:20.317Z",
    "0.2.0-rc.3": "2017-10-20T14:26:38.358Z",
    "0.2.0-rc.4": "2017-10-24T05:27:36.830Z",
    "1.0.0": "2017-10-24T18:52:26.000Z",
    "1.1.0-beta.0": "2017-11-01T14:29:03.642Z",
    "1.1.0-beta.1": "2017-11-01T14:31:12.455Z",
    "1.1.0": "2017-11-06T15:58:20.578Z",
    "1.1.1": "2017-11-16T02:57:38.009Z",
    "1.1.2": "2017-11-30T19:03:29.912Z",
    "1.1.3": "2017-12-06T13:10:01.576Z",
    "1.1.4": "2017-12-08T15:31:18.959Z",
    "1.1.5": "2018-01-05T20:35:18.018Z",
    "1.1.6": "2018-01-29T17:31:34.540Z",
    "1.1.7": "2018-02-02T16:00:29.047Z",
    "1.1.8": "2018-02-14T20:16:33.433Z",
    "1.1.9": "2018-02-14T23:56:24.086Z",
    "1.1.10": "2018-03-06T17:02:22.847Z",
    "1.1.11": "2018-03-13T17:27:28.493Z",
    "1.1.12": "2018-03-26T13:36:06.526Z",
    "1.2.0": "2018-05-02T18:27:22.184Z",
    "1.2.1": "2018-05-04T21:55:02.007Z",
    "1.2.2": "2018-05-30T02:05:34.988Z",
    "1.3.0-beta.0": "2018-06-12T16:31:12.659Z",
    "1.2.3": "2018-06-13T10:36:31.649Z",
    "1.2.4": "2018-06-14T02:08:18.069Z",
    "1.3.0-beta.1": "2018-06-15T14:02:19.876Z",
    "1.3.0-beta.2": "2018-06-15T20:39:02.003Z",
    "1.2.5": "2018-06-20T01:27:05.814Z",
    "1.3.0-beta.3": "2018-06-20T23:08:07.493Z",
    "1.3.0-beta.4": "2018-07-05T18:27:05.787Z",
    "1.3.0-beta.5": "2018-07-18T00:26:51.668Z",
    "1.2.6-alpha.1": "2018-07-19T17:29:48.178Z",
    "1.2.6-alpha.2": "2018-07-23T13:57:03.172Z",
    "1.2.6": "2018-07-24T19:39:47.942Z",
    "1.2.6-alpha.3": "2018-07-24T21:28:08.267Z",
    "1.2.6-alpha.4": "2018-07-25T00:44:26.296Z",
    "1.2.6-alpha.5": "2018-07-25T04:40:16.088Z",
    "1.2.6-alpha.6": "2018-07-25T05:13:49.609Z",
    "1.2.6-alpha.7": "2018-07-25T05:27:04.436Z",
    "1.2.6-alpha.8": "2018-07-25T18:16:59.378Z",
    "1.2.6-alpha.9": "2018-07-25T18:50:21.825Z",
    "1.2.6-alpha.10": "2018-07-25T19:08:11.904Z",
    "1.2.6-alpha.12": "2018-07-27T01:23:45.552Z",
    "1.3.0-beta.6": "2018-07-27T20:23:28.437Z",
    "1.2.6-alpha.13": "2018-07-31T08:06:06.007Z",
    "1.3.0-beta.7": "2018-08-07T23:32:31.606Z",
    "1.2.6-alpha.14": "2018-08-08T02:18:58.410Z",
    "1.2.7": "2018-08-09T12:10:30.593Z",
    "1.2.8": "2018-08-17T14:00:57.015Z",
    "1.3.0-verify.1": "2018-08-17T16:42:39.169Z",
    "1.3.0-verify.2": "2018-08-17T17:09:48.571Z",
    "1.3.0-verify.3": "2018-08-17T18:11:24.748Z",
    "1.3.0-verify.4": "2018-08-17T18:43:41.744Z",
    "1.2.9": "2018-08-26T16:30:44.362Z",
    "1.3.0-beta.8": "2018-09-11T22:46:50.664Z",
    "1.3.0-beta.9": "2018-09-11T22:52:49.780Z",
    "1.3.0-beta.10": "2018-09-12T00:32:41.777Z",
    "1.2.10": "2018-09-12T09:38:19.925Z",
    "1.3.0-beta.11": "2018-09-14T18:23:08.270Z",
    "1.3.0-beta.12": "2018-09-14T19:01:16.640Z",
    "1.3.0-beta.13": "2018-09-14T19:05:07.848Z",
    "1.3.0-beta.14": "2018-09-20T13:57:36.661Z",
    "1.3.0-beta.15": "2018-09-27T15:05:27.334Z",
    "1.3.0": "2018-09-28T16:40:04.056Z",
    "1.3.1": "2018-10-01T16:29:16.326Z",
    "1.3.2": "2018-10-01T16:33:39.442Z",
    "1.3.3": "2018-10-03T00:18:07.798Z",
    "1.3.4": "2018-10-03T15:36:20.167Z",
    "1.3.1-local-state-alpha.0": "2018-10-04T17:24:34.747Z",
    "1.3.1-local-state-alpha.1": "2018-10-04T17:39:59.298Z",
    "1.3.1-local-state-alpha.2": "2018-10-05T02:48:03.885Z",
    "1.3.1-local-state-alpha.3": "2018-10-05T13:39:58.141Z",
    "1.3.1-local-state-alpha.4": "2018-10-05T13:52:38.886Z",
    "1.3.1-local-state-alpha.5": "2018-10-05T19:29:29.210Z",
    "1.3.5": "2018-10-05T19:46:46.211Z",
    "1.3.1-local-state-alpha.6": "2018-10-07T15:44:50.884Z",
    "1.3.1-local-state-alpha.7": "2018-10-09T18:53:24.320Z",
    "1.3.1-local-state-alpha.8": "2018-10-09T20:33:22.815Z",
    "1.3.1-local-state-alpha.9": "2018-10-19T18:57:14.827Z",
    "1.3.6": "2018-10-22T22:54:44.388Z",
    "1.3.1-local-state-alpha.10": "2018-10-23T15:26:31.674Z",
    "1.3.1-local-state-alpha.11": "2018-10-25T18:31:06.226Z",
    "1.3.1-local-state-alpha.12": "2018-10-26T13:07:25.027Z",
    "1.3.7": "2018-10-26T17:39:37.372Z",
    "1.3.8": "2018-10-30T15:24:42.083Z",
    "1.3.9-beta.0": "2018-11-02T01:38:01.195Z",
    "1.3.9-beta.1": "2018-11-02T01:40:04.729Z",
    "1.3.9": "2018-11-03T20:51:02.695Z",
    "1.3.1-local-state-alpha.13": "2018-11-06T00:24:13.937Z",
    "1.3.1-local-state-alpha.14": "2018-11-06T18:51:04.136Z",
    "1.4.0-alpha.1": "2018-11-06T23:38:40.969Z",
    "1.3.10": "2018-11-16T22:26:28.440Z",
    "1.3.11": "2018-11-21T18:14:06.308Z",
    "1.4.0-alpha.2": "2018-12-11T01:29:38.384Z",
    "1.3.12-beta.0": "2018-12-19T16:46:52.030Z",
    "1.3.12-beta.1": "2018-12-19T18:54:05.535Z",
    "1.3.12": "2018-12-19T19:38:14.821Z",
    "1.4.0-alpha.3": "2019-01-14T01:19:56.108Z",
    "1.4.0-alpha.4": "2019-01-14T01:39:56.227Z",
    "1.4.0-alpha.5": "2019-01-14T01:44:23.714Z",
    "1.4.0-alpha.7": "2019-01-14T01:55:58.528Z",
    "1.4.0-alpha.8": "2019-01-14T14:44:06.413Z",
    "1.4.0-alpha.10": "2019-01-14T16:14:41.615Z",
    "1.4.0-alpha.11": "2019-01-14T16:26:39.334Z",
    "1.4.0-alpha.12": "2019-01-14T17:26:17.184Z",
    "1.4.0": "2019-01-17T20:18:26.850Z",
    "1.4.1": "2019-01-18T17:26:01.524Z",
    "1.4.2": "2019-01-18T22:17:57.154Z",
    "1.5.0-beta.0": "2019-02-01T17:22:30.253Z",
    "1.5.0-beta.1": "2019-02-07T19:23:44.733Z",
    "1.4.3": "2019-02-13T18:08:10.631Z",
    "1.5.0-rc.0": "2019-02-21T19:27:37.953Z",
    "1.5.0-rc.1": "2019-02-21T20:20:33.391Z",
    "1.5.0-rc.2": "2019-02-25T12:30:56.009Z",
    "1.5.0": "2019-02-26T19:41:09.036Z",
    "1.5.1": "2019-02-27T14:02:34.483Z",
    "1.6.0-beta.0": "2019-03-15T16:33:25.924Z",
    "1.6.0-beta.1": "2019-03-22T17:57:05.181Z",
    "1.6.0-beta.4": "2019-04-08T16:56:34.674Z",
    "1.6.0-beta.5": "2019-04-16T19:25:15.365Z",
    "1.6.0-beta.6": "2019-04-23T16:04:08.290Z",
    "1.6.0-rc.1": "2019-05-06T23:14:16.264Z",
    "1.6.0-rc.2": "2019-05-10T18:24:04.384Z",
    "1.6.0": "2019-05-21T19:23:43.406Z",
    "1.6.1": "2019-06-04T15:45:19.114Z",
    "1.6.2": "2019-06-06T14:45:10.727Z",
    "1.6.3": "2019-08-10T16:23:51.718Z",
    "1.6.5": "2019-12-14T11:44:28.051Z",
    "1.6.6": "2020-05-09T10:55:09.026Z"
  },
  "homepage": "https://github.com/apollographql/apollo-client#readme",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/apollographql/apollo-client.git"
  },
  "contributors": [
    {
      "name": "James Baxley",
      "email": "james@meteor.com"
    },
    {
      "name": "Jonas Helfer",
      "email": "jonas@helfer.email"
    },
    {
      "name": "Sashko Stubailo",
      "email": "sashko@stubailo.com"
    },
    {
      "name": "James Burgess",
      "email": "jamesmillerburgess@gmail.com"
    },
    {
      "name": "Bazyli Brzóska",
      "email": "bazyli.brzoska@gmail.com"
    }
  ],
  "author": {
    "name": "James Baxley",
    "email": "james@meteor.com"
  },
  "bugs": {
    "url": "https://github.com/apollographql/apollo-client/issues"
  },
  "license": "MIT",
  "readmeFilename": "README.md"
}