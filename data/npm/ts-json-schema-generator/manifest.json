{
  "_id": "ts-json-schema-generator",
  "_rev": "238-86fc4b693c5b093294a3eab1cf924be9",
  "name": "ts-json-schema-generator",
  "description": "Generate JSON schema from your Typescript sources",
  "dist-tags": {
    "latest": "1.5.0",
    "canary": "1.5.1--canary.1846.9f69a47.0",
    "next": "1.5.1-next.0"
  },
  "versions": {
    "0.9.0": {
      "name": "ts-json-schema-generator",
      "version": "0.9.0",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "./bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "licenses": [
        {
          "type": "MIT",
          "url": "http://www.opensource.org/licenses/mit-license.php"
        }
      ],
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=6.0.0"
      },
      "dependencies": {
        "commander": "~2.11.0",
        "glob": "~7.1.2",
        "json-stable-stringify": "^1.0.1",
        "ts-node": "^3.3.0",
        "typescript": "~2.5.2"
      },
      "devDependencies": {
        "@types/assertion-error": "^1.0.30",
        "@types/chai": "^4.0.4",
        "@types/commander": "^2.9.2",
        "@types/glob": "^5.0.32",
        "@types/json-stable-stringify": "^1.0.32",
        "@types/mocha": "^2.2.42",
        "@types/node": "^8.0.26",
        "ajv": "~5.2.2",
        "chai": "~4.1.2",
        "mocha": "~3.5.0",
        "source-map-support": "~0.4.17",
        "tslint": "~5.7.0"
      },
      "scripts": {
        "prepublish": "npm run build",
        "preversion": "npm run lint && npm run test",
        "build": "tsc -p .",
        "watch": "tsc -p . -w",
        "lint": "tslint --project tsconfig.json -c tslint.json --type-check",
        "test": "tsc -p . && mocha -t 10000 --require source-map-support/register dist/test",
        "debug": "ts-node --inspect=19248 --debug-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts"
      },
      "gitHead": "b4e27411bc2fc536ebd297cd052406877c52f7c3",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.9.0",
      "_npmVersion": "5.4.0",
      "_nodeVersion": "8.2.1",
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "dist": {
        "integrity": "sha512-2xLoc/v+2U/VeMl1dRijX/ib5BmJhtbdaoUxh/xBvNFC+iK7kbj9U09mBqsB0L7S9jceYwE+8zd+5P6PsYNMRw==",
        "shasum": "09f56161821b01feeb0ff6550d5356688ecc9066",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.9.0.tgz",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEQCIE/jZ380rOggbweRcIi5MB/W4t6YHOm62lpWgQZyKeE5AiB5/sU5pVVr4XsoVSNwyrz8QZfSmfe6+/mgzt5Qyo2Q3g=="
          }
        ]
      },
      "maintainers": [
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator-0.9.0.tgz_1504634186637_0.1061656316742301"
      },
      "directories": {}
    },
    "0.10.0": {
      "name": "ts-json-schema-generator",
      "version": "0.10.0",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "./bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "licenses": [
        {
          "type": "MIT",
          "url": "http://www.opensource.org/licenses/mit-license.php"
        }
      ],
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=6.0.0"
      },
      "dependencies": {
        "commander": "~2.11.0",
        "glob": "~7.1.2",
        "json-stable-stringify": "^1.0.1",
        "ts-node": "^3.3.0",
        "typescript": "~2.5.2"
      },
      "devDependencies": {
        "@types/assertion-error": "^1.0.30",
        "@types/chai": "^4.0.4",
        "@types/commander": "^2.9.2",
        "@types/glob": "^5.0.32",
        "@types/json-stable-stringify": "^1.0.32",
        "@types/mocha": "^2.2.42",
        "@types/node": "^8.0.26",
        "ajv": "~5.2.2",
        "chai": "~4.1.2",
        "mocha": "~3.5.0",
        "source-map-support": "~0.4.17",
        "tslint": "~5.7.0"
      },
      "scripts": {
        "prepublish": "npm run build",
        "preversion": "npm run lint && npm run test",
        "build": "tsc -p .",
        "watch": "tsc -p . -w",
        "lint": "tslint --project tsconfig.json -c tslint.json --type-check",
        "test": "tsc -p . && mocha -t 10000 --require source-map-support/register dist/test",
        "debug": "ts-node --inspect=19248 --debug-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts"
      },
      "gitHead": "7c270ca503b99fb66ef18f69cf134307a7acd57d",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.10.0",
      "_npmVersion": "5.4.0",
      "_nodeVersion": "8.2.1",
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "dist": {
        "integrity": "sha512-BgD5HXCvzEmavBZT/Ik3eLPi+gHMp4NNHgiLw7rKWlSkcDrFEkoB3WkFDjvOiLxFXHHlCi+tojNeNSsoYwZRWw==",
        "shasum": "6c7e702252f35abd097e34ffa5356fe4410ea7b4",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.10.0.tgz",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEQCIEkToMnESe5IYBItPKBbU1lXa4i9X+uFFJY6VTRx3kP/AiBuNGonqles8ytTOdp8MzY73oBpCxfFRKUQ1uCyrn/64A=="
          }
        ]
      },
      "maintainers": [
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator-0.10.0.tgz_1504636532090_0.32101606181822717"
      },
      "directories": {}
    },
    "0.11.0": {
      "name": "ts-json-schema-generator",
      "version": "0.11.0",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "./bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "licenses": [
        {
          "type": "MIT",
          "url": "http://www.opensource.org/licenses/mit-license.php"
        }
      ],
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=6.0.0"
      },
      "dependencies": {
        "commander": "~2.11.0",
        "glob": "~7.1.2",
        "json-stable-stringify": "^1.0.1",
        "ts-node": "^3.3.0",
        "typescript": "~2.5.2"
      },
      "devDependencies": {
        "@types/assertion-error": "^1.0.30",
        "@types/chai": "^4.0.4",
        "@types/commander": "^2.9.2",
        "@types/glob": "^5.0.32",
        "@types/json-stable-stringify": "^1.0.32",
        "@types/mocha": "^2.2.42",
        "@types/node": "^8.0.26",
        "ajv": "~5.2.2",
        "chai": "~4.1.2",
        "mocha": "~3.5.0",
        "source-map-support": "~0.4.17",
        "tslint": "~5.7.0"
      },
      "scripts": {
        "prepublish": "npm run build",
        "preversion": "npm run lint && npm run test",
        "build": "tsc -p .",
        "watch": "tsc -p . -w",
        "lint": "tslint --project tsconfig.json -c tslint.json --type-check",
        "test": "tsc -p . && mocha -t 10000 --require source-map-support/register dist/test",
        "debug": "ts-node --inspect=19248 --debug-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts"
      },
      "gitHead": "810fbad051b012142f03ccecd29531d3a8594cd0",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.11.0",
      "_npmVersion": "5.4.0",
      "_nodeVersion": "8.2.1",
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "dist": {
        "integrity": "sha512-OewKoL8OeuXLhfctCUTeZ3gzYNL91kfxP15dF/Kqils6mmz/pUMl6hW5arZa9OBRtLFAMdTOEwgbC9ikX+43oA==",
        "shasum": "ba3a5476e2d840f706576feab233b3e6e990237e",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.11.0.tgz",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEYCIQC3h7V2aofnIGPnEuMJD4zTgJmM357/4ljDLDd35pQylAIhANumpXDijQNGoWvH6US3CAyrJQOBx8KQ7hm2/m5VkAQb"
          }
        ]
      },
      "maintainers": [
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator-0.11.0.tgz_1504645689949_0.013751353602856398"
      },
      "directories": {}
    },
    "0.12.0": {
      "name": "ts-json-schema-generator",
      "version": "0.12.0",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "./bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "licenses": [
        {
          "type": "MIT",
          "url": "http://www.opensource.org/licenses/mit-license.php"
        }
      ],
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=6.0.0"
      },
      "dependencies": {
        "commander": "~2.11.0",
        "glob": "~7.1.2",
        "json-stable-stringify": "^1.0.1",
        "ts-node": "^3.3.0",
        "typescript": "~2.5.2"
      },
      "devDependencies": {
        "@types/assertion-error": "^1.0.30",
        "@types/chai": "^4.0.4",
        "@types/commander": "^2.9.2",
        "@types/glob": "^5.0.32",
        "@types/json-stable-stringify": "^1.0.32",
        "@types/mocha": "^2.2.42",
        "@types/node": "^8.0.27",
        "ajv": "~5.2.2",
        "chai": "~4.1.2",
        "mocha": "~3.5.0",
        "source-map-support": "~0.4.17",
        "tslint": "~5.7.0"
      },
      "scripts": {
        "prepublish": "npm run build",
        "preversion": "npm run lint && npm run test",
        "build": "tsc -p .",
        "watch": "tsc -p . -w",
        "lint": "tslint --project tsconfig.json -c tslint.json --type-check",
        "test": "tsc -p . && mocha -t 10000 --require source-map-support/register dist/test",
        "debug": "ts-node --inspect=19248 --debug-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts"
      },
      "gitHead": "a963280ef7ff782e1f9829f2e4b5d2e4c17a5a9c",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.12.0",
      "_npmVersion": "5.4.0",
      "_nodeVersion": "8.2.1",
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "dist": {
        "integrity": "sha512-SV50FJoLq73d9zkVcPde97QNNjAiHlaRXYckBDcaHKx4BKk/0N2yUMSh0zgP5oGdjH+IQoQHSxAB8J/OedwNEA==",
        "shasum": "e36189a38cf5c4551f95f0b93d0cf46f708fa7ad",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.12.0.tgz",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEQCID93AxHtrovhfgmaEmU5QRpgr+Zk8uxDXuF52q0PEQcrAiBTfwGnj6xvwTLBvNbi4MAcp0t71ByPBp76Yg+OLHDmPQ=="
          }
        ]
      },
      "maintainers": [
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator-0.12.0.tgz_1504846848805_0.2040094977710396"
      },
      "directories": {}
    },
    "0.13.0": {
      "name": "ts-json-schema-generator",
      "version": "0.13.0",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "./bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "licenses": [
        {
          "type": "MIT",
          "url": "http://www.opensource.org/licenses/mit-license.php"
        }
      ],
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=6.0.0"
      },
      "dependencies": {
        "commander": "~2.11.0",
        "glob": "~7.1.2",
        "json-stable-stringify": "^1.0.1",
        "ts-node": "^3.3.0",
        "typescript": "~2.5.3"
      },
      "devDependencies": {
        "@types/assertion-error": "^1.0.30",
        "@types/chai": "^4.0.4",
        "@types/commander": "^2.11.0",
        "@types/glob": "^5.0.33",
        "@types/json-stable-stringify": "^1.0.32",
        "@types/mocha": "^2.2.43",
        "@types/node": "^8.0.41",
        "ajv": "~5.2.3",
        "chai": "~4.1.2",
        "mocha": "~4.0.1",
        "source-map-support": "~0.5.0",
        "tslint": "~5.7.0"
      },
      "scripts": {
        "prepublish": "npm run build",
        "preversion": "npm run lint && npm run test",
        "build": "tsc -p .",
        "watch": "tsc -p . -w",
        "lint": "tslint --project tsconfig.json -c tslint.json --type-check",
        "test": "tsc -p . && mocha -t 10000 --require source-map-support/register dist/test",
        "debug": "ts-node --inspect=19248 --debug-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts"
      },
      "gitHead": "0dabdac07d5cbc20643bf873dfd1f87712ab6cd8",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.13.0",
      "_npmVersion": "5.5.1",
      "_nodeVersion": "8.7.0",
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "dist": {
        "integrity": "sha512-DKS5r6gNyqZFGq1npwsXhRbq/s6oTKyZB+EJyeDL0vpwtjK9Xg9ZmHSkqzisPi0bUALfZBZavMYN+WlvAMKGVg==",
        "shasum": "58e474aa21bd130453c4e38e1349509629b8b150",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.13.0.tgz",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEQCICAg2yUHFXa5FLkvMhF3G7+iZYmGmwIW+Bh7Z+eZwffkAiBxRZ89x46L8jgQErW87ChzaQ0J24HfXZr9JttTnsLv2w=="
          }
        ]
      },
      "maintainers": [
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator-0.13.0.tgz_1508217841502_0.550029335077852"
      },
      "directories": {}
    },
    "0.14.0": {
      "name": "ts-json-schema-generator",
      "version": "0.14.0",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "./bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "licenses": [
        {
          "type": "MIT",
          "url": "http://www.opensource.org/licenses/mit-license.php"
        }
      ],
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=6.0.0"
      },
      "dependencies": {
        "commander": "~2.11.0",
        "glob": "~7.1.2",
        "json-stable-stringify": "^1.0.1",
        "ts-node": "^3.3.0",
        "typescript": "~2.5.3"
      },
      "devDependencies": {
        "@types/assertion-error": "^1.0.30",
        "@types/chai": "^4.0.4",
        "@types/commander": "^2.11.0",
        "@types/glob": "^5.0.33",
        "@types/json-stable-stringify": "^1.0.32",
        "@types/mocha": "^2.2.43",
        "@types/node": "^8.0.41",
        "ajv": "~5.2.3",
        "chai": "~4.1.2",
        "mocha": "~4.0.1",
        "source-map-support": "~0.5.0",
        "tslint": "~5.7.0"
      },
      "scripts": {
        "prepublish": "npm run build",
        "preversion": "npm run lint && npm run test",
        "build": "tsc -p .",
        "watch": "tsc -p . -w",
        "lint": "tslint --project tsconfig.json -c tslint.json --type-check",
        "test": "tsc -p . && mocha -t 10000 --require source-map-support/register dist/test",
        "debug": "ts-node --inspect=19248 --debug-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts"
      },
      "gitHead": "38a7d887f013013f37b4ac85e49ebeeda1652ea6",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.14.0",
      "_npmVersion": "5.5.1",
      "_nodeVersion": "8.7.0",
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "dist": {
        "integrity": "sha512-HznJsHC0dmExtkxtmV2IuRzGP+seXmroedEdFEOHx6UtQd5KoNcgrlj8AJMpsMDbWOPHwJfC+mnSBIlZlGn9eQ==",
        "shasum": "29c8fef5a4b273930081ed085080db15b5bd93a7",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.14.0.tgz",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEQCIHzZywb7fZ8bQ1K4J1gWS3K3/3/9jTZ2GKWoDeYl+wL5AiB4MahqVgg8wr6edVi/JOFuhKHCKxW8X5G1Lhl+cfgLIg=="
          }
        ]
      },
      "maintainers": [
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator-0.14.0.tgz_1508367021794_0.4480300419963896"
      },
      "directories": {}
    },
    "0.15.0": {
      "name": "ts-json-schema-generator",
      "version": "0.15.0",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "./bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "licenses": [
        {
          "type": "MIT",
          "url": "http://www.opensource.org/licenses/mit-license.php"
        }
      ],
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=6.0.0"
      },
      "dependencies": {
        "commander": "~2.11.0",
        "glob": "~7.1.2",
        "json-stable-stringify": "^1.0.1",
        "ts-node": "^3.3.0",
        "typescript": "~2.6.1"
      },
      "devDependencies": {
        "@types/assertion-error": "^1.0.30",
        "@types/chai": "^4.0.4",
        "@types/commander": "^2.11.0",
        "@types/glob": "^5.0.33",
        "@types/json-stable-stringify": "^1.0.32",
        "@types/mocha": "^2.2.44",
        "@types/node": "^8.0.47",
        "ajv": "~5.3.0",
        "chai": "~4.1.2",
        "mocha": "~4.0.1",
        "source-map-support": "~0.5.0",
        "tslint": "~5.8.0"
      },
      "scripts": {
        "prepublish": "npm run build",
        "preversion": "npm run lint && npm run test",
        "build": "tsc -p .",
        "watch": "tsc -p . -w",
        "lint": "tslint -p .",
        "test": "tsc -p . && mocha -t 10000 --require source-map-support/register dist/test",
        "debug": "ts-node --inspect=19248 --debug-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts"
      },
      "gitHead": "9df14a40a1ee3e211fc8d22c85503649ad5705ff",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.15.0",
      "_npmVersion": "5.5.1",
      "_nodeVersion": "8.9.0",
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "dist": {
        "integrity": "sha512-rhFzK7jb0rb5uH5QT+gtcnYoOqRmAF/mZaVIuKGaPqL2koH1eb0XNKFOykCr3KxwZLaZDGYss/mM2qwOgW8xvQ==",
        "shasum": "8bd1555d7c1190a3cd03831729b17dc16007cbdb",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.15.0.tgz",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEYCIQC2HBugN3rzmViXsvNXUq+aHmHzFf5RS79P0ununJzYugIhANUPCrEGrHx86Nd5wNM6GDuP1ls6+xYtTFuyYAsksiVs"
          }
        ]
      },
      "maintainers": [
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator-0.15.0.tgz_1509754709749_0.3189814502838999"
      },
      "directories": {}
    },
    "0.16.0": {
      "name": "ts-json-schema-generator",
      "version": "0.16.0",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "./bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "licenses": [
        {
          "type": "MIT",
          "url": "http://www.opensource.org/licenses/mit-license.php"
        }
      ],
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=6.0.0"
      },
      "dependencies": {
        "commander": "~2.11.0",
        "glob": "~7.1.2",
        "json-stable-stringify": "^1.0.1",
        "ts-node": "^3.3.0",
        "typescript": "~2.6.1"
      },
      "devDependencies": {
        "@types/assertion-error": "^1.0.30",
        "@types/chai": "^4.0.4",
        "@types/commander": "^2.11.0",
        "@types/glob": "^5.0.33",
        "@types/json-stable-stringify": "^1.0.32",
        "@types/mocha": "^2.2.44",
        "@types/node": "^8.0.47",
        "ajv": "~5.3.0",
        "chai": "~4.1.2",
        "mocha": "~4.0.1",
        "source-map-support": "~0.5.0",
        "tslint": "~5.8.0"
      },
      "scripts": {
        "prepublish": "npm run build",
        "preversion": "npm run lint && npm run test",
        "build": "tsc -p .",
        "watch": "tsc -p . -w",
        "lint": "tslint -p .",
        "test": "tsc -p . && mocha -t 10000 --require source-map-support/register dist/test",
        "debug": "ts-node --inspect=19248 --debug-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts"
      },
      "gitHead": "b1a0c2b4d42e85bfc2e8c81fd31f1621354b4b83",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.16.0",
      "_npmVersion": "5.5.1",
      "_nodeVersion": "8.9.0",
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "dist": {
        "integrity": "sha512-FLcHYhC77DLw2xZWPWAs13kQJH5AEGR7Q6czDxw6tkykwBXMojAE2NLZX4vO0TwPhCXInfN5FgaWkWlHRCVO4Q==",
        "shasum": "6eabb87dfc0fa5153c64363ddf2b49020e7b9716",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.16.0.tgz",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIQCMS1LgWfqS85Q/EnE6eKTRh9LyJ0EYdU7zHEXOzrT8sQIgDNgFgmjlYKl3pAaXlIepKO3S3TO17SKXIHR2icKPbWU="
          }
        ]
      },
      "maintainers": [
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator-0.16.0.tgz_1510185298588_0.6639068289659917"
      },
      "directories": {}
    },
    "0.18.0": {
      "name": "ts-json-schema-generator",
      "version": "0.18.0",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "./bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "licenses": [
        {
          "type": "MIT",
          "url": "http://www.opensource.org/licenses/mit-license.php"
        }
      ],
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=6.0.0"
      },
      "dependencies": {
        "commander": "~2.12.2",
        "glob": "~7.1.2",
        "json-stable-stringify": "^1.0.1",
        "ts-node": "^4.1.0",
        "typescript": "~2.6.2"
      },
      "devDependencies": {
        "@types/assertion-error": "^1.0.30",
        "@types/chai": "^4.0.10",
        "@types/glob": "^5.0.34",
        "@types/json-stable-stringify": "^1.0.32",
        "@types/mocha": "^2.2.45",
        "@types/node": "^8.5.2",
        "ajv": "~5.5.2",
        "chai": "~4.1.2",
        "mocha": "~4.1.0",
        "source-map-support": "~0.5.0",
        "tslint": "~5.8.0"
      },
      "scripts": {
        "prepublish": "npm run build",
        "preversion": "npm run lint && npm run test",
        "build": "tsc -p .",
        "watch": "tsc -p . -w",
        "lint": "tslint -p .",
        "test": "tsc -p . && mocha -t 10000 --require source-map-support/register --recursive dist/test",
        "debug": "ts-node --inspect=19248 --debug-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts"
      },
      "gitHead": "a7c86ecebc013e6f4ec64d36c650d4912a5ec520",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.18.0",
      "_npmVersion": "5.6.0",
      "_nodeVersion": "9.3.0",
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "dist": {
        "integrity": "sha512-AOrXe0DKYVkBaFfBVszH2R17ZC+sEv0RBv51URs9VyOEDmcnLQkCwgjQk6jz68AX/8rNoxvsteksTXuVkQAziQ==",
        "shasum": "4bd35ec83591b17455f019eda12aced841f68921",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.18.0.tgz",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEQCIHqHdPe/xtbr6n+lTbufKrQehaD4zVKSzRRvt8pA8ea9AiAXHk34tHKntigiij7SMqrV8tIXOXMeepq4SqL7sK+nPQ=="
          }
        ]
      },
      "maintainers": [
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator-0.18.0.tgz_1514676378394_0.7890631526242942"
      },
      "directories": {}
    },
    "0.19.0": {
      "name": "ts-json-schema-generator",
      "version": "0.19.0",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "./bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "licenses": [
        {
          "type": "MIT",
          "url": "http://www.opensource.org/licenses/mit-license.php"
        }
      ],
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=6.0.0"
      },
      "dependencies": {
        "commander": "~2.13.0",
        "glob": "~7.1.2",
        "json-stable-stringify": "^1.0.1",
        "ts-node": "^4.1.0",
        "typescript": "~2.7.1"
      },
      "devDependencies": {
        "@types/assertion-error": "^1.1.0",
        "@types/chai": "^4.1.2",
        "@types/glob": "^5.0.35",
        "@types/json-stable-stringify": "^1.0.32",
        "@types/mocha": "^2.2.48",
        "@types/node": "^9.4.0",
        "ajv": "~6.1.1",
        "chai": "~4.1.2",
        "mocha": "~5.0.0",
        "source-map-support": "~0.5.3",
        "tslint": "~5.9.1"
      },
      "scripts": {
        "prepublish": "npm run build",
        "preversion": "npm run lint && npm run test",
        "build": "tsc -p .",
        "watch": "tsc -p . -w",
        "lint": "tslint -p .",
        "test": "tsc -p . && mocha -t 10000 --require source-map-support/register --recursive dist/test",
        "debug": "ts-node --inspect=19248 --debug-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts"
      },
      "gitHead": "89490f0f0207241da4470dd812af0e6cd46abf29",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.19.0",
      "_npmVersion": "5.6.0",
      "_nodeVersion": "9.4.0",
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "dist": {
        "integrity": "sha512-8tsgg5HMUAP+AX+Fj8ljSois2rehC8SE9s0CtWuvpKl+qvMJ3lrd/BdH+yRnB6Jwb4/qc+ArqW/6ZwLOqF41ZQ==",
        "shasum": "e32cb1f5751bd62360f023659e95ad6ba827dce6",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.19.0.tgz",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIQDrstefXAcbJppCpgKKnAYmIVVOeyVuwHhOvvidSNLbxgIgB7JM1geFo5s2uieNBCzC5SlAZWT6bENpU9qyGlnFTcg="
          }
        ]
      },
      "maintainers": [
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator-0.19.0.tgz_1517438266224_0.44723125104792416"
      },
      "directories": {}
    },
    "0.20.0": {
      "name": "ts-json-schema-generator",
      "version": "0.20.0",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "./bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "licenses": [
        {
          "type": "MIT",
          "url": "http://www.opensource.org/licenses/mit-license.php"
        }
      ],
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=6.0.0"
      },
      "dependencies": {
        "commander": "~2.14.1",
        "glob": "~7.1.2",
        "json-stable-stringify": "^1.0.1",
        "ts-node": "^5.0.0",
        "typescript": "~2.7.2"
      },
      "devDependencies": {
        "@types/assertion-error": "^1.1.0",
        "@types/chai": "^4.1.2",
        "@types/glob": "^5.0.35",
        "@types/json-stable-stringify": "^1.0.32",
        "@types/mocha": "^2.2.48",
        "@types/node": "^9.4.6",
        "ajv": "~6.1.1",
        "chai": "~4.1.2",
        "mocha": "~5.0.1",
        "source-map-support": "~0.5.3",
        "tslint": "~5.9.1"
      },
      "scripts": {
        "prepublish": "npm run build",
        "preversion": "npm run lint && npm run test",
        "build": "tsc -p .",
        "watch": "tsc -p . -w",
        "lint": "tslint -p .",
        "test": "tsc -p . && mocha -t 10000 --require source-map-support/register --recursive dist/test",
        "debug": "ts-node --inspect=19248 --debug-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts"
      },
      "gitHead": "7537f97cb66b8ec8d403c55dacafc9136ced442c",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.20.0",
      "_npmVersion": "5.6.0",
      "_nodeVersion": "9.5.0",
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "dist": {
        "integrity": "sha512-n4I33WumVHUmqm+++MqD0Jb9aWLidblcWqsNbMPncsCQEw7YcBCVYBMaega6NLERfmic5USWClDX67ahAk4Frw==",
        "shasum": "844b8af0a8b62ef4d2aa3ad18e0b4c8db8967586",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.20.0.tgz",
        "fileCount": 313,
        "unpackedSize": 245743,
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIDYBKgHg7EhsafsLRqwA7bERQqxuIT2ESiKhVwF1PtlMAiEAkOhU/Ow3+IQq5y7puamfDjpHz+hO/neZbEftpo2KaY0="
          }
        ]
      },
      "maintainers": [
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.20.0_1519157131366_0.4463909911864028"
      },
      "_hasShrinkwrap": false
    },
    "0.21.0": {
      "name": "ts-json-schema-generator",
      "version": "0.21.0",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "./bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "licenses": [
        {
          "type": "MIT",
          "url": "http://www.opensource.org/licenses/mit-license.php"
        }
      ],
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=6.0.0"
      },
      "dependencies": {
        "commander": "~2.15.0",
        "glob": "~7.1.2",
        "json-stable-stringify": "^1.0.1",
        "ts-node": "^5.0.1",
        "typescript": "~2.7.2"
      },
      "devDependencies": {
        "@types/assertion-error": "^1.1.0",
        "@types/chai": "^4.1.2",
        "@types/glob": "^5.0.35",
        "@types/json-stable-stringify": "^1.0.32",
        "@types/mocha": "^2.2.48",
        "@types/node": "^9.4.7",
        "ajv": "~6.2.1",
        "chai": "~4.1.2",
        "mocha": "~5.0.4",
        "source-map-support": "~0.5.3",
        "tslint": "~5.9.1"
      },
      "scripts": {
        "prepublish": "npm run build",
        "preversion": "npm run lint && npm run test",
        "build": "tsc -p .",
        "watch": "tsc -p . -w",
        "lint": "tslint -p .",
        "test": "tsc -p . && mocha -t 10000 --require source-map-support/register --recursive dist/test",
        "debug": "ts-node --inspect=19248 --debug-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts"
      },
      "gitHead": "2752ecf36151bbf0610573ca3b8b8907f32b3858",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.21.0",
      "_npmVersion": "5.7.1",
      "_nodeVersion": "9.7.1",
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "dist": {
        "integrity": "sha512-qGsG+M4JEDCBtL0SjEuNBxae6G85VI4xA/oTy01w53N8f49ZIY4Y8R35XrDEqM441sAbknsF0TpIFJ76sA6oSw==",
        "shasum": "3ea36bb3c6a70b326c1141c3de7c8aff65e2b1c4",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.21.0.tgz",
        "fileCount": 314,
        "unpackedSize": 265285,
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEYCIQDMH7VaEP5D46YCYogY4prQWW+0WqkdxHjnNlVqmbsmvgIhAIZTSP70n9s8ue1l15KTlkZxTFv9IWL7urfs8s1+o454"
          }
        ]
      },
      "maintainers": [
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.21.0_1520705900551_0.1482560008334306"
      },
      "_hasShrinkwrap": false
    },
    "0.22.0": {
      "name": "ts-json-schema-generator",
      "version": "0.22.0",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "./bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "licenses": [
        {
          "type": "MIT",
          "url": "http://www.opensource.org/licenses/mit-license.php"
        }
      ],
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=6.0.0"
      },
      "dependencies": {
        "commander": "~2.15.1",
        "glob": "~7.1.2",
        "json-stable-stringify": "^1.0.1",
        "ts-node": "^5.0.1",
        "typescript": "~2.7.2"
      },
      "devDependencies": {
        "@types/assertion-error": "^1.1.0",
        "@types/chai": "^4.1.2",
        "@types/glob": "^5.0.35",
        "@types/json-stable-stringify": "^1.0.32",
        "@types/mocha": "^5.0.0",
        "@types/node": "^9.6.0",
        "ajv": "~6.4.0",
        "chai": "~4.1.2",
        "mocha": "~5.0.5",
        "source-map-support": "~0.5.4",
        "tslint": "~5.9.1"
      },
      "scripts": {
        "prepublish": "npm run build",
        "preversion": "npm run lint && npm run test",
        "build": "tsc -p .",
        "watch": "tsc -p . -w",
        "lint": "tslint -p .",
        "test": "tsc -p . && mocha -t 10000 --require source-map-support/register --recursive dist/test",
        "debug": "ts-node --inspect=19248 --debug-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts"
      },
      "gitHead": "34f7904a28be7794f40cee2a4e75562a9475263d",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.22.0",
      "_npmVersion": "5.7.1",
      "_nodeVersion": "9.8.0",
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "dist": {
        "integrity": "sha512-pyYp/mn8hbOdTux0B/7Owz4OVTjZdWnW77coX5kN+7RbOMlbON24FgY1RwnFoJEvQjDDhyabuRrB6UaU62OcRg==",
        "shasum": "977a43b67cf837b63eef345e73cf4adf8e27928c",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.22.0.tgz",
        "fileCount": 314,
        "unpackedSize": 266935,
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIC8CdTg7zKZYHsTXSaAdkLA3TlFmWuQgMhd/k+b7FaMOAiEAgaHnupM6ppjDaaLgFVNHm8wy16zRgnJfuF8ZH3x0Q20="
          }
        ]
      },
      "maintainers": [
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.22.0_1522346978101_0.3455344606975814"
      },
      "_hasShrinkwrap": false
    },
    "0.23.0": {
      "name": "ts-json-schema-generator",
      "version": "0.23.0",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "./bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "licenses": [
        {
          "type": "MIT",
          "url": "http://www.opensource.org/licenses/mit-license.php"
        }
      ],
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=6.0.0"
      },
      "dependencies": {
        "commander": "~2.15.1",
        "glob": "~7.1.2",
        "json-stable-stringify": "^1.0.1",
        "ts-node": "^5.0.1",
        "typescript": "~2.7.2"
      },
      "devDependencies": {
        "@types/assertion-error": "^1.1.0",
        "@types/chai": "^4.1.2",
        "@types/glob": "^5.0.35",
        "@types/json-stable-stringify": "^1.0.32",
        "@types/mocha": "^5.0.0",
        "@types/node": "^9.6.0",
        "ajv": "~6.4.0",
        "chai": "~4.1.2",
        "mocha": "~5.0.5",
        "source-map-support": "~0.5.4",
        "tslint": "~5.9.1"
      },
      "scripts": {
        "prepublish": "npm run build",
        "preversion": "npm run lint && npm run test",
        "build": "tsc -p .",
        "watch": "tsc -p . -w",
        "lint": "tslint -p .",
        "test": "tsc -p . && mocha -t 10000 --require source-map-support/register --recursive dist/test",
        "debug": "ts-node --inspect=19248 --debug-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts"
      },
      "gitHead": "0228fd7a4fdb44563091ce1b751686a5e83310f5",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.23.0",
      "_npmVersion": "5.7.1",
      "_nodeVersion": "9.8.0",
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "dist": {
        "integrity": "sha512-tQjvPgl9MPAgbivt5ChjWneAhnm5K25Ll5vaG7nzmNfxm53Y+sKiSFoo4076qS+xNCiuZF/2E0EUL1WRBLfYPw==",
        "shasum": "c42fa98f9cea4a9ebd36c4e2f7f6b6833df1f6b1",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.23.0.tgz",
        "fileCount": 314,
        "unpackedSize": 266844,
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIDDnaIwN8nALwX+dmJ/fTkiYkeR71q7sCAgInJ6a0l/XAiEAwGY5cA0Sz4t1FFRQ6xUNxNY5/R1fMS89WTYuCpChbzs="
          }
        ]
      },
      "maintainers": [
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.23.0_1522347860190_0.8716854275688142"
      },
      "_hasShrinkwrap": false
    },
    "0.24.1": {
      "name": "ts-json-schema-generator",
      "version": "0.24.1",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "./bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "licenses": [
        {
          "type": "MIT",
          "url": "http://www.opensource.org/licenses/mit-license.php"
        }
      ],
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=6.0.0"
      },
      "dependencies": {
        "commander": "~2.15.1",
        "glob": "~7.1.2",
        "json-stable-stringify": "^1.0.1",
        "ts-node": "^5.0.1",
        "typescript": "~2.8.1"
      },
      "devDependencies": {
        "@types/assertion-error": "^1.1.0",
        "@types/chai": "^4.1.2",
        "@types/glob": "^5.0.35",
        "@types/json-stable-stringify": "^1.0.32",
        "@types/mocha": "^5.0.0",
        "@types/node": "^9.6.1",
        "ajv": "~6.4.0",
        "chai": "~4.1.2",
        "mocha": "~5.0.5",
        "source-map-support": "~0.5.4",
        "tslint": "~5.9.1"
      },
      "scripts": {
        "preversion": "npm run build",
        "build": "tsc -p .",
        "watch": "tsc -p . -w",
        "lint": "tslint -p .",
        "test": "tsc -p . && mocha -t 10000 --require source-map-support/register --recursive dist/test",
        "debug": "ts-node --inspect=19248 --debug-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts"
      },
      "gitHead": "220086618d4eece2a8d50b0e9e93d526c44c1552",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.24.1",
      "_npmVersion": "5.6.0",
      "_nodeVersion": "8.11.1",
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "dist": {
        "integrity": "sha512-t0z+0UODq5TMnIIZaElraDFr2EslBNE327OpmVsgUyTtpX6m/dMnuIN0H3Nmq68X5dZoaQZqmOh+onXb4IH0YQ==",
        "shasum": "78ff85173d8ec1e7e6e9c98a64e8873e13d71403",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.24.1.tgz",
        "fileCount": 5,
        "unpackedSize": 20996,
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIQD7vuvpufve0NVrxRWSDVbN1vjEZzeCRnYVXwKpUeRwJAIgNuaJfv0mK66n/7zOWWHFeStWWKlVSNoU9RaeK7vhbN4="
          }
        ]
      },
      "maintainers": [
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.24.1_1522542334423_0.9191743739266649"
      },
      "_hasShrinkwrap": false
    },
    "0.24.2": {
      "name": "ts-json-schema-generator",
      "version": "0.24.2",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "./bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "licenses": [
        {
          "type": "MIT",
          "url": "http://www.opensource.org/licenses/mit-license.php"
        }
      ],
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=6.0.0"
      },
      "dependencies": {
        "commander": "~2.15.1",
        "glob": "~7.1.2",
        "json-stable-stringify": "^1.0.1",
        "ts-node": "^5.0.1",
        "typescript": "~2.8.1"
      },
      "devDependencies": {
        "@types/assertion-error": "^1.1.0",
        "@types/chai": "^4.1.2",
        "@types/glob": "^5.0.35",
        "@types/json-stable-stringify": "^1.0.32",
        "@types/mocha": "^5.0.0",
        "@types/node": "^9.6.1",
        "ajv": "~6.4.0",
        "chai": "~4.1.2",
        "mocha": "~5.0.5",
        "source-map-support": "~0.5.4",
        "tslint": "~5.9.1"
      },
      "scripts": {
        "preversion": "npm run build",
        "build": "tsc -p .",
        "watch": "tsc -p . -w",
        "lint": "tslint -p .",
        "test": "tsc -p . && mocha -t 10000 --require source-map-support/register --recursive dist/test",
        "debug": "ts-node --inspect=19248 --debug-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts"
      },
      "gitHead": "b3adc2b4c89aab4da41bb11111a664d5b3aed3d8",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.24.2",
      "_shasum": "587a8b3564b8b3a9860d66b68f2141b3cd301b60",
      "_from": ".",
      "_npmVersion": "3.10.10",
      "_nodeVersion": "6.14.1",
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "dist": {
        "shasum": "587a8b3564b8b3a9860d66b68f2141b3cd301b60",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.24.2.tgz",
        "fileCount": 6,
        "unpackedSize": 21150,
        "integrity": "sha512-gE2cpxf6Wgr4ID3nHOwFiUgOQLtv30FpgU5D7FToSoPyzZcvy7z+yXRFXBFeNdrIStdzYoqEbXiZFaRQ/9xLKw==",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIGHsiG1fMQaZgWpoX2o736AIiy7HnbvKCeATTZfLXZJrAiEAgGfygJi+lFVcfrlp0kI7iN7jWsIMqi09Ulah/bXgow0="
          }
        ]
      },
      "maintainers": [
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.24.2_1522542466310_0.8217205854691716"
      },
      "_hasShrinkwrap": false
    },
    "0.24.3": {
      "name": "ts-json-schema-generator",
      "version": "0.24.3",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "./bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "licenses": [
        {
          "type": "MIT",
          "url": "http://www.opensource.org/licenses/mit-license.php"
        }
      ],
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=6.0.0"
      },
      "dependencies": {
        "commander": "~2.15.1",
        "glob": "~7.1.2",
        "json-stable-stringify": "^1.0.1",
        "ts-node": "^5.0.1",
        "typescript": "~2.8.1"
      },
      "devDependencies": {
        "@types/assertion-error": "^1.1.0",
        "@types/chai": "^4.1.2",
        "@types/glob": "^5.0.35",
        "@types/json-stable-stringify": "^1.0.32",
        "@types/mocha": "^5.0.0",
        "@types/node": "^9.6.1",
        "ajv": "~6.4.0",
        "chai": "~4.1.2",
        "mocha": "~5.0.5",
        "source-map-support": "~0.5.4",
        "tslint": "~5.9.1"
      },
      "scripts": {
        "preversion": "npm run lint",
        "predeploy": "npm run build",
        "build": "tsc -p .",
        "watch": "tsc -p . -w",
        "lint": "tslint -p .",
        "test": "tsc -p . && mocha -t 10000 --require source-map-support/register --recursive dist/test",
        "debug": "ts-node --inspect=19248 --debug-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts"
      },
      "gitHead": "4256196e9cdcedcc91a752c1e66c627fc56940cd",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.24.3",
      "_npmVersion": "5.6.0",
      "_nodeVersion": "8.11.1",
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "dist": {
        "integrity": "sha512-db3SrfK/wV9kffsLXrJI64XTJ60cCGKFJ0nTlNiawWgX4nekM4Jv8h898nDnn3rPMnidjh5MnaUerVRN3qkh/w==",
        "shasum": "0685f51b97079e4b48026a8a26d33ab9f5b604a1",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.24.3.tgz",
        "fileCount": 5,
        "unpackedSize": 21029,
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEQCIAXhGx2FeZZ9zw+rc350/pdbsNNVT2Auq+rtbhB7I66UAiBfWp9vwvmQi/4MRQyla/DYZ5RJEUjoidzf4OWJhyF7wA=="
          }
        ]
      },
      "maintainers": [
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.24.3_1523543120995_0.619218117964933"
      },
      "_hasShrinkwrap": false
    },
    "0.24.5": {
      "name": "ts-json-schema-generator",
      "version": "0.24.5",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "./bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "licenses": [
        {
          "type": "MIT",
          "url": "http://www.opensource.org/licenses/mit-license.php"
        }
      ],
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=6.0.0"
      },
      "dependencies": {
        "commander": "~2.15.1",
        "glob": "~7.1.2",
        "json-stable-stringify": "^1.0.1",
        "ts-node": "^5.0.1",
        "typescript": "~2.8.1"
      },
      "devDependencies": {
        "@types/assertion-error": "^1.1.0",
        "@types/chai": "^4.1.2",
        "@types/glob": "^5.0.35",
        "@types/json-stable-stringify": "^1.0.32",
        "@types/mocha": "^5.0.0",
        "@types/node": "^9.6.4",
        "ajv": "~6.4.0",
        "chai": "~4.1.2",
        "mocha": "~5.0.5",
        "source-map-support": "~0.5.4",
        "tslint": "~5.9.1"
      },
      "scripts": {
        "preversion": "npm run lint",
        "build": "tsc -p .",
        "watch": "tsc -p . -w",
        "lint": "tslint -p .",
        "test": "tsc -p . && mocha -t 10000 --require source-map-support/register --recursive dist/test",
        "debug": "ts-node --inspect=19248 --debug-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts"
      },
      "gitHead": "d19c9cee13e234c1a3c05336fa2fb21b6c2b6c13",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.24.5",
      "_npmVersion": "5.6.0",
      "_nodeVersion": "8.11.1",
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "dist": {
        "integrity": "sha512-j7XAE3zpym+sD9Wzfyw7rTQP8IwWESTbDH9XRBv7QfQQqthBib+IwRqJyfXTj5YvC3QarWAryN9/P1DUd8lSJQ==",
        "shasum": "4249133f893820b2f0ff8b9beb3a84a46d9b1a4d",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.24.5.tgz",
        "fileCount": 5,
        "unpackedSize": 20995,
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIQDJQVL/CDvcW1qVC/l4UCQJeomC8WnbwJUStipVy9rQ4wIgHDFvfyWTfvZbs2H8v0ZTTL/wQ7EIk7xWUxLDv69a5Xw="
          }
        ]
      },
      "maintainers": [
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.24.5_1523544470628_0.9577455195451254"
      },
      "_hasShrinkwrap": false
    },
    "0.24.6": {
      "name": "ts-json-schema-generator",
      "version": "0.24.6",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "./bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "licenses": [
        {
          "type": "MIT",
          "url": "http://www.opensource.org/licenses/mit-license.php"
        }
      ],
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=6.0.0"
      },
      "dependencies": {
        "commander": "~2.15.1",
        "glob": "~7.1.2",
        "json-stable-stringify": "^1.0.1",
        "ts-node": "^5.0.1",
        "typescript": "~2.8.1"
      },
      "devDependencies": {
        "@types/assertion-error": "^1.1.0",
        "@types/chai": "^4.1.2",
        "@types/glob": "^5.0.35",
        "@types/json-stable-stringify": "^1.0.32",
        "@types/mocha": "^5.0.0",
        "@types/node": "^9.6.4",
        "ajv": "~6.4.0",
        "chai": "~4.1.2",
        "mocha": "~5.0.5",
        "source-map-support": "~0.5.4",
        "tslint": "~5.9.1"
      },
      "scripts": {
        "prepublishOnly": "npm run build",
        "preversion": "npm run lint",
        "build": "tsc -p .",
        "watch": "tsc -p . -w",
        "lint": "tslint -p .",
        "test": "tsc -p . && mocha -t 10000 --require source-map-support/register --recursive dist/test",
        "debug": "ts-node --inspect=19248 --debug-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts"
      },
      "gitHead": "6ced5b23979d3901635f4cf12bd932cee4c2aa3e",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.24.6",
      "_npmVersion": "5.6.0",
      "_nodeVersion": "8.11.1",
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "dist": {
        "integrity": "sha512-QGbeXxOALl+RSAP3fe+YENFC+TaWJA34BZcQuqyYB/vyM3LuOl/3pt6tIbjwt85cCpufzlooH2qbvpr1ahH3Wg==",
        "shasum": "c52b91b85e31a1e22c661b6bfc0a1591692a90d7",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.24.6.tgz",
        "fileCount": 301,
        "unpackedSize": 236999,
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEYCIQDUkUPmayaxTIJMrsVQXc51qCB9blXmGmH+aWd7MYqv6gIhAJ6O6p8RbTV9Sxhzr+MRI88aUDJmcWx10ibEh70NN+Cm"
          }
        ]
      },
      "maintainers": [
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.24.6_1523626670472_0.2598918084940225"
      },
      "_hasShrinkwrap": false
    },
    "0.24.7": {
      "name": "ts-json-schema-generator",
      "version": "0.24.7",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "./bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "licenses": [
        {
          "type": "MIT",
          "url": "http://www.opensource.org/licenses/mit-license.php"
        }
      ],
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=6.0.0"
      },
      "dependencies": {
        "commander": "~2.15.1",
        "glob": "~7.1.2",
        "json-stable-stringify": "^1.0.1",
        "ts-node": "^6.0.3",
        "typescript": "~2.8.3"
      },
      "devDependencies": {
        "@types/assertion-error": "^1.1.0",
        "@types/chai": "^4.1.3",
        "@types/glob": "^5.0.35",
        "@types/json-stable-stringify": "^1.0.32",
        "@types/mocha": "^5.2.0",
        "@types/node": "^9.0.0",
        "ajv": "~6.4.0",
        "chai": "~4.1.2",
        "jest": "^22.4.3",
        "source-map-support": "~0.5.5",
        "ts-jest": "^22.4.5",
        "tslint": "~5.10.0"
      },
      "scripts": {
        "prepublishOnly": "npm run build",
        "preversion": "npm run lint",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "tslint -p .",
        "test": "jest test/ --verbose",
        "debug": "ts-node --inspect=19248 --debug-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts"
      },
      "jest": {
        "transform": {
          "^.+\\.tsx?$": "ts-jest"
        },
        "testRegex": "(/__tests__/.*|(\\.|/)(test|spec))\\.(jsx?|tsx?)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "jsx",
          "json",
          "node"
        ],
        "testPathIgnorePatterns": [
          "node_modules",
          "test-runtime",
          "<rootDir>/build",
          "_site",
          "src"
        ],
        "coverageDirectory": "./coverage/",
        "collectCoverage": false
      },
      "gitHead": "26ea047c43c9f1ca973358939511cbe55a8ce01a",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.24.7",
      "_shasum": "b9daed4ac7a4233848f4a4c8b101969538748825",
      "_from": ".",
      "_npmVersion": "3.10.10",
      "_nodeVersion": "6.14.2",
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "dist": {
        "shasum": "b9daed4ac7a4233848f4a4c8b101969538748825",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.24.7.tgz",
        "fileCount": 5,
        "unpackedSize": 123624,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJa70PdCRA9TVsSAnZWagAA+08QAJkHRlJr2l1l6ewLXGcV\n0CHm1ZIB/RZ9/JrIUgVMgm7qmdCAC/oUty3b5OYmXi3lRMRVczEbs9j5yrES\ny+LQBSwDDxeINTZ9PVn+81iHCiuDs+SgnBPX5gIfppaw8C2ZxjF3pMJhErLV\nM8Je2huCsw/FmduxTN3ofzCHj7WFU/o62gYFWbjRfTn4N7cCYiJIIq47Uvai\nzwaoxDKypyOwMAv0Bq+03zjKFWv9UnJCEi4Kv0InFOcEm0053Us6BtpPTiu1\nQg4fff6bDGD3YiRlkT0bPhkcpRlCu0dXoPFD3kc9Q3ho5ECu+AcGQ7yIHfIz\n4rrMmDFngLXvIm+S4jkn0Eaq3T0eRcBpwNHo4IBX7KiS3HtlDLZL74LRSPwx\nTDengatEFBo7O30ZZnkFf16BQRPkTgvokkypzrMnptjZLSrV9Do1n4h2W87W\nEwpsCsyOk1WNdpWTcEG2kxdBPS9/Xrq6Q/AU9yvFLUA9D6AVrJsWVV2URd0G\nZb5G5av5gMJ1RrJVLJMr5+3WqeqMmoFN9MD6SmI2NuqSC9Udt5ldb4a3BeWa\nYyNqS7tU6x0D1aR1ncKOZhGZQxf0ds1zX/EeX+3EExt6Tg4v1A4n0CwDqB8r\nCH2ylMmCmNCx3jDmBpZHC8iV6lj4nszTMDLheOjoE+QTIr++dJze/dFay6IM\nyO7m\r\n=fEa2\r\n-----END PGP SIGNATURE-----\r\n",
        "integrity": "sha512-ackOtDcNypO9XRmSzkENkLXNBAXie0ymeCF11vj1H+OeYgyoIGT68Mb76gWX6iT6kMR4txIIuWTWjS3ZWT8ojA==",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEYCIQDXF/XweUQ5cjke6b+zQI6JA5pSNXbI592skiv/pI4gHAIhAITO9WzHF4Gp+0chnurFRF4uq9Yi1ThujiiZwvDZeqy7"
          }
        ]
      },
      "maintainers": [
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.24.7_1525629916306_0.3653461668119047"
      },
      "_hasShrinkwrap": false
    },
    "0.25.0": {
      "name": "ts-json-schema-generator",
      "version": "0.25.0",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "./bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "licenses": [
        {
          "type": "MIT",
          "url": "http://www.opensource.org/licenses/mit-license.php"
        }
      ],
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=6.0.0"
      },
      "dependencies": {
        "commander": "~2.15.1",
        "glob": "~7.1.2",
        "json-stable-stringify": "^1.0.1",
        "ts-node": "^6.0.3",
        "typescript": "~2.8.3"
      },
      "devDependencies": {
        "@types/assertion-error": "^1.1.0",
        "@types/chai": "^4.1.3",
        "@types/glob": "^5.0.35",
        "@types/json-stable-stringify": "^1.0.32",
        "@types/mocha": "^5.2.0",
        "@types/node": "^9.0.0",
        "ajv": "~6.4.0",
        "chai": "~4.1.2",
        "jest": "^22.4.3",
        "source-map-support": "~0.5.5",
        "ts-jest": "^22.4.5",
        "tslint": "~5.10.0"
      },
      "scripts": {
        "prepublishOnly": "npm run build",
        "preversion": "npm run lint",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "tslint -p .",
        "test": "jest test/ --verbose",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts"
      },
      "jest": {
        "transform": {
          "^.+\\.tsx?$": "ts-jest"
        },
        "testRegex": "(/__tests__/.*|(\\.|/)(test|spec))\\.(jsx?|tsx?)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "jsx",
          "json",
          "node"
        ],
        "testPathIgnorePatterns": [
          "node_modules",
          "test-runtime",
          "<rootDir>/build",
          "_site",
          "src"
        ],
        "coverageDirectory": "./coverage/",
        "collectCoverage": false
      },
      "gitHead": "a366020aa517ab5e174ea3fcebf7a112646d7c20",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.25.0",
      "_shasum": "b167b5ab03f6919b47f3b9c8e7bad631b9c4d3a4",
      "_from": ".",
      "_npmVersion": "3.10.10",
      "_nodeVersion": "6.14.2",
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "dist": {
        "shasum": "b167b5ab03f6919b47f3b9c8e7bad631b9c4d3a4",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.25.0.tgz",
        "fileCount": 6,
        "unpackedSize": 123564,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJa78omCRA9TVsSAnZWagAA9gYP/3Dzyv/cMfAC00RkJK14\nJ0n/qYkL3QW8rsGdQtTwHWjexdYigFEN1icfCVw8iC8iRFCeDLUpkaycybSX\nwHR8MsiQQ18i+kxlBjf+qdKfwWWl6okpjtQ5mGCXFYoPJI4EiA9YTZ1nsZNP\nL6MMRYKU+rp8njeQE5uv37yC/MTT59Fynwirb/ScrFbs6LtvjxE9AvhL3YhH\nhm8/M0UOp9vRAdZSPiAGLmQGR8xtqZzPfTG1IGhLniTEP1AwzQLHrAzOTB1O\n5xwlcJTJgreQ7wcodkjlD0RiZ9ONavyn6/Xu9rZ3D3RYFug2xFT/PkiGS+Mv\nsOX74Hx46F8q4Xt7rhb1JxFwRyDIEHYjnQmjldBF29jca+C18Al2z2jix2Fr\nNdptRToiarZccSDeuuzMalTlXslw9IxgkR7dzUkniZoRJBa5CHVhoashAVhJ\ny3mSJJQm8+QLkWcmQNRjvD3T96e5ousUy1Kgro+REIDCtw8Q1hwy1t2QMdUx\nJG1sY2DvWcmGOGoekIF+OTDgdTjUEOHxe3zG3Yg7wiwHZ4DUys4DKy2RcO4q\nWqEkF9uR691zdV/XnuCNiWpEq3hrNW0sM7ibOT466y4TWfkJAUn2tMAcZn6N\nZDdgdWazDF3EWFjwWOJb+o1pOaKXX1fTeiWVYRRuNieAsskgTwqn6gXQ2R98\n4VfC\r\n=razf\r\n-----END PGP SIGNATURE-----\r\n",
        "integrity": "sha512-j8IzlJcl+4WNs7aUAGIIJCjsGMv4Znv8SjEsNWpZT5huo3vzl7eQhJla6mSAEVb7yMmjkcxH4cXXIWDnEAuOmQ==",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIHlqT39i6ZH77RGMvqrGT47I+XS7In46TX5puKqK5THAAiEA0hSs3tcf/PZbHCyqkKNaNMPvYdIZMRDleZ0BcCPpQi8="
          }
        ]
      },
      "maintainers": [
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.25.0_1525664293674_0.8007643091228949"
      },
      "_hasShrinkwrap": false
    },
    "0.25.1": {
      "name": "ts-json-schema-generator",
      "version": "0.25.1",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "./bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "licenses": [
        {
          "type": "MIT",
          "url": "http://www.opensource.org/licenses/mit-license.php"
        }
      ],
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=6.0.0"
      },
      "dependencies": {
        "commander": "~2.15.1",
        "glob": "~7.1.2",
        "json-stable-stringify": "^1.0.1",
        "ts-node": "^6.0.3",
        "typescript": "~2.8.3"
      },
      "devDependencies": {
        "@types/assertion-error": "^1.1.0",
        "@types/chai": "^4.1.3",
        "@types/glob": "^5.0.35",
        "@types/json-stable-stringify": "^1.0.32",
        "@types/mocha": "^5.2.0",
        "@types/node": "^9.0.0",
        "ajv": "~6.4.0",
        "chai": "~4.1.2",
        "jest": "^22.4.3",
        "source-map-support": "~0.5.5",
        "ts-jest": "^22.4.5",
        "tslint": "~5.10.0"
      },
      "scripts": {
        "prepublishOnly": "npm run build",
        "preversion": "npm run lint",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "tslint -p .",
        "test": "jest test/ --verbose",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts"
      },
      "jest": {
        "transform": {
          "^.+\\.tsx?$": "ts-jest"
        },
        "testRegex": "(/__tests__/.*|(\\.|/)(test|spec))\\.(jsx?|tsx?)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "jsx",
          "json",
          "node"
        ],
        "testPathIgnorePatterns": [
          "node_modules",
          "test-runtime",
          "<rootDir>/build",
          "_site",
          "src"
        ],
        "coverageDirectory": "./coverage/",
        "collectCoverage": false
      },
      "gitHead": "53ec620ab08783f6dd975d0bb508ade4838a3072",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.25.1",
      "_shasum": "e86644a9b0769bea6fc6ba6d0df49bf54e05d837",
      "_from": ".",
      "_npmVersion": "3.10.10",
      "_nodeVersion": "6.14.2",
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "dist": {
        "shasum": "e86644a9b0769bea6fc6ba6d0df49bf54e05d837",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.25.1.tgz",
        "fileCount": 327,
        "unpackedSize": 376359,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJa789bCRA9TVsSAnZWagAAMmQP/R1s/BXadtnzkE3Y1wr2\n/hkfWPMRvK0QTuDp7mQICLf1fnVwse4ezL9XtpNcwm2ItnkuGK2W9BvnAY2E\nq4ZVQ+tn0GoLwMWQWiGOLrgFMR7AtyQafbsCLV8bvQLDXCloPJPx1DFD8a07\nHPjokNmT54FtxgUKQbdfBo69JmnOSqHRzoNk+3H85B61SXCWze9+5W3SOVGy\nw1iRti2A6vS5IbmFRjTA0ifmMopoDnNqmzlahzG0inSbaKNdJlkN6QgIysdq\nJkkSiDV2Supk970NDV/70l/wUWqIvg68/0VVAzA/2umgQqXmBggmI0kaX/Jj\nocRRpxsoNeXWc7Tl6yoL3yeOGai2ostoqo2T1lbS9FGvm4HPNv7NJ+EkwEhH\nDGwqLvnGJh+g0Uk/5J2neSJ/xZGM+tdtx8U+veNdGGQxsDp9WBBqe064QZXM\nRjpzd09yUgeQ8tRO4zcXYb8r9B8galFc53CQ7B5gSU6pFMDex7EHO1xOAo1c\nmQelOpANym9juOfXDB1m24kdj2bqb+24cf07l682fLwKdH3upCES3TN/1qj8\neMWoSmdQq68gSOnyio7IwBcVvo/gkmKyRPBPlHELX/lkfiMErD/4Qj8DmJ+t\nB84/9wWTj5Obp1EnVxpVpRoIf6na/its0FeCGXOr+DPyRALgWpPG+hatNjBo\n2hIy\r\n=nN6D\r\n-----END PGP SIGNATURE-----\r\n",
        "integrity": "sha512-J8g3mmbyKQJ6sljWgGtp6gbS1p3VvUir/yGkknI3GT87PxeAFLsNCK3KiCCgPMpV+NnloLLOuIxakTyTz7DY2g==",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEQCIDhY8m8Eg4RJEr19gq8TIQNDI7sYyCtcaIO49jOUmV8ZAiAMpz7PTKK/Q/huRgEkllGGz/+/r5KezHAv44HGMqow7w=="
          }
        ]
      },
      "maintainers": [
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.25.1_1525665626859_0.9134448721595931"
      },
      "_hasShrinkwrap": false
    },
    "0.26.0": {
      "name": "ts-json-schema-generator",
      "version": "0.26.0",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "./bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "licenses": [
        {
          "type": "MIT",
          "url": "http://www.opensource.org/licenses/mit-license.php"
        }
      ],
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=6.0.0"
      },
      "dependencies": {
        "commander": "~2.15.1",
        "glob": "~7.1.2",
        "json-stable-stringify": "^1.0.1",
        "ts-node": "^6.0.5",
        "typescript": "~2.9.1"
      },
      "devDependencies": {
        "@types/assertion-error": "^1.1.0",
        "@types/chai": "^4.1.3",
        "@types/glob": "^5.0.35",
        "@types/json-stable-stringify": "^1.0.32",
        "@types/mocha": "^5.2.1",
        "@types/node": "^10.3.0",
        "ajv": "~6.5.0",
        "chai": "~4.1.2",
        "jest": "^23.1.0",
        "source-map-support": "~0.5.6",
        "ts-jest": "^22.4.6",
        "tslint": "~5.10.0"
      },
      "scripts": {
        "prepublishOnly": "npm run build",
        "preversion": "npm run lint",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "tslint -p .",
        "test": "jest test/ --verbose",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts"
      },
      "jest": {
        "transform": {
          "^.+\\.tsx?$": "ts-jest"
        },
        "testRegex": "(/__tests__/.*|(\\.|/)(test|spec))\\.(jsx?|tsx?)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "jsx",
          "json",
          "node"
        ],
        "testPathIgnorePatterns": [
          "node_modules",
          "test-runtime",
          "<rootDir>/build",
          "_site",
          "src"
        ],
        "coverageDirectory": "./coverage/",
        "collectCoverage": false
      },
      "gitHead": "b235586a923b2b10cd981103fefc004c6f4d4dfc",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.26.0",
      "_npmVersion": "5.6.0",
      "_nodeVersion": "8.11.2",
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "dist": {
        "integrity": "sha512-rfhc/KXiY4UjouKaEhwcAfQ3fcAP/dfFs0cECME7Upj2YxqZTDiIFVjttmgkJp61WVsPIFuf7QfpfGd487jviw==",
        "shasum": "44a578b1ab18c9a4765be0c844977319aa6a495c",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.26.0.tgz",
        "fileCount": 326,
        "unpackedSize": 379817,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJbEc0tCRA9TVsSAnZWagAAYnYP/3YuFsh8X38rrIE6mL+4\nLG4KXCsb7QHLMkfiYLF7NbteBfrzWQQvd6/OucCuRq6ngGVx+35wPDxOaEgP\nCPfngsqQjlAMGVUOalRqExHrF+zhLty0f4Ybj3T9DovC4IKWE+lSB0DiiqJQ\nOhlR/d4zP49/UKNKe/VpM4aD8dLvzrrVUHhUFJTh1VuQHqZtBDV0zEzPq3NS\nuUFVbD+q3Ew2vk5MX3K5Gemml18YOk8UsrNhpH89YEaSrPXw/Nx3hm6OAn72\nYf2rn7oouNGPh/zKRz5PMbGByq5V0vV8SVZ0Sid3XZTf4jtbfADTnwUIAepW\nhu3Lsy4JStY3odxuIYf0p2bfVuIG5ZDYlcKYyuxYZDvIh4BaB9ZTu8l1yfVc\nDcyH7YFr6D/D8S1+TW7Lah8ND2XrXs9oJX0for61Azrt8gC3CMj3npWgeiYn\nnm1zLUdsy5H6pIFk6Xf4rKW2XdUfCf/k859OyUzLFvTPYZfu8MgqJZVe7sDH\nP5CZIr4EATODx49n+xXG0NpFUcHRHi94vn5u0Z/gkJSkRSNU3O2m+Ubi5FWg\nSS6ERy7CWDNSDpPwDzfuJu3lAp7f7jEy4SQxBPqAbS9lhxfzNs+KJ4erS2G8\nOwATQUINZz7+ikIaiS16Xo6biO/ThLBd3oCJ3v9CeNjNxKyY5fycWwOmTdGb\nMUSB\r\n=Tq7D\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEYCIQC60njNWuFOiezEp6C1R0UKG3x5c86jBCxRxN7oWdCjpQIhAIwuYiwTdIPcN+ml5jDloLJbD2r3nbT3v+a+SWBopE4D"
          }
        ]
      },
      "maintainers": [
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.26.0_1527893292669_0.721267805861846"
      },
      "_hasShrinkwrap": false
    },
    "0.27.0": {
      "name": "ts-json-schema-generator",
      "version": "0.27.0",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "./bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "licenses": [
        {
          "type": "MIT",
          "url": "http://www.opensource.org/licenses/mit-license.php"
        }
      ],
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=6.0.0"
      },
      "dependencies": {
        "commander": "~2.15.1",
        "glob": "~7.1.2",
        "json-stable-stringify": "^1.0.1",
        "ts-node": "^6.0.5",
        "typescript": "~2.9.1"
      },
      "devDependencies": {
        "@types/assertion-error": "^1.1.0",
        "@types/chai": "^4.1.3",
        "@types/glob": "^5.0.35",
        "@types/json-stable-stringify": "^1.0.32",
        "@types/mocha": "^5.2.1",
        "@types/node": "^10.3.0",
        "ajv": "~6.5.0",
        "chai": "~4.1.2",
        "jest": "^23.1.0",
        "source-map-support": "~0.5.6",
        "ts-jest": "^22.4.6",
        "tslint": "~5.10.0"
      },
      "scripts": {
        "prepublishOnly": "npm run build",
        "preversion": "npm run lint",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "tslint -p .",
        "test": "jest test/ --verbose",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts"
      },
      "jest": {
        "transform": {
          "^.+\\.tsx?$": "ts-jest"
        },
        "testRegex": "(/__tests__/.*|(\\.|/)(test|spec))\\.(jsx?|tsx?)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "jsx",
          "json",
          "node"
        ],
        "testPathIgnorePatterns": [
          "node_modules",
          "test-runtime",
          "<rootDir>/build",
          "_site",
          "src"
        ],
        "coverageDirectory": "./coverage/",
        "collectCoverage": false
      },
      "gitHead": "594cbdeff967a9c5e3d4fe2941ae90567b5cf23e",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.27.0",
      "_npmVersion": "6.1.0",
      "_nodeVersion": "10.4.0",
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "dist": {
        "integrity": "sha512-r4WjrzkXpO9ty9BTEM3afX7lHjuKUu9oajNP6FQQgMWRYQk9D+DNXrORvM8Ik5xNQfDbQlemcYG+rUchpsocoA==",
        "shasum": "e248b92d5b6ad6e3d729b9f71785d94f5a461433",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.27.0.tgz",
        "fileCount": 326,
        "unpackedSize": 381822,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJbGrcTCRA9TVsSAnZWagAAZ+cQAKJueg8Ky/T/tPX7if2Q\nhpJ4KnWDxGZO6C82WbV0e5wofwu53DE09y0bXYgQqVFBJXXT1FSMI+arYIlS\nTR+p5i13H36D79MngKzl5XU9a2T2932Jrf22u1E7qHHJjUMSG0rPH8CQ1mvU\nviGnBaXkOpZIXjePkrduWLxKvGp5Sk+GFEvGdyI+KO9BZacgI1qWxcjGb0iT\nUKvWGv8rKrhLj9giLdeGhUMzRpdufUYza1jw2S/35jbFB0IGKwCk8H31wVD2\namlkWQSqoifta6+io4bfDdUPfjwHUE/BdqwYVRYLc2x8JLjk1yy4UWOble2R\n2Se+RP/fx+AiUjWpBy3ZfGzS62aTkwyYlxKEjttqiW+kyaz8j8m/V98v3exi\nsEaNK3mApWE9XrjCwz746JHtVVFeZPTntTIjMK3011U4vtC/peM6jcxlfE9t\n07iqZFq4+qiCyY972tMFodu4hcoKU9KyGHzDb9usOcvGwiSltzQiAWKq8scP\nuaNFMIUheuuCkOD+S8un0QtOYae5I9wt6O13PTwliSV+awM6GfRb6rYlzOeh\npO96bmiSIZyEM4VI5sFolW3v5snCvyzx0Uimj5kg6Kis2qiTgxc9Gv1/4IpZ\nVwG7cpRp++g3IdkHPShFSS5Xe2MwvQkeDRp2BcqDz+ztiGeAGCqD8uuaa2aX\nStLn\r\n=xVXZ\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEYCIQCj3nkNRObweCE9/BpnK7IYKcxpsue4TiIANyXzaG7xMwIhAN1HK7XQogZA1YNqMd/28KMk3E9UCyL69f7Agd/kGPYG"
          }
        ]
      },
      "maintainers": [
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.27.0_1528477458126_0.8502731470483482"
      },
      "_hasShrinkwrap": false
    },
    "0.28.0": {
      "name": "ts-json-schema-generator",
      "version": "0.28.0",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "./bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "licenses": [
        {
          "type": "MIT",
          "url": "http://www.opensource.org/licenses/mit-license.php"
        }
      ],
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=6.0.0"
      },
      "dependencies": {
        "commander": "~2.15.1",
        "glob": "~7.1.2",
        "json-stable-stringify": "^1.0.1",
        "ts-node": "^6.1.1",
        "typescript": "~2.9.2"
      },
      "devDependencies": {
        "@types/assertion-error": "^1.1.0",
        "@types/chai": "^4.1.4",
        "@types/glob": "^5.0.35",
        "@types/json-stable-stringify": "^1.0.32",
        "@types/mocha": "^5.2.2",
        "@types/node": "^10.3.4",
        "ajv": "~6.5.1",
        "chai": "~4.1.2",
        "jest": "^23.1.0",
        "source-map-support": "~0.5.6",
        "ts-jest": "^22.4.6",
        "tslint": "~5.10.0"
      },
      "scripts": {
        "prepublishOnly": "npm run build",
        "preversion": "npm run lint",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "tslint -p .",
        "test": "jest test/ --verbose",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts"
      },
      "jest": {
        "transform": {
          "^.+\\.tsx?$": "ts-jest"
        },
        "testRegex": "(/__tests__/.*|(\\.|/)(test|spec))\\.(jsx?|tsx?)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "jsx",
          "json",
          "node"
        ],
        "testPathIgnorePatterns": [
          "node_modules",
          "test-runtime",
          "<rootDir>/build",
          "_site",
          "src"
        ],
        "coverageDirectory": "./coverage/",
        "collectCoverage": false
      },
      "gitHead": "06610264dfe34c5a26ada773b401a1af593ff6d8",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.28.0",
      "_npmVersion": "6.1.0",
      "_nodeVersion": "10.4.1",
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "dist": {
        "integrity": "sha512-WH5yK598fT4czpQwpUZJiTrjVkQmEW44jDDfDRsGuF+LnmA+KVG12aEVRXLBWtWa6vNPPIw+O9IMSE1RiuNGyw==",
        "shasum": "8dc69e155401e424c82e6b97514dffaeabacba54",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.28.0.tgz",
        "fileCount": 326,
        "unpackedSize": 382217,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJbKX6LCRA9TVsSAnZWagAAcF8P/jtb1gP02KZAkBb5kfym\nmRQ0P4mpPpeVAgOuy0XlUb7rl7MNApUj//FJgiBD1LR2BSIR+gBk2jezaCFq\nGcb5EEl0NvsWhihC0/DrGuv2N7AB6cH7AUarCXGpVpKStDRT/kOysxLqUtVo\nR2DBe7ATLS+lcGcsFwJ0A9WCvwCQ8tofIptCYZVX76IXK0JmOzvi7rRPQmVn\n9rktmUxFRSr/TjjHZ04DSsJSys4i0HY2v9HpxfDydm5riwK432v//usLPZ/G\nVCClL3ZBfYWEhSn34y+1kmMIHabztZYF4YNTJl+6DhOikkPjyTR4UcGHq+Ra\nQqEjGJ+PKwgQXys35IIp7wR2ff6mHP1gJ/V4UFEyjmtzfd9eAQSMR1LE4fNX\ngpx4ONtXKEmqf4wZNBFQvnuiuo6yrqNsIbEG4OnScxLtJiXNNbxSr7wTNtpX\noD7WM6xxeLXbaCtyY4iF3mxk5pBTUKzwyveWtLnHtcSQfHjsjwkLv0nzql3B\nDMO4fO0Ei+Atl23HDyPc6DdoNn8J4S2NG/Wi85AJaLG2XgKLNMIqRuaClQOc\nDTC3oPbZQHSEss6j+HJR1SrEPzUjXVs+MyZy9wleUgY9cvPOpY0NSR4D2sQr\nCOKyDDDQO5CzMfShWKVMzg7Zk7sZIQ9iA+5Fp/6UoDqdQSZ9759KRsYWp1Mp\nAuRC\r\n=44FB\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIEClPuSH6F6wFHbhD1Heg+vSCn/PLc71DvhSh682jutUAiEA1X59nJ4pUKBXhxL7DVg+HKqHdc7L454/QlN+x/Ufah0="
          }
        ]
      },
      "maintainers": [
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.28.0_1529446026070_0.5032872058882039"
      },
      "_hasShrinkwrap": false
    },
    "0.28.1": {
      "name": "ts-json-schema-generator",
      "version": "0.28.1",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "./bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "licenses": [
        {
          "type": "MIT",
          "url": "http://www.opensource.org/licenses/mit-license.php"
        }
      ],
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=6.0.0"
      },
      "dependencies": {
        "commander": "~2.15.1",
        "glob": "~7.1.2",
        "json-stable-stringify": "^1.0.1",
        "ts-node": "^6.1.1",
        "typescript": "~2.9.2"
      },
      "devDependencies": {
        "@types/assertion-error": "^1.1.0",
        "@types/chai": "^4.1.4",
        "@types/glob": "^5.0.35",
        "@types/json-stable-stringify": "^1.0.32",
        "@types/mocha": "^5.2.2",
        "@types/node": "^10.3.4",
        "ajv": "~6.5.1",
        "chai": "~4.1.2",
        "jest": "^23.1.0",
        "source-map-support": "~0.5.6",
        "ts-jest": "^22.4.6",
        "tslint": "~5.10.0"
      },
      "scripts": {
        "prepublishOnly": "npm run build",
        "preversion": "npm run lint",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "tslint -p .",
        "test": "jest test/ --verbose",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts"
      },
      "jest": {
        "transform": {
          "^.+\\.tsx?$": "ts-jest"
        },
        "testRegex": "(/__tests__/.*|(\\.|/)(test|spec))\\.(jsx?|tsx?)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "jsx",
          "json",
          "node"
        ],
        "testPathIgnorePatterns": [
          "node_modules",
          "test-runtime",
          "<rootDir>/build",
          "_site",
          "src"
        ],
        "coverageDirectory": "./coverage/",
        "collectCoverage": false
      },
      "gitHead": "d2adc238c3cf619b63017389aa771ed78a64c50e",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.28.1",
      "_npmVersion": "6.1.0",
      "_nodeVersion": "10.5.0",
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "dist": {
        "integrity": "sha512-n0GQgwuo0CmmH8JjeTqpkgjBGCC/+hiye5QVkx6PqrjPVxo66ktaFb+u6VmCEkTvfKTif7oKGevR0wer9I0/PQ==",
        "shasum": "dbe6fe09e1dd1c2680264ef70832af102b92b76d",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.28.1.tgz",
        "fileCount": 326,
        "unpackedSize": 382378,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJbOrNeCRA9TVsSAnZWagAA2ZIQAKPVkX9osyPJs1SjBVka\nh0yXlIz1M2vKcI3fZ3qv156NrufjvKYHiDeCTYadh1nOAMZ6mq6C26Wyn1cM\n9MFGnRVFjF2a/dy1lnbf76DVJkcz8nHo2uPGv0ccXaUdqdSnMqO+uesxoB+l\nmHKQs3YRUzrm/q1qqrIWIwBh1n2OSc9NHjCDxjMy4e1L49dOOGNgumfqxkK9\nvL5LFUptwONI7836wAGHxDlxyGyzIouMHi9dlvNT3a1EWbrQLtpTF9+qV9st\nJRLjNzu7K72FYHNYSM77ooG0ZtLxIbJGmhrt5gr7Izn8/zTWcOAfV8Y8ASUX\nmlx7llKkln4+sma/dKo436qYJ1QpdhcNWLRkxTNLovPvwiUQURP5hQObYSUR\nwdCKevcjrl8HtMX53/972pAd5xBVo64/RKM+qDeOCt/bfWD5EBOdXFwxv6lW\n5e+WV7XvHUpng0XddaU7H5PusCo+Quv7mUSnZegrObkTnhnioOOI0+qpyOx7\nKt2K9HlCKW6v+LcNeQ/5G5IQXxz3UREnLsWNomB+16oL7rMm2Wa3x++Cdewt\n1AJ1CbCnyi/ywDxMv/v7nzx/xhJ+7DZ6psGaqkk6X7nMQSE5Hm1VwQLRqU+c\n3eelj08/KCpW6/CfFwwmSzKTe2AJXFL2dH1xRcc+ppdKJL1pE7TjySApNVFo\nWaYT\r\n=kG/D\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIGUKpXsxlw8qPBsTdBewxFhd/uxc+RMB+sk0bAd+EFMfAiEAzmQ/efarkRbGcyjLg/ZGOiViBtowCy7doINtwKxuMbU="
          }
        ]
      },
      "maintainers": [
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.28.1_1530573662152_0.07767262973831923"
      },
      "_hasShrinkwrap": false
    },
    "0.28.2": {
      "name": "ts-json-schema-generator",
      "version": "0.28.2",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "./bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "licenses": [
        {
          "type": "MIT",
          "url": "http://www.opensource.org/licenses/mit-license.php"
        }
      ],
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=6.0.0"
      },
      "dependencies": {
        "commander": "~2.16.0",
        "glob": "~7.1.2",
        "json-stable-stringify": "^1.0.1",
        "ts-node": "^7.0.0",
        "typescript": "~2.9.2"
      },
      "devDependencies": {
        "@types/assertion-error": "^1.1.0",
        "@types/chai": "^4.1.4",
        "@types/glob": "^5.0.35",
        "@types/json-stable-stringify": "^1.0.32",
        "@types/mocha": "^5.2.4",
        "@types/node": "^10.5.1",
        "ajv": "~6.5.2",
        "chai": "~4.1.2",
        "jest": "^23.2.0",
        "source-map-support": "~0.5.6",
        "ts-jest": "^23.0.0",
        "tslint": "~5.10.0"
      },
      "scripts": {
        "prepublishOnly": "npm run build",
        "preversion": "npm run lint",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "tslint -p .",
        "test": "jest test/ --verbose",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts"
      },
      "jest": {
        "transform": {
          "^.+\\.tsx?$": "ts-jest"
        },
        "testRegex": "(/__tests__/.*|(\\.|/)(test|spec))\\.(jsx?|tsx?)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "jsx",
          "json",
          "node"
        ],
        "testPathIgnorePatterns": [
          "node_modules",
          "test-runtime",
          "<rootDir>/build",
          "_site",
          "src"
        ],
        "coverageDirectory": "./coverage/",
        "collectCoverage": false
      },
      "gitHead": "a74f130e689a140e4d2ac853c965f0ed1700d9cb",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.28.2",
      "_npmVersion": "6.1.0",
      "_nodeVersion": "10.5.0",
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "dist": {
        "integrity": "sha512-SbGjr3+Mt55jNJgMilauDtCkwEV8u/TJFo1+coHw2oDDBKey5h25VaeaowQcP+gVJUYQSG5C7fCYk5NMlNolCA==",
        "shasum": "32c7e100aef08250496c0929eff57c4de2d1a51d",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.28.2.tgz",
        "fileCount": 326,
        "unpackedSize": 379268,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJbOrtZCRA9TVsSAnZWagAAXTYQAJA7bEZ68wZDnL/rjgkm\nhRVNukaQPD2QFljV7wqGs/a8eWrDIDL3/sg48Do0iFpgOD4UJnJCPJ27WlYS\n0nmlceVfcD9jeOMNYyJ1PzjqwOjWujwJVr5D3CV3rOUzXKBFh653r49wPFSu\nwF9/ysciz51a56Pp1fzVmENVWlPkCZVz6GWodtcEJcI+RlITaCDqik2Cx52j\nzvD1TUjQ10wonbHmbqoDTHhFtYrovTkvZNlnV0siqm32JHLDgGM5pQI/VMNx\nQUdecw5D1BOIc3uop4GrlidDSK3o3Q9j04AG/K60IHdz9e7ME+oKkQB821bG\nGvyk0dUIYtL8hg9MZX3qjPRMlDV0wA5jW0WJ2/UA+J0ogMfxkd45+MDOI4//\nr1vSOw6Phu/M2rYyiTCx9q+uh6PPWavtIGuTAl11537mmj5j1Q3hYTfuZ2tg\nXeqg0AxxZowe8fi+IVBRW9OVWf4rv+mssHNMeoxOX0OrpNLJMq5OP+xhUKCn\n+wxeuzq0XHabDkYm/VKVwZTkaX8z2Rjoc1CclzAyJYwerekNJ2uh50nDy7SZ\n2H5784GRdmIgvozNJltvKeCQ73u/APW8biRKRM/8hYisM7xlXbBVeKLuwU7C\ngqmr2w0K2n1WZPZcRsjcz3lGmtFBpMqlv6hzsd5q1SJ4XekfKaKyTM6NWG11\n6RY6\r\n=KzJR\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEQCIA/7pz9APLLYeN7+d3fEgIcUJf+vtnl8F8fsa475tDmoAiBWshcXCOzQI/lQlxyry1vgxp/Zs2WQx7ze3OQrysNjAQ=="
          }
        ]
      },
      "maintainers": [
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.28.2_1530575705200_0.6932968758083442"
      },
      "_hasShrinkwrap": false
    },
    "0.29.0": {
      "name": "ts-json-schema-generator",
      "version": "0.29.0",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "./bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "licenses": [
        {
          "type": "MIT",
          "url": "http://www.opensource.org/licenses/mit-license.php"
        }
      ],
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=6.0.0"
      },
      "dependencies": {
        "commander": "~2.16.0",
        "glob": "~7.1.2",
        "json-stable-stringify": "^1.0.1",
        "ts-node": "^7.0.0",
        "typescript": "~2.9.2"
      },
      "devDependencies": {
        "@types/assertion-error": "^1.1.0",
        "@types/chai": "^4.1.4",
        "@types/glob": "^5.0.35",
        "@types/json-stable-stringify": "^1.0.32",
        "@types/mocha": "^5.2.4",
        "@types/node": "^10.5.1",
        "ajv": "~6.5.2",
        "chai": "~4.1.2",
        "jest": "^23.2.0",
        "source-map-support": "~0.5.6",
        "ts-jest": "^23.0.0",
        "tslint": "~5.10.0"
      },
      "scripts": {
        "prepublishOnly": "npm run build",
        "preversion": "npm run lint",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "tslint -p .",
        "test": "jest test/ --verbose",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts"
      },
      "jest": {
        "transform": {
          "^.+\\.tsx?$": "ts-jest"
        },
        "testRegex": "(/__tests__/.*|(\\.|/)(test|spec))\\.(jsx?|tsx?)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "jsx",
          "json",
          "node"
        ],
        "testPathIgnorePatterns": [
          "node_modules",
          "test-runtime",
          "<rootDir>/build",
          "_site",
          "src"
        ],
        "coverageDirectory": "./coverage/",
        "collectCoverage": false
      },
      "gitHead": "d2558933ba3af4924968fb0388c5b9b3fef18049",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.29.0",
      "_npmVersion": "6.1.0",
      "_nodeVersion": "10.6.0",
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "dist": {
        "integrity": "sha512-ZtoiahhTReLZx3RBb7JQW9kYYdKYc7uMmcFqYbpvFaNP2W/ASUk0T3WsMjNLtI3LexYGyfRiWIDuTIy91BjXlg==",
        "shasum": "c70c5f9791241a1a4e6ba0d1d0ae62fa2bea1e77",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.29.0.tgz",
        "fileCount": 326,
        "unpackedSize": 380415,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJbQBKvCRA9TVsSAnZWagAAXsQP/2BBkZ58A2xS/hFsxlc/\ndkAFC2z1UTT72D8v7E1FKUYWdukiQuHAisJcK2qdnBIk6bD+HNlSkB4zCghR\niqboYgUelMWoRDJAzuwkEo4ZlEeCEOgJDJFxq7FbNGxsiODV8czTcJi8sFLn\nuqewy9WgwvMX5W6/PohwHXNFwdNm3qSi54wV3jazrj0JlzSNIbmTVPd7TXvT\nEbsU+TAHyUNxriShWPu8ZJ5GlKrN3RY/9yW1HFpumQsgeVjFPNnNZhK5fUGj\n9dgZTPR5OiZtCc3D9qfH5zRtX1haBsgqKZFkFmSyvZ4BFjjGWV3um5pS3Em1\nUYP9nu3HZwQeDuY4YsC15sEM81uwMi4Vb+ZJjTH952JIsvKXX6J7zc/WFiDz\n9NYkJV+cy1weT8m23Og554JYy7JQeGyQpUnJP94pID8OpmpkIl/SQRT3SbG7\nmaWFDGaOu16x8sDEBllmJt4UZf2YLojSIxWVD2VCN7DnCoD2muVOWMLJHEgM\n7OZYwoI1qpLbG+F6fI7o37m1o7o9j+NoxSnd5zOVcRN61hFUQPz5ELKMMX1u\n3Mmvanx53yEqjiQr+ZALqQkh2yVqyJnnWaiBXVZlx2Tgl1xr8WEvw0GWEKbV\nApLocSC3p5eUnjA1ZBzyAC3MelFXaWqLYT44u311WpwQ8jq1RDwJrhy7dQPp\nU0cw\r\n=j4gi\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEQCIAvtJ7GKzlebdUSoFEYgmFEe0U6SDOcK4PYuCGBp5CCJAiA6HBrjjDQjrgjUK4P5MH4WgCMZcu0qcj3xMleh0nSSZg=="
          }
        ]
      },
      "maintainers": [
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.29.0_1530925743207_0.7630143689862883"
      },
      "_hasShrinkwrap": false
    },
    "0.30.0": {
      "name": "ts-json-schema-generator",
      "version": "0.30.0",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "./bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "licenses": [
        {
          "type": "MIT",
          "url": "http://www.opensource.org/licenses/mit-license.php"
        }
      ],
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=6.0.0"
      },
      "dependencies": {
        "commander": "~2.16.0",
        "glob": "~7.1.2",
        "json-stable-stringify": "^1.0.1",
        "typescript": "~2.9.2"
      },
      "devDependencies": {
        "@types/assertion-error": "^1.1.0",
        "@types/chai": "^4.1.4",
        "@types/glob": "^5.0.35",
        "@types/json-stable-stringify": "^1.0.32",
        "@types/mocha": "^5.2.4",
        "@types/node": "^10.5.1",
        "ajv": "~6.5.2",
        "chai": "~4.1.2",
        "jest": "^23.2.0",
        "source-map-support": "~0.5.6",
        "ts-jest": "^23.0.0",
        "ts-node": "^7.0.0",
        "tslint": "~5.10.0"
      },
      "scripts": {
        "prepublishOnly": "npm run build",
        "preversion": "npm run lint",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "tslint -p .",
        "test": "jest test/ --verbose",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts"
      },
      "jest": {
        "transform": {
          "^.+\\.tsx?$": "ts-jest"
        },
        "testRegex": "(/__tests__/.*|(\\.|/)(test|spec))\\.(jsx?|tsx?)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "jsx",
          "json",
          "node"
        ],
        "testPathIgnorePatterns": [
          "node_modules",
          "test-runtime",
          "<rootDir>/build",
          "_site",
          "src"
        ],
        "coverageDirectory": "./coverage/",
        "collectCoverage": false
      },
      "gitHead": "57ee52b69ada2c364ed3a349767dae85c458c114",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.30.0",
      "_npmVersion": "6.1.0",
      "_nodeVersion": "10.7.0",
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "dist": {
        "integrity": "sha512-7iqkQaD0sW6J1NsmxuldN1cNJq3e6W9xLjAmrSqSPIK24zDzN0ItugjcurzW0N2EC9w9JqXuglmODRpLomKmJg==",
        "shasum": "8224d56f0d644078248c85bd55fb8dce5edc43ae",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.30.0.tgz",
        "fileCount": 326,
        "unpackedSize": 381125,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJbV3kkCRA9TVsSAnZWagAAfyoP/R/YI4ljUaEcHTmF9xLD\nBluS183uOVwq+oiRLT7uGnWPlxRl+nZ/BfI7+rJY+F0x1IHwr8SIjYxTWihf\ndKIzm3giUWdGEPAkYNPSEwfeE0XBWGXE28RnqBNKU6/DOsgz1qalhavr+ewQ\ntvm+iZvhDEr9qkEtH27xnb9uQkAiN1BbV1X/vZpTB+C1ez6t6HazV7/dAgrL\nAVN0cgvqt+idNLYEAee11uyJKyV1P8xk5BAArgJAFY3LfJJN3v79NvIH2jiG\nGW6cBIdXdGdUEq1i0WuL6A0rl9wzqUUmRPX5LeAO4oSWM27LNLiBfvzpKkKD\n/L2TBY4jwo2M1gaU/YvTMDuanRIPkY1lqHbdlQGzRIaPtcAXgpU3W/cLuw2K\nRR9JA6Lgy9SSDrVb0Rxb3e2y4tLCsjcCCvWr2TRTPxQOAyvwQA3NKo603T4R\nmI1R6VKMptkzn8yeORtC6jNEioFM5kTB92lxJuBTCr4vQH6W/bSDmueaVQ8E\nTUR7hxZlEYvEOEB6L7Oz1A4HBiSjpiwbh9WJJuAbHZ6/hW7QAHrvS8oUKkDV\n7vQcCMU2FvGRpmh6wQU5BQNpKzGxmbzgE7RmzK2z/4I9cI2tgXb+9vHSli8f\nhM0M02h2DnpCCY0SfKTR99FFRu1lqCUe2xAv961B2g9zjrazhCBSdODzntev\nbR2j\r\n=/AlF\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIQC+UiBKPVawXQThO46ZX/0G+zGLILw07hcM/ZS+3+vD1QIgHM0fcc96nCZqzEDTSJbIvuhzl2NNKnUZ7x6W7IK0rsI="
          }
        ]
      },
      "maintainers": [
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.30.0_1532459300308_0.7536238827499646"
      },
      "_hasShrinkwrap": false
    },
    "0.31.0": {
      "name": "ts-json-schema-generator",
      "version": "0.31.0",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "./bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "licenses": [
        {
          "type": "MIT",
          "url": "http://www.opensource.org/licenses/mit-license.php"
        }
      ],
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=6.0.0"
      },
      "dependencies": {
        "commander": "~2.16.0",
        "glob": "~7.1.2",
        "json-stable-stringify": "^1.0.1",
        "typescript": "~3.0.1"
      },
      "devDependencies": {
        "@types/assertion-error": "^1.1.0",
        "@types/chai": "^4.1.4",
        "@types/glob": "^5.0.35",
        "@types/json-stable-stringify": "^1.0.32",
        "@types/mocha": "^5.2.5",
        "@types/node": "^10.5.4",
        "ajv": "~6.5.2",
        "chai": "~4.1.2",
        "jest": "^23.4.2",
        "source-map-support": "~0.5.6",
        "ts-jest": "^23.0.1",
        "ts-node": "^7.0.0",
        "tslint": "~5.11.0"
      },
      "scripts": {
        "prepublishOnly": "npm run build",
        "preversion": "npm run lint",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "tslint -p .",
        "test": "jest test/ --verbose",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts"
      },
      "jest": {
        "transform": {
          "^.+\\.tsx?$": "ts-jest"
        },
        "testRegex": "(/__tests__/.*|(\\.|/)(test|spec))\\.(jsx?|tsx?)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "jsx",
          "json",
          "node"
        ],
        "testPathIgnorePatterns": [
          "node_modules",
          "test-runtime",
          "<rootDir>/build",
          "_site",
          "src"
        ],
        "coverageDirectory": "./coverage/",
        "collectCoverage": false
      },
      "gitHead": "a4e9bc7981e0ccb411c39fa2fff353a566132506",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.31.0",
      "_npmVersion": "6.1.0",
      "_nodeVersion": "10.7.0",
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "dist": {
        "integrity": "sha512-mYYQRf+wpzxb6sZbmw/XEkPxaTCffGVB/ORrHkysTBy74pEYKXmeuwV+A8CsQbTY5udFnwWEKONoQG5rCgFAcw==",
        "shasum": "549553475cc6506d2f1468785cd3607ca5ff01bc",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.31.0.tgz",
        "fileCount": 326,
        "unpackedSize": 381368,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJbX1UJCRA9TVsSAnZWagAAwb4P/1gv21Yo0CFjvr/hLgRw\nlYN0tLHnKRPJv5lFAmSNW6Wa/hbWWVAhxSIKNIzM42YsdtbnNwH7YNU1iVON\n5nCoS3LYIaDM5xF7WbGVwuf2W798dLtr4tv7f8JZ17g9lwQLha24lIUvZXHW\nnoU+TEG7703bzXSFYmZMYFUhybsxnBepvE8VWOYzMEjHQDMrKlnCKA8JeRIY\nLfR+NuVqNBn1u3TrSurZKf4sRsL32qn3quvaNXsTi47VJ7ipKa0s3HwGW3o1\n+0uuthbE6wiM0i07WzKY6w0ClnxfsNDCjsf5jg5tysaedGLEQoWfWTRQzpM3\nlQZ3NremMX+i6F70ukfRPCbiNmEQRBfjA91K0pSKxPe+zquWWehiT0tuDB5p\neJTBJgtSCoBhPp0vITQAxjZGzK5QzhVqsJHpmufETytg60HALm57/I+5mCZ2\nLTGxKs5VeMy+0zI87bsDCEfhEQyGOfZBH9tpGa2KJJX0hwfitVK30PajOGAT\nK7nAdt6PmC2pLxPN3Jgj/h+M5IYF5Y/g1ZSLePnN7weaHnEnL2Mc5ra4+IEh\nfE8C7GZ4EySTuIZsQlv5LDc7hQhvgJt/4bjVTJbzPlmelIqbGuV8a8Nry0ej\n2gUEgiayBAg1l+zfGPjpqS4HRXeJkScCl1On8FeGANQus7qSMDhE6duXgDxE\n0LtN\r\n=+kkE\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIQChwhOVGkYxOx2kuSV6Sz9Z99O3mwE8I6r13vHekw4XIQIgcizuxExDI4yShVWAL93niTtXQx5oryRibZa366HGwmI="
          }
        ]
      },
      "maintainers": [
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.31.0_1532974345253_0.36778224932386405"
      },
      "_hasShrinkwrap": false
    },
    "0.32.0": {
      "name": "ts-json-schema-generator",
      "version": "0.32.0",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "./bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "licenses": [
        {
          "type": "MIT",
          "url": "http://www.opensource.org/licenses/mit-license.php"
        }
      ],
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=6.0.0"
      },
      "dependencies": {
        "commander": "~2.16.0",
        "glob": "~7.1.2",
        "json-stable-stringify": "^1.0.1",
        "typescript": "~3.0.1"
      },
      "devDependencies": {
        "@types/assertion-error": "^1.1.0",
        "@types/chai": "^4.1.4",
        "@types/glob": "^5.0.35",
        "@types/json-stable-stringify": "^1.0.32",
        "@types/mocha": "^5.2.5",
        "@types/node": "^10.5.4",
        "ajv": "~6.5.2",
        "chai": "~4.1.2",
        "jest": "^23.4.2",
        "source-map-support": "~0.5.6",
        "ts-jest": "^23.0.1",
        "ts-node": "^7.0.0",
        "tslint": "~5.11.0"
      },
      "scripts": {
        "prepublishOnly": "npm run build",
        "preversion": "npm run lint",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "tslint -p .",
        "test": "jest test/ --verbose",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts"
      },
      "jest": {
        "transform": {
          "^.+\\.tsx?$": "ts-jest"
        },
        "testRegex": "(/__tests__/.*|(\\.|/)(test|spec))\\.(jsx?|tsx?)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "jsx",
          "json",
          "node"
        ],
        "testPathIgnorePatterns": [
          "node_modules",
          "test-runtime",
          "<rootDir>/build",
          "_site",
          "src"
        ],
        "coverageDirectory": "./coverage/",
        "collectCoverage": false,
        "testEnvironment": "node"
      },
      "gitHead": "82d7653a7ac2166ce393d8a0224838e18d970d01",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.32.0",
      "_npmVersion": "6.2.0",
      "_nodeVersion": "10.7.0",
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "dist": {
        "integrity": "sha512-bDaTiJuFRTq0TlvOTtfWe2s4bCI22X+SuM2KY4vlOZzQllkESisfyGwiPNj0WqLgpcworYdZTe4utYM7QLzbxQ==",
        "shasum": "dc571b591d497b218666790221afe0de36b082c4",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.32.0.tgz",
        "fileCount": 345,
        "unpackedSize": 392478,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJbYytJCRA9TVsSAnZWagAAc4oP/0eBBOqs1GWa91pVAAEa\nMdzl33Nqp+7ymtmsb92Z7C9rKre2rN82seGw75T6us5scU1aPG0ZefXF01jF\n6KFEim0xp1aKLwzbmiMjSJRcTrqA8QbKBOic3TdS5Ynz/LBB2mvq+zGJQgt6\nGtI+MDgBYAv4nAKK+4DnEMQIJGqfVxn049dTs4CY1d+dTAHoRYyJJU3h0X+r\nVYgZbeG7FuFkgQOt/luCEqJTqgoi8ZPiWRBcfH+D3DvbeH4G05frBoc89MLy\nM/vkUUjcWLpZ5OMCITTduMxH7T3Px43faqZXFtRykt8nA8/PYPrrgmofczGx\nO6vi/XYwTBFTHZf+p98gDBj4Iye36nXOjRfBPNtd1KysVaTvHdkhFUFxtT2N\nHVgbcBmO0Qy8ZGXZkK/6v90dqNxlYtbACnyUXFDszvbaj4G6a0v+OS+hqjVD\n3Jy8oOX7jnfv/pVzC1OyUXanbe9rWBixOpxwbmULMrOzo15i2vZkaQtuWlhv\nM+lRki+a1B7GeeoKo6moe4tD71KYeUaYxz6tXDHMN+8WLpg8zZPRabp4x/YI\ni0xj8J30eSmjpCkwuSm/M+lsCcYaLHTEMD2rDvPYmCecRUVLHg6fo9DWKPqE\nvhD92inIpiZTfi3bnxA7yyC17bw0SfzWUSV9fy8e1119RLr0TnyAZhUUeIPE\nX1wD\r\n=TTww\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIEqZv9U2bpitQJEpai46yLtRskPNlJ4FmV70aYgfDuyhAiEAwmuFGLI/qNWdBcePQqM9y62YOTkG0GOmTGI/ZJ7RrUw="
          }
        ]
      },
      "maintainers": [
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.32.0_1533225800539_0.590726857254732"
      },
      "_hasShrinkwrap": false
    },
    "0.33.0": {
      "name": "ts-json-schema-generator",
      "version": "0.33.0",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "./bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "licenses": [
        {
          "type": "MIT",
          "url": "http://www.opensource.org/licenses/mit-license.php"
        }
      ],
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=6.0.0"
      },
      "dependencies": {
        "commander": "~2.18.0",
        "glob": "~7.1.3",
        "json-stable-stringify": "^1.0.1",
        "typescript": "next"
      },
      "devDependencies": {
        "@types/assertion-error": "^1.1.0",
        "@types/chai": "^4.1.4",
        "@types/glob": "^5.0.35",
        "@types/json-stable-stringify": "^1.0.32",
        "@types/mocha": "^5.2.5",
        "@types/node": "^10.9.4",
        "ajv": "~6.5.3",
        "chai": "~4.1.2",
        "jest": "^23.5.0",
        "source-map-support": "~0.5.9",
        "ts-jest": "^23.1.4",
        "ts-node": "^7.0.1",
        "tslint": "~5.11.0"
      },
      "scripts": {
        "prepublishOnly": "npm run build",
        "preversion": "npm run lint",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "tslint -p .",
        "test": "jest test/ --verbose",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts"
      },
      "jest": {
        "transform": {
          "^.+\\.tsx?$": "ts-jest"
        },
        "testRegex": "(/__tests__/.*|(\\.|/)(test|spec))\\.(jsx?|tsx?)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "jsx",
          "json",
          "node"
        ],
        "testPathIgnorePatterns": [
          "node_modules",
          "test-runtime",
          "<rootDir>/build",
          "_site",
          "src"
        ],
        "coverageDirectory": "./coverage/",
        "collectCoverage": false,
        "testEnvironment": "node"
      },
      "gitHead": "44813cdc0a8b3a2cbc7e646a414c1f3d99427e86",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.33.0",
      "_npmVersion": "6.4.1",
      "_nodeVersion": "10.10.0",
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "dist": {
        "integrity": "sha512-wwu53NCfhQse4Msy3Oqq0QJX9gAaAIkN7BDYNrF/HTLMgBqX8JUypf5im5IZaWrBXRx3DVdokBFRvgioWcKNHQ==",
        "shasum": "6793b022f38b65581e75a4dfe1e33c69b20e9445",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.33.0.tgz",
        "fileCount": 344,
        "unpackedSize": 383185,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJbkwp7CRA9TVsSAnZWagAA7wAP+QAZfIjkSjkCvZeaffUj\nl8TQulMXIAmz8O22xvTxC/Uh7KqeLe64nr7E4oqofHidJsJmKrb4x8kntjl7\nEBlOuSIUlEXD+Xcpt7irFDVF4Hl2E+Diodk2YuNh5NuTjxnxQ1rHmdU/opTe\n0RX4qJP0gOvuRRxQLORmfr7D9XWIA8TBFz+u3bm0qD8OTl1s83XfBiguH9Xs\n5ekq39gsOOFT/iS65BVzgd+JZTDhxRFzieX7PWkU7m/fkXyXLyYmEJlHp+Eg\npOg/v0DuC1OQMzQQdnHsXJNyiJRvaaAW9M8tupTY5+7UkwV/u5vhaYzONZMt\nU/a7FVEoBwpD7kXyg0cZ8OyFYPF1lpiJQbS7VDXp2h9blT2m8YFHqRVHlpmv\nsWSXhbfWOyq3msz+hzRmH7Q8WOS57trcgKrs8lEirHcv3STWwPZUP6UxNs8a\ngBPUWoQfwMfXqa1MEqZOYoAlhquXr6sZJ26D7UALO/5T/Sh7iGd2PBKkvn6X\nKeREvrHJMZ3WjEgpB9dUmzyd8NZr38rEVVAoQVhEulRvzp7/hfXJzuBfDPZX\n1ab1JsKuhBlOVblsBTClhT4Feg7BWAW5B0v3+m+93Ep8x/hzh8lcvDZVOp7d\nMcAMEiz4zmR2bMYaEKvEj+z1p7X5BAPQpTGnzu9vV2bUOg1s9zol/cecVxna\nJ3VR\r\n=sw4N\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEYCIQCIKniB6yDB/XZ5PqBWqdbzVRif1mlmnRrnbYJuZI1I1AIhAM1DOc48CWIbHQrfOTnB8790BRspNy7UnHolfGtUJk4q"
          }
        ]
      },
      "maintainers": [
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.33.0_1536363130766_0.7650694656857113"
      },
      "_hasShrinkwrap": false
    },
    "0.34.0": {
      "name": "ts-json-schema-generator",
      "version": "0.34.0",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "./bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "licenses": [
        {
          "type": "MIT",
          "url": "http://www.opensource.org/licenses/mit-license.php"
        }
      ],
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=6.0.0"
      },
      "dependencies": {
        "commander": "~2.18.0",
        "glob": "~7.1.3",
        "json-stable-stringify": "^1.0.1",
        "typescript": "rc"
      },
      "devDependencies": {
        "@types/assertion-error": "^1.1.0",
        "@types/chai": "^4.1.5",
        "@types/glob": "^7.1.0",
        "@types/json-stable-stringify": "^1.0.32",
        "@types/mocha": "^5.2.5",
        "@types/node": "^10.11.0",
        "ajv": "~6.5.4",
        "chai": "~4.1.2",
        "jest": "^23.6.0",
        "source-map-support": "~0.5.9",
        "ts-jest": "^23.10.1",
        "ts-node": "^7.0.1",
        "tslint": "~5.11.0"
      },
      "scripts": {
        "prepublishOnly": "npm run build",
        "preversion": "npm run lint",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "tslint -p .",
        "test": "jest test/ --verbose",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts"
      },
      "jest": {
        "transform": {
          "^.+\\.tsx?$": "ts-jest"
        },
        "testRegex": "(/__tests__/.*|(\\.|/)(test|spec))\\.(jsx?|tsx?)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "jsx",
          "json",
          "node"
        ],
        "testPathIgnorePatterns": [
          "node_modules",
          "test-runtime",
          "<rootDir>/build",
          "_site",
          "src"
        ],
        "coverageDirectory": "./coverage/",
        "collectCoverage": false,
        "testEnvironment": "node"
      },
      "gitHead": "7480efa1c3fbb571c966f442eb3712f865eb4092",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.34.0",
      "_npmVersion": "6.4.1",
      "_nodeVersion": "10.11.0",
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "dist": {
        "integrity": "sha512-FM02iwtNIevm0Qu/wcam8f1/Dg2/zFhfLI/mueU8hBk9EDn/BC5rT7eZBGcE0JSkK8xtMFMRyP8w+3TnJO2baA==",
        "shasum": "58aefa83025dd0cee8febbaef01d9f2063407b5b",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.34.0.tgz",
        "fileCount": 344,
        "unpackedSize": 380603,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJbqXHoCRA9TVsSAnZWagAAsyQP/29as39OPJ7HdlySDKBr\nymDoDSjOzrSjsm0DmP6TtJAFgW6OSSSyWCKNXnvyaPr+0zfpRhZQDrCgoF4a\nsMLuuLbJ77+2jAPHmzVDDmz2//4s6//Cq271Pv2mXi7tGdqMrzwk/Rq6ZIAm\n29Aycgo9rXpDQCTiD7up65iJf8qsgza5Zsi4DlR+3Ct/+OgEMCB55VLjkWjD\n4LZzFbCvq0dcq1ponZvUKcyQ//P1KdlrokM9oLy1nEeVYJetUCWalCa4l6Bv\nAyq4Yq20cV7zdkJ+gZlnHee/yciyw+omTqQRoJvWQPndMicltm5ABwc2rhhh\ne6wn0l24q2ui6E6TcdpXknqDBUeyxNQamT0YaKzBVv5zPNslJSRWCAQG3AsD\n7L+q5nuwdwLgYdJ3mke+l4EqY+JjuOEb6YOFBHnVDmOWbeMuQAnOcUnBbpg6\nQ6I8T9p9C11V1gy8f19fyEmuXxdwS8tSUMRG1mN8TqTlKw6tx1SHy3z7G7HS\n2LymfBJQxIKEDlRwKIdf347GzwW0aTRNJzRI5Xp/YDQQmsUtdz2svCy4j7Ok\ne26sWwUK2qswjUdiClp5Rhu4k0l8u4Jc43aQtrafB9BFNQHCGSXVeT97b7sC\niOrD90iWijOBNHNX8hVGWNPJbXNYLB2E94wFlGpBfwiYb9isAIqd+JaY4nvO\nMDHI\r\n=L9AI\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIQDPGk4udfOy2rPwtx8+5QaVcD93pc9p7CAgfH7mxDdZEwIgcxIElbAzb854jGcWUfMQuLwQov+DETx3H4guT9ALK3I="
          }
        ]
      },
      "maintainers": [
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.34.0_1537831399346_0.6789284491148888"
      },
      "_hasShrinkwrap": false
    },
    "0.35.0": {
      "name": "ts-json-schema-generator",
      "version": "0.35.0",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "./bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "licenses": [
        {
          "type": "MIT",
          "url": "http://www.opensource.org/licenses/mit-license.php"
        }
      ],
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=6.0.0"
      },
      "dependencies": {
        "commander": "~2.18.0",
        "glob": "~7.1.3",
        "json-stable-stringify": "^1.0.1",
        "typescript": "rc"
      },
      "devDependencies": {
        "@types/assertion-error": "^1.1.0",
        "@types/chai": "^4.1.5",
        "@types/glob": "^7.1.0",
        "@types/json-stable-stringify": "^1.0.32",
        "@types/mocha": "^5.2.5",
        "@types/node": "10.9.4",
        "ajv": "~6.5.4",
        "chai": "~4.1.2",
        "jest": "^23.6.0",
        "source-map-support": "~0.5.9",
        "ts-jest": "^23.10.1",
        "ts-node": "^7.0.1",
        "tslint": "~5.11.0"
      },
      "scripts": {
        "prepublishOnly": "npm run build",
        "preversion": "npm run lint",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "tslint -p .",
        "test": "jest test/ --verbose",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts"
      },
      "jest": {
        "transform": {
          "^.+\\.tsx?$": "ts-jest"
        },
        "testRegex": "(/__tests__/.*|(\\.|/)(test|spec))\\.(jsx?|tsx?)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "jsx",
          "json",
          "node"
        ],
        "testPathIgnorePatterns": [
          "node_modules",
          "test-runtime",
          "<rootDir>/build",
          "_site",
          "src"
        ],
        "coverageDirectory": "./coverage/",
        "collectCoverage": false,
        "testEnvironment": "node"
      },
      "gitHead": "c0f13a0c8aa01a4bba22c0e46de33585677a39b0",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.35.0",
      "_npmVersion": "6.4.1",
      "_nodeVersion": "10.11.0",
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "dist": {
        "integrity": "sha512-DqQN1gRmV1pEYKs7Uk9SdRHP+m4xxjrFptpiz+67/y7Tp2Zk/MdV7db50aCVQcaZd39jUpwdl53zMeRpBBYApw==",
        "shasum": "44bde42eb5578a96695d12b952c39db96d797af9",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.35.0.tgz",
        "fileCount": 344,
        "unpackedSize": 380732,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJbqXipCRA9TVsSAnZWagAAjMIP/0QxDPTQG8MWMlrJP+h6\nca84523LXNRdFPAdjyY85y67X+AuRGa4t5FJfxqMqEiu6o9LABxLSIRV8zlh\nLzNIIc9nx7RcXGvmmSxr+zg+et8yFzkooYTSAVbeLz79XVfekd7Ox9EFJYCZ\nMyKPkHnMy0Qu7/HLRHpIIdLyf1bUdcEpk6w1BdOetiF3xD4/q/khvowrUBn5\nlFTVNdbQfo4j7EsNLt1hGuQJ6iMEI5hrUew4+TMaB9DQXxiiMjLkXazuHxzV\no/xbebS2Wmss/SL6qFwpGUh1XVXrJpchiD8BZzVlj1m68iZrTMxgPKBzLul/\n2quKsaxCRgUaJF2O5p6CFnMOh5jzPAIGtkynprHtK5y1+0Jjs39sDVCWV7K1\nthTfb79wDzd9GjHUw8ML0gH1HVQh/+btzQXPNP7upQLnCXIL3B1uZIqrLaxk\naNf3OgGgyD/s6ZWazPQKz2SRqGjiJyzj/2GC0jpkyDJ+cdule3Rc2W0MqfpP\n27+TVBE7IORXBmBJBBpcQG+/UediKVPq/CGLAD2V9RDEYS49/POXIFgmJhez\nGny257WQOiEwKR11ADtLXROU6IzghmOgl7Z6mfACgjKqTFqsKyrclMRUHI3C\n3KfP+ZOtVyTrdpWvqFtesZtHeXsxI1SwXupoGMWJKgGNtKbDdKjkVmRp6SGu\nZTkT\r\n=7rE1\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCICxU+9ZTsKleKzRdr725VOr5MwamfIoD6LvgwwJXL+EpAiEAiqWFo8TiwF6KvjjSbHpP7WqRBQe0xpimIOzUqEhGzJQ="
          }
        ]
      },
      "maintainers": [
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.35.0_1537833128706_0.6006609473776601"
      },
      "_hasShrinkwrap": false
    },
    "0.35.1": {
      "name": "ts-json-schema-generator",
      "version": "0.35.1",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "./bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "licenses": [
        {
          "type": "MIT",
          "url": "http://www.opensource.org/licenses/mit-license.php"
        }
      ],
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=6.0.0"
      },
      "dependencies": {
        "commander": "~2.18.0",
        "glob": "~7.1.3",
        "json-stable-stringify": "^1.0.1",
        "typescript": "^3.1.1"
      },
      "devDependencies": {
        "@types/assertion-error": "^1.1.0",
        "@types/chai": "^4.1.5",
        "@types/glob": "^7.1.1",
        "@types/json-stable-stringify": "^1.0.32",
        "@types/mocha": "^5.2.5",
        "@types/node": "10.9.4",
        "ajv": "~6.5.4",
        "chai": "~4.2.0",
        "jest": "^23.6.0",
        "source-map-support": "~0.5.9",
        "ts-jest": "^23.10.2",
        "ts-node": "^7.0.1",
        "tslint": "~5.11.0"
      },
      "scripts": {
        "prepublishOnly": "npm run build",
        "preversion": "npm run lint",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "tslint -p .",
        "test": "jest test/ --verbose",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts"
      },
      "jest": {
        "transform": {
          "^.+\\.tsx?$": "ts-jest"
        },
        "testRegex": "(/__tests__/.*|(\\.|/)(test|spec))\\.(jsx?|tsx?)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "jsx",
          "json",
          "node"
        ],
        "testPathIgnorePatterns": [
          "node_modules",
          "test-runtime",
          "<rootDir>/build",
          "_site",
          "src"
        ],
        "coverageDirectory": "./coverage/",
        "collectCoverage": false,
        "testEnvironment": "node"
      },
      "gitHead": "adfe7eb90f66a8dcc63ad8b9a767ca0e8e59db1d",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.35.1",
      "_npmVersion": "6.4.1",
      "_nodeVersion": "10.11.0",
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "dist": {
        "integrity": "sha512-VVJ39ZBCRsMUk9ok9kep0AXiTp1i4ucDlMMZu0/2C7E7fYjjmMwMZADlbjEzpXFqV+xTbluGG++es2RlMBFnsg==",
        "shasum": "9e4d25fb5da29eace3136fb04ef4d371c68931fb",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.35.1.tgz",
        "fileCount": 344,
        "unpackedSize": 380736,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJbrT8RCRA9TVsSAnZWagAAZ68P/1ZwuuVSUt5NyOBOTaQ9\nuFUhCsvG/0d78hCtzLQq9AoIBvoilsBqiao7HZNMi1KlGA+0Dt2Pd7mWMnTD\n/Y3z+M5thVFRE2JiY0pd7JIpwmwN/qxNtzkT8+zjNP/QTb6LT92+IHj+DPrk\nVDKC3Upku2HLNKb2sOnf2B/6a6ylUx5Y9Ztglt2tcNME/sSw3cGoD25ioiTa\nMqHCFHB66LErYVnEvJ8LAx4Ip8UApsNPZVGX24rPoRkVaNx8oX5oMnwzqhCI\nawVE70Heqc1iY4hLkEONp3bNDT9KWvxGmmfcxsTqg97QFBDb1cM6xYtB837o\ndioi+ObxLMEyonKSpgV5sVx1cHY6PfW6a0HD5R2mRv4yVxx+F25tojTm7XQG\nSJt/pD7LS0r8pgYkFA9RL3ne/L378VUuxJnjdsq8vGrOykqovZ2BYZgJsiaC\nMOcu9uVE5UvQ6hafw5W6MEftt/UfAQQ7PmnrSz8hexy4c2Xeqw9lkyNKGVA6\nrROsv+qqnXy1W6xIwbvkvRTaAO0DKNRtMJ8zd5XPNsx8tR2+cIp1kbDYPrLn\nlbp5n/TofVv4jq2eVZdG51H7aS01Th03qWLfzUOaP81f1KKs3vTfggYPCY2g\nDnClYLl8ixbQPQFcMzhbwilJYUKrijNN254HjSwKyTHfmDxpoGhDMMfsVqwI\n1/8N\r\n=QurS\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIQCLkWYzznX7J0PIQ+e/8RL50DekXL2U6BqAKWKClnW6HQIgCFJmZ1uM8vwZRNYvKLJ3T7SpwXEv500hRAbA72mpINU="
          }
        ]
      },
      "maintainers": [
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.35.1_1538080528664_0.4300212592420889"
      },
      "_hasShrinkwrap": false
    },
    "0.36.0": {
      "name": "ts-json-schema-generator",
      "version": "0.36.0",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "./bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "licenses": [
        {
          "type": "MIT",
          "url": "http://www.opensource.org/licenses/mit-license.php"
        }
      ],
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=6.0.0"
      },
      "dependencies": {
        "commander": "~2.18.0",
        "glob": "~7.1.3",
        "json-stable-stringify": "^1.0.1",
        "typescript": "^3.1.1"
      },
      "devDependencies": {
        "@types/assertion-error": "^1.1.0",
        "@types/chai": "^4.1.5",
        "@types/glob": "^7.1.1",
        "@types/json-stable-stringify": "^1.0.32",
        "@types/mocha": "^5.2.5",
        "@types/node": "10.9.4",
        "ajv": "~6.5.4",
        "chai": "~4.2.0",
        "jest": "^23.6.0",
        "jest-junit": "^5.2.0",
        "source-map-support": "~0.5.9",
        "ts-jest": "^23.10.2",
        "ts-node": "^7.0.1",
        "tslint": "~5.11.0"
      },
      "scripts": {
        "prepublishOnly": "npm run build",
        "preversion": "npm run lint",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "tslint -p .",
        "test": "jest test/ --verbose",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts"
      },
      "jest": {
        "transform": {
          "^.+\\.tsx?$": "ts-jest"
        },
        "testRegex": "(/__tests__/.*|(\\.|/)(test|spec))\\.(jsx?|tsx?)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "jsx",
          "json",
          "node"
        ],
        "testPathIgnorePatterns": [
          "node_modules",
          "test-runtime",
          "<rootDir>/build",
          "_site",
          "src"
        ],
        "coverageReporters": [
          "html",
          "cobertura"
        ],
        "coverageDirectory": "./coverage/",
        "collectCoverage": false,
        "testEnvironment": "node"
      },
      "gitHead": "a69e495480735d3afe0a89f741b002390dd9f9e9",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.36.0",
      "_npmVersion": "6.4.1",
      "_nodeVersion": "10.12.0",
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "dist": {
        "integrity": "sha512-LeEzQn+eSiSdP1WwLb8nQziftiEQpBKsSR2z7ChyvopXl6+NJ3AAJgArNmO8lOEBHCD9h+4j1+vtCJnZThfWOw==",
        "shasum": "345919628697c2e9a9135c0649956a36efe71115",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.36.0.tgz",
        "fileCount": 345,
        "unpackedSize": 423052,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJbyt8YCRA9TVsSAnZWagAA76oP/0gV/Hp5bzmRHJCJ8Q0w\nxeh8ULaZqbigtHFBC8XV0nlnswcOvZLFQjsd0Mw4rDwrgIvLpLyW9t7jZz8y\noPsJRKHtUC0lfbHzSoEzrY1ksHMLyT+LHrvsRU9f9oEPmhFp2RLtEpzN16Xw\ndizM5l2bypghntUS9EvgKXslP/W2zeBrswjBwEbmdkHWnAE3GPROu4nOJFAk\nHnp5sG8EeicopBeVNs6h+UgPu1/e2i1qNDUyu3LpyAn1zN2bFQgUvngaiqrf\nj3a2xa8kl3tcJPYCMs4r6QfHlU2rNicwkTihb8AR+v/GhIaEE6WHJDoESKCW\nVTkbJXJT+z29fqzRoqiLjuw/CnzCAcv7xs4tB/EnFVD6MmfUkRvxTC+9s8Au\nKVDB6WP+KgE+8do1cNYLWCxQf19LjdEQBoHPL2a3JlVMBei2xem42pOv1Uqb\nDpAJI9wRSO7lVl7jqCitwnFkHVbXY4WUSuFCH2/p54d1Gv/J7w0duqB73wkH\nBVYD1o7XvNGf13lu1uOFWtrdWEJqpyq47R1t+FifF+zs7XlHVeCM43++2jQP\nQZhJFmzfI8ud79AiqEWxGC07Jssqh5QsZ4u5HlBoSJxtuwNFGBhBCiXxidro\n8GFb1w+Gat90rSEDyXiTjZgGaSZfE3AxFYXJY6H694DJ98NBKageEBmKz0D7\n7kyW\r\n=zHGN\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIQDBuVrqV2gGfL2xi1c0cAmTX6mzJW8LovxiuQtSEkY9VQIgFdo2K9v7UH7JQ5vuuifa9F13BROR6ehrOnEzQ4y8SUc="
          }
        ]
      },
      "maintainers": [
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.36.0_1540022039845_0.6603993043278831"
      },
      "_hasShrinkwrap": false
    },
    "0.36.3": {
      "name": "ts-json-schema-generator",
      "version": "0.36.3",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "./bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "licenses": [
        {
          "type": "MIT",
          "url": "http://www.opensource.org/licenses/mit-license.php"
        }
      ],
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=6.0.0"
      },
      "dependencies": {
        "commander": "~2.19.0",
        "glob": "~7.1.3",
        "json-stable-stringify": "^1.0.1",
        "typescript": "^3.1.6"
      },
      "devDependencies": {
        "@types/assertion-error": "^1.1.0",
        "@types/chai": "^4.1.7",
        "@types/glob": "^7.1.1",
        "@types/json-stable-stringify": "^1.0.32",
        "@types/mocha": "^5.2.5",
        "@types/node": "10.12.5",
        "ajv": "~6.5.5",
        "chai": "~4.2.0",
        "jest": "^23.6.0",
        "jest-junit": "^5.2.0",
        "source-map-support": "~0.5.9",
        "ts-jest": "^23.10.4",
        "ts-node": "^7.0.1",
        "tslint": "~5.11.0"
      },
      "scripts": {
        "prepublishOnly": "npm run build",
        "preversion": "npm run lint",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "tslint -p .",
        "test": "jest test/ --verbose",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts"
      },
      "jest": {
        "transform": {
          "^.+\\.tsx?$": "ts-jest"
        },
        "testRegex": "(/__tests__/.*|(\\.|/)(test|spec))\\.(jsx?|tsx?)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "jsx",
          "json",
          "node"
        ],
        "testPathIgnorePatterns": [
          "node_modules",
          "test-runtime",
          "<rootDir>/build",
          "_site",
          "src"
        ],
        "coverageReporters": [
          "html",
          "cobertura"
        ],
        "coverageDirectory": "./coverage/",
        "collectCoverage": false,
        "testEnvironment": "node"
      },
      "gitHead": "8de83da8f5645e8f86d8ccc0d74fcefef709dd39",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.36.3",
      "_npmVersion": "6.4.1",
      "_nodeVersion": "10.13.0",
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "dist": {
        "integrity": "sha512-XY6erlZjtcy1b/yuFSsDGQsiNIfLu0uro7h0V5F4VTgtarfcRcAaS9tafsUNBgjfZNX8H83pPyXbhU4R67HXMQ==",
        "shasum": "0af84c57c372bd1c9b77d0225a58de15288a2017",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.36.3.tgz",
        "fileCount": 346,
        "unpackedSize": 433822,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJb6diZCRA9TVsSAnZWagAA6JAP/i5D7ixvIz5fzj1pfNkK\nozDanMg+0xYIKFuHlGkUCzlKFMqMmcmnnGATJ14zkEXBgI2dZYooTdI7bhox\ns5IK68Ko50hB4zSA2EQ4TspQEtEWfqB7fRyteCTzbjbkkkQOsrVbZ5B+9Yp+\nqbBjVjmaMy0qm0m6g9pioY7beKyI0X4nbid68EMohLsYpAY39SHaCmNrVSez\nfAEVg7LAFWO50+5mXeZ5Cqt73QPn4c5rUGwvyq+Mf8RWPWfHWphYRJgjL0+s\ndsxscUqcYnNfJNoO6e+rerE6q3/SIIcuONjTeoVS+/OBvdQrAYxr84d4v+2F\nDXX0ZASOw25VLBiHmkndf0jlqToK+K6hADQfodMU64mcbLUGNwdyHHfxkukH\npPwnwb/azO0Qy0I5/5H2e+WXUVhO9fmaU29fV1wuMDhQ8QKhh/2HlFSmO2aX\nljpI4OJzd+RBIaedjRjIdwMxTC+HZuKa/0pyCM1OrAbiOL12DejT0cd0UVHA\noIcixkyTLbI4M+2chIIRYex6Mb3JUmFifZcHTEKrCLvoQjF7YhjqbUb1AKWM\nuYwsLWY0DZ9WzZYmvWXCShHzHb7JlbvUy0cjqDGeQnYZWGAg5To3OFF8LTeJ\naLBVptMNhhvXcAE5UAu+Pg5+xMzvk5A/7oE329cDNrMiM7HXfMmDIsYexsfO\nBqy1\r\n=Motm\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCICVXzuoLU0aNduxV6ZykMRwSK9LsI9cfa97swuB8iJNUAiEAwmp3S4sNdHAmoxf68gMlhWDy1VXQmD1n1Gfbgjznv18="
          }
        ]
      },
      "maintainers": [
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.36.3_1542051993281_0.005430510881476058"
      },
      "_hasShrinkwrap": false
    },
    "0.37.0": {
      "name": "ts-json-schema-generator",
      "version": "0.37.0",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "./bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "licenses": [
        {
          "type": "MIT",
          "url": "http://www.opensource.org/licenses/mit-license.php"
        }
      ],
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=6.0.0"
      },
      "dependencies": {
        "commander": "~2.19.0",
        "glob": "~7.1.3",
        "json-stable-stringify": "^1.0.1",
        "typescript": "^3.2.1"
      },
      "devDependencies": {
        "@types/assertion-error": "^1.1.0",
        "@types/chai": "^4.1.7",
        "@types/glob": "^7.1.1",
        "@types/json-stable-stringify": "^1.0.32",
        "@types/mocha": "^5.2.5",
        "@types/node": "10.12.12",
        "ajv": "~6.6.1",
        "chai": "~4.2.0",
        "jest": "^23.6.0",
        "jest-junit": "^5.2.0",
        "source-map-support": "~0.5.9",
        "ts-jest": "^23.10.5",
        "ts-node": "^7.0.1",
        "tslint": "~5.11.0"
      },
      "scripts": {
        "prepublishOnly": "npm run build",
        "preversion": "npm run lint",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "tslint -p .",
        "test": "jest test/ --verbose",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts"
      },
      "jest": {
        "transform": {
          "^.+\\.tsx?$": "ts-jest"
        },
        "testRegex": "(/__tests__/.*|(\\.|/)(test|spec))\\.(jsx?|tsx?)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "jsx",
          "json",
          "node"
        ],
        "testPathIgnorePatterns": [
          "node_modules",
          "test-runtime",
          "<rootDir>/build",
          "_site",
          "src"
        ],
        "coverageReporters": [
          "html",
          "cobertura"
        ],
        "coverageDirectory": "./coverage/",
        "collectCoverage": false,
        "testEnvironment": "node"
      },
      "gitHead": "bd1c45b2c47fe342d1f303097fa2529d4ac6dc81",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.37.0",
      "_npmVersion": "6.4.1",
      "_nodeVersion": "11.3.0",
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "dist": {
        "integrity": "sha512-Xv/JWwxy1UDep3YtlALdUHaF4h0OAEX08vPtq3jjkZupPUVe4Kd3SpZE9BwiBqAJw3uSG6d/VwyrnNUSz+N1fQ==",
        "shasum": "808f31c54b87cb351d97f2adec862aa05b708808",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.37.0.tgz",
        "fileCount": 346,
        "unpackedSize": 432608,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJcB0COCRA9TVsSAnZWagAAeJoP+gPgt4z6b+StGHWFj4Ck\nnLBgB3/WOyXvIRvvpb9Q6Oi0xfF50GozrpWC3uCgc3jfuDw+6S5tkozuVeFS\n6MB2mrxek2R3hvah359X+ZqzASZ26X8Zk4JbSAjtsBCL4sNT0KKZKUIwpidD\nyz5iRjhqJvhpsxJm4FNABieU9FI3f7PUFPATrw6uW0yatp5PCde4dMQw+qn+\nCbt45jxDRXBA42N9AVtEJt8EM8APpIkxTOpxo6m5G4pjx70Mp4bki82rUnsE\n8CDZf5T0MjiieWdrC+UXy8W8BQgtkCAfO9Dbpsi6Z0YaN98cVBnQusb6Otkp\nODOZZBO2lFaOnQ8sjFFxyrgIWlgYvKpAQwHDocI0FKZGrQKXhF42axTuZyIa\nW0mHM6JKiZQdwxWGkJ2cXxrOX69ZulDi5LZMw6UlaXD4gpdyh37bbjaOoKN0\nxjUd3NjR/CAVurjiqA4GL6L0StrW8R9vEeBd54HtcR7wPrbwDt/xihrORxqK\no7E1/EVGftWOiSTsMD/jYGmoF21ppKAakCiIluM5TB2SQSSyDEGPYO9aIqm5\nlQlzLVp5Bdcag8hFHV2cpp4IwvNLXCkn52yjuSfHWVKPFOMEdMI8A+XI8CXW\nnsjW6PgGGAbkVanQ+iIQilH7Bpc/EAZAeMi3pk8Jx9XWoSQZuQZAcswXbOtX\nfcKb\r\n=2n8J\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIAIbtGewhHF8uWTxK9HUd7dONsvIOo37ADrxW6PyTv99AiEAsyYgZzX87UMbdkDcox4RAqxxc+g5JwOCKdQc5U6qrnY="
          }
        ]
      },
      "maintainers": [
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.37.0_1543979149923_0.3238851124850195"
      },
      "_hasShrinkwrap": false
    },
    "0.37.1": {
      "name": "ts-json-schema-generator",
      "version": "0.37.1",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "./bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "licenses": [
        {
          "type": "MIT",
          "url": "http://www.opensource.org/licenses/mit-license.php"
        }
      ],
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=6.0.0"
      },
      "dependencies": {
        "commander": "~2.19.0",
        "glob": "~7.1.3",
        "json-stable-stringify": "^1.0.1",
        "typescript": "^3.2.2"
      },
      "devDependencies": {
        "@types/assertion-error": "^1.1.0",
        "@types/chai": "^4.1.7",
        "@types/glob": "^7.1.1",
        "@types/json-stable-stringify": "^1.0.32",
        "@types/mocha": "^5.2.5",
        "@types/node": "10.12.12",
        "ajv": "~6.6.1",
        "chai": "~4.2.0",
        "jest": "^23.6.0",
        "jest-junit": "^5.2.0",
        "source-map-support": "~0.5.9",
        "ts-jest": "^23.10.5",
        "ts-node": "^7.0.1",
        "tslint": "~5.11.0"
      },
      "scripts": {
        "prepublishOnly": "npm run build",
        "preversion": "npm run lint",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "tslint -p .",
        "test": "jest test/ --verbose",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts"
      },
      "jest": {
        "transform": {
          "^.+\\.tsx?$": "ts-jest"
        },
        "testRegex": "(/__tests__/.*|(\\.|/)(test|spec))\\.(jsx?|tsx?)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "jsx",
          "json",
          "node"
        ],
        "testPathIgnorePatterns": [
          "node_modules",
          "test-runtime",
          "<rootDir>/build",
          "_site",
          "src"
        ],
        "coverageReporters": [
          "html",
          "cobertura"
        ],
        "coverageDirectory": "./coverage/",
        "collectCoverage": false,
        "testEnvironment": "node"
      },
      "gitHead": "cc63e91ecf8fab8e5babdf1195bc0cea0e775ebe",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.37.1",
      "_npmVersion": "6.4.1",
      "_nodeVersion": "11.4.0",
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "dist": {
        "integrity": "sha512-fXTDJ/Saz6gHsJA7o5y6ltlVEQIfc9HOgfSn4lbuAPm+BnfLMJbce8ylQT3yCH8N9zbMqkF3ceOtcN8nxoINMA==",
        "shasum": "b85d7ad0821f9193cb57b6848bb96a57d8d90227",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.37.1.tgz",
        "fileCount": 346,
        "unpackedSize": 433341,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJcE/58CRA9TVsSAnZWagAAi1MP/R1WdrL01Q0KEvFpd6b9\nCIAJjNTtoelYjLfyH5zTA4JuCZnDpT66aD3AVck3OCNT36If1cKI6fyuMDwK\nWqyAdq0ljyHFMEyzmXA/xLPCFQRx6LePJs/bZoIcdh/w+DZmDYqtyOQ7FbfN\nFmim4h7jf03nhFheelKfW1vw38LBGT576PGW3drKOXhhbfIvCen2uVE8IyxR\nrY5cG/qnnqWjSUWRQfwiFfiRRjHcihmMHvRzzZuC0AplgeYDKMbLRqHavFat\nav9zKwJwL+kYGlDVNv6hJRH64gg9vh36t4KiJU+9njne8drDiG0ryUDMwSSm\nFKdmLcknfOFqM0ZbaF5hyNHULKhQyrFXMdnEtefuh1dCxFNA2V/78gqyliR2\nQLrHNi6piPg3AHBUtCDlAnwH6mKy5T7SJSkw6PPtYDFjDVRHonTl0cD5WExj\nCh99U9RcUOexeQIMEzyOCBi/U3r6QjcnnPiAuw1+TIfosGLnuKUhpH1jEPc8\nQ7zR7WKi7kfwZTaAr10ShDt7+gp2GEwTy21STj5D2aIvdRzCWKpj0q/FUH9a\nDolLkgLpkFbQOzrwwSZxPX3sKxRk2CgF9LZlXQDhxVnF0BEZrC17uUV7oXkX\n2lGui09xKPGTta31aor/1ml7YZou88dXJsZ54vt1Tv1WIHCuKZYD2jdnsChU\nscJE\r\n=bV+d\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEQCIExfVNvE4M4nxRNT6piCcN3qWawdTkrxU/4TC8BOmSkkAiBiVcT7VbhQyBfhwZTsKXIOfMylIuwOHwgjhFy8KX5LuA=="
          }
        ]
      },
      "maintainers": [
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.37.1_1544814203968_0.6006794916062783"
      },
      "_hasShrinkwrap": false
    },
    "0.38.0": {
      "name": "ts-json-schema-generator",
      "version": "0.38.0",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "./bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "licenses": [
        {
          "type": "MIT",
          "url": "http://www.opensource.org/licenses/mit-license.php"
        }
      ],
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=6.0.0"
      },
      "dependencies": {
        "commander": "~2.19.0",
        "glob": "~7.1.3",
        "json-stable-stringify": "^1.0.1",
        "typescript": "^3.2.2"
      },
      "devDependencies": {
        "@types/assertion-error": "^1.1.0",
        "@types/chai": "^4.1.7",
        "@types/glob": "^7.1.1",
        "@types/json-stable-stringify": "^1.0.32",
        "@types/mocha": "^5.2.5",
        "@types/node": "10.12.18",
        "ajv": "~6.6.2",
        "chai": "~4.2.0",
        "jest": "^23.6.0",
        "jest-junit": "^5.2.0",
        "source-map-support": "~0.5.9",
        "ts-jest": "^23.10.5",
        "ts-node": "^7.0.1",
        "tslint": "~5.12.0"
      },
      "scripts": {
        "prepublishOnly": "npm run build",
        "preversion": "npm run lint",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "tslint -p .",
        "test": "jest test/ --verbose",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts"
      },
      "jest": {
        "transform": {
          "^.+\\.tsx?$": "ts-jest"
        },
        "testRegex": "(/__tests__/.*|(\\.|/)(test|spec))\\.(jsx?|tsx?)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "jsx",
          "json",
          "node"
        ],
        "testPathIgnorePatterns": [
          "node_modules",
          "test-runtime",
          "<rootDir>/build",
          "_site",
          "src"
        ],
        "coverageReporters": [
          "html",
          "cobertura"
        ],
        "coverageDirectory": "./coverage/",
        "collectCoverage": false,
        "testEnvironment": "node"
      },
      "gitHead": "548c6e2904acd9df6de01fa62ebe2501652ec213",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.38.0",
      "_npmVersion": "6.4.1",
      "_nodeVersion": "11.5.0",
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "dist": {
        "integrity": "sha512-UamN+q864u5F2tDXPydX0bge8S4TLnUwpWn9zRG7Nchicc5FjsexKeeP7uJIVNSmqAUato0u4vUTDOqcZ6SREQ==",
        "shasum": "145518eaba20f99c5b5ad498845837795f72e817",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.38.0.tgz",
        "fileCount": 346,
        "unpackedSize": 433707,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJcGtOFCRA9TVsSAnZWagAA5JQP/jFb+yMxf1JAZ9XXTlTM\ndlJWuMmsuBOHxRYN6blALVFzRuQr7gjadwU+e0811LR25jPUHI2ZjCkAGFd/\nEobJjxkxHUa8vxu00KjFXOyQcXF2qNVDFmWR2AXxeUAC2YlUD6NkoQBURovQ\na7vfXj2A2lfRE6PlsjEZy5DT0CrlQfikbT+4NjEi/aqkZZiw5ZLfNysBvPDL\nBfHcmItxyjcxKOBF+DQfkUDSovcRVWy8VzgbsCW4BkWWAhUG/Y9hoh9UqM7j\n5L78Xp9LTEMI95hi3h5Kg7FHeff7N2gHofAH/G6YXFKsJVlv9Y28y1mwSTYG\nsYa3TW582yzWq7JNzrgs21IJfphAaqZUVWzMaSTeYwEzSwT2jwvf97uZvaXL\nxMUCcZIGWCxqp0orNbJEfIDTi0qwrNIcnu6CgmvDpZwsY99oxFZJIfLOx8ZG\n9sFTV+mMZDo8xU+7N0EskvfZmOjH8cAZzLWU6TtpDq/XQEWnUN/+peH6X3AY\nUeIJFMIOXoSM6V+i1jEw7qJH3Zuethwy/uEMJzTYVvSy00bJBrSJRWFPzxaB\n0HjI/N8MSkMUrGUal7g74la50IABX7NE/iSlFhMDpcykBHsg1T7TLJD7FPRu\nRowI1alOcYYPQ1Jzhc9qhnAWlUBdB/LAGVcA3n27oCrzJBr6QgaK30Etz5TS\nFq37\r\n=8jTU\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEQCIEU2w/X+re4Bx2/iCe47pRCxlemi6Ch4uVUciFHul+S8AiBjBQk4FyfJ6hI4hTCvYB5EPRe/LEkazk+gCSpEeEZTdA=="
          }
        ]
      },
      "maintainers": [
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.38.0_1545261956576_0.5424247538758034"
      },
      "_hasShrinkwrap": false
    },
    "0.38.1": {
      "name": "ts-json-schema-generator",
      "version": "0.38.1",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "./bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "licenses": [
        {
          "type": "MIT",
          "url": "http://www.opensource.org/licenses/mit-license.php"
        }
      ],
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=6.0.0"
      },
      "dependencies": {
        "commander": "~2.19.0",
        "glob": "~7.1.3",
        "json-stable-stringify": "^1.0.1",
        "typescript": "^3.2.2"
      },
      "devDependencies": {
        "@types/assertion-error": "^1.1.0",
        "@types/chai": "^4.1.7",
        "@types/glob": "^7.1.1",
        "@types/json-stable-stringify": "^1.0.32",
        "@types/mocha": "^5.2.5",
        "@types/node": "10.12.18",
        "ajv": "~6.6.2",
        "chai": "~4.2.0",
        "jest": "^23.6.0",
        "jest-junit": "^5.2.0",
        "source-map-support": "~0.5.9",
        "ts-jest": "^23.10.5",
        "ts-node": "^7.0.1",
        "tslint": "~5.12.0"
      },
      "scripts": {
        "prepublishOnly": "npm run build",
        "preversion": "npm run lint",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "tslint -p .",
        "test": "jest test/ --verbose",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts"
      },
      "jest": {
        "transform": {
          "^.+\\.tsx?$": "ts-jest"
        },
        "testRegex": "(/__tests__/.*|(\\.|/)(test|spec))\\.(jsx?|tsx?)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "jsx",
          "json",
          "node"
        ],
        "testPathIgnorePatterns": [
          "node_modules",
          "test-runtime",
          "<rootDir>/build",
          "_site",
          "src"
        ],
        "coverageReporters": [
          "html",
          "cobertura"
        ],
        "coverageDirectory": "./coverage/",
        "collectCoverage": false,
        "testEnvironment": "node"
      },
      "gitHead": "e34247e21d816e9faa2c3053381453dfccd4e308",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.38.1",
      "_npmVersion": "6.5.0-next.0",
      "_nodeVersion": "11.6.0",
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "dist": {
        "integrity": "sha512-m0yBRUU35pPBUIavL1fFN7XEgcA1xNqcuIegT5Zm7QF3wsjqXofIMqO/lCVXVGCAHYvaOcRfpsPCS63w3vvAEQ==",
        "shasum": "abfdc1d570a81545b3a52a229dd90f392e8f23f4",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.38.1.tgz",
        "fileCount": 345,
        "unpackedSize": 434110,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJcKHTyCRA9TVsSAnZWagAAPWkP/1KnRQUCLo8ZtqpypiwD\nbqDLyOoBXQ4ddQzrG1O0qGJOpuCWkzQjxjVmj7bvW9UX/uGZxdekRmDEu3fQ\nDM6gUGr5RqMyUIrQSt85efKISTmMl2Cs6PLqWwUpzflQNnrSIjrxAV5IoebT\nTrhZ72mwGg6p18B6cQsF8LL//UnOV0eiQfHxf1iBJn1mvKGe8AVOLcXhx8sG\n+Ogq5fLqMzzi1AUG8PFnVDpFlH9+K7ySI2sj7Xf1oTlLKYS+a1VdnmtYYvNS\ncw72J8dGfLt8oRuFOKlI3Y37viXruVmFz47WvmqFMStoBSWw/DP9S04UxjIq\nljrVa4g6k8I2wQDuLApk71YNdsP4XloY4j7omV1qDT7IBzY6nxJtbpKBOEJ7\nXDnUhvF/+Dkav9G/Je3XD1RdyiJkG5xhU3S4/1yE32HJBQrv14Ky6mrZm65g\ntpqT1lGXNhL8iSB0cZ6KyTprf/Oj00iMEnR4w6+otNCmtQpkA40KMXvu1otm\nORkjdiVhdy/lV/46CF1hnIuvA1CBwo0B3gCDnmvEcwOm4Cy5JotwGKg9ZkqD\nr76+bB3Yy1SNEL7/1qTeYJhivHgpx7tTMRHM0Vg2NemVfuif6gY3THZUHp7X\n8TI/sFhEo2pJEk8gdW9rZPCJBiMs/0xJnhOnyvGOngkt6gwXGIPP1qOLA95u\n8iQ+\r\n=Vl8V\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEQCICluUBkS71fsW5ww3gFSMbI2kVJYZ2Jzc1LAfI9jj0O3AiAj8VcYYBorQeou57gql5X4y2kBq1zNRiAB3pS3JJoNPA=="
          }
        ]
      },
      "maintainers": [
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.38.1_1546155249669_0.5217995757222809"
      },
      "_hasShrinkwrap": false
    },
    "0.39.0": {
      "name": "ts-json-schema-generator",
      "version": "0.39.0",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "./bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "licenses": [
        {
          "type": "MIT",
          "url": "http://www.opensource.org/licenses/mit-license.php"
        }
      ],
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=6.0.0"
      },
      "dependencies": {
        "commander": "~2.19.0",
        "glob": "~7.1.3",
        "json-stable-stringify": "^1.0.1",
        "typescript": "^3.2.4"
      },
      "devDependencies": {
        "@types/assertion-error": "^1.1.0",
        "@types/chai": "^4.1.7",
        "@types/glob": "^7.1.1",
        "@types/json-stable-stringify": "^1.0.32",
        "@types/mocha": "^5.2.5",
        "@types/node": "10.12.18",
        "ajv": "~6.7.0",
        "chai": "~4.2.0",
        "jest": "^24.0.0",
        "jest-junit": "^6.1.0",
        "source-map-support": "~0.5.10",
        "ts-jest": "^23.10.5",
        "ts-node": "^8.0.1",
        "tslint": "~5.12.1"
      },
      "scripts": {
        "prepublishOnly": "npm run build",
        "preversion": "npm run lint",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "tslint -p .",
        "test": "jest test/ --verbose",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts"
      },
      "jest": {
        "transform": {
          "^.+\\.tsx?$": "ts-jest"
        },
        "testRegex": "(/__tests__/.*|(\\.|/)(test|spec))\\.(jsx?|tsx?)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "jsx",
          "json",
          "node"
        ],
        "testPathIgnorePatterns": [
          "node_modules",
          "test-runtime",
          "<rootDir>/build",
          "_site",
          "src"
        ],
        "coverageReporters": [
          "html",
          "cobertura"
        ],
        "coverageDirectory": "./coverage/",
        "collectCoverage": false,
        "testEnvironment": "node"
      },
      "gitHead": "948c134b120e2e2f4ba52a993d246ff4222fcbd3",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.39.0",
      "_npmVersion": "6.5.0",
      "_nodeVersion": "11.8.0",
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "dist": {
        "integrity": "sha512-0YbcEZlXJvUXaywd/50jSuvMpjpVrF8AfU2qsNbPhrUqylLFUOQFgfpkJlIwlvHio7l7CfN48l6Dc8+WMbZM4A==",
        "shasum": "a77ebb1662215ea4cbd3c7666d8399572d115480",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.39.0.tgz",
        "fileCount": 345,
        "unpackedSize": 462777,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJcS1lYCRA9TVsSAnZWagAADzQP/1C8WvTYK9rbm/6XSNas\nML2e+wGAWRm/GdkkZY3CrzRl0mL34a/BHJC90+E0MHc/NPWddUjaervG5xVh\n7DMpt2QAJX3Speyjd6vm99MPmz2boGhXW9y0gffSLLxUDQuSO2Zir/O2xDyL\naNcDMJVi7wKR4J/fatlbNiT2I4GR+NnNC+PU+Ma6i44ZxGcEg3Wul7TF4whE\nc54BakABu4Os/Nq/geB+bc+PPVw5DdwI9W9XsVFB0ZSGTaX5uJIt6WK+S04S\nEtKtVKzUQyvUc4/z8V+Ponk0tvL2hOM5HYMTrzlpYZLKerbPzVlhMHJ4DIO0\nzIqAVRl24r8yz5TdWUJZ9mSRJkOrV0GZf6CwLpLJyOySw56qkkHQjBd41k9N\nXvgXHpZHrRgAG5GoWy8D8+n+k9kQ1ElB+WIMsUqijGNLzc8pgUOlxFoO88Ns\nLTeI9T72jdsTqirf6zz6WKBJcytsZFZ2gkykXh7AgCFGlicitX6evsxOqSAI\n4qR/jZVOhqxXIcaOuJuNPAESHlsXBVCdlmIvV099pLLQbwE5pfJTDRneDr2+\n5TKltssiPUhndUXilWW5R2n52DxcvO5s0qt/mQnWynXByKuL64wz637bv39J\nwtpRNIeilZ+3IEL7HPNX0tJ2Wr9sLT9fJz/thO+rfgAJYcmrnSL0ns14OylZ\nqvKL\r\n=P6Rc\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEYCIQDXnUyLY0j1NfE/P+toQViXuZeH+MPvpA/6TRuQVcB98gIhAKl0Xf5hptx2kGZV0a0+QlL/2i/5mYZklB9a+xwUvJmy"
          }
        ]
      },
      "maintainers": [
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.39.0_1548441943669_0.8990651912616388"
      },
      "_hasShrinkwrap": false
    },
    "0.40.0": {
      "name": "ts-json-schema-generator",
      "version": "0.40.0",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "./bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "licenses": [
        {
          "type": "MIT",
          "url": "http://www.opensource.org/licenses/mit-license.php"
        }
      ],
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=6.0.0"
      },
      "dependencies": {
        "commander": "~2.19.0",
        "glob": "~7.1.3",
        "json-stable-stringify": "^1.0.1",
        "typescript": "^3.3.1"
      },
      "devDependencies": {
        "@types/chai": "^4.1.7",
        "@types/glob": "^7.1.1",
        "@types/json-stable-stringify": "^1.0.32",
        "@types/mocha": "^5.2.5",
        "@types/node": "10.12.21",
        "ajv": "~6.8.1",
        "chai": "~4.2.0",
        "jest": "^24.0.0",
        "jest-junit": "^6.2.1",
        "source-map-support": "~0.5.10",
        "ts-jest": "^23.10.5",
        "ts-node": "^8.0.2",
        "tslint": "~5.12.1"
      },
      "scripts": {
        "prepublishOnly": "npm run build",
        "preversion": "npm run lint",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "tslint -p .",
        "test": "jest test/ --verbose",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts"
      },
      "jest": {
        "transform": {
          "^.+\\.tsx?$": "ts-jest"
        },
        "testRegex": "(/__tests__/.*|(\\.|/)(test|spec))\\.(jsx?|tsx?)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "jsx",
          "json",
          "node"
        ],
        "testPathIgnorePatterns": [
          "node_modules",
          "test-runtime",
          "<rootDir>/build",
          "_site",
          "src"
        ],
        "coverageReporters": [
          "html",
          "cobertura"
        ],
        "coverageDirectory": "./coverage/",
        "collectCoverage": false,
        "testEnvironment": "node"
      },
      "gitHead": "665a8aca9ccaa1ccec017ec9a0c3f2d40b41d8c5",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.40.0",
      "_npmVersion": "6.5.0",
      "_nodeVersion": "11.9.0",
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "dist": {
        "integrity": "sha512-VkxzG2fBVzu5Ohv6UXa6g43GGq3d/ejeZHetvMbLDFJZ2xPOEKglMLAQbZ8aX6WAE7cdhhSum8S5BnDMqB045Q==",
        "shasum": "a2147675c94f022df14004a659c0b75a2e595425",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.40.0.tgz",
        "fileCount": 345,
        "unpackedSize": 433488,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJcWLixCRA9TVsSAnZWagAAlYoQAJu+/k4acM5ipvHR5/H3\nzqOi0+ku+pxk0Kw4NrdseiNva6Mjd86RWnCt7oQtCJkt4ivHdDmrvfbmlb47\nhV4bQJxwdJhLLBXkVm7tDY7+SFRSYWdIHmDjYi1fU5pvBSaewC/uJgyn6XZA\nUI5sws5Pa76hzWPIBC04fSnZAJxucB/yM+LyXvs+sGuUmoLu/cnzpB0hsUBw\nuQYZB7a/S/C+yykMaTORnAMaX2yjC/YkIYM9UWYcGZtLvGII/HCVOfMNUs2n\n10v+9132KU+pyIKCjjixmcWy/+f5pxt7uTol1wohljUGmTOwZOYWTMLkGvmf\noB4VmdIqLPeFXD6IE51nqaQsqfQajdE74LsMnVTlJjoFh1k/CYc/rSARrTW5\nZxxKnVuwZL7IROFx7RsT2+5itP9IMBERpbs5ZWt28W21KBdcBVzRnstejSKk\nlJ98R7nBmb4Q3c9twILyF4jt9IhgqPSd+Y3rDaHrAXSiK1ZCP9jLe+w6bYr3\n1BYD3V4GtcbHJF/QZS7J8NZt8+Sc9ik2BdUblb6c7Wk1DCdRhSctTh5yqyce\n+T3rcxGyiOYgcHSeudJ++RCV1qByoF6qaENP7YZU26yqNwSpGYFBfVyobezD\nyXzDBSXMipyE4msx2JA8XHVKiy22IR1oLqLxlnupoQDIoAiuOJjB1g2w0BaU\nnDmD\r\n=Ru2J\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEQCIFhfXundun9WJY2dcxo6mU/YDjMzKBZuoncdZpyC6mwkAiA/8M+HxJBgcyZtSztBQJ/GDqHQQUpuOIjkM41ZNmRmVQ=="
          }
        ]
      },
      "maintainers": [
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.40.0_1549318320342_0.2579383158274182"
      },
      "_hasShrinkwrap": false
    },
    "0.41.0": {
      "name": "ts-json-schema-generator",
      "version": "0.41.0",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "./bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "licenses": [
        {
          "type": "MIT",
          "url": "http://www.opensource.org/licenses/mit-license.php"
        }
      ],
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=6.0.0"
      },
      "dependencies": {
        "commander": "~2.20.0",
        "glob": "~7.1.3",
        "json-stable-stringify": "^1.0.1",
        "typescript": "~3.4.4"
      },
      "devDependencies": {
        "@types/glob": "^7.1.1",
        "@types/jest": "^24.0.11",
        "@types/json-stable-stringify": "^1.0.32",
        "@types/node": "^11.13.6",
        "ajv": "~6.10.0",
        "chai": "~4.2.0",
        "jest": "^24.7.1",
        "jest-junit": "^6.3.0",
        "source-map-support": "~0.5.12",
        "ts-jest": "^24.0.2",
        "ts-node": "^8.1.0",
        "tslint": "~5.16.0"
      },
      "scripts": {
        "prepublishOnly": "npm run build",
        "preversion": "npm run lint",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "tslint -p .",
        "fix": "tslint -p . --fix",
        "test": "jest test/ --verbose",
        "test:fast": "FAST_TEST=1 jest test/ --verbose",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts"
      },
      "jest": {
        "transform": {
          "^.+\\.tsx?$": "ts-jest"
        },
        "testRegex": "(/__tests__/.*|(\\.|/)(test|spec))\\.(jsx?|tsx?)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "jsx",
          "json",
          "node"
        ],
        "testPathIgnorePatterns": [
          "node_modules",
          "test-runtime",
          "<rootDir>/build",
          "_site",
          "src",
          "dist"
        ],
        "coverageReporters": [
          "html",
          "cobertura"
        ],
        "coverageDirectory": "./coverage/",
        "collectCoverage": false,
        "testEnvironment": "node"
      },
      "gitHead": "32685e61d4709991e98fdab94f11cc5b8090be20",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.41.0",
      "_nodeVersion": "11.14.0",
      "_npmVersion": "6.7.0",
      "dist": {
        "integrity": "sha512-oopc+ETaoc1C+6sAn40hvYTkso8WJYbImv6Wqvnwf8eaEdLzm9bnKCrLLESujCHXelzMiLMAZQgB1P9IS9u/yg==",
        "shasum": "e60405577d3111997a405ac80d07d30f085a85eb",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.41.0.tgz",
        "fileCount": 352,
        "unpackedSize": 664025,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJcu/r4CRA9TVsSAnZWagAA03sP/2xRdL/kD3LX9RJfnULM\n4FEaBg3VvS2XLarn9eXN30goAJJ9O3hTtDsLhb6SfA28BalLZYJEj2B1qCl3\ntYk85Jk1bSYLwPVVVj5+SDpM/p8klRN+120RuOoTRYkzLoPvYXE9yhoY35x1\nVNoDwcd5wngTEuM9lmJ/3KW/0TU2GXoD+6avQDFXZA8BX0bHYpEsIv4IiQib\n5bSCFaPiXREUnxAzQymhgDhNhoWlJE4+ZtLaFd3Ph7kf3dY47OUJTKwavqa5\nSW1jaia3WPxtPKwNgbwwqCqmEp1qKt8QTJ1O/u7iMfrVGxYs5NzlkLSDxsmT\niNSWgZmGsTO4ukU369tJp+Edk/hRId3j7i+3Tc7orwxr/tn9sZB12SLcRm6F\nn+yb5TMCkhJjOU3z+aeWI1/RzNoV7VHGNK8OIwMzoslQGaKTDGXfuk/0rP0u\nr9vKBmCQYb91HuN60XY+naEOQ6ZlLxnv8wGCXUVsMWkUlvd68aCfUhpvBqhD\nsBfZ6QO+88ZusvVaH3GdHbYpEuJGGvx1WIaglC028wd9Zj/Gx1kPzUuO4P8r\nUDYemMUxDLFxPAJyIUvNISprP4Lp4qOJ1NNcoU/HUt8WX7pM8+g4AoJqx/Go\nOxiXtvlcHgp4RCncong/Pof7V/oNfWEnrwx+197QwCXrY6rmaNAo7iwQ17s4\nsJdz\r\n=gwnb\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEQCIFb2TVe/lw3Zc9ujDojyyPJ/flKpi4jlJUkdVTaLot/uAiAPMb1hUgQ6pNCeUphqzkgjiyt6J3onIYATtS10Cim+fw=="
          }
        ]
      },
      "maintainers": [
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.41.0_1555823351564_0.7032630176752386"
      },
      "_hasShrinkwrap": false
    },
    "0.42.0": {
      "name": "ts-json-schema-generator",
      "version": "0.42.0",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "./bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "licenses": [
        {
          "type": "MIT",
          "url": "http://www.opensource.org/licenses/mit-license.php"
        }
      ],
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=6.0.0"
      },
      "dependencies": {
        "commander": "~2.20.0",
        "glob": "~7.1.4",
        "json-stable-stringify": "^1.0.1",
        "typescript": "~3.4.5"
      },
      "devDependencies": {
        "@types/glob": "^7.1.1",
        "@types/jest": "^24.0.13",
        "@types/json-stable-stringify": "^1.0.32",
        "@types/node": "^12.0.2",
        "ajv": "~6.10.0",
        "chai": "~4.2.0",
        "jest": "^24.8.0",
        "jest-junit": "^6.4.0",
        "source-map-support": "~0.5.12",
        "ts-jest": "^24.0.2",
        "ts-node": "^8.1.1",
        "tslint": "~5.16.0"
      },
      "scripts": {
        "prepublishOnly": "npm run build",
        "preversion": "npm run lint",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "tslint -p .",
        "fix": "tslint -p . --fix",
        "test": "jest test/ --verbose",
        "test:fast": "FAST_TEST=1 jest test/ --verbose",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts"
      },
      "jest": {
        "transform": {
          "^.+\\.tsx?$": "ts-jest"
        },
        "testRegex": "(/__tests__/.*|(\\.|/)(test|spec))\\.(jsx?|tsx?)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "jsx",
          "json",
          "node"
        ],
        "testPathIgnorePatterns": [
          "node_modules",
          "test-runtime",
          "<rootDir>/build",
          "_site",
          "src",
          "dist"
        ],
        "coverageReporters": [
          "html",
          "cobertura"
        ],
        "coverageDirectory": "./coverage/",
        "collectCoverage": false,
        "testEnvironment": "node"
      },
      "gitHead": "657c34ad74622330027dc6eac0e36685e0a015c2",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.42.0",
      "_nodeVersion": "11.15.0",
      "_npmVersion": "6.7.0",
      "dist": {
        "integrity": "sha512-UAfnxm4u10t3HC81DUPFgyIiXpa5XHotNlUEPqbhdoiW+MU+MYNtPCgeU/VK/F+mBmw6uPow+5VCEUNZYwMupQ==",
        "shasum": "6990b71d2ad5ec3cd95842a18c360b7e272172c9",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.42.0.tgz",
        "fileCount": 352,
        "unpackedSize": 666816,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJc6cPJCRA9TVsSAnZWagAAgZcQAI5z23d6OfzXnVWqiuIq\nigU4KfhY0OsMj4f3iMlxxmRRnwvbeAha5zQ/34rEnaMOyg7rLeTZttWP/ydk\nOAn+BKvy53Asbgmy2u9TfMWy5XQdoJpGU12pg8aPYovjgh17r+Cp/Z7pxoar\npnK5rKylDFmTBInLPxPynWJm/8EZ2EYe/uFnnRD2zGipD8vj7hKKCk9Z5C2b\nxIwl7ktk/XUka78ceHbAZszb5Bn8VFv/OjvxJOlHWja1aBdIoomuSthxSuTT\nnHHZuCUjycz3RIUT6ZtqA5oG5Cx8dPPL3j58cak5suMJbrC7ujVhe7c6fj/L\nMNt1eGudfjAqFna18gDD5TQ8NHZG4bv0sps9q7tPb3g+uzdml2QkPUMFAO15\nJCpVs3ImLmsJxreIWXA2Lmkt1tMM5gMecpyXaaVcWvaE2s+Clv5mLeUZ8fjC\n/mlc0ApORQ45X8RfiUdhOqCjpUazLU5GRR4wA581e8mYrbaBnIUnwpms+esf\n05m1enfQGtPaVmwk+22P6qTgfqlenRq0vJYLDa8J32s2PKX/mYa/04fVD+Cu\nEpeufEimyqJczUun4M4Dxet7TmnGbK43POWURg+gsPvdjZfsJ16Lu8xckBSE\nCnutRBK50wHMPdb+cr4fJCSpsie9TUN6TjslzAxZVV9Z8CjAuenzTHVMhv7x\n9YyG\r\n=OqJX\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEQCIA1Uw1HkJdvBA/sa3vjAZveE1blyICCChBdqM3y9El8+AiA/wIRdEKqDEditQjvZY2VORO1SQ/w1+Z8UeMWs04kzVQ=="
          }
        ]
      },
      "maintainers": [
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.42.0_1558823878735_0.28709600143457514"
      },
      "_hasShrinkwrap": false
    },
    "0.43.0": {
      "name": "ts-json-schema-generator",
      "version": "0.43.0",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "./bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "licenses": [
        {
          "type": "MIT",
          "url": "http://www.opensource.org/licenses/mit-license.php"
        }
      ],
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=6.0.0"
      },
      "dependencies": {
        "commander": "~2.20.0",
        "glob": "~7.1.4",
        "json-stable-stringify": "^1.0.1",
        "typescript": "~3.5.1"
      },
      "devDependencies": {
        "@types/glob": "^7.1.1",
        "@types/jest": "^24.0.13",
        "@types/json-stable-stringify": "^1.0.32",
        "@types/node": "^12.0.3",
        "ajv": "~6.10.0",
        "chai": "~4.2.0",
        "jest": "^24.8.0",
        "jest-junit": "^6.4.0",
        "source-map-support": "~0.5.12",
        "ts-jest": "^24.0.2",
        "ts-node": "^8.2.0",
        "tslint": "~5.16.0"
      },
      "scripts": {
        "prepublishOnly": "npm run build",
        "preversion": "npm run lint",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "tslint -p .",
        "fix": "tslint -p . --fix",
        "test": "jest test/ --verbose",
        "test:fast": "FAST_TEST=1 jest test/ --verbose",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts"
      },
      "jest": {
        "transform": {
          "^.+\\.tsx?$": "ts-jest"
        },
        "testRegex": "(/__tests__/.*|(\\.|/)(test|spec))\\.(jsx?|tsx?)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "jsx",
          "json",
          "node"
        ],
        "testPathIgnorePatterns": [
          "node_modules",
          "test-runtime",
          "<rootDir>/build",
          "_site",
          "src",
          "dist"
        ],
        "coverageReporters": [
          "html",
          "cobertura"
        ],
        "coverageDirectory": "./coverage/",
        "collectCoverage": false,
        "testEnvironment": "node"
      },
      "gitHead": "3784296f9b7ccbabe4121b2579a6f462c5fe95e0",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.43.0",
      "_nodeVersion": "11.15.0",
      "_npmVersion": "6.7.0",
      "dist": {
        "integrity": "sha512-qvtfvgOk04CDfmeCrm/tT+8SA4O3qhx+XN0Mqs8Niromli0hwEyOWBzm8o6JypqR4le97F/ptQWvBNgM1aVGVw==",
        "shasum": "8e9f272e06f404029124793201fb49ea289f1980",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.43.0.tgz",
        "fileCount": 352,
        "unpackedSize": 666738,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJc7/SnCRA9TVsSAnZWagAAL+YP/R9Y7xkwuyBPFeswI7rm\n1rqRxFX8TPtrToecWHW//JFwWfiTQJ6QqgnKVWv48wFPhlpqa4o91WegnNVE\nB3A0rWO5VlN+cGndgxX0Px4+M9YcDk39mEmL/3RxMf0w7Xl6PyGqio7BUT8J\ntWnqIYKDN0N+o+JmCQVrXm4dJzufPTJnI0Ia6fZvr1nP5EMCevJDBBCztK5C\nSexDDBJkxLkrG+jOykwSe4pvLDceixhKw6OIHIaZYgGB2jfI6YR97uCd56n5\nlut24Dxs7LVbbrkK0Xe4Nwa4k2lD0tTKJZkTK40IjiniMghLEv48cYk7aUkR\nOLmdqnknxoH3aE0NUu2OdbiaCwZT5Sl7hgo39DkX121JTTQqyItiJjsmw8re\nHW1GoIGWGBeAe2D7DkAKjX/zVEdffJ0WY8P+DCgU6kBLFxGI4kEt0r3SNIXS\nq/HlT+zvRlcY+Ape15QbLCb4mBY2LjxJjvbtIzNHIYeHxUvAZopo4fRd+sGI\ncF8K7kCDFPK2Xfj8Fl4di42OjHEpcEH9WUTjifWYOUnh67p9exST1SAvr4Db\nGknafRUOCCbW98FRWt9r25y/SsriwD+B43qwdcJLKQXtGyLgI/NiI7JR2aXb\nueXEuNfSuNdttfJ9mDyMWy9MupIL7XGCn1xQFLEjpvGInfoDujA4YwSnsHlj\nCjEJ\r\n=tLFR\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEQCIEAQ/Vv4QEXf2l4/EbpY8Z92r3P0Sw76Bzuhf3d8KYYnAiB3wYkZbuSat9mb+Ef/9Z0D+K2/YDoHH8eyaPaBqcvhCA=="
          }
        ]
      },
      "maintainers": [
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.43.0_1559229606460_0.014231370463973603"
      },
      "_hasShrinkwrap": false
    },
    "0.44.0": {
      "name": "ts-json-schema-generator",
      "version": "0.44.0",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "./bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "licenses": [
        {
          "type": "MIT",
          "url": "http://www.opensource.org/licenses/mit-license.php"
        }
      ],
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=6.0.0"
      },
      "dependencies": {
        "commander": "~2.20.0",
        "glob": "~7.1.4",
        "json-stable-stringify": "^1.0.1",
        "typescript": "~3.5.1"
      },
      "devDependencies": {
        "@types/glob": "^7.1.1",
        "@types/jest": "^24.0.13",
        "@types/json-schema": "^7.0.3",
        "@types/json-stable-stringify": "^1.0.32",
        "@types/node": "^12.0.4",
        "ajv": "~6.10.0",
        "chai": "~4.2.0",
        "jest": "^24.8.0",
        "jest-junit": "^6.4.0",
        "source-map-support": "~0.5.12",
        "ts-jest": "^24.0.2",
        "ts-node": "^8.2.0",
        "tslint": "~5.17.0"
      },
      "scripts": {
        "prepublishOnly": "npm run build",
        "preversion": "npm run lint",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "tslint -p .",
        "fix": "tslint -p . --fix",
        "test": "jest test/ --verbose",
        "test:fast": "FAST_TEST=1 jest test/ --verbose",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts"
      },
      "jest": {
        "transform": {
          "^.+\\.tsx?$": "ts-jest"
        },
        "testRegex": "(/__tests__/.*|(\\.|/)(test|spec))\\.(jsx?|tsx?)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "jsx",
          "json",
          "node"
        ],
        "testPathIgnorePatterns": [
          "node_modules",
          "test-runtime",
          "<rootDir>/build",
          "_site",
          "src",
          "dist"
        ],
        "coverageReporters": [
          "html",
          "cobertura"
        ],
        "coverageDirectory": "./coverage/",
        "collectCoverage": false,
        "testEnvironment": "node"
      },
      "gitHead": "743a6f04e2cc5e4fd4bf2d676ec6f1975848e62f",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.44.0",
      "_nodeVersion": "11.15.0",
      "_npmVersion": "6.7.0",
      "dist": {
        "integrity": "sha512-R7Cr+2ibmT0KkbuRBmPjunLSNx1PtR5VNfsm4El7zXRQ/+yq6UK128ZxroDBh2z6lWgIoLJ8Su92J/o9GCX8CQ==",
        "shasum": "c573f4f53f5ec5780a167e20372f6fe2e1de4baa",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.44.0.tgz",
        "fileCount": 358,
        "unpackedSize": 670856,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJc9AokCRA9TVsSAnZWagAAwwgP+wdLOkEtImQ1tZ+3OjvO\nTG0CvbRhKZCbpL7LNrpZ95Ldi6Pnp0G4D6gafGOAKcV0i/3n9Cy7SDqFwMK0\nNtHWlKIzdderrKx96YPY2vQaGBCvX073cnDd4DozDvdsybU4CxLPamxHCaPX\nMGV0om51bUxa+5/v6gtw+Neto7es3zB03v6lhnM+sL/s+owFJJ9cCuCx8PT9\nz2aAwo751IJD9x6TV8ySY0hZtw1pz6jXss8dRW9WVaz+EDxIHi9qgfIq6r/l\nnuCDNOujnZHzqUfx4BmxGMmezwrxSYSR4DeYV3nhXALgcXur5jwLxWDcGBZV\n1nM4K4MG9x4K0S4Hmc14KlRBHt3Lq2yaSNv05DkbYMxUthCKlzbdLuaAbSon\nyMPxLTgHAH/as2d1PvY/upac6i8OZA5wZR/b3Wlhv2dc1sWWB2Db2UdIt0CB\nFt3kdgwPGFt2E4aNDUma9GDLW2wv/xu1XFPXqQr8AJbKn1s+aHKn2v/CKhDk\ndoRBXgjEuCtfXDW9o/8nrtE6MW5jvY5LCmTMbGMJOpmYGdLP2MKltBOM6ozt\nXjJ72Ccd2xLsVsGIqGaSUCa/y9E65CpE9Qo2rxaaAY+3igP9xLdGm5QMF9hZ\nPezNZIiaZxYLfW1UNlWNXMjI8nO09nNe9fwdvT8DKZZE8Tp5yAbaWLtHzA4h\nKvWz\r\n=7um7\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEQCIC/YGRcRW9fEhvT432E99V8wurLfJHMSqYV/4Mlsn+GkAiAeAKNqJoz4k7+kZt6dEo7Oyl0QfjBtReiwcaVDNAkCVg=="
          }
        ]
      },
      "maintainers": [
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.44.0_1559497251067_0.724463818312034"
      },
      "_hasShrinkwrap": false
    },
    "0.45.0": {
      "name": "ts-json-schema-generator",
      "version": "0.45.0",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "./bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "licenses": [
        {
          "type": "MIT",
          "url": "http://www.opensource.org/licenses/mit-license.php"
        }
      ],
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=6.0.0"
      },
      "dependencies": {
        "commander": "~2.20.0",
        "glob": "~7.1.4",
        "json-stable-stringify": "^1.0.1",
        "typescript": "~3.5.1"
      },
      "devDependencies": {
        "@types/glob": "^7.1.1",
        "@types/jest": "^24.0.13",
        "@types/json-schema": "^7.0.3",
        "@types/json-stable-stringify": "^1.0.32",
        "@types/node": "^12.0.4",
        "ajv": "~6.10.0",
        "chai": "~4.2.0",
        "jest": "^24.8.0",
        "jest-junit": "^6.4.0",
        "source-map-support": "~0.5.12",
        "ts-jest": "^24.0.2",
        "ts-node": "^8.2.0",
        "tslint": "~5.17.0"
      },
      "scripts": {
        "prepublishOnly": "npm run build",
        "preversion": "npm run lint",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "tslint -p .",
        "fix": "tslint -p . --fix",
        "test": "jest test/ --verbose",
        "test:fast": "FAST_TEST=1 jest test/ --verbose",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts"
      },
      "jest": {
        "transform": {
          "^.+\\.tsx?$": "ts-jest"
        },
        "testRegex": "(/__tests__/.*|(\\.|/)(test|spec))\\.(jsx?|tsx?)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "jsx",
          "json",
          "node"
        ],
        "testPathIgnorePatterns": [
          "node_modules",
          "test-runtime",
          "<rootDir>/build",
          "_site",
          "src",
          "dist"
        ],
        "coverageReporters": [
          "html",
          "cobertura"
        ],
        "coverageDirectory": "./coverage/",
        "collectCoverage": false,
        "testEnvironment": "node"
      },
      "gitHead": "77b55561529e86c13b4a2726f3b43197ef25126b",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.45.0",
      "_nodeVersion": "11.15.0",
      "_npmVersion": "6.7.0",
      "dist": {
        "integrity": "sha512-obK6EiFT+yEQlbTxFNySMCiEjx8WgMjS1L0L8gBua9HlSWtVGW1tMbb+eygZq08KgH8PViAGOO3m6Lgo+T00gA==",
        "shasum": "aa95a7bd1255c55450f81257f1a57fcc75dca7d2",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.45.0.tgz",
        "fileCount": 358,
        "unpackedSize": 680178,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJc9+WPCRA9TVsSAnZWagAAwooQAINqKA86QSDMXfaEfAbI\n5yy9+5gDwoXOZxF5TuqsJ8k6KkQi8Pi0EhQUMwYLQlAxC2xKxEPMnfi4zI8o\nRriYVSLwvdsMYDEjlUqKX9MqkK53yhpeBFlvtq4O4NDJ0MVOp86OzbaGFM2u\nFpgztz15pckpfyFjjNHHM0q/xwC0egUSnqhokAUyP3GS+tE7utQ2Va6ucwcj\n0aGOJPpiIiMcn7eN6ctn+CHvcIcy+8WoRKk2w5eufuKGEWvJP1WCzZaRG72X\nydYXqg3ndXbh2JyARnqBHafUN/4tcB4XM82D01wWqwZph4uewGLM5rHyXpAC\n2h+Rc2GPeyVzMYC2r20ndcVd7lVdbnW1MT03zn+T4QDgjRJY2u/3xKbxHmxq\no0uoUVnFz2ogU0QIdx+pN5kx0iwe1/6Z7pftQAyO6O8eYR5xzcQjpEBvHoh0\nF1ThGDughbK5VV2wbt/idX0LUMZOP8yK5vvKXjbDgDkN5iLV9ASQ+DQKmfXG\nhzflf9UAtpA8/hiK1/X57bQS2CJ2gTkqwvJGzQmaLpwWcOilSSBhKCpFq+0T\nvwsrgRVqs9s6JcXKy66ZXdteTu/XnwYJzeQ8O8wPhWS/nSxbde8KHOocTH/j\nOw14Bg4kgQdlMU7NDe2oBkc0FsbZNpl+XapZJL0cix5hGC7sdRTfdQO+2mPu\nbfES\r\n=OMdy\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEYCIQC/91npSnEhW6g21S7oBhjfuQVtFA0SU7G6XEl8A5QHxQIhAIfqIy3qt8mqzgV30QLBPApvROXUVyVsqCKlQuQHr+Hi"
          }
        ]
      },
      "maintainers": [
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.45.0_1559750030690_0.82751935355057"
      },
      "_hasShrinkwrap": false
    },
    "0.46.0": {
      "name": "ts-json-schema-generator",
      "version": "0.46.0",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "./bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "licenses": [
        {
          "type": "MIT",
          "url": "http://www.opensource.org/licenses/mit-license.php"
        }
      ],
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=6.0.0"
      },
      "dependencies": {
        "commander": "~2.20.0",
        "glob": "~7.1.4",
        "json-stable-stringify": "^1.0.1",
        "typescript": "~3.5.1"
      },
      "devDependencies": {
        "@types/glob": "^7.1.1",
        "@types/jest": "^24.0.13",
        "@types/json-schema": "^7.0.3",
        "@types/json-stable-stringify": "^1.0.32",
        "@types/node": "^12.0.4",
        "ajv": "~6.10.0",
        "chai": "~4.2.0",
        "jest": "^24.8.0",
        "jest-junit": "^6.4.0",
        "source-map-support": "~0.5.12",
        "ts-jest": "^24.0.2",
        "ts-node": "^8.2.0",
        "tslint": "~5.17.0"
      },
      "scripts": {
        "prepublishOnly": "npm run build",
        "preversion": "npm run lint",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "tslint -p .",
        "fix": "tslint -p . --fix",
        "test": "jest test/ --verbose",
        "test:fast": "FAST_TEST=1 jest test/ --verbose",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts"
      },
      "jest": {
        "transform": {
          "^.+\\.tsx?$": "ts-jest"
        },
        "testRegex": "(/__tests__/.*|(\\.|/)(test|spec))\\.(jsx?|tsx?)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "jsx",
          "json",
          "node"
        ],
        "testPathIgnorePatterns": [
          "node_modules",
          "test-runtime",
          "<rootDir>/build",
          "_site",
          "src",
          "dist"
        ],
        "coverageReporters": [
          "html",
          "cobertura"
        ],
        "coverageDirectory": "./coverage/",
        "collectCoverage": false,
        "testEnvironment": "node"
      },
      "gitHead": "7ba3e5111f969bac7fde0ab7bc2d92cf1012d26e",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.46.0",
      "_nodeVersion": "11.15.0",
      "_npmVersion": "6.7.0",
      "dist": {
        "integrity": "sha512-uHyYEZU2Yj1vPTUzCHnl7GAXVnmDufbTpBAKvRf62GhJKBr82iVOd3BmzuN4d8czOKmRA3P/5OODYe5futGv0A==",
        "shasum": "12a3f95fc46e20e69f8894fd3621cc45661cfff9",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.46.0.tgz",
        "fileCount": 361,
        "unpackedSize": 691506,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJc+zBtCRA9TVsSAnZWagAA/lsP/2HQQIDMxOedt7z+h8+o\nBQjntndtvx6xoQbpoYUJkQ1J7gPfZyeGrM5/qEBJPs1XburcuFFIK5/JDMrN\nCZIfdvZ1bGFh198a5y+MjOUYFK/xzN/qc6WfBVXBujCXdE8Xtlct+Kw/fGjf\nZ+mvnpEAXY6yg1p2zzcLCWmBA4KgUVf+YwSd7dZ5WQPmGRXddt6E/602Yi08\nCq9f6VFuhbzYijRZBl8OXNog7amxZmW03XnG/knrx+3b8LibI+Irugv4+adk\nesnpKvuKvpXK0cJmgn+I03AX82acjpsDE7YANkaeXb+33qi6nLKQHvrzM2m2\nvRnMTL1JcxOh7byIc5ddLhEdP+YAHU6yg/tL5aD/ZGA8Hf1MlFJvRBo9cjEv\nscxaMaoIAE0MWInpkWalyRiJjxcsL0YoBkKjBbciQgIPh88wBRnLC9ZlI62T\n+dki5TaXSUjTlBpO/v0APXvoEENPhRb3daQABTVvMwut3B97ioOg3MakVPKb\n9+ortUUaKweuOGJD/GjWTdR5MwzwmztBwIaPeuR2mnisHeSyfe5QVolOON09\nIN4nJHROo6O/EJdihZ1XGgfFSDL7xqkLQkgzosmHYSqDYuMKUNUOTaqW/IIm\n4CAxKJB3SSYwXsn++0n7HewQMD8XtArsBEpN6+ehazYj7QyhKTILb0anFIrn\nmWAR\r\n=yii3\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIAyEFqnn66rgppI6QcwN+adkTTCGGDUK9zOdIyITZud7AiEA/Mxxw9Cf0uhpIzuMqimqe/mxc4DOdMY0So6NZ71dfr4="
          }
        ]
      },
      "maintainers": [
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.46.0_1559965804555_0.6355473514965158"
      },
      "_hasShrinkwrap": false
    },
    "0.47.0": {
      "name": "ts-json-schema-generator",
      "version": "0.47.0",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "./bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "licenses": [
        {
          "type": "MIT",
          "url": "http://www.opensource.org/licenses/mit-license.php"
        }
      ],
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=6.0.0"
      },
      "dependencies": {
        "commander": "~2.20.0",
        "glob": "~7.1.4",
        "json-stable-stringify": "^1.0.1",
        "typescript": "~3.5.2"
      },
      "devDependencies": {
        "@types/glob": "^7.1.1",
        "@types/jest": "^24.0.15",
        "@types/json-schema": "^7.0.3",
        "@types/json-stable-stringify": "^1.0.32",
        "@types/node": "^12.0.8",
        "ajv": "~6.10.0",
        "chai": "~4.2.0",
        "jest": "^24.8.0",
        "jest-junit": "^6.4.0",
        "source-map-support": "~0.5.12",
        "ts-jest": "^24.0.2",
        "ts-node": "^8.3.0",
        "tslint": "~5.17.0"
      },
      "scripts": {
        "prepublishOnly": "npm run build",
        "preversion": "npm run lint",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "tslint -p .",
        "fix": "tslint -p . --fix",
        "test": "jest test/ --verbose",
        "test:fast": "FAST_TEST=1 jest test/ --verbose",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts"
      },
      "jest": {
        "transform": {
          "^.+\\.tsx?$": "ts-jest"
        },
        "testRegex": "(/__tests__/.*|(\\.|/)(test|spec))\\.(jsx?|tsx?)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "jsx",
          "json",
          "node"
        ],
        "testPathIgnorePatterns": [
          "node_modules",
          "test-runtime",
          "<rootDir>/build",
          "_site",
          "src",
          "dist"
        ],
        "coverageReporters": [
          "html",
          "cobertura"
        ],
        "coverageDirectory": "./coverage/",
        "collectCoverage": false,
        "testEnvironment": "node"
      },
      "gitHead": "eb04762b2385b81aac1e56e7bfb0bf91872eb2eb",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.47.0",
      "_nodeVersion": "11.15.0",
      "_npmVersion": "6.7.0",
      "dist": {
        "integrity": "sha512-lAATfwDYnEXNzsKnUpb2AyIf869/WIwQElXcJgwZaiP8TOQVf+PBxix0FJM9G31urkf3evGxyZKkcARPjqzs7Q==",
        "shasum": "74c82ade204c7be3b4cefd3d8b0371809c0641ca",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.47.0.tgz",
        "fileCount": 367,
        "unpackedSize": 702316,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJdCDE6CRA9TVsSAnZWagAAZKIP/i1XfxWV7znCksiC9Pab\nBFWxuUGwYj/UmfdHLYzothWcxUm/YIYWxu0mTco6W/JJbXIBURUwZDPZSwIh\nLyBFBNU3NuzYw5HikXD3jPwLXTW0Of0s0bIgYIHXWRpLo3tek12pL1UXZSl7\nJLj2zcYNMM9KcRS71uvR5WjYdCsemFPxtcXDmNfon/ao3SAQpR4FMhhmktCd\nB567bM2u+UQAvqh6zFDKsf0avJclRQZgetidEOXgn3c3NIzm6H4PyOx3zY1E\neB4EsAb3ynuoJ8VjqsvLnSnjhn2G/IJh0ngvg64/qehHsG3NPFk8OH8+BGMw\nfuAGS7xqYn4gmB8vOgj5DmJjlotwNzNKA4l0FOJyPZ/IRrgjY8E0Wl4qCJmt\nDYSJIYcr6nJp7iR2hV/Pgt30RwmhENJWrPIWhGlSePB4zYnKjoPnkiR+ovuO\np48KdyQ9VsHkn2X8VfMht3+xhDe3bm7HB9H3lrtbR8yyE5LaDfKDqsXGzUub\nqz0kvh5KXLe/KCR+jxrPipXG3s3NeywF4uDRyJgfo83B3PKQ56YA+Wu64mPP\n5I7rhHo0mKFFq/IVGXYDxK7LmaS7gOTVHP+aBQrEo5LB7beqN8P5DfsKgQd4\nWN8Za2BSiMm66AtGolnR5tB4L826O/l+LDCstz5bdsao4NaQrgYmEcZiVg6+\nWvvk\r\n=vYxh\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIC5ekxXjCYwDLLtN4Be01t09SIRAZvZbppCLc6H3kdnMAiEAy6u9St89qjU++W0QVCKb8VzNoT8hNNveOMrMzRANJHE="
          }
        ]
      },
      "maintainers": [
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.47.0_1560817977689_0.7465739332586916"
      },
      "_hasShrinkwrap": false
    },
    "0.48.0": {
      "name": "ts-json-schema-generator",
      "version": "0.48.0",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "./bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "licenses": [
        {
          "type": "MIT",
          "url": "http://www.opensource.org/licenses/mit-license.php"
        }
      ],
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=6.0.0"
      },
      "dependencies": {
        "commander": "~2.20.0",
        "glob": "~7.1.4",
        "json-stable-stringify": "^1.0.1",
        "typescript": "~3.5.2"
      },
      "devDependencies": {
        "@types/glob": "^7.1.1",
        "@types/jest": "^24.0.15",
        "@types/json-schema": "^7.0.3",
        "@types/json-stable-stringify": "^1.0.32",
        "@types/node": "^12.0.8",
        "ajv": "~6.10.0",
        "chai": "~4.2.0",
        "jest": "^24.8.0",
        "jest-junit": "^6.4.0",
        "source-map-support": "~0.5.12",
        "ts-jest": "^24.0.2",
        "ts-node": "^8.3.0",
        "tslint": "~5.18.0"
      },
      "scripts": {
        "prepublishOnly": "npm run build",
        "preversion": "npm run lint",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "tslint -p .",
        "fix": "tslint -p . --fix",
        "test": "jest test/ --verbose",
        "test:fast": "FAST_TEST=1 jest test/ --verbose",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts"
      },
      "jest": {
        "transform": {
          "^.+\\.tsx?$": "ts-jest"
        },
        "testRegex": "(/__tests__/.*|(\\.|/)(test|spec))\\.(jsx?|tsx?)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "jsx",
          "json",
          "node"
        ],
        "testPathIgnorePatterns": [
          "node_modules",
          "test-runtime",
          "<rootDir>/build",
          "_site",
          "src",
          "dist"
        ],
        "coverageReporters": [
          "html",
          "cobertura"
        ],
        "coverageDirectory": "./coverage/",
        "collectCoverage": false,
        "testEnvironment": "node"
      },
      "gitHead": "d3c83ace79e3e17d8492a9700a462504ec29beec",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.48.0",
      "_nodeVersion": "11.15.0",
      "_npmVersion": "6.7.0",
      "dist": {
        "integrity": "sha512-rsWjDSDTsiVpVzALzsZEeGvtKu+rqhoDJ+OZKB74W7RIbLy0dRmhreYRROfVjFR7uzIbWHT+UXsGeEu4SRZ6Hg==",
        "shasum": "4e43eced2f9806414cdbe3e6a38a55c1110f9f06",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.48.0.tgz",
        "fileCount": 370,
        "unpackedSize": 705015,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJdDpGaCRA9TVsSAnZWagAAmQEP/3RR0PC0Drp4egzcsDbq\nMy1+bDK8pVCMdrYGq+KopIwYEfrPEOW1ee81O1qT0g6L7SPyYk3HailfD3AK\nkih16pO/QwpIbDC1HHiEZRzpMD3TeugDn+p1JRKpSTMsdD2NM2ZHBOYeF6z/\nYjcoNhdU9iwVD8E0bDHX7FQXNkroDS6+EwocR4M5YF1Wb0wrvDiecmN9tuzq\nx8C3ACH3n60AvRGuIj7MP3+vqsap5IWUZhC2+pplOoY7WhCGWRNzyODkQQDP\n60PMiHw+z+NhYf+FsplRjem3v1qyfdD+q4e9K0bw8qVOmSMWWgMqn4t0uHsu\nM1kf6kK2t0QkAHDYKGzVuQJA70bWoaHby2cFbUf/u2uPckIj5NiUF+p6dGJP\nvxBKEoOTTP0tUgWIlhz/UKUwTtQ9OfrDofd0GCT6G284NCJ01ZF3UI0DPq7a\n6lINRCwzGMC8n4kcYkcbGLYTSPd4LpyG6OETLix73xk0FYoFrq7/8qcrt7Pl\nq5u2vk+3bGm9qM0ZOoNyYbPslaPCyb5XduUW7q2s9eidKajsxGxRm7O03Pw1\n2K2GJxvcROfkPc7UVyXdmgJn3faPB2zZHloEhASAQcBy7pYvorO4JrE4hGm5\n1Kevyq1LoNVbWfs5jXllNiLq1n4NSdGvbH3BAzHNwVnRxK0gqMdoQGqSlZDc\nkgR+\r\n=o+2S\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIQD7tzdTAk08XUzJCTsh4ykm5WYaT3VG38PSGDoXw2b51QIgG3a1vV8Q+HDEt+z/q3U3QcpbxmmM8uOT8XajGeJ3d4U="
          }
        ]
      },
      "maintainers": [
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.48.0_1561235865440_0.44441948389014985"
      },
      "_hasShrinkwrap": false
    },
    "0.49.0": {
      "name": "ts-json-schema-generator",
      "version": "0.49.0",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "./bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "licenses": [
        {
          "type": "MIT",
          "url": "http://www.opensource.org/licenses/mit-license.php"
        }
      ],
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=6.0.0"
      },
      "dependencies": {
        "commander": "~2.20.0",
        "glob": "~7.1.4",
        "json-stable-stringify": "^1.0.1",
        "typescript": "~3.5.2"
      },
      "devDependencies": {
        "@types/glob": "^7.1.1",
        "@types/jest": "^24.0.15",
        "@types/json-schema": "^7.0.3",
        "@types/json-stable-stringify": "^1.0.32",
        "@types/node": "^12.0.8",
        "@typescript-eslint/eslint-plugin": "^1.9.0",
        "@typescript-eslint/parser": "^1.9.0",
        "ajv": "~6.10.0",
        "chai": "~4.2.0",
        "eslint": "^5.16.0",
        "jest": "^24.8.0",
        "jest-junit": "^6.4.0",
        "source-map-support": "~0.5.12",
        "ts-jest": "^24.0.2",
        "ts-node": "^8.2.0"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "preversion": "yarn lint",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint '{src,test,factory}/**/*.ts'",
        "fix": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "FAST_TEST=1 jest test/ --verbose",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts"
      },
      "jest": {
        "transform": {
          "^.+\\.tsx?$": "ts-jest"
        },
        "testRegex": "(/__tests__/.*|(\\.|/)(test|spec))\\.(jsx?|tsx?)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "jsx",
          "json",
          "node"
        ],
        "testPathIgnorePatterns": [
          "node_modules",
          "test-runtime",
          "<rootDir>/build",
          "_site",
          "src",
          "dist"
        ],
        "coverageReporters": [
          "html",
          "cobertura"
        ],
        "coverageDirectory": "./coverage/",
        "collectCoverage": false,
        "testEnvironment": "node"
      },
      "gitHead": "e38afc5386304ae3351990f7c56e14b6f4ef7ed1",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.49.0",
      "_nodeVersion": "11.15.0",
      "_npmVersion": "6.7.0",
      "dist": {
        "integrity": "sha512-GdRIPpuh5ax/KWa4/2mYJhM0HR2pqWid5P04UdgFFHXXIyaxdTBcEr2OlHKugGRTWFFl8pSLrbEaxDCBJpGk+Q==",
        "shasum": "f63469c3d1965d611207c7a18b05d23837376bbb",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.49.0.tgz",
        "fileCount": 399,
        "unpackedSize": 766762,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJdD9cdCRA9TVsSAnZWagAA/p0QAI/bkEFgAM+cBm/14PXN\nmgeuik+SDjvIYiFogPfJ2XU5eokiVyuF56NsmPcsi2LFcxAYruXaKI7idMQC\npZVwNmVaLPG6AvfT13B7b+0mFUiPxXuQnhgp4ZNoyA4tY5fUi7QRu2s/KqBZ\nHfMj99DCrhNMQhoFZEUHV1rQeeQVJZIjbwrFcz2BxM7lLU3oROu7Sfbja8Kg\n34ke2mf7theY1Yxgi0MKERpg8mfPuxazSD40hnEYUycib4txsfJAbXoL0qLJ\n02HykcugtGp704hjxg4QaIfSHH0Cs27q6MxsLFBQTd5GwuLcE5Ek4b68p+uV\nUtdEHAV1SKFCXC5/bIeZlwbSt5qKHs1U66z3QRwSuXcIQvPDdYTUMXXpXvcD\nnlQ7IjYb5eFtApgDMTvorw4ZYJ9/2RbLW8RcI0LOBzWkBq8Oa2gi89TVzndj\nSfE+X+7K5Zp8ag1MCwI31l85S+rPmqaaKmrvJOanJJuucI6BqcWCphphisBU\nX/EX/DiyAC4rOhVPXbDuboE+U5B3vWY++SJYvHkTPcEw0kwoFCm0PBq2Oqah\nBn3xyK0o/wC9RqJS43WDbzG0xeLBN+UuFlg1HfFE3cwmr7rLrCppBVbaFX3j\nQgodaWyjNp4g05V38HNarjBC8XtjgD3n2YO8kkENp6q2lbjGEInoSWZb+ESb\nWTKn\r\n=Mbzc\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEYCIQCnV0pSLnX/QRgwzPZ+Q9pEPt5WYam/bsdQ3Ai0hZWFIgIhAKBRH1Eg7jGCkA0BX60oX0jowJyTasOAgUwCWHnQ9BN3"
          }
        ]
      },
      "maintainers": [
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.49.0_1561319196541_0.7750702929751894"
      },
      "_hasShrinkwrap": false
    },
    "0.50.0": {
      "name": "ts-json-schema-generator",
      "version": "0.50.0",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "./bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "licenses": [
        {
          "type": "MIT",
          "url": "http://www.opensource.org/licenses/mit-license.php"
        }
      ],
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=6.0.0"
      },
      "dependencies": {
        "commander": "~2.20.0",
        "glob": "~7.1.4",
        "json-stable-stringify": "^1.0.1",
        "typescript": "~3.5.2"
      },
      "devDependencies": {
        "@types/glob": "^7.1.1",
        "@types/jest": "^24.0.15",
        "@types/json-schema": "^7.0.3",
        "@types/json-stable-stringify": "^1.0.32",
        "@types/node": "^12.0.8",
        "@typescript-eslint/eslint-plugin": "^1.9.0",
        "@typescript-eslint/parser": "^1.9.0",
        "ajv": "~6.10.0",
        "chai": "~4.2.0",
        "eslint": "^5.16.0",
        "jest": "^24.8.0",
        "jest-junit": "^6.4.0",
        "source-map-support": "~0.5.12",
        "ts-jest": "^24.0.2",
        "ts-node": "^8.2.0"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "preversion": "yarn lint",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint '{src,test,factory}/**/*.ts'",
        "fix": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "FAST_TEST=1 jest test/ --verbose",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts"
      },
      "jest": {
        "transform": {
          "^.+\\.tsx?$": "ts-jest"
        },
        "testRegex": "(/__tests__/.*|(\\.|/)(test|spec))\\.(jsx?|tsx?)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "jsx",
          "json",
          "node"
        ],
        "testPathIgnorePatterns": [
          "node_modules",
          "test-runtime",
          "<rootDir>/build",
          "_site",
          "src",
          "dist"
        ],
        "coverageReporters": [
          "html",
          "cobertura"
        ],
        "coverageDirectory": "./coverage/",
        "collectCoverage": false,
        "testEnvironment": "node"
      },
      "gitHead": "5f18740619b83dc043f44decc2eca84d134359e9",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.50.0",
      "_nodeVersion": "11.15.0",
      "_npmVersion": "6.7.0",
      "dist": {
        "integrity": "sha512-Tm8S64CB+97Tp9bSYkbmUASyyAsEVL+O41nxLER6XjuJIBX23H3Gzps8Yd7hQNJ/4s0NB3Hha4IJVuubjfuAAg==",
        "shasum": "4b0edd7b5566775918006fb31c806f0612fc0afe",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.50.0.tgz",
        "fileCount": 399,
        "unpackedSize": 766938,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJdD9rvCRA9TVsSAnZWagAAkysQAIwNfbJiQDNYFnQ4/9bY\nUB0IOfNiFriLrwp0R0R+pt1gi7+hkqpxbipJy57rFq7oKCIXq8l5rKyEEm5R\nPVU82V3E6ERfPCWeoAsA/uAvcFENvXZSglVexuaWw3WzGhqmo4SdrqER///J\nTpMYAO0WLZIm1T9+pUdQByL1vC0m3ydIK+nI/7RKSnja3MwK9lKYD4IAsRPW\nZtWmnJ13doc+6rFL1H1q2Bf3PAkqE36hxawY372/kH2Znfkd9NsSVyM0PgAD\nEumP8wMxRACgKh802I+CUGjF2LEhIj+R1lJUxdcxfyg+lkkuhceLkcvL1AhD\nojEZYbDgY3no3isInw+TxcP4G/XTK3xNc9vLjE5jS5hhLPkkzKF1CxsWcrQR\nRs0Li5+9Oa+vp4mX+hpmNl/uxJIOY59/cM3EmxVtUv1um4sPc2wIjoQhhRs5\n6rNtJ6WVftdD8KEWdz7aXpJmEjX8aYDP9p4LVPHRNatW1HNqaMD5b21jsGKP\nZHd8V7D1lFd7RJx65IvLtcRDsSpv4WWLpT2xxKIDW+bWh7+WAnWHO+6XuMB3\n34sx4Z7Ogh+P5ArhLtpBc2VBgWdJx3/ij5swzpYNfS6WQO2bcLLl47dXsUOR\nj7ZNJQftyznaVkXKxMIwcZNS0/+Eh7jqblTJGQsdq9xJ1I/puGf6gLf99ODF\n/eBJ\r\n=7KSG\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIQCQCG8M7665tJOTZULatYlHTJ4TTZf4/QCBZ94Kn6LcXQIgH8ADsB/X51pVCuGPQB4VOi3SN0NZTSPPSApfzosQe4Y="
          }
        ]
      },
      "maintainers": [
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.50.0_1561320174713_0.3554672665197742"
      },
      "_hasShrinkwrap": false
    },
    "0.50.1": {
      "name": "ts-json-schema-generator",
      "version": "0.50.1",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "./bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "licenses": [
        {
          "type": "MIT",
          "url": "http://www.opensource.org/licenses/mit-license.php"
        }
      ],
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=6.0.0"
      },
      "dependencies": {
        "commander": "~2.20.0",
        "glob": "~7.1.4",
        "json-stable-stringify": "^1.0.1",
        "typescript": "~3.5.2"
      },
      "devDependencies": {
        "@types/glob": "^7.1.1",
        "@types/jest": "^24.0.15",
        "@types/json-schema": "^7.0.3",
        "@types/json-stable-stringify": "^1.0.32",
        "@types/node": "^12.0.8",
        "@typescript-eslint/eslint-plugin": "^1.9.0",
        "@typescript-eslint/parser": "^1.9.0",
        "ajv": "~6.10.0",
        "chai": "~4.2.0",
        "eslint": "^5.16.0",
        "jest": "^24.8.0",
        "jest-junit": "^6.4.0",
        "source-map-support": "~0.5.12",
        "ts-jest": "^24.0.2",
        "ts-node": "^8.2.0"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "preversion": "yarn lint",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint '{src,test,factory}/**/*.ts'",
        "fix": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "FAST_TEST=1 jest test/ --verbose",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts"
      },
      "jest": {
        "transform": {
          "^.+\\.tsx?$": "ts-jest"
        },
        "testRegex": "(/__tests__/.*|(\\.|/)(test|spec))\\.(jsx?|tsx?)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "jsx",
          "json",
          "node"
        ],
        "testPathIgnorePatterns": [
          "node_modules",
          "test-runtime",
          "<rootDir>/build",
          "_site",
          "src",
          "dist"
        ],
        "coverageReporters": [
          "html",
          "cobertura"
        ],
        "coverageDirectory": "./coverage/",
        "collectCoverage": false,
        "testEnvironment": "node"
      },
      "gitHead": "c0f908bd3ec931ec55ded4804e2ca95c3b9145cd",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.50.1",
      "_nodeVersion": "11.15.0",
      "_npmVersion": "6.7.0",
      "dist": {
        "integrity": "sha512-T1hdPRM2gWy7NjOWOpwG+UD4loL/JdGkXps9R4OhpHbxunlS2qH9Ev+9yKGHyq5X/VkWlLDMNkyUAaBIORe0XQ==",
        "shasum": "5b09dd88499d9810715d336c9cb3d37dc50be552",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.50.1.tgz",
        "fileCount": 399,
        "unpackedSize": 766994,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJdEPHSCRA9TVsSAnZWagAAd8QP/3vSr82b67sbTwf18iKG\nxJ8gyHoRZSRcRYrWvG6nvfyWImFQ7LWN2jHTDGIChDwTsMcptPxugMvUoOes\nci7Z1Y8SHI7uF+EJWBfQ3RkXSfGIN/I1k0ayKj1H3gUSXtl3+StN5HrNsm5E\nvi3E0hfXZJ0W5EkLHdRDN+SgAjVEvSnuzO09ThHAkOxEgWohFfBSGvLO29DO\nLJZI8SiS8YQKyZt9wrlJxEpnhNXgXtZqGX9AJM/4Ogg0zV4Lvix77Fu8ll2C\n6MmAFgdlU/2og929xBBauFW6c0GAkUPEjCuUJwslpfJrO3o1Tp3ejCT0qXvv\np0RssGhY9udPBXBFo3Hk+2xMoAwpSvLlAa4uWdd75TX2XpzhWjohV6r/EOY8\nNozqKO2HalXll98Awrd/z2Ir/3XB0mAhAozcuk8Fl/JblU6kyAxqg2X5e0zQ\nePOnlvYc/XXtpRwNk15BB7c7T28lgcSyCJT+ieXmJChgtamD85A1NGW30USV\nxvdLZb++vWN7hPzjug3f5giJtgnC4ik9DU8PSiELMVG1qdacoBeXxfx5fIm6\nnTIq9+M+IRNFPekkEbwlcR1nFawvl9z0ZcbeA80aL1ipG50l7vgbb3XSkTYl\n0ePWyDuVlWFXjuYH5SUHxnekLx9/87220sfaBRe3yzf4cnehHq7bjhhfOAt3\nw1Kv\r\n=lnM2\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEQCIFgZlDnMf3xlFg8z0KUevgLkxzZou8ViL6kv+A5B0tc0AiAB40DRPLkoE22zM6+jJ4PzWbUBTiL55YL18hIvO9AH0A=="
          }
        ]
      },
      "maintainers": [
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.50.1_1561391569723_0.8710707428034714"
      },
      "_hasShrinkwrap": false
    },
    "0.50.2": {
      "name": "ts-json-schema-generator",
      "version": "0.50.2",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "./bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "licenses": [
        {
          "type": "MIT",
          "url": "http://www.opensource.org/licenses/mit-license.php"
        }
      ],
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=6.0.0"
      },
      "dependencies": {
        "commander": "~2.20.0",
        "glob": "~7.1.4",
        "json-stable-stringify": "^1.0.1",
        "typescript": "~3.5.2"
      },
      "devDependencies": {
        "@types/glob": "^7.1.1",
        "@types/jest": "^24.0.15",
        "@types/json-schema": "^7.0.3",
        "@types/json-stable-stringify": "^1.0.32",
        "@types/node": "^12.0.8",
        "@typescript-eslint/eslint-plugin": "^1.9.0",
        "@typescript-eslint/parser": "^1.9.0",
        "ajv": "~6.10.0",
        "chai": "~4.2.0",
        "eslint": "^5.16.0",
        "jest": "^24.8.0",
        "jest-junit": "^6.4.0",
        "source-map-support": "~0.5.12",
        "ts-jest": "^24.0.2",
        "ts-node": "^8.2.0"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "preversion": "yarn lint",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint '{src,test,factory}/**/*.ts'",
        "fix": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "FAST_TEST=1 jest test/ --verbose",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts"
      },
      "jest": {
        "transform": {
          "^.+\\.tsx?$": "ts-jest"
        },
        "testRegex": "(/__tests__/.*|(\\.|/)(test|spec))\\.(jsx?|tsx?)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "jsx",
          "json",
          "node"
        ],
        "testPathIgnorePatterns": [
          "node_modules",
          "test-runtime",
          "<rootDir>/build",
          "_site",
          "src",
          "dist"
        ],
        "coverageReporters": [
          "html",
          "cobertura"
        ],
        "coverageDirectory": "./coverage/",
        "collectCoverage": false,
        "testEnvironment": "node"
      },
      "gitHead": "35e674978d60b409ca5c2698e9d9a7a385a050c5",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.50.2",
      "_nodeVersion": "11.15.0",
      "_npmVersion": "6.7.0",
      "dist": {
        "integrity": "sha512-S6n8kHpU2y7IJvr07rA2Xn9wbKRWTs31jvgpFQnkWn4n7jWXOj/yGEzp1UN/qQOBB0r3qSZjsOMr2KzuaSWTGA==",
        "shasum": "3a2f6ace51166b7c8d16c11f58f316ff4279d3ad",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.50.2.tgz",
        "fileCount": 402,
        "unpackedSize": 775095,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJdEkS+CRA9TVsSAnZWagAA9u0QAJwV1n+E+HdWEXYC8xul\nw04OblpKQzQP8HgdbC77+NQmdoenSHNWkTnuKKcoO5P2IVSyby5JZ6afENZR\nbmfX8VccfwrdFhtWDRD/E5Uip7mwSEUo3DSPLSqnifZXOFCADQ/z2YTKQZjC\nFyYxZfOBOD0mB32cUpZIrmVlEvL5Wk5YEu+31OjGCuUb4mvd+L7TwmaPAGoE\nFN9X8gCZptkc9/fEmeJSgoSO5LC+ujae8dAL6LvASzNN4m0E5XTThuRJDyB7\nEGmLTv7SN4OfhbhyenpXix2IRZg5W8CEjm2+UiUN8MdDqS0JTnrENKnNLruA\nz0/1yXyg15PvwuSGtQlfstK4X/BpTqngX7JIv9Ox7FdScwBP4nPabYmL6DQO\nkt3VfSdM/tREUcy9cFxkvH/pmrKycjAQYToT4eaYATYDVDPmm2YS+ti7gP0U\nn9zw9d+dSETCzbaRYI/UA2Ox7jx9hfQiMHZn3YyP9iBFKnruIrRMX2ICg8J8\nQ0CRJYT0o1Bw4whG154Nj7LwBFhDPu7AKyKROv+4a6durUw3g+IMKzv/IBHh\nZYkqaPij/kCMpaAhzk0QFG9qql3p9wH25kMPn16G0bBoCdnh4EbrOPxcGez4\nWQgCmO7iC+I812j1BYTNj5E83UyDYyPOeKRIFP3X2adgyx++z8sjPsJL3uUd\nx7wh\r\n=jjzU\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIHb9ccsI7jt1J6KMXko/xBccTu0amSXyTrdBaOV8o/NsAiEAka37ylmOCRE+Uu4YA4RCmwOlDmlQt2C0dCkHBjgEpSI="
          }
        ]
      },
      "maintainers": [
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.50.2_1561478333634_0.13568879292093894"
      },
      "_hasShrinkwrap": false
    },
    "0.51.0": {
      "name": "ts-json-schema-generator",
      "version": "0.51.0",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "./bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "licenses": [
        {
          "type": "MIT",
          "url": "http://www.opensource.org/licenses/mit-license.php"
        }
      ],
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=6.0.0"
      },
      "dependencies": {
        "commander": "~2.20.0",
        "glob": "~7.1.4",
        "json-stable-stringify": "^1.0.1",
        "typescript": "~3.5.3"
      },
      "devDependencies": {
        "@types/glob": "^7.1.1",
        "@types/jest": "^24.0.15",
        "@types/json-schema": "^7.0.3",
        "@types/json-stable-stringify": "^1.0.32",
        "@types/node": "^12.6.8",
        "@typescript-eslint/eslint-plugin": "^1.12.0",
        "@typescript-eslint/parser": "^1.12.0",
        "ajv": "~6.10.2",
        "chai": "~4.2.0",
        "eslint": "^5.16.0",
        "jest": "^24.8.0",
        "jest-junit": "^6.4.0",
        "source-map-support": "~0.5.12",
        "ts-jest": "^24.0.2",
        "ts-node": "^8.3.0"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "preversion": "yarn lint",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint '{src,test,factory}/**/*.ts'",
        "fix": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "FAST_TEST=1 jest test/ --verbose",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts"
      },
      "jest": {
        "transform": {
          "^.+\\.tsx?$": "ts-jest"
        },
        "testRegex": "(/__tests__/.*|(\\.|/)(test|spec))\\.(jsx?|tsx?)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "jsx",
          "json",
          "node"
        ],
        "testPathIgnorePatterns": [
          "node_modules",
          "test-runtime",
          "<rootDir>/build",
          "_site",
          "src",
          "dist"
        ],
        "coverageReporters": [
          "html",
          "cobertura"
        ],
        "coverageDirectory": "./coverage/",
        "collectCoverage": false,
        "testEnvironment": "node"
      },
      "gitHead": "e48686e9646bf6010c716319de314aee470f8018",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.51.0",
      "_nodeVersion": "11.15.0",
      "_npmVersion": "6.7.0",
      "dist": {
        "integrity": "sha512-DUQKCnBwDaJije9W0HrBp+5alrb6BLsFX8KAbwmC1a+cmrMLpT8yZ22SP95dQnCRYPbsJW/+q39Q8mDx7skbBg==",
        "shasum": "ffc684bfd75208e4ffed3052a39a4ae8c0fe58bf",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.51.0.tgz",
        "fileCount": 408,
        "unpackedSize": 784458,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJdNHwGCRA9TVsSAnZWagAA9XQP/jQC7tYQWfGBGylbI5sH\nkNzyJQW1TEzOhzDxyaWvtUpsgrlUd/0X/dK2vhI6ZFXGWXzk0r98LatZT4pq\ngwifvgta7LRRXZUaykKOvGs8OTnzTCMzweKu3WVIaYWWdO7bRgJ+7Qrd9Cg8\niyegFhfnKaRuSKF5ikU0xQCwwSBfyI78wbaXGKclM/2F0/rwJwhH7QRgbkWE\nshmFCEQOg6V226cw16XDryLmXSXfC/zWqm4XvYyqzzDgaMwf/NO6qqBK3Aq8\n0wz3/vcGr9Aexi9Fxnw8CCJ+syZLEXnx7CjlNhOz4cU863ggfnWIWeh+b/jt\njObyq6JjLyrLo0UfD34ifRrOhOoix6GMSCvTiEyXKtXBYrIJF6spIsexpZF6\nzGC0r68TDhNQOIRRFB8bC4c0Fkx17FbFRWNtOYrrESJXSAOM9FgGei00d3vJ\nAuDSDpCsSEMP3QZ2gJa6lhxnJ2mAthDTJo58Uak7FF5cSum/UwejJ0mD2KDb\neCKdmnu/AlWmj3iedYMwUVkVz4EOjuIfb5SAzyS5+ckuUnjGRFCBpzG+2Zwm\n3DoAvp1OsXnSRLnVF1dXN1ahbWuOr4TWe/6KFxF/TYQVjtbJmhC0sI9Uuq4X\no+UibFGPwOMTFNY7/BvT4qswkkbbMyDsrv1BQhXI7mSDISUAQD8R6uJSCR82\nSmNb\r\n=6Zj+\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEYCIQC6pyXMPrFKNiE4aEKRGC9cFN6Y3EwXHKgHf9JXBveQnAIhAOOf5oZoY7OdNjX8Hr+cSFZmbqfaLkG+X2k0c8Qg9bbD"
          }
        ]
      },
      "maintainers": [
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.51.0_1563720709280_0.39920650956787473"
      },
      "_hasShrinkwrap": false
    },
    "0.52.2": {
      "name": "ts-json-schema-generator",
      "version": "0.52.2",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "./bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "licenses": [
        {
          "type": "MIT",
          "url": "http://www.opensource.org/licenses/mit-license.php"
        }
      ],
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=6.0.0"
      },
      "dependencies": {
        "commander": "~2.20.0",
        "glob": "~7.1.4",
        "json-stable-stringify": "^1.0.1",
        "typescript": "~3.5.3"
      },
      "devDependencies": {
        "@types/glob": "^7.1.1",
        "@types/jest": "^24.0.15",
        "@types/json-schema": "^7.0.3",
        "@types/json-stable-stringify": "^1.0.32",
        "@types/node": "^12.6.8",
        "@typescript-eslint/eslint-plugin": "^1.13.0",
        "@typescript-eslint/parser": "^1.13.0",
        "ajv": "~6.10.2",
        "chai": "~4.2.0",
        "eslint": "^6.1.0",
        "eslint-config-prettier": "^6.0.0",
        "eslint-plugin-prettier": "^3.1.0",
        "jest": "^24.8.0",
        "jest-junit": "^6.4.0",
        "prettier": "^1.18.2",
        "source-map-support": "~0.5.12",
        "ts-jest": "^24.0.2",
        "ts-node": "^8.3.0"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "preversion": "yarn lint",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint '{src,test,factory}/**/*.ts'",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "FAST_TEST=1 jest test/ --verbose",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts"
      },
      "jest": {
        "transform": {
          "^.+\\.tsx?$": "ts-jest"
        },
        "testRegex": "(/__tests__/.*|(\\.|/)(test|spec))\\.(jsx?|tsx?)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "jsx",
          "json",
          "node"
        ],
        "testPathIgnorePatterns": [
          "node_modules",
          "test-runtime",
          "<rootDir>/build",
          "_site",
          "src",
          "dist"
        ],
        "coverageReporters": [
          "html",
          "cobertura"
        ],
        "coverageDirectory": "./coverage/",
        "collectCoverage": false,
        "testEnvironment": "node"
      },
      "gitHead": "cdf25e4db5bbd8bad97f8322c788a2e1de83a686",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.52.2",
      "_nodeVersion": "12.4.0",
      "_npmVersion": "6.9.0",
      "dist": {
        "integrity": "sha512-RrDUZuQu+XJDLoYR19p0b7EGE8D+U0Xq34a7lEtIrYQYROcuoQ6Kodh0DoegLQd8S4CY0QOp1bk+IPpSq1qjYQ==",
        "shasum": "4659a91f346c6c34626d0da87ad8df27a69bc757",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.52.2.tgz",
        "fileCount": 414,
        "unpackedSize": 684799,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJdNrakCRA9TVsSAnZWagAA69QQAIKTuHuNgPYWDpI14+27\nYMfHWca89OchlZX1z97QS1ixQqZd6tV8WpuecwVADFgXLtas/BNdIzww86yl\nem9s1W071gOkU5mTNZ1sWN3LOcUb1jpDTHRrczWHijYe+dxby99kK5VveBOQ\nlLOD95fgVYPrrdYpxulNmDRgmJ9LfNCufUR1fAbwA04bxeShseDqXgMDx0Al\ncjknLLCHIeGflGsjQ6FrKmmUaKC2a6M2Tb0yPlHd1L6Y4iO7RlLcgfmjVE+2\njymmzpFwo7SDHCHN0uHc2GcW4ADzG2BSkqWRZaHA0H6TrG3pgZAd/LzoNfON\nEOLxy0HbhhZAOGsVs+VXqQ7H6rTgy2oTKqsWhgyqeYiXhiUeDUqWFKQI6KrB\nRnDL+8w9AepSpzvYqSNlZbc8yKvPg4fDbInpyIHHUcn0TqdsVGKFC4Q8o9ch\n26B6pXrIIjRefT8sIP+ZrHA5SOdeHXj4lL1DpkMv9fXHwEBIQC+VFT95WAPJ\notgvmwawgSFU2OfuPud41NI4ojqrwZRPy4JsubpgpxRdaTjGXo+E80V7Owfe\no3Sf9kt+i+PzCS5lnfqzDXByDXdv3DKsktBYwUtGtPbQgxA7dWuBJRziUNV+\nBbaSYh9bAbX6r2mkkol8pWTADXltUntXLMtK/lQb2zXaTsuLBLB7ht8TlsMi\n2CCC\r\n=92WY\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEQCIGtrANiJMwYoSNkEB9GQtYcpHynryVXo4iopeksXlq+8AiAh8RNRlqAeqv74IzUfWhwes5xGOXX9wv3OhJZFY67qbw=="
          }
        ]
      },
      "maintainers": [
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.52.2_1563866787861_0.6650689358949504"
      },
      "_hasShrinkwrap": false
    },
    "0.52.10": {
      "name": "ts-json-schema-generator",
      "version": "0.52.10",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "./bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "licenses": [
        {
          "type": "MIT",
          "url": "http://www.opensource.org/licenses/mit-license.php"
        }
      ],
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=6.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.3",
        "commander": "~2.20.0",
        "glob": "~7.1.4",
        "json-stable-stringify": "^1.0.1",
        "typescript": "~3.5.3"
      },
      "devDependencies": {
        "@types/glob": "^7.1.1",
        "@types/jest": "^24.0.15",
        "@types/json-stable-stringify": "^1.0.32",
        "@types/node": "^12.6.8",
        "@typescript-eslint/eslint-plugin": "^1.13.0",
        "@typescript-eslint/parser": "^1.13.0",
        "ajv": "~6.10.2",
        "chai": "~4.2.0",
        "eslint": "^6.1.0",
        "eslint-config-prettier": "^6.0.0",
        "eslint-plugin-prettier": "^3.1.0",
        "jest": "^24.8.0",
        "jest-junit": "^6.4.0",
        "prettier": "^1.18.2",
        "source-map-support": "~0.5.12",
        "ts-jest": "^24.0.2",
        "ts-node": "^8.3.0"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint '{src,test,factory}/**/*.ts'",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "FAST_TEST=1 jest test/ --verbose",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts"
      },
      "jest": {
        "transform": {
          "^.+\\.tsx?$": "ts-jest"
        },
        "testRegex": "(/__tests__/.*|(\\.|/)(test|spec))\\.(jsx?|tsx?)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "jsx",
          "json",
          "node"
        ],
        "testPathIgnorePatterns": [
          "node_modules",
          "test-runtime",
          "<rootDir>/build",
          "_site",
          "src",
          "dist"
        ],
        "coverageReporters": [
          "html",
          "cobertura"
        ],
        "coverageDirectory": "./coverage/",
        "collectCoverage": false,
        "testEnvironment": "node"
      },
      "gitHead": "e51ea80af5f330055a4529b5ba61f2e06af38ede",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.52.10",
      "_nodeVersion": "12.6.0",
      "_npmVersion": "6.9.0",
      "dist": {
        "integrity": "sha512-1pRwJfpjVbSgqoZX99HpheI3NmX3QAxiGQ3CqDMSfJmyXyXZLeCn0+84/UqdHtKyU8L585Fc3T5zBosbcgiBDA==",
        "shasum": "81e1814cef0d90b79bbe94cd563adc01444b4dc6",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.52.10.tgz",
        "fileCount": 413,
        "unpackedSize": 598426,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJdNwhMCRA9TVsSAnZWagAA4GsQAJnT0dwYS1LFBjAshpup\nuIDslyt/Snskv9sZhluyAfpqI5bVRXGKfp9QKt4aRnj9OFqAj4zI89zh6U97\nwGGYK9QDzV7eQw1O2LQWFWMSqoKsXa+xM0HBFRPvG7nNaOTONic4eg91WNBc\ne7F2Ik50JFGcXswsVhJkVwQWtOPzPj0liqD5fcJEO09OL5ahA28z6j8h61T4\ned7LyH5iGyg1+caVID89IPtDxehgSwWU4rCMGBG9i1oxY3QxbY8tFqErAWHK\nL2IO/lDzKUvLm9i7FKmoIlvARyE/YREUOevbFQKQJtsKy0Epywgz5MJ9eriw\nOn+BY4hfLWyRIq/T3w6qDKPuSIUBP7+k6QTT7zvWeOH3IFAXYD3WbXXhVaRg\nBcei5MgzNdorLSM9Ae2bQedE+1Zk4tmohcJtLujjRDYG5y+ed8vCxFl/qFI5\nh2+tuj7slmiCcCRvxcZQQyyy9VcntmxrM3RuDaHWOwKuh6E4TJYoKVuwl/RH\nViHhLTEFKxvBCknAbZDRyj0msrdXdrpIr7RT0uDYVusplK2OQLg6uABhcwtJ\n5UD3I354EOzGeFQcRmj2H3mgjP+4M809FuinfiDUzgv+R2JRWifItfGtiV8+\nJr48egFLSvihQPa34hACo4zvcm2eaGhY9gC4foy21XbaFMdABnHUEJSG6rXD\n3Uyb\r\n=ackw\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIQDljcpkkabigChKQenrx+pIh4htmVvStER8j/cecA1MRAIgckVyE7QDpmKGqNyxszeo08A4YDNMVlMDA8k8Wc34hEc="
          }
        ]
      },
      "maintainers": [
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.52.10_1563887691967_0.7435753226873327"
      },
      "_hasShrinkwrap": false
    },
    "0.52.9": {
      "name": "ts-json-schema-generator",
      "version": "0.52.9",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "./bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "licenses": [
        {
          "type": "MIT",
          "url": "http://www.opensource.org/licenses/mit-license.php"
        }
      ],
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=6.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.3",
        "commander": "~2.20.0",
        "glob": "~7.1.4",
        "json-stable-stringify": "^1.0.1",
        "typescript": "~3.5.3"
      },
      "devDependencies": {
        "@types/glob": "^7.1.1",
        "@types/jest": "^24.0.15",
        "@types/json-stable-stringify": "^1.0.32",
        "@types/node": "^12.6.8",
        "@typescript-eslint/eslint-plugin": "^1.13.0",
        "@typescript-eslint/parser": "^1.13.0",
        "ajv": "~6.10.2",
        "chai": "~4.2.0",
        "eslint": "^6.1.0",
        "eslint-config-prettier": "^6.0.0",
        "eslint-plugin-prettier": "^3.1.0",
        "jest": "^24.8.0",
        "jest-junit": "^6.4.0",
        "prettier": "^1.18.2",
        "source-map-support": "~0.5.12",
        "ts-jest": "^24.0.2",
        "ts-node": "^8.3.0"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint '{src,test,factory}/**/*.ts'",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "FAST_TEST=1 jest test/ --verbose",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts"
      },
      "jest": {
        "transform": {
          "^.+\\.tsx?$": "ts-jest"
        },
        "testRegex": "(/__tests__/.*|(\\.|/)(test|spec))\\.(jsx?|tsx?)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "jsx",
          "json",
          "node"
        ],
        "testPathIgnorePatterns": [
          "node_modules",
          "test-runtime",
          "<rootDir>/build",
          "_site",
          "src",
          "dist"
        ],
        "coverageReporters": [
          "html",
          "cobertura"
        ],
        "coverageDirectory": "./coverage/",
        "collectCoverage": false,
        "testEnvironment": "node"
      },
      "gitHead": "27d4f82715547bf6fe4682243418fb9509dd6ab6",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.52.9",
      "_nodeVersion": "12.6.0",
      "_npmVersion": "6.9.0",
      "dist": {
        "integrity": "sha512-QsEWz5J0+r7+t/Q5WTqvvkIGAuL0M3PnhKDU4GVr7CBPJZjnPpzCXT552P+C4UpbRZJQaNKl4SyppM/kGdMjUw==",
        "shasum": "871f3fa7d5267a79ee88c03c2c9bdbcd96725a97",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.52.9.tgz",
        "fileCount": 413,
        "unpackedSize": 598539,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJdNwhYCRA9TVsSAnZWagAAdW4QAKOJjbJzSc84nE80pySf\nVURTGUn9CiOpn+qHh5UXVX9xt+loz7eyXXUDSEcwwboS84cpaUNE2aEx80YI\nRR7ZFscTeBSlCLaB948vv3gGwrJc40e+uKEhHWOLtSAnvITNgUyO+d/IRw1f\ngs4LyL2N3I1uIsyGHCB4p4wTmFrQ7fCOlElR7Y1bWkP7QGWWrsGc8fipRcNd\ntUjhXTRIbZ5mkIts4Q3wzZN20TEDBztA3gk38BCGSHMVLaPZG/nvgWrGkOL5\njxCqhCP5H2o0+czhA6i8gx5E04EaEdtblJdOxVpq9uDw/vY1YXiulFb31j+p\n9KGBiEUg0tOkLZW+/WTAAElijyx9HaK5lDNbqbKzmCmvtZWzZcbqdOmBCZiG\nPh/XYCZxzEDnzPebvGzPjuxn1ed9DRHBYqQNwcFMUR0QrekoEWIPAyafh7r9\ntRB50LO5oi4UNO8WBdT6qMeAWgB0wnJrV+dCMbbLObC+EC9VvygGuvSI9jm1\nlXjcXJkGEr7L6TKKxooZeA8CfMZ/1vczi8iAXHOqXu6nSfE5VE8ANqZIc836\noKt5iH2LYNgR3ih/qEHytlu+YrnFmQUC+BZjNj4aFqFg/IdEKt8vF2nMjhkb\nRmyxZqvWw6mknfLx/2h0+SdMJ5lI4TdxeH8dwNOBNP2Pt7NCGQFuL95mfwBw\n3vCz\r\n=8/kn\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIQDdtFSVmQLtsDETAlygSHjha9/EXZMvYaOmb+BFjJiNmwIgUOqK+tTOh0kSHpfzXvDbLpR2iKF60XehZIrjCJlzmIs="
          }
        ]
      },
      "maintainers": [
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.52.9_1563887703929_0.7398597215167089"
      },
      "_hasShrinkwrap": false
    },
    "0.52.12": {
      "name": "ts-json-schema-generator",
      "version": "0.52.12",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "./bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "licenses": [
        {
          "type": "MIT",
          "url": "http://www.opensource.org/licenses/mit-license.php"
        }
      ],
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=6.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.3",
        "commander": "~2.20.0",
        "glob": "~7.1.4",
        "json-stable-stringify": "^1.0.1",
        "typescript": "~3.5.3"
      },
      "devDependencies": {
        "@types/glob": "^7.1.1",
        "@types/jest": "^24.0.15",
        "@types/json-stable-stringify": "^1.0.32",
        "@types/node": "^12.6.8",
        "@typescript-eslint/eslint-plugin": "^1.13.0",
        "@typescript-eslint/parser": "^1.13.0",
        "ajv": "~6.10.2",
        "chai": "~4.2.0",
        "eslint": "^6.1.0",
        "eslint-config-prettier": "^6.0.0",
        "eslint-plugin-prettier": "^3.1.0",
        "jest": "^24.8.0",
        "jest-junit": "^7.0.0",
        "prettier": "^1.18.2",
        "source-map-support": "~0.5.12",
        "ts-jest": "^24.0.2",
        "ts-node": "^8.3.0"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint '{src,test,factory}/**/*.ts'",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "FAST_TEST=1 jest test/ --verbose",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts"
      },
      "jest": {
        "transform": {
          "^.+\\.tsx?$": "ts-jest"
        },
        "testRegex": "(/__tests__/.*|(\\.|/)(test|spec))\\.(jsx?|tsx?)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "jsx",
          "json",
          "node"
        ],
        "testPathIgnorePatterns": [
          "node_modules",
          "test-runtime",
          "<rootDir>/build",
          "_site",
          "src",
          "dist"
        ],
        "coverageReporters": [
          "html",
          "cobertura"
        ],
        "coverageDirectory": "./coverage/",
        "collectCoverage": false,
        "testEnvironment": "node"
      },
      "gitHead": "a83c8087577a3b973cfbffb3cacda71ed13f0113",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.52.12",
      "_nodeVersion": "12.6.0",
      "_npmVersion": "6.9.0",
      "dist": {
        "integrity": "sha512-kj2Kmso7kO6tzHL0O7VwoxujOgeheOMHBVrE4h/aEZlR/KrV9DWVWyjxB6Nsc/Nm9yzbyW549S03500dmX/yBw==",
        "shasum": "def19bf29eb9c95bd425b7f511858dd3dd2b0a1e",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.52.12.tgz",
        "fileCount": 413,
        "unpackedSize": 598540,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJdN4fgCRA9TVsSAnZWagAAHmMP/RVz2C4qILRB9TvD+LCO\nAwsSo/9D/UOCWF4VnBIy62CXsz9HOcaUHt2N0fySwCiOjy9weQnSQSWWqQJa\nIuadmOirzewdPLfLBxrSStCODx0ZCk2f//I6RQ9jf9lyQ5i+m0xhdBq00Isk\nyt3LuxWca+GL6y03nB0pRcdbuW4RJl8gcnjO5jT5tYx2gSr0YrKPtqmmmmjX\nPF1Tm/U0IblYUTyYs46HZh+fjlNyWaiog0OMjKZd7USvLJCYXhnUQr0ppGbF\nGdEQ9GGMZqzIN8kXRCL7bcfT3uSDXPtLfgCzn2nC5eopMM+0IZIsfgpr/DoO\n9Ek+vUuiAYU4qup3H6iVw9WamJkhxIJp3vWO8bojg2RERidf/P22rSzGGtiC\nGzF7vkAQObCH3vpIlgOKteJr2q8vX084JqOX878frPOjwkLDbeT1EWz8QlZk\nPj4HuS1tXBiWAGZvjhvuhhjWvWK9aOxzhz5d2J3IPb9uDmH8R+GG4wRWFQLa\nZw+yzofk1t1DN5rpG7U1+wxt3TRU71Ppszb7l8KLMD+MbjYzy46+CQy1IuTw\nagCuwWJBx7cOcI1c+YOhO6izTxTfKspYE4Gq6VrOPvI7Z/oh9d8qMM0p9txK\nrTX9Ef8PFyYYer2mXXFu1LexTlY3XNM6nIJ+B1Azc3Pir2fbRQvuWweMal20\nelnj\r\n=+uHb\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEQCICgzZpnRnj49ROTYSRKhAHnHoCyPDEobgp1EgGQozdKKAiBMLzwNjvB7dT8q1sLxqJpbaG2djJ5AslgZXjRi83QE/A=="
          }
        ]
      },
      "maintainers": [
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.52.12_1563920351968_0.8678841849313819"
      },
      "_hasShrinkwrap": false
    },
    "0.32.14": {
      "name": "ts-json-schema-generator",
      "version": "0.32.14",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "./bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "licenses": [
        {
          "type": "MIT",
          "url": "http://www.opensource.org/licenses/mit-license.php"
        }
      ],
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=6.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.3",
        "commander": "~2.20.0",
        "glob": "~7.1.4",
        "json-stable-stringify": "^1.0.1",
        "typescript": "~3.5.3"
      },
      "devDependencies": {
        "@types/glob": "^7.1.1",
        "@types/jest": "^24.0.15",
        "@types/json-stable-stringify": "^1.0.32",
        "@types/node": "^12.6.8",
        "@typescript-eslint/eslint-plugin": "^1.13.0",
        "@typescript-eslint/parser": "^1.13.0",
        "ajv": "~6.10.2",
        "chai": "~4.2.0",
        "eslint": "^6.1.0",
        "eslint-config-prettier": "^6.0.0",
        "eslint-plugin-prettier": "^3.1.0",
        "jest": "^24.8.0",
        "jest-junit": "^7.0.0",
        "prettier": "^1.18.2",
        "source-map-support": "~0.5.12",
        "ts-jest": "^24.0.2",
        "ts-node": "^8.3.0"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint '{src,test,factory}/**/*.ts'",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "FAST_TEST=1 jest test/ --verbose",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts"
      },
      "jest": {
        "transform": {
          "^.+\\.tsx?$": "ts-jest"
        },
        "testRegex": "(/__tests__/.*|(\\.|/)(test|spec))\\.(jsx?|tsx?)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "jsx",
          "json",
          "node"
        ],
        "testPathIgnorePatterns": [
          "node_modules",
          "test-runtime",
          "<rootDir>/build",
          "_site",
          "src",
          "dist"
        ],
        "coverageReporters": [
          "html",
          "cobertura"
        ],
        "coverageDirectory": "./coverage/",
        "collectCoverage": false,
        "testEnvironment": "node"
      },
      "gitHead": "110d39866030604ed579ab1bf557ba83c8b743d7",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.32.14",
      "_nodeVersion": "12.6.0",
      "_npmVersion": "6.9.0",
      "dist": {
        "integrity": "sha512-FxUNZB/FiVLeIRfjqu5Lb7F1GDAtN+YTAlLjtyV0St4Kn9fAXwnyV2R8ggYKwIwc2EckLedB/aiUAF0PhxfQjw==",
        "shasum": "dd84ea3d1f6eaea2dc667915d927f0d286cd6045",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.32.14.tgz",
        "fileCount": 413,
        "unpackedSize": 598630,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJdOYF8CRA9TVsSAnZWagAAcJoP/RImjhNsIC8aOSi1oC1X\nBzxy4OtcX/SEuCRDKkYThiIzOK+HQ5OjP29OUfwUUw0jUbpYettc0Nih6zcy\nIixW0jz+FHF2YlcRgMZIjtF3ghnCq8ncXjAGHgi9A+CaSdyE0tRvJkT/DwAB\ncIX+Dc2A45+cWkWeWv3slCzVmQR+3EOlKb/Cq8NUbdQv88Vf/kf/m95Djz97\nPg4Zf8wAlBRQiqe2hGrnN7VYuxMZoj1WT/+ztBwexn4Ub3JJLb8WIeFio25b\nlTOjZgGc5gVINZwTrq89jwZlwJ/G3dKYoKVyNcM4fWQrevRWkrS7ewz2129T\npCwQu5CH/h5HtUGdeM6OTKwy/o1j5pb16OWRIHZJA6aBxxbB7RV4bRP42yVB\nV6147T/sH8nJJdsDDhZEcOKB6Jc4BE2MrSwccNtqBKn/XC7uRCYLqBP5ES6+\ngkk50fDHfMxaFcj5jJhl7Xdik1c2acANenqv5UOwz8n4mqr5+pFshBufW6mU\n4OUeeOtKfnnU5H9C1gOX1loN/4kgiDyhHKh+JIugNLduLkibFxQbnzKoOrR0\nwUBfK3kCcBzuFWiRFyuVQu6JVgnFzl+cxvKKb6t1ptYZNqnG3nru2JNhc7sy\nawr2hiyhpn03H9ENND/4cScbZTBj38kdUVPHcihjuvEQWMxAXY/U7rXmATsV\npbmm\r\n=GJW/\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIQCgH7bZLT/Jr+cuhnxJPEvJq8t449Is+cBLjyD5WDtG8wIgYlbwqq7HMvcUCqxK9vFEYxdgeZaQs76k/shNdff0k6Q="
          }
        ]
      },
      "maintainers": [
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.32.14_1564049788182_0.5427120869234501"
      },
      "_hasShrinkwrap": false
    },
    "0.52.13": {
      "name": "ts-json-schema-generator",
      "version": "0.52.13",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "./bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "licenses": [
        {
          "type": "MIT",
          "url": "http://www.opensource.org/licenses/mit-license.php"
        }
      ],
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=6.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.3",
        "commander": "~2.20.0",
        "glob": "~7.1.4",
        "json-stable-stringify": "^1.0.1",
        "typescript": "~3.5.3"
      },
      "devDependencies": {
        "@types/glob": "^7.1.1",
        "@types/jest": "^24.0.15",
        "@types/json-stable-stringify": "^1.0.32",
        "@types/node": "^12.6.8",
        "@typescript-eslint/eslint-plugin": "^1.13.0",
        "@typescript-eslint/parser": "^1.13.0",
        "ajv": "~6.10.2",
        "chai": "~4.2.0",
        "eslint": "^6.1.0",
        "eslint-config-prettier": "^6.0.0",
        "eslint-plugin-prettier": "^3.1.0",
        "jest": "^24.8.0",
        "jest-junit": "^7.0.0",
        "prettier": "^1.18.2",
        "source-map-support": "~0.5.12",
        "ts-jest": "^24.0.2",
        "ts-node": "^8.3.0"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint '{src,test,factory}/**/*.ts'",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "FAST_TEST=1 jest test/ --verbose",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts"
      },
      "jest": {
        "transform": {
          "^.+\\.tsx?$": "ts-jest"
        },
        "testRegex": "(/__tests__/.*|(\\.|/)(test|spec))\\.(jsx?|tsx?)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "jsx",
          "json",
          "node"
        ],
        "testPathIgnorePatterns": [
          "node_modules",
          "test-runtime",
          "<rootDir>/build",
          "_site",
          "src",
          "dist"
        ],
        "coverageReporters": [
          "html",
          "cobertura"
        ],
        "coverageDirectory": "./coverage/",
        "collectCoverage": false,
        "testEnvironment": "node"
      },
      "gitHead": "3e10b42432b05709052b780e093f261d32cfcadb",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.52.13",
      "_nodeVersion": "12.4.0",
      "_npmVersion": "6.9.0",
      "dist": {
        "integrity": "sha512-kKujhSEllAxkG2VScnvP6m7pHx0P1a6L/MpIxy+7yxx7wBsZmIxL+FQZ0pRuCfne1dFE4OVD35KpN7XW4IyivQ==",
        "shasum": "cf793bbde77bc481205c3b7ef546cacc0a429f3e",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.52.13.tgz",
        "fileCount": 417,
        "unpackedSize": 687519,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJdOYX4CRA9TVsSAnZWagAADrAQAJxxyVL6+yOAZnpG8nv5\nYOqrSXnrShl/FIOf51IWSx0SCKa1Zc7S5IjagBYB2YmR1/EtQ5hKW8/geg+Z\n25dH+RIjv8rW6L8VNfXmbZHQfqtKDwpVxqrS1fVyQsjD8rd4wz5R0af4grP/\nGEoRFtWk5y0grZj6/XnKYEr7pUpc3bvpAh9kwWFjLpIS1xwwhByRNmXjLZ1e\n+ak8c7tcf/Z3gne9WG10GtEqMVz8TRTJvgA5J5m60fwTRY4a8qU1x0Az6kE4\nbkol9wsGjp4v+4HPghuIslzDPNESLVxTtXS5HzZy+7thDAW4SH8JiolPLQzq\nVhnnaGqNP+/0ScZcnys0mZzh0fMnU06Mn6oh+0zPji1dDicz2W1JMsoD41R4\nQc280WO3cu1sxVN97KkOTVBfjEU6FOeE9OGilagXMh5LgC4EpthnAZI5IlrA\nSh/Ics194R9zmDZcBSRJ4/NhWTQFTDF4CyXmrhD7vOeH7+9Z6pKLt6Uq32Hl\nmddIJhbGHJbfjzlhYAatg1XbsVSei4jQSOdBY0B3SCRY7rYrAmFFWCFcI2Rc\nEnk4I7hnKkPmq/YXxD2MhhscOQ/MEy6cWflsG/1aCDwbcOkNiSYkwzLZcap6\nvlsfxHPEQq87Gy6HiG03Nsdjm8CPzq8lgHP4FzCbv7dPAZeMq9jTlQ2CeGlr\nSRGN\r\n=srvC\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEQCIFJMagLf0w7DiFeI24n71Rga0sDC1agRrFWVq7phsfAkAiAkHHlXFcYo6EMvJxxRLc8mWVP8T01DFmNA+Y79YQvwrg=="
          }
        ]
      },
      "maintainers": [
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.52.13_1564050936305_0.9692238963725561"
      },
      "_hasShrinkwrap": false
    },
    "0.52.14": {
      "name": "ts-json-schema-generator",
      "version": "0.52.14",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "./bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "licenses": [
        {
          "type": "MIT",
          "url": "http://www.opensource.org/licenses/mit-license.php"
        }
      ],
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=6.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.3",
        "commander": "~2.20.0",
        "glob": "~7.1.4",
        "json-stable-stringify": "^1.0.1",
        "typescript": "~3.5.3"
      },
      "devDependencies": {
        "@types/glob": "^7.1.1",
        "@types/jest": "^24.0.15",
        "@types/json-stable-stringify": "^1.0.32",
        "@types/node": "^12.6.8",
        "@typescript-eslint/eslint-plugin": "^1.13.0",
        "@typescript-eslint/parser": "^1.13.0",
        "ajv": "~6.10.2",
        "chai": "~4.2.0",
        "eslint": "^6.1.0",
        "eslint-config-prettier": "^6.0.0",
        "eslint-plugin-prettier": "^3.1.0",
        "jest": "^24.8.0",
        "jest-junit": "^7.0.0",
        "prettier": "^1.18.2",
        "source-map-support": "~0.5.12",
        "ts-jest": "^24.0.2",
        "ts-node": "^8.3.0"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint '{src,test,factory}/**/*.ts'",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "FAST_TEST=1 jest test/ --verbose",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts"
      },
      "jest": {
        "transform": {
          "^.+\\.tsx?$": "ts-jest"
        },
        "testRegex": "(/__tests__/.*|(\\.|/)(test|spec))\\.(jsx?|tsx?)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "jsx",
          "json",
          "node"
        ],
        "testPathIgnorePatterns": [
          "node_modules",
          "test-runtime",
          "<rootDir>/build",
          "_site",
          "src",
          "dist"
        ],
        "coverageReporters": [
          "html",
          "cobertura"
        ],
        "coverageDirectory": "./coverage/",
        "collectCoverage": false,
        "testEnvironment": "node"
      },
      "gitHead": "2c0665ed1919c47c57b9e432dee4e7fbf77f52c4",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.52.14",
      "_nodeVersion": "12.4.0",
      "_npmVersion": "6.9.0",
      "dist": {
        "integrity": "sha512-OkhNEvTu7q2Mw7vMgMuXPDkWY3mIfH5EUIeyIIBkajZVWSpaRD+Mb9j5DBacD/sZn/pf2Q/o2tEf4um6S6L6WA==",
        "shasum": "04b0005e23e1b13a8dc9a58d5a1f85e229eef056",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.52.14.tgz",
        "fileCount": 416,
        "unpackedSize": 687907,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJdOY+RCRA9TVsSAnZWagAAz4gP/RzCl542K4g4FDzF7Cmq\nGbuifEJq0Rb0o99CXAALroIKKyAPsQ7m4t9ebfvddLpLVoGHLR4xoenW5L6r\norRm8+tzUhUMywS88UO4FrVttY3POMm1jmgt1jOTIb1TT2mPRxPf3mZBr0De\nQOz/sa3E+bWcLcKTMZzsNVsk6kQ2oLVlOfkFgpmzYL/lduNSo9JRai+t8eBU\nca/JAdHCfncDiYnJPyJlFkZDsaTVrH/3/AuuHlLW2wfoOTBpZ1i2aFvkM6Yg\nDhtAyxNggUkhIcGfNVlb3/A1KtazyCErN3nhu1KcTaE+EQ6gPuPDAlAYh8Wp\nver98E0yqcR6PGmx8e45q9cLRRAbmccy/f/eFBPZh+ih19OpHB89eEYp451t\nXLCANPgAD7vekHKstEjaeZF023RuA41YQvK5J+rPhm2JFuu2trKpBbDpXEki\nLRNupgfckOuidC0wP+BIBEeiONXUWZeFa43Ojq4MM4QW1pVRzFDBxJjPzpvV\nFc7BUihlrupJeh7kzabLwNCRM/QAAmrktGFUR7UwsJHj0u74fJaFbdHHfQzT\nmLvqS0IHyLQUv+95xsF2p/QyrEj66MjcUy4IPN75lsgz7syFCJto7I9+9ikv\nk2AiMPVue1T78F+APWJZZvY15zK72Ej9vrjwnlAWAtiAzuXsgj+iYV+BMEx6\npRfd\r\n=zv/g\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEQCIB3GRLaX98QsxuHrWOr0PpEQq2hLmxw7A2FJBdH+e7+1AiB6sH26J3d3WPZCb0ijFdqsMUNh6ViFIn+/ypIq7K2KGw=="
          }
        ]
      },
      "maintainers": [
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.52.14_1564053393169_0.9473277885196949"
      },
      "_hasShrinkwrap": false
    },
    "0.53.0": {
      "name": "ts-json-schema-generator",
      "version": "0.53.0",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "./bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "licenses": [
        {
          "type": "MIT",
          "url": "http://www.opensource.org/licenses/mit-license.php"
        }
      ],
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=6.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.3",
        "commander": "~3.0.1",
        "glob": "~7.1.4",
        "json-stable-stringify": "^1.0.1",
        "typescript": "~3.6.3"
      },
      "devDependencies": {
        "@types/glob": "^7.1.1",
        "@types/jest": "^24.0.18",
        "@types/json-stable-stringify": "^1.0.32",
        "@types/node": "^12.7.5",
        "@typescript-eslint/eslint-plugin": "^2.3.0",
        "@typescript-eslint/parser": "^2.3.0",
        "ajv": "~6.10.2",
        "chai": "~4.2.0",
        "eslint": "^6.4.0",
        "eslint-config-prettier": "^6.3.0",
        "eslint-plugin-prettier": "^3.1.1",
        "jest": "^24.9.0",
        "jest-junit": "^8.0.0",
        "prettier": "^1.18.2",
        "source-map-support": "~0.5.13",
        "ts-jest": "^24.1.0",
        "ts-node": "^8.4.1"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint '{src,test,factory}/**/*.ts'",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "FAST_TEST=1 jest test/ --verbose",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts"
      },
      "jest": {
        "transform": {
          "^.+\\.tsx?$": "ts-jest"
        },
        "testRegex": "(/__tests__/.*|(\\.|/)(test|spec))\\.(jsx?|tsx?)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "jsx",
          "json",
          "node"
        ],
        "testPathIgnorePatterns": [
          "node_modules",
          "test-runtime",
          "<rootDir>/build",
          "_site",
          "src",
          "dist"
        ],
        "coverageReporters": [
          "html",
          "cobertura"
        ],
        "coverageDirectory": "./coverage/",
        "collectCoverage": false,
        "testEnvironment": "node"
      },
      "gitHead": "78a32cb33071545d7c6f50047bdc295df96d14cf",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.53.0",
      "_nodeVersion": "12.10.0",
      "_npmVersion": "6.10.3",
      "dist": {
        "integrity": "sha512-xFZznDZStSP5lBbUy2IjfOQQSoVqdsI2OaSpLzxkhczW/1hPtxry1laoa9G/OCLJS0EFkDcO7X30PbC/nII/cQ==",
        "shasum": "4548dfca1d3f9cca2ec2438cda6ca5d0713d5e0d",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.53.0.tgz",
        "fileCount": 414,
        "unpackedSize": 552285,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJdli63CRA9TVsSAnZWagAAtyMP/2NGq7UMPvh9j4pLJGRG\n+VAbX0AK7L7CCw6AoBJqRGL+dfsiUcOSvBpn9XFYXZP81+D2WhaLiLwRAeV6\nqbytUNPQ3GbJRIqavzgix8ig0SWlvyQdiahmZIT/zE55DE8s2YglkB2aWu2g\nCwMuN5FafcjvnEJwCOtS/GkX45Txc0mxPG0BIZS2Vhocn4kCqq3mb9ujj5p4\nc2RBRYpNhCoK9BN8lQyw6RrvlgEgzMmkqxLQcSlIl0riRATf6f137EWrL2dv\nMCGEu6/OTkxUgzytVArI/glZepH8ap/Z56sAlec4CHeoVB4iSVVSJ+URJw3N\nqSN7wEHu6rEUaah19JBXUoNj9N4V+eu/DDbBCT58oL9xUwyQLRrDRm0sw6WC\n6CurmoLCQtK2KIqe0QnSKKP4bh7vsV8Y6QQeGZvAKFrzCWTeMh9VGT2MaX1B\nbvHuTmF0QoSES7cAeOG/BtLZ7QONFf1aQ5NA0iPbTAzcNmhHq/XpQvs44/Tn\nfCL5vbVJ0qljNrYg7fsRJgQhe+nksnoGdXBEbLkTJQvk1nOcSdVjenrfC5Fy\n2tksn2eS/42mSIvHOhsB4uVu0VXa1nVW88NMBRris4AOOy0uwhahoFws5wJz\nBj98r3cJus1zrkhCUEh3MmpwRZL4/gylnFg3OAAX84oZOrHsQmnPJMlsfIWs\n48Bm\r\n=WG/E\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEQCIG1st4qedPB/z4C35SzZLiVQzGhfFstWKBBFcZT8jJi1AiASCzMYrWnfaUycjNiJDr4NP8CtzlAtEHaYaUhkh1VDKQ=="
          }
        ]
      },
      "maintainers": [
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.53.0_1570123446629_0.09026229630628024"
      },
      "_hasShrinkwrap": false
    },
    "0.54.0": {
      "name": "ts-json-schema-generator",
      "version": "0.54.0",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "./bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=6.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.3",
        "commander": "~3.0.2",
        "glob": "~7.1.4",
        "json-stable-stringify": "^1.0.1",
        "typescript": "~3.6.3"
      },
      "devDependencies": {
        "@types/glob": "^7.1.1",
        "@types/jest": "^24.0.18",
        "@types/json-stable-stringify": "^1.0.32",
        "@types/node": "^12.7.12",
        "@typescript-eslint/eslint-plugin": "^2.3.3",
        "@typescript-eslint/parser": "^2.3.3",
        "ajv": "~6.10.2",
        "chai": "~4.2.0",
        "eslint": "^6.5.1",
        "eslint-config-prettier": "^6.4.0",
        "eslint-plugin-prettier": "^3.1.1",
        "jest": "^24.9.0",
        "jest-junit": "^8.0.0",
        "prettier": "^1.18.2",
        "source-map-support": "~0.5.13",
        "ts-jest": "^24.1.0",
        "ts-node": "^8.4.1"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint '{src,test,factory}/**/*.ts'",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "FAST_TEST=1 jest test/ --verbose",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts"
      },
      "jest": {
        "transform": {
          "^.+\\.tsx?$": "ts-jest"
        },
        "testRegex": "(/__tests__/.*|(\\.|/)(test|spec))\\.(jsx?|tsx?)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "jsx",
          "json",
          "node"
        ],
        "testPathIgnorePatterns": [
          "node_modules",
          "test-runtime",
          "<rootDir>/build",
          "_site",
          "src",
          "dist"
        ],
        "coverageReporters": [
          "html",
          "cobertura"
        ],
        "coverageDirectory": "./coverage/",
        "collectCoverage": false,
        "testEnvironment": "node"
      },
      "gitHead": "503efe3a361d7a16a1e20d82114da22561b20595",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.54.0",
      "_nodeVersion": "12.11.1",
      "_npmVersion": "6.11.3",
      "dist": {
        "integrity": "sha512-EXOsX0/fr7BxZgiruO53by/VoUMA0IDzKDQ4XE9ttrM9tEbUnjkpdCD+xbN8itZ8Wq7Kv1dj1kHZJOP1ZApbgQ==",
        "shasum": "d2a37847085b2194e780815126fa5bb23b88f681",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.54.0.tgz",
        "fileCount": 420,
        "unpackedSize": 562112,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJdnSwnCRA9TVsSAnZWagAAKkcP/2J2vSPAXQOZmMBB4dgv\nFcI2/15dpV1GCoo9J6oWocDdVdgJjO4EVepfYBSLweXW4Z6QCSQd4eanWG4B\nxHtWYDO0E6nGLBzZBu458yPP8/NgTfqEgg5+riSUXMWchdZ1vNTTAGOzBOCn\npTBKq9WlxtRvDKzpws/KYZiIO5tK+0IJTkhs288BH/yiwGiUSWDg4wN9Ctts\nudoBuY78zCFp4YTftwg9Q9uFWg1vLa0PWpsMVOTczuQrbt722QF6S3lCZB/+\nGzNsEfujv0XZWGapQo3gWSo27342rcrJorwF2aXE+cgceLgEoTH740DgBsM9\nO0iC2IRW/Rjtv8O7UOMEdfWgceYupGHwyz1Ku+oUbmWRzbWfpQBx9s0lea3g\nuN8Yml+tJte4XsmMte/ZVL+2vYi7UGKN7rl6e5vyncOT9TJjybBctiD2ut+d\n9zr5fItItOAkCBDVCyNfXQpZfwU2JuKkmvbJlgf6W4hZDw1A9Xc03MHnzcKt\nHaYhmENJC/kysy4EwC6ANZ6tp7dJGhUvS0ycub7ipCk5u5wcWwMkSG+3CJ5t\n8/uUqNjN7tOcUrOCbnjPZf0oynpXJY8wG3E4gvxMncsvIjnQyzSJfX+noFAt\nRYV1cIvNLXWs7bS/j/CGKs5oVRCqPVO4rC4u5y0bIuZpjJBdDKS/+6MtH15g\nRAl6\r\n=X8vo\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIFfEQ31SxWWv3KjglXxsEKlCI0bzl9EBGBrx+O2fpu8eAiEAwOg2yEQthcGU0QAZ7Fw05CJz3c70b7IUj58aoWh8VAw="
          }
        ]
      },
      "maintainers": [
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.54.0_1570581542725_0.6996966343016722"
      },
      "_hasShrinkwrap": false
    },
    "0.55.0": {
      "name": "ts-json-schema-generator",
      "version": "0.55.0",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "./bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=6.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.3",
        "commander": "~3.0.2",
        "glob": "~7.1.5",
        "json-stable-stringify": "^1.0.1",
        "typescript": "~3.6.4"
      },
      "devDependencies": {
        "@types/glob": "^7.1.1",
        "@types/jest": "^24.0.19",
        "@types/json-stable-stringify": "^1.0.32",
        "@types/node": "^12.11.7",
        "@typescript-eslint/eslint-plugin": "^2.5.0",
        "@typescript-eslint/parser": "^2.5.0",
        "ajv": "~6.10.2",
        "chai": "~4.2.0",
        "eslint": "^6.6.0",
        "eslint-config-prettier": "^6.4.0",
        "eslint-plugin-prettier": "^3.1.1",
        "jest": "^24.9.0",
        "jest-junit": "^9.0.0",
        "prettier": "^1.18.2",
        "source-map-support": "~0.5.13",
        "ts-jest": "^24.1.0",
        "ts-node": "^8.4.1"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint '{src,test,factory}/**/*.ts'",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "FAST_TEST=1 jest test/ --verbose",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts"
      },
      "jest": {
        "transform": {
          "^.+\\.tsx?$": "ts-jest"
        },
        "testRegex": "(/__tests__/.*|(\\.|/)(test|spec))\\.(jsx?|tsx?)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "jsx",
          "json",
          "node"
        ],
        "testPathIgnorePatterns": [
          "node_modules",
          "test-runtime",
          "<rootDir>/build",
          "_site",
          "src",
          "dist"
        ],
        "coverageReporters": [
          "html",
          "cobertura"
        ],
        "coverageDirectory": "./coverage/",
        "collectCoverage": false,
        "testEnvironment": "node"
      },
      "gitHead": "7a4a1152f8410e374e4831bde80571fece0b4676",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.55.0",
      "_nodeVersion": "12.13.0",
      "_npmVersion": "6.12.0",
      "dist": {
        "integrity": "sha512-6bEVSVhvNnhYXZxutN2j96tabfEiu0OPeq5Z5i+h0N5zDm2lyYhr/zNc/K2Rx/FPPf02LLg5//NsCiX+U1wcpg==",
        "shasum": "66ea47a6cf20c26d9d4858abf59579a1bc39ea85",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.55.0.tgz",
        "fileCount": 429,
        "unpackedSize": 603619,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJds4E+CRA9TVsSAnZWagAAPFcP+weEzPd+G+uS70brD0Nz\n0NRJGCI/bcFkARyg5uLuCC2sAXRpa7zxjVfev9ljJuyJZ11H5sZv6ir1Xbv2\nn7eaO2aV3+EEPRZkPT9KH90DM94sxC2AJMokNJbYgob7bih0EpNtZxsqWrky\nYx/2ZaWSidhHcWEhmli86DTHYZVoOiQeos7RxntTocwOihH0MaGzLbhzBE+f\nxxddcvuqp1QVUAKprRgcFd2x6L5V0wQaPu/IoXnPuh75l0hesXOA7lI115f5\nk/JMYrcsSumrzYiTuySKdRy5cnuHpKoRV8U0xytji9XJ/XN+jv4snggcnsRo\nf44h8JTL7tmXIB9lKrfR9EmxuvLVU/PZ59ma08tDJgLJbZ/tojyz1GuGlsua\nwbjyODK4UCvldELAC1KX6eOR5CDQ6TwqCc936ufr8Eoa5UTok0Iqf0DdIFHJ\nShQ11B1Af2ESn5zz5mii+RoL3qPQKiKeCM9kd5P0VFDiSjB2aOr7UZrWQJ20\nlA3T2RJWGrjkkx3ftHdRGFLBcB0HIXD1E1hyt1t3hgL1AEpws0nUWadYDrWI\nOuCAupVf0IEVc4WXXILeqDmMh0/DzVDf9/TjcPAOB3TAeOC7/QBOeAP8Bn53\nsSRI981m8IWC53SMKmg1hh2hb0y3/v1vZr/qaD7/SpyMBqVVy4+ooomWO6I+\nS4IY\r\n=Y6Sj\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCICy9Mo2NVrGHIJt+HDICtR+ljq93xqTjNfFS5wWNglzxAiEAyOERaRomwJq3KgtupjaAOWjXhM6XYo9bWgVib9BqX5E="
          }
        ]
      },
      "maintainers": [
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.55.0_1572045117521_0.5976695809845647"
      },
      "_hasShrinkwrap": false
    },
    "0.56.0": {
      "name": "ts-json-schema-generator",
      "version": "0.56.0",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "./bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=6.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.3",
        "commander": "~4.0.0",
        "glob": "~7.1.5",
        "json-stable-stringify": "^1.0.1",
        "typescript": "~3.7.2"
      },
      "devDependencies": {
        "@types/glob": "^7.1.1",
        "@types/jest": "^24.0.21",
        "@types/json-stable-stringify": "^1.0.32",
        "@types/node": "^12.12.6",
        "@typescript-eslint/eslint-plugin": "^2.6.1",
        "@typescript-eslint/parser": "^2.6.1",
        "ajv": "~6.10.2",
        "chai": "~4.2.0",
        "eslint": "^6.6.0",
        "eslint-config-prettier": "^6.5.0",
        "eslint-plugin-prettier": "^3.1.1",
        "jest": "^24.9.0",
        "jest-junit": "^9.0.0",
        "prettier": "^1.18.2",
        "source-map-support": "~0.5.16",
        "ts-jest": "^24.1.0",
        "ts-node": "^8.4.1"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint '{src,test,factory}/**/*.ts'",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "FAST_TEST=1 jest test/ --verbose",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts"
      },
      "jest": {
        "transform": {
          "^.+\\.tsx?$": "ts-jest"
        },
        "testRegex": "(/__tests__/.*|(\\.|/)(test|spec))\\.(jsx?|tsx?)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "jsx",
          "json",
          "node"
        ],
        "testPathIgnorePatterns": [
          "node_modules",
          "test-runtime",
          "<rootDir>/build",
          "_site",
          "src",
          "dist"
        ],
        "coverageReporters": [
          "html",
          "cobertura"
        ],
        "coverageDirectory": "./coverage/",
        "collectCoverage": false,
        "testEnvironment": "node"
      },
      "gitHead": "6f70ff2afd3a454e38ab24b7f18636cdd8fc8ce9",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.56.0",
      "_nodeVersion": "12.13.0",
      "_npmVersion": "6.12.0",
      "dist": {
        "integrity": "sha512-zLkyP2gPnXFsZIeCfk5uKWT81Eh4C0jYGiOZbNKoRVjkzp/5NhNoW+859PfLpGPeK3vMJ5/SGIOVn5lWidOVCw==",
        "shasum": "68fc3aa1b0396416406a64a19ef080fff9586449",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.56.0.tgz",
        "fileCount": 429,
        "unpackedSize": 603607,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJdwfY9CRA9TVsSAnZWagAAJjMP/3uksbhuVOyNG7INpVWo\nZfyXekJY8DC6AAR+RXZQR/UYYsxH6DUfn6pAVfREpxUTDuymLQJbjgsJV3l1\nkmGWgvKse8R79XdEp/lJffZ4iXgrOLtFvAJLqOGn6nRHxmkTGtJkjp+FcwkQ\nsdNb62Ie384EErrme4dOl37FzYHetYMeiF/KuObaRBYKBRqm3keN1eyOqLlJ\nTIdai6FB4ccl5lHpfBYR113oazNa1jyXAJkGYfsTwrUgZ3yF2qlLMNde3DCj\n3C12sajfj8FjmqP94xy3kXoOL9YsYl5Q/ZClacQ5NtMhrJuKeSYssv9v5pgE\nkWvYle2tr7JhuR/7rgzdCPbp9ogIqISv2rrpC76bBP7ui9oGmTLiCi09Mmf/\nPztnh/ZN1wB26awYciKwA71S1CWvcg1GvXgEHEkfD71dj+U515Ju1qZjoaOW\ncXjTCj7SwkqZOtSNqMDglT4ZmOaTN0m4EbSKsGkbMsram+//5AFulJEnPmGu\nTrnqSRo9N0d5XlNz6t/8VXRDa9khiI+yY6Jgt7FwHp+mH67/82GS41mzB9k4\ngwousBEMoXkGhUnsHuluGZLadMvPq7CVeOQcg15I2BDuCAWUNZEJaAZfYMo7\n99cUxvCBBQpzJNMF65Jiw4b9eCaZL3URXc85YiIlPRRmKjkz7t2CFmyutd+5\nI74B\r\n=fjRr\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEQCIGUAwqlL7m8ZrhM7GQA+uo/6moyFzx2SJw/UIGqtral7AiBD2fET2ab6yShozgbhVReVSAOkcLBgr0Sd5aTyljLZgQ=="
          }
        ]
      },
      "maintainers": [
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.56.0_1572992572460_0.21511516161986943"
      },
      "_hasShrinkwrap": false
    },
    "0.57.0": {
      "name": "ts-json-schema-generator",
      "version": "0.57.0",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "./bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=6.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.3",
        "commander": "~4.0.0",
        "glob": "~7.1.6",
        "json-stable-stringify": "^1.0.1",
        "typescript": "~3.7.2"
      },
      "devDependencies": {
        "@types/glob": "^7.1.1",
        "@types/jest": "^24.0.22",
        "@types/json-stable-stringify": "^1.0.32",
        "@types/node": "^12.12.7",
        "@typescript-eslint/eslint-plugin": "^2.6.1",
        "@typescript-eslint/parser": "^2.6.1",
        "ajv": "~6.10.2",
        "chai": "~4.2.0",
        "eslint": "^6.6.0",
        "eslint-config-prettier": "^6.5.0",
        "eslint-plugin-prettier": "^3.1.1",
        "jest": "^24.9.0",
        "jest-junit": "^10.0.0",
        "prettier": "^1.19.1",
        "source-map-support": "~0.5.16",
        "ts-jest": "^24.1.0",
        "ts-node": "^8.4.1"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint '{src,test,factory}/**/*.ts'",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "FAST_TEST=1 jest test/ --verbose",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts"
      },
      "jest": {
        "transform": {
          "^.+\\.tsx?$": "ts-jest"
        },
        "testRegex": "(/__tests__/.*|(\\.|/)(test|spec))\\.(jsx?|tsx?)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "jsx",
          "json",
          "node"
        ],
        "testPathIgnorePatterns": [
          "node_modules",
          "test-runtime",
          "<rootDir>/build",
          "_site",
          "src",
          "dist"
        ],
        "coverageReporters": [
          "html",
          "cobertura"
        ],
        "coverageDirectory": "./coverage/",
        "collectCoverage": false,
        "testEnvironment": "node"
      },
      "gitHead": "ccd47c5f00f67942e69b86f9fb087035c4afed0a",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.57.0",
      "_nodeVersion": "13.1.0",
      "_npmVersion": "6.12.1",
      "dist": {
        "integrity": "sha512-t846uLm5GkseA9dSp00RGVKXM3fKO4cuPkzEkLTxNC2zOfVSjprWcdL2rUe30VoGm0sAoFdkaSwSfeib3O6bMw==",
        "shasum": "699f8e0602bc1185ca61d85c46d178b513fbc2be",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.57.0.tgz",
        "fileCount": 432,
        "unpackedSize": 605174,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJd6F3zCRA9TVsSAnZWagAA6H8P/0h+Xcv2/YCZ+NTl3muz\nQMjKscfdnvC0f+gev6H5faUSNVxj4LsymQ2hOTIGFHtk8dcDyJgOwE4aVWmQ\nyS5JX7Pg4Q5N50mhlivl0ztpB/BOUDP8fyQryo09fA+NImakFSXcrAtOpbdR\nYwH+wTRpsClUuBaSOPcVMk+ZizJoxkkU8O1zwTsNXxhozqMMzQWlgv7Ky13h\nl5lAVgDrEwP3PxlOWlX8DPiOQYjBBBrvXPPpEsr4IMRAN+nEV7gzmSDi6QSS\nkSioO57v/lu3BMzGWfmLcTb9WGk9H3loeDNqcFdyfrEkBbFa9ILnQKebS15a\nEjN0k6QDn4FwhnEzQGzKfULhYvfnPVzReQSc47VXBwqNf4hc4sZZAAdZODNq\nVp1JDsw5UFkteq8oAYrwyNf1ZASBE5BAthDr1bCykzNgQ/MD4GYdxtrvFg4L\nafcWmSYc0hHVk848rKAbGkz0rlh7GjKPw6a6nRFlx6Wmwu9Oyjj4I9LxEFh4\nVQT3u0u3+1SIfcAJYTPKEkGJR52eBOmJ5e85/7t9L/NoxLoEs2Ceab8f55Bg\niodMN5IyH4uGIjUtaA3vUuwkeV9FVXWt+B3Mr3Cr1ZwbF2Kio6eYMJ8ycV/Y\n1h81T5v0rn5VLNwoexdlJSN4BWqttGMR4g9fPRJXDDF9upnHgQRowNlrM5kX\nMUhC\r\n=vhmL\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEQCIBlbWlUZlb9vZk3IDBUCkNy6nih6q/Hp1t1UC8BLOTVMAiAcoT1tOoNTIy4B7QG73NrVeoMtqrkkn1QjnVGW2Lv8UQ=="
          }
        ]
      },
      "maintainers": [
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.57.0_1575509490836_0.764202180968744"
      },
      "_hasShrinkwrap": false
    },
    "0.58.0": {
      "name": "ts-json-schema-generator",
      "version": "0.58.0",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "./bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=6.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.3",
        "commander": "~4.0.1",
        "glob": "~7.1.6",
        "json-stable-stringify": "^1.0.1",
        "typescript": "~3.7.3"
      },
      "devDependencies": {
        "@types/glob": "^7.1.1",
        "@types/jest": "^24.0.23",
        "@types/json-stable-stringify": "^1.0.32",
        "@types/node": "^12.12.17",
        "@typescript-eslint/eslint-plugin": "^2.11.0",
        "@typescript-eslint/parser": "^2.11.0",
        "ajv": "~6.10.2",
        "chai": "~4.2.0",
        "eslint": "^6.7.2",
        "eslint-config-prettier": "^6.7.0",
        "eslint-plugin-prettier": "^3.1.1",
        "jest": "^24.9.0",
        "jest-junit": "^10.0.0",
        "prettier": "^1.19.1",
        "source-map-support": "~0.5.16",
        "ts-jest": "^24.2.0",
        "ts-node": "^8.5.4"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint '{src,test,factory}/**/*.ts'",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "FAST_TEST=1 jest test/ --verbose",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts"
      },
      "jest": {
        "transform": {
          "^.+\\.tsx?$": "ts-jest"
        },
        "testRegex": "(/__tests__/.*|(\\.|/)(test|spec))\\.(jsx?|tsx?)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "jsx",
          "json",
          "node"
        ],
        "testPathIgnorePatterns": [
          "node_modules",
          "test-runtime",
          "<rootDir>/build",
          "_site",
          "src",
          "dist"
        ],
        "coverageReporters": [
          "html",
          "cobertura"
        ],
        "coverageDirectory": "./coverage/",
        "collectCoverage": false,
        "testEnvironment": "node"
      },
      "gitHead": "8136659ada92c94519623a4e844495b7262c929f",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.58.0",
      "_nodeVersion": "12.13.1",
      "_npmVersion": "6.12.1",
      "dist": {
        "integrity": "sha512-AmVrx+YehQ19MjSKPMJ+L+3h53Cv7Kd26Ri60l7BHNoHhZrrFqOXO9bLZr4DoWR+DMp8QzEwQ6Fu4SrKSX1Vww==",
        "shasum": "ce15e08496f7a5b9fa4c1b50e21f0e2927aeb548",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.58.0.tgz",
        "fileCount": 429,
        "unpackedSize": 602896,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJd8DmECRA9TVsSAnZWagAANsgP/3ITLADSbJr3oe9lIYby\nbJE1duZusC4hV2a3OAgSuI52iCIWiYlNwfHx7awj0YNvrt2AV/WOjnX8Tm45\nUEkphI+6cd4rwc1VnXZoyYiot5W9CG2/V5Cr6LHDMaSdv5oxmSwzgkzyoPpR\njiVFkyMCOwPqNBJmx+uHEzGWQX2SIrJa8aL5FpoRU+lTn4NUlqBMn/aSu+ra\nLy5sIZHV+HlbCgifh6PlcnXZ8M5oCKewwSsHmG89pdLONFXCtWlRNnOm2yTD\nQemVOaoOV0qUZJ3r5MAa4MUgnajqbahNVxISzg6b+o2Xn7oO3n2QsPr2OMUr\nDHLDUElG6R22zw5gj9ix7VPBxJV7Pi7VxvXWcINtDw0LCR2d/ANdDGF8fwD4\nMwwnXu3ypumnyuPeamD3UYOFm66NdvB5l+HZZi+DaeOT81ZD7NdYhIdCnJyW\ncmA2ju3CgCVWsmRrwKMa2tzWAI5e934oN3DmvqnWOahgIdmWlNgTWleRPk2A\nOL61SlQNiG+HqfrRrT+05PvroQ2T+OTiL4nhxS5Q1g4LJvdr8piYZhACOBt/\n71EQyltGffsGcphbFpqTxJHyIvOCS8Ry+hHM7eYoPQ7RFIkbwV2h+QQ+JxoG\nJgZazkBozYN0z0CwC7Dw9Q8HwQrWsguaQd40XnEo4p8xlwNSBAS/uP1p1pUy\nzmZ7\r\n=RGj0\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIEAXsQxx2fizBHiyuEu1074SEFC+m6j9pyf12kI1xfo1AiEAk3i0oULggSOkSw1xekGuE83L3qmlo2HKL0oDNOgVHP0="
          }
        ]
      },
      "maintainers": [
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.58.0_1576024451828_0.5119899066372045"
      },
      "_hasShrinkwrap": false
    },
    "0.58.1": {
      "name": "ts-json-schema-generator",
      "version": "0.58.1",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "./bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=6.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.3",
        "commander": "~4.0.1",
        "glob": "~7.1.6",
        "json-stable-stringify": "^1.0.1",
        "typescript": "~3.7.3"
      },
      "devDependencies": {
        "@types/glob": "^7.1.1",
        "@types/jest": "^24.0.23",
        "@types/json-stable-stringify": "^1.0.32",
        "@types/node": "^12.12.18",
        "@typescript-eslint/eslint-plugin": "^2.12.0",
        "@typescript-eslint/parser": "^2.12.0",
        "ajv": "~6.10.2",
        "chai": "~4.2.0",
        "eslint": "^6.7.2",
        "eslint-config-prettier": "^6.7.0",
        "eslint-plugin-prettier": "^3.1.2",
        "jest": "^24.9.0",
        "jest-junit": "^10.0.0",
        "prettier": "^1.19.1",
        "source-map-support": "~0.5.16",
        "ts-jest": "^24.2.0",
        "ts-node": "^8.5.4"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint '{src,test,factory}/**/*.ts'",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "FAST_TEST=1 jest test/ --verbose",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts"
      },
      "jest": {
        "transform": {
          "^.+\\.tsx?$": "ts-jest"
        },
        "testRegex": "(/__tests__/.*|(\\.|/)(test|spec))\\.(jsx?|tsx?)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "jsx",
          "json",
          "node"
        ],
        "testPathIgnorePatterns": [
          "node_modules",
          "test-runtime",
          "<rootDir>/build",
          "_site",
          "src",
          "dist"
        ],
        "coverageReporters": [
          "html",
          "cobertura"
        ],
        "coverageDirectory": "./coverage/",
        "collectCoverage": false,
        "testEnvironment": "node"
      },
      "gitHead": "c6e10ce6bdd9e80c5b608769cc31becc85758017",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.58.1",
      "_nodeVersion": "12.13.1",
      "_npmVersion": "6.12.1",
      "dist": {
        "integrity": "sha512-v4shrlxAYtEfeq+1Hfr57pljGv2OMHV8oZ5NwbaWHHGOfXDuDAPn9Cf7HJU4+7ls7UqUPZiyRpKQdRV+GhuSuQ==",
        "shasum": "41bce930e53422723646f0b037f33b1b4c8a42d5",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.58.1.tgz",
        "fileCount": 429,
        "unpackedSize": 603089,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJd+BDpCRA9TVsSAnZWagAA8L0QAJw79O9DDS0pLeNnhXsl\nmoXV1GJDJ7Hjlemyok8xkommlPkROcuLa/KfSiRBWkni81A3IpIFxLHU0QCN\nTuzIclZ/PdxulkVPnPj58YUE0YY8oQG75fdMGCKI3+Nz0G7QE+aNIlIqsHRX\n951mN3PQtkrhL9a5tst2ng7ybkO2U5laa14aQhzNlVnfGH/BlUyFyIWCezF0\nVKYOjjBcpdLfRVzng/jFHDw5RUTrFEo6ThgHGxAfnM1daffuSTlTk9bb7CRj\nHnFM4inQbQlFll+6mWR738gDsrT8gE0l6nf+QwshN0vLv7D/PXEp6JYDjJJu\nlmmjjfxi80HASz9OubV5/5smkl0gKVPpnmx0Id6515jsmoBpEvF8ojOitKZ3\nF8j64m4Zou+rGPePL3ecQXGDhOVagyfVEC4Gkh+pGMts46/0e3zRIY+Kbf2e\np/i3Uxoq5bEx+V2Xp/fKhWpNwkzqIV+ULT5Tp5H34PuUMbI7bkGWQYc5jIiu\n5HmXZA2W8dROU2fXtM5/R8RxjYeevioSwym4acc6IlwZM8Pu3MMVgvNrhJYx\nVIC5YzBZ4G1E5v/EDb7Kfe47SbL5dCCjGosuw1tCAOIDz7YViD3KSKE/eaGY\nJxDDjqdt2a//vtWee1a0C3P47KVvmtazCg4rdOgrZle9JVIp2ug0oPaiREGc\ne1jZ\r\n=cwLJ\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIATiXbTF2zOen9a4P+B7SCg4H2s9yBl7vKX9DIuprSKMAiEAwaTgnpi+lNiBqebC8LGuqaIejCs5MGudPgGzqP9uAYo="
          }
        ]
      },
      "maintainers": [
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.58.1_1576538344752_0.11211886198335863"
      },
      "_hasShrinkwrap": false
    },
    "0.59.0": {
      "name": "ts-json-schema-generator",
      "version": "0.59.0",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=6.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.4",
        "commander": "~4.1.1",
        "glob": "~7.1.6",
        "json-stable-stringify": "^1.0.1",
        "typescript": "~3.7.5"
      },
      "devDependencies": {
        "@types/glob": "^7.1.1",
        "@types/jest": "^25.1.1",
        "@types/json-stable-stringify": "^1.0.32",
        "@types/node": "^13.7.0",
        "@typescript-eslint/eslint-plugin": "^2.19.0",
        "@typescript-eslint/parser": "^2.19.0",
        "ajv": "~6.11.0",
        "chai": "~4.2.0",
        "eslint": "^6.8.0",
        "eslint-config-prettier": "^6.10.0",
        "eslint-plugin-prettier": "^3.1.2",
        "jest": "^25.1.0",
        "jest-junit": "^10.0.0",
        "prettier": "^1.19.1",
        "source-map-support": "~0.5.16",
        "ts-jest": "^25.2.0",
        "ts-node": "^8.6.2"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint '{src,test,factory}/**/*.ts'",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "FAST_TEST=1 jest test/ --verbose",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts"
      },
      "jest": {
        "transform": {
          "^.+\\.tsx?$": "ts-jest"
        },
        "testRegex": "(/__tests__/.*|(\\.|/)(test|spec))\\.(jsx?|tsx?)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "jsx",
          "json",
          "node"
        ],
        "testPathIgnorePatterns": [
          "node_modules",
          "test-runtime",
          "<rootDir>/build",
          "_site",
          "src",
          "dist"
        ],
        "coverageReporters": [
          "html",
          "cobertura"
        ],
        "coverageDirectory": "./coverage/",
        "collectCoverage": false,
        "testEnvironment": "node"
      },
      "gitHead": "252a68eda0649fa2f04668758016b14f2c51cbba",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.59.0",
      "_nodeVersion": "12.14.1",
      "_npmVersion": "6.13.4",
      "dist": {
        "integrity": "sha512-SN/mBWq8OGPoLbFODE29Vwp9HSZjWi+/RB/m2l8Fy3/bzWCyrG6biax5NQJV4Y4/D+XsEEt95pvV9ows09PQPw==",
        "shasum": "cc926deb4752f6b68c159929db4e415bede0de51",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.59.0.tgz",
        "fileCount": 429,
        "unpackedSize": 613411,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJeO6NQCRA9TVsSAnZWagAA9t0P/Rd5tufNrD1H0/YjiTH0\nFMbdKuFlJglBWOPaDs+RiV4B/ETx0Tn31hWMk7bLKItyxstIiz8q5GO7Yau4\ny8TtSyE3Hgc01nXNGA3+e7hC/AAFZ4wqUPKfJm/YV+V712hR8yvxurlZfXMm\nqtMNpDZ1IPZKiQYbEJ5+mCqewo4ZTGjz9yI6/YjQAbMxOTWjxjvg8phPNWSw\n5Bc19YSCjdAxlBxB9Djc+1J2iF9HjH/B4fTX9mFKubTSGc+2zKlQdP9VB8Ot\nWUgrr50CVTJH9NBnxs9I1qEbmN1lpLVgCEu2Q7dn03V86tLRP+LiL9H7nWO6\nPf4gMWBXTtuFR2eLZyU2xgmFbslXlio1oGDiZZ+9N+1A30iNR/U4yBTstjeh\nxTWGcmcqPw5DtR8ebKogZzbHj8Mrec6yp7sa4tbnon6NxDoWeuUeZrUGNN3b\nO0WuCVqI2wwlC4D16gArWNmQdGGdYrk9t9HJynaYbGCnvyMV3JghChhzHFrt\npkqgyc+rXy7qMjkazmAbdOw17eorn6haerychW/Ag+WxUhLZLX4j/iBzqMsG\n1Lnp2Ba2ZSjFFfnYpkb/QDHoTstlLuMrWgF1WreFQuFrLYTTsQoa+DaeCuOT\nq5Y4m8/aybKHG7O7Ie5soyoz9HLDr5N5MA4j1+IupkwIbCgsw1bJco5PCKnM\nRsBY\r\n=UWIr\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEQCIGRvKsl8u8sWoeZVmWHxG4pp8KYXIjZHsyp76gxUPR5MAiAL+x+cyd/q9KqNp5ltK2DezYkhcpVCuav7MhLp+gSpMg=="
          }
        ]
      },
      "maintainers": [
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.59.0_1580966735953_0.8699995847516349"
      },
      "_hasShrinkwrap": false
    },
    "0.60.0": {
      "name": "ts-json-schema-generator",
      "version": "0.60.0",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=6.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.4",
        "commander": "~4.1.1",
        "glob": "~7.1.6",
        "json-stable-stringify": "^1.0.1",
        "typescript": "~3.7.5"
      },
      "devDependencies": {
        "@types/glob": "^7.1.1",
        "@types/jest": "^25.1.1",
        "@types/json-stable-stringify": "^1.0.32",
        "@types/node": "^13.7.0",
        "@typescript-eslint/eslint-plugin": "^2.19.0",
        "@typescript-eslint/parser": "^2.19.0",
        "ajv": "~6.11.0",
        "chai": "~4.2.0",
        "eslint": "^6.8.0",
        "eslint-config-prettier": "^6.10.0",
        "eslint-plugin-prettier": "^3.1.2",
        "jest": "^25.1.0",
        "jest-junit": "^10.0.0",
        "prettier": "^1.19.1",
        "source-map-support": "~0.5.16",
        "ts-jest": "^25.2.0",
        "ts-node": "^8.6.2"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint '{src,test,factory}/**/*.ts'",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "FAST_TEST=1 jest test/ --verbose",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts"
      },
      "jest": {
        "transform": {
          "^.+\\.tsx?$": "ts-jest"
        },
        "testRegex": "(/__tests__/.*|(\\.|/)(test|spec))\\.(jsx?|tsx?)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "jsx",
          "json",
          "node"
        ],
        "testPathIgnorePatterns": [
          "node_modules",
          "test-runtime",
          "<rootDir>/build",
          "_site",
          "src",
          "dist"
        ],
        "coverageReporters": [
          "html",
          "cobertura"
        ],
        "coverageDirectory": "./coverage/",
        "collectCoverage": false,
        "testEnvironment": "node"
      },
      "gitHead": "d05b01da8d5f36afc820030be7b51d68633e394b",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.60.0",
      "_nodeVersion": "13.7.0",
      "_npmVersion": "6.13.6",
      "dist": {
        "integrity": "sha512-hXSlkb2kID3WJq9CHrnIxlLdIiGuRvrajJT8mQEaHI8xWNk5Sy+wRXvWlHRUn64RpUR9dyydI4d33aKb/CXssw==",
        "shasum": "7d84e5c8303012bc4788e13b1ef45ce0ef78a4c8",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.60.0.tgz",
        "fileCount": 438,
        "unpackedSize": 623347,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJePgpKCRA9TVsSAnZWagAAoIgP/j1QgvLNkXPiwA6k6maU\nWbQmUrbODCz245McUgX/ld5LxGXkr0xQ+h3Wl+660N0JEUMAtv8pBGLZfuXC\nw9eZoTmuNebjezjGEO47hcr3JnZpygBm+FhwllLVlpLEDOcZWuQJHqxkHqa3\n1z9RQkgrPEG03CSQlgHF5Mj8lJoLGy7mXZrviLWqzxeXwsGOMkQmLLfCLzBY\n6F6ZrYmFBBeMSy3St2/c3H2Ew2nIDuTM4EFM2fBK1AkmwpoebNPiM+kZd1Iv\n0eOUnLQN0CMPG/faOaWsbUWEBvmDsXnxOF7QHR6zbWtu65yxPcIImnKMACbC\nhBZ+6xvO8rpgUESEw07v9wxAP+JQehLhYpwF4wszu6NHMDddXhOO3Zk9yCWe\nyEAQjrIGer44YM/xkRpQ68/VBwcO0mz+5g0345sOiw7Votyg9iO8SibwRPJd\nBu97J67IlAq+Hs2BZCqBcUj0P+LYADryqgVoTVTR9qaiMMfgf7oemBcve061\nEkO50q3P3fCRQa61Wbb7lBPvvk5HDiBrs/U3BFR1sOjufRzxmEYI2s9/Yf9F\n0uv4cXq69LuBgxtSCzp8Bv3+GmO23mHDlp8ewdBWjOK8yxHpCpTh34y2XIfa\nbVO+vIvcgzvuuNOoSQQmZ7Oa0+6g9oXdNUfaOFSEW2ad4JdTHc1pauy7kaU7\n63dL\r\n=O11q\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEQCICJPm3mrCGoNX3Pms4KMFCNLZdYKqMvzc95oM/UWblgAAiB6inPEC79mpMaUJJ4IWhIyJrKXrgdsVY/usWefKcaBLw=="
          }
        ]
      },
      "maintainers": [
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.60.0_1581124169400_0.8093222243051672"
      },
      "_hasShrinkwrap": false
    },
    "0.61.0": {
      "name": "ts-json-schema-generator",
      "version": "0.61.0",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=6.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.4",
        "commander": "~4.1.1",
        "glob": "~7.1.6",
        "json-stable-stringify": "^1.0.1",
        "typescript": "~3.8.2"
      },
      "devDependencies": {
        "@types/glob": "^7.1.1",
        "@types/jest": "^25.1.3",
        "@types/json-stable-stringify": "^1.0.32",
        "@types/node": "^13.7.4",
        "@typescript-eslint/eslint-plugin": "^2.20.0",
        "@typescript-eslint/parser": "^2.20.0",
        "ajv": "~6.11.0",
        "chai": "~4.2.0",
        "eslint": "^6.8.0",
        "eslint-config-prettier": "^6.10.0",
        "eslint-plugin-prettier": "^3.1.2",
        "jest": "^25.1.0",
        "jest-junit": "^10.0.0",
        "prettier": "^1.19.1",
        "source-map-support": "~0.5.16",
        "ts-jest": "^25.2.1",
        "ts-node": "^8.6.2"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint '{src,test,factory}/**/*.ts'",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "FAST_TEST=1 jest test/ --verbose",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts"
      },
      "jest": {
        "transform": {
          "^.+\\.tsx?$": "ts-jest"
        },
        "testRegex": "(/__tests__/.*|(\\.|/)(test|spec))\\.(jsx?|tsx?)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "jsx",
          "json",
          "node"
        ],
        "testPathIgnorePatterns": [
          "node_modules",
          "test-runtime",
          "<rootDir>/build",
          "_site",
          "src",
          "dist"
        ],
        "coverageReporters": [
          "html",
          "cobertura"
        ],
        "coverageDirectory": "./coverage/",
        "collectCoverage": false,
        "testEnvironment": "node"
      },
      "gitHead": "86bce774aa83173e2bf44294b1f33d10cfd527f2",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.61.0",
      "_nodeVersion": "13.8.0",
      "_npmVersion": "6.13.6",
      "dist": {
        "integrity": "sha512-YiWP8quUiU6X15V0YxkD4Ya7XvKEAdXDxb0keziRmO456lryJHrrOrSWaNB3vkkQTYuRVRMHXxDpGBoCsrNNpw==",
        "shasum": "eafcf10cb5c26e96115a29449d71d4d90b81db01",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.61.0.tgz",
        "fileCount": 429,
        "unpackedSize": 618812,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJeTzOhCRA9TVsSAnZWagAAWVsP/iaFeR+/wXjLbqBkszkT\neTUpwx4ZFg8nOedEAMvP9s4Eqg+4Hy7/SuGjlRfHL5XvcuwpSw5/XKckxv+t\nkfo7YHCyw8SJGdX3lbbl6YjYXdOdy7Aly4SpFyPcVk2dNH7IrYqcU1TAsW/n\ngffsvKsE+SU7PDPBAiQMajXyFHinQ6wkqQt05gA/bpPKkBTmCvzIo6nOyAGW\nQD2fEtoyE6vPjXnl4lOtrrV6Z8Sul/9jgwohUdnCWdLtvXHYWeCAs5ENqECE\n1pnuNFYtZAbtiN2M3GQSRkgf6hSK7T1tc0CqhIgbNmv0vFlM50+yxgSSx7aO\nHgwfEYIM7N/r9N64hIFnwWxk/wbb+IWlR7s0yRAnY+fBjsYFznk+foPN05ed\nR+OqFsNRyhmROZvIgxyY+pqL00FA09blTC5X2wz+IzC4ZW/+hkaIF7MTbeQk\nRp8J0W9O4txMs78EAQwJyIrkG2WcEcC4ZSIDImcUacpXPn8P7+TT7YTwGWSV\n+9yh0yLDebS/bIVyrcMUp5eGDW5JYtWG0UPzr5XSVXpacWwY8KT+xkMTv508\nFKNxOZCdTK1gOkKNtYCPzAGAMrvjJrf2eVPp9JoWlXGmn+Tf5AmB1ueSdos9\n7Eo1mT4e05x4/9gZKAiVhiVTYSoXsAadtzWK5A81r4OZn2tfSm1hWBfzatXq\nUyhW\r\n=NaHo\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEYCIQD0DfK6fLvYquP+RGSJNTJCFYQahGppgqTNc/U7wFYIJQIhAJ44joYX7e3XT8/33u4poXFoX3Arhx9NipN/cg+yTfU8"
          }
        ]
      },
      "maintainers": [
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.61.0_1582248864583_0.2684552196442951"
      },
      "_hasShrinkwrap": false
    },
    "0.61.1": {
      "name": "ts-json-schema-generator",
      "version": "0.61.1",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=6.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.4",
        "commander": "~4.1.1",
        "glob": "~7.1.6",
        "json-stable-stringify": "^1.0.1",
        "typescript": "~3.8.3"
      },
      "devDependencies": {
        "@types/glob": "^7.1.1",
        "@types/jest": "^25.1.3",
        "@types/json-stable-stringify": "^1.0.32",
        "@types/node": "^13.7.7",
        "@typescript-eslint/eslint-plugin": "^2.21.0",
        "@typescript-eslint/parser": "^2.21.0",
        "ajv": "~6.12.0",
        "chai": "~4.2.0",
        "eslint": "^6.8.0",
        "eslint-config-prettier": "^6.10.0",
        "eslint-plugin-prettier": "^3.1.2",
        "jest": "^25.1.0",
        "jest-junit": "^10.0.0",
        "prettier": "^1.19.1",
        "source-map-support": "~0.5.16",
        "ts-jest": "^25.2.1",
        "ts-node": "^8.6.2"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint '{src,test,factory}/**/*.ts'",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "FAST_TEST=1 jest test/ --verbose",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts"
      },
      "jest": {
        "transform": {
          "^.+\\.tsx?$": "ts-jest"
        },
        "testRegex": "(/__tests__/.*|(\\.|/)(test|spec))\\.(jsx?|tsx?)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "jsx",
          "json",
          "node"
        ],
        "testPathIgnorePatterns": [
          "node_modules",
          "test-runtime",
          "<rootDir>/build",
          "_site",
          "src",
          "dist"
        ],
        "coverageReporters": [
          "html",
          "cobertura"
        ],
        "coverageDirectory": "./coverage/",
        "collectCoverage": false,
        "testEnvironment": "node"
      },
      "gitHead": "82600fa4f49b6a014c822bea55b859634c225005",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.61.1",
      "_nodeVersion": "13.8.0",
      "_npmVersion": "6.13.6",
      "dist": {
        "integrity": "sha512-JLoFdVhQh9dXAMjJVFd3dok0LX+Ko5oGilPMEePxjrQDNBeh9nHbQFK1SGAQKf5kk7Fe120dXqeapjUBTTePQg==",
        "shasum": "92b5022b1f4678037312c5d56ff5bf44a067143e",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.61.1.tgz",
        "fileCount": 429,
        "unpackedSize": 618886,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJeWZsgCRA9TVsSAnZWagAA848P/1+PgSnPbIxLh0DrdKd4\nXXABr799xVnWlqpeElx2MRJ8wLz58whQhyYWbWcsGKRgZZZV7M4CKO1iBUsT\nJxfMoTuduPA0y2qWyh8dz8XBuVChG+wjkXXhi5Uur9Jdko8+PPj7CBV5McZ4\nc9BfKEzYlpa/F6OokaN9N62V35CSLuV1ydtsSu46JEGSpVQK3a6YGMIZnKpr\nDtrkUmK+SprzYErClYT+5DTl6db5+TeJr0rUvxClfL7VNXpCDHo6nvF5t6CC\n54aLqP7p/Tn6/IUflLOxHtl0jhP189V8sHlnBwv4Hfidk+f6mRD1dHdZ6SC3\ncqmVXZ+z/xHf50KAG1EFsVm190nuorL4Uey3BlCdY8WOSRhpyxdRYol4pvAm\n8S3lSlFVxk6EG1Y+58B09qxQXGrGm5eAxTyWiRl+7+YIkooBbfHD9Gr40kTR\nwf6MHOLX1X3O8HYz8pbVDRCi6DS7jshe9INJ981Jr8ruxrZT5/jSYrzGLCXY\n02psLbF+4eIesh+6c/8tGl9+RWNR7PHFkRk7XC/X2/ZnUt8CR/BlJyZ00OnC\nhmjjevSDJl3NGnVY5SMpSo6Jlrm2wIGD5mqdjNRjwDJL3GueRb1Lh/W1Q5mu\nQc7/jk2MGorCjkvWVf0PGAS3vCNME7zPuz0GJes5asQCoZWAFlR1sPEmroOd\nhMhr\r\n=itdj\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIQD5vZsw/h03Ej1JwMtZgDsIxPXKXNJVe22RJrU5LHXBbAIgSFtS+5AiN1Mru6gMhB8A8yU68NU2dyIyCBkLidG6qpw="
          }
        ]
      },
      "maintainers": [
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.61.1_1582930719289_0.7193534374922592"
      },
      "_hasShrinkwrap": false
    },
    "0.62.0": {
      "name": "ts-json-schema-generator",
      "version": "0.62.0",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=6.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.4",
        "commander": "~4.1.1",
        "glob": "~7.1.6",
        "json-stable-stringify": "^1.0.1",
        "typescript": "~3.8.3"
      },
      "devDependencies": {
        "@types/glob": "^7.1.1",
        "@types/jest": "^25.1.3",
        "@types/json-stable-stringify": "^1.0.32",
        "@types/node": "^13.7.7",
        "@typescript-eslint/eslint-plugin": "^2.21.0",
        "@typescript-eslint/parser": "^2.21.0",
        "ajv": "~6.12.0",
        "chai": "~4.2.0",
        "eslint": "^6.8.0",
        "eslint-config-prettier": "^6.10.0",
        "eslint-plugin-prettier": "^3.1.2",
        "jest": "^25.1.0",
        "jest-junit": "^10.0.0",
        "prettier": "^1.19.1",
        "source-map-support": "~0.5.16",
        "ts-jest": "^25.2.1",
        "ts-node": "^8.6.2"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint '{src,test,factory}/**/*.ts'",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "FAST_TEST=1 jest test/ --verbose",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts"
      },
      "jest": {
        "transform": {
          "^.+\\.tsx?$": "ts-jest"
        },
        "testRegex": "(/__tests__/.*|(\\.|/)(test|spec))\\.(jsx?|tsx?)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "jsx",
          "json",
          "node"
        ],
        "testPathIgnorePatterns": [
          "node_modules",
          "test-runtime",
          "<rootDir>/build",
          "_site",
          "src",
          "dist"
        ],
        "coverageReporters": [
          "html",
          "cobertura"
        ],
        "coverageDirectory": "./coverage/",
        "collectCoverage": false,
        "testEnvironment": "node"
      },
      "gitHead": "d7a119868c63af02c6f5d72c4a7565dd5c9c1ba2",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.62.0",
      "_nodeVersion": "13.8.0",
      "_npmVersion": "6.13.6",
      "dist": {
        "integrity": "sha512-HLZqtu21MX15McgluhaN7lKA1DYD6ywWHqKhzUI8EpJVEMXcs/J3oaaTR7OmSi1b27TI0YTuDV0kkDqqeyUYAQ==",
        "shasum": "b0c56d209a1f6632ac81d0843da76befec5deee1",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.62.0.tgz",
        "fileCount": 429,
        "unpackedSize": 619504,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJeXxcLCRA9TVsSAnZWagAAZSgP/2s03OVxO2syeUJrQapb\n4TGpi77EkZVJzTFS52jZjhrF1iR7BMaddFV+SfNQxECm4sMX1mPfgiDtkTcc\nsvvrMQMDmJ+15jg6WQ5nLZiT0WrSjGM7cNZN2vITFleVGtqEu7TrthnXtfns\nWJaspdIn1Yz73G8Ix2acJpM4Km72xj5iS9kTaQNdDV1NN7eyJy1B+VISC8Cy\ncfcz5C1XMUKkCaxR/I3j/+dyKBs8kvp5KlrFhVrLOZmPv4vMW+XrMprNbtro\nVqkqMQnVA+S+Gc0fNtefQaxmSlPtkEPQ/x12OBQsSuYx+Ymy4ACUBvBwU5NQ\nW4T47N8hNCMVZjiEmJ3bUUBsYYvxgzddhfeQjC7fBqmWJqq1tubxABnpPmxQ\nJQG6YhrYRcbZVo+hLh0MPQHoFFGDslORXBWVzEJBpiOuuzX2/Tk1bfya7y1H\n7eJfezBBttUZL2t5w7HiQ6uh202w9dQfJuaDjKvTP/AmN8oDFBdWABng3xHt\nxRLShQq4V7HcSCjveeYp8KdMrwPRTeBpFt/eKHjDakQ6PGDbDWuqI7N8+iwT\n8kvdQQRDQR4R2rBwDUl7m/irrg8NxeuZ0j4wXTte01my/7t6kf+MXe9/nccs\nC18VZ6DLdIh9X7m1wNSkRSYe0BfGg3h1I7BhHSOjbX8Gt71VB5FLD5Kdtn7g\nep21\r\n=ZeC6\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCICDlIDXmtDGB19hvpx2EE86T5/1+tGd7d8tcX4oOyQILAiEA1V7RHiSWRDvyfeqKcehgadowc4uJu3WtXCS6C+dyEnU="
          }
        ]
      },
      "maintainers": [
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.62.0_1583290123095_0.7934490431967893"
      },
      "_hasShrinkwrap": false
    },
    "0.63.0": {
      "name": "ts-json-schema-generator",
      "version": "0.63.0",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=6.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.4",
        "commander": "~4.1.1",
        "glob": "~7.1.6",
        "json-stable-stringify": "^1.0.1",
        "typescript": "~3.8.3"
      },
      "devDependencies": {
        "@types/glob": "^7.1.1",
        "@types/jest": "^25.1.3",
        "@types/json-stable-stringify": "^1.0.32",
        "@types/node": "^13.7.7",
        "@typescript-eslint/eslint-plugin": "^2.21.0",
        "@typescript-eslint/parser": "^2.21.0",
        "ajv": "~6.12.0",
        "chai": "~4.2.0",
        "eslint": "^6.8.0",
        "eslint-config-prettier": "^6.10.0",
        "eslint-plugin-prettier": "^3.1.2",
        "jest": "^25.1.0",
        "jest-junit": "^10.0.0",
        "prettier": "^1.19.1",
        "source-map-support": "~0.5.16",
        "ts-jest": "^25.2.1",
        "ts-node": "^8.6.2"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint '{src,test,factory}/**/*.ts'",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "FAST_TEST=1 jest test/ --verbose",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts"
      },
      "jest": {
        "transform": {
          "^.+\\.tsx?$": "ts-jest"
        },
        "testRegex": "(/__tests__/.*|(\\.|/)(test|spec))\\.(jsx?|tsx?)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "jsx",
          "json",
          "node"
        ],
        "testPathIgnorePatterns": [
          "node_modules",
          "test-runtime",
          "<rootDir>/build",
          "_site",
          "src",
          "dist"
        ],
        "coverageReporters": [
          "html",
          "cobertura"
        ],
        "coverageDirectory": "./coverage/",
        "collectCoverage": false,
        "testEnvironment": "node"
      },
      "gitHead": "e55008604f9c92b1ce6842a37ef89165d1ca6b31",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.63.0",
      "_nodeVersion": "13.8.0",
      "_npmVersion": "6.13.6",
      "dist": {
        "integrity": "sha512-Qzy3nTVwM7+xsJjep68VcX7cMO923PQ/y+tlqeYoLRoFXTH/vAcZIFJCe5oUbVx3NCWQig7NgjB5TQG3uiuBFw==",
        "shasum": "2ead4ff56ebbb6e1635889bf2e708bf1d761fad3",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.63.0.tgz",
        "fileCount": 441,
        "unpackedSize": 628841,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJeYDJNCRA9TVsSAnZWagAAsA4P/0lgngnh5Z+RahPcMaa7\n8JIGfUIzdQFkk5Z9SnRmE9fzNUHcsBJYERLm6dPB7LhG5v2ye30+F4dt1vK6\nJ4OF/u06QK14DTOXmoaL1OUG3jeCZYBCdBanKawIut9QZfyUDkXlG/K/F8dt\nRk3st4oL85Zk4Z4fdLhw2ZykNYOuXooyy9LupKxqQcBclBFjVJ762+lrG8YE\nKmrXsXde13kCtWIp3v7S3i+FRS2oafC1d1zXqwBHjWrfgNWuECE8H8URMTRf\nlQXnkytgmIdgazLcCG86Po1FdLYJvbzHgb56MWrIFf48Xe7s62hzo4nVw3Kr\nUUXK5MZBMQqrW2m5MDa+J+MeEik1dF0wBzDv1p6YUSoUW2udy6Kav+4JbPGo\nX3e/ACUxotMcqm0wFqe0we0Oa4Etf1TegOOE6vp/r3KhNbX36Y8JusKAp0ME\n+nAmsHm49cIUbuodbdGBLFxuas0qWjoq3GeumP6uCIuMhdnZjcjzdcpAX0Lf\nDDq0ZXdyT4FbZ0Y+7wdyQIfgXF65HAW5OX42O6gW9PLmtQuYfz7Cc7173poi\nTBJcSeSok6WguITKNiyA6xP4vfyKeobyzCZydoQ/SsX2dZ37XBO4HVjouieu\na8mKWQWAPuKEAWuKTEROmh1EkzsL9qfNtMw3VjdrLtT9Jvy7ylCpsX0I3xld\nJSZL\r\n=iFIG\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEYCIQDKyiM1JQLkfoziYt2cDLcBbU+3aar8/YamNWrud78lnQIhAJQVeKR4Lg/CWYhJjKnEFzKxHOmlNEPL8FhqmSOH10xM"
          }
        ]
      },
      "maintainers": [
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.63.0_1583362636550_0.8437592246538628"
      },
      "_hasShrinkwrap": false
    },
    "0.64.0": {
      "name": "ts-json-schema-generator",
      "version": "0.64.0",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=6.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.4",
        "commander": "~4.1.1",
        "glob": "~7.1.6",
        "json-stable-stringify": "^1.0.1",
        "typescript": "~3.8.3"
      },
      "devDependencies": {
        "@types/glob": "^7.1.1",
        "@types/jest": "^25.1.3",
        "@types/json-stable-stringify": "^1.0.32",
        "@types/node": "^13.7.7",
        "@typescript-eslint/eslint-plugin": "^2.21.0",
        "@typescript-eslint/parser": "^2.21.0",
        "ajv": "~6.12.0",
        "chai": "~4.2.0",
        "eslint": "^6.8.0",
        "eslint-config-prettier": "^6.10.0",
        "eslint-plugin-prettier": "^3.1.2",
        "jest": "^25.1.0",
        "jest-junit": "^10.0.0",
        "prettier": "^1.19.1",
        "source-map-support": "~0.5.16",
        "ts-jest": "^25.2.1",
        "ts-node": "^8.6.2"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint '{src,test,factory}/**/*.ts'",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "FAST_TEST=1 jest test/ --verbose",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts"
      },
      "jest": {
        "transform": {
          "^.+\\.tsx?$": "ts-jest"
        },
        "testRegex": "(/__tests__/.*|(\\.|/)(test|spec))\\.(jsx?|tsx?)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "jsx",
          "json",
          "node"
        ],
        "testPathIgnorePatterns": [
          "node_modules",
          "test-runtime",
          "<rootDir>/build",
          "_site",
          "src",
          "dist"
        ],
        "coverageReporters": [
          "html",
          "cobertura"
        ],
        "coverageDirectory": "./coverage/",
        "collectCoverage": false,
        "testEnvironment": "node"
      },
      "gitHead": "5472c76425309cff5776ece84134ab6fc411062f",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.64.0",
      "_nodeVersion": "13.10.0",
      "_npmVersion": "6.13.7",
      "dist": {
        "integrity": "sha512-cYyF8BP6mdaau/MfxwxrtRJUaDmi+QLDK/Z140H6sxphCCvHz2KR4+teNulFY2JlhPCzvq5Vj8wiaSSXRMlzsQ==",
        "shasum": "5e0b1c1ce92bf8cee1bf10d39a103c9c48d22f77",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.64.0.tgz",
        "fileCount": 451,
        "unpackedSize": 653259,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJeYUDLCRA9TVsSAnZWagAAB70QAIE2E6qoGfl1sag1/hKL\nMsbk6K+cvaJ52Ljlfxe3oYiWNB00H1CCF2YkM4/MYQhj08HU636tGJafvtpJ\nkNRVi2yl+rkv8lK2v1pf/TspHGJwp5qJ4bvRfKYzabUWOkWmJuTy+VhdwoDC\nsPL9BIOMv2NLrN8ZbGi3IgAVjNSCXu2VDj1Nmb1nMSxkPnxDwI3pRVuwfZrp\ne2RWq71gCNb2+8AbiBnLOTjtVYyzjDFZnR6YgKowKa2VWBdOyYuHG0svUg2p\nCYubE6zzNukmHapni7qRJgsslbGB5FRbOCY+V2hMTKC5228xqXcYpFKi/15R\n0cViCHDHriekbIRDPZgCMxyZpf9BkUie77FDM1z5riRK5Rl6y3mrwGxiaHos\nADQvkCXE14GA5KZKkW/ciRsk86u4B1IGZBq5Ml3NKPreNC9sintC6w5jbwWA\nWw9O/qcOWqBNotKwQEPo7X1jhzsXez5C5h7I16tgImXxi79pNEM6XeplMFJa\n9G4sUb+HZRPusMlBs0CPuTqDSpKY080FiJYaXQHvTr+zp/Zx1/NuF6yuh55k\n0k6YzE57SHeDDenNgIk1xdLVQ/pydl0Nd94CEgRZUetAFTm2MyFSAEg+gQjb\nck+YXyXpSgh6sWNjZH71hYmArHaQL3DzpPpMVWUGKH9sIwrAdzk2F4r0ax2z\nnWtT\r\n=PXZO\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEQCIBUzBc8sWeUdP1Aw5FOmRKJVKhjFw7eWNJ+1jKgl1fqwAiAZPdqpeCfsG8GPAPx+rmQ51/lEDhmB6IhotF4iPrN3GA=="
          }
        ]
      },
      "maintainers": [
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.64.0_1583431882677_0.6884438815943279"
      },
      "_hasShrinkwrap": false
    },
    "0.65.0": {
      "name": "ts-json-schema-generator",
      "version": "0.65.0",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=6.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.4",
        "commander": "~4.1.1",
        "glob": "~7.1.6",
        "json-stable-stringify": "^1.0.1",
        "typescript": "~3.8.3"
      },
      "devDependencies": {
        "@types/glob": "^7.1.1",
        "@types/jest": "^25.1.3",
        "@types/json-stable-stringify": "^1.0.32",
        "@types/node": "^13.7.7",
        "@typescript-eslint/eslint-plugin": "^2.21.0",
        "@typescript-eslint/parser": "^2.21.0",
        "ajv": "~6.12.0",
        "chai": "~4.2.0",
        "eslint": "^6.8.0",
        "eslint-config-prettier": "^6.10.0",
        "eslint-plugin-prettier": "^3.1.2",
        "jest": "^25.1.0",
        "jest-junit": "^10.0.0",
        "prettier": "^1.19.1",
        "source-map-support": "~0.5.16",
        "ts-jest": "^25.2.1",
        "ts-node": "^8.6.2"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint '{src,test,factory}/**/*.ts'",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "FAST_TEST=1 jest test/ --verbose",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts"
      },
      "jest": {
        "transform": {
          "^.+\\.tsx?$": "ts-jest"
        },
        "testRegex": "(/__tests__/.*|(\\.|/)(test|spec))\\.(jsx?|tsx?)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "jsx",
          "json",
          "node"
        ],
        "testPathIgnorePatterns": [
          "node_modules",
          "test-runtime",
          "<rootDir>/build",
          "_site",
          "src",
          "dist"
        ],
        "coverageReporters": [
          "html",
          "cobertura"
        ],
        "coverageDirectory": "./coverage/",
        "collectCoverage": false,
        "testEnvironment": "node"
      },
      "gitHead": "702e3f3acdd291ad912ed949f1cd449faa48fa46",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.65.0",
      "_nodeVersion": "13.10.1",
      "_npmVersion": "6.13.7",
      "dist": {
        "integrity": "sha512-UbDmCc3NM8vsTTWnHDzwEJt0e0bK/LOIveHT7LeQ35YhgkGr/Y18b5NCEVGCv81LV1UszXvgEKbJV39gxAMXQA==",
        "shasum": "c167bda22c501740ee336d84d1052e3188e76a09",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.65.0.tgz",
        "fileCount": 441,
        "unpackedSize": 629566,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJeYvdrCRA9TVsSAnZWagAA2PUQAIGYSoON3xr5kYoHboAN\nJiumjme/KSbOBPPATeBYKArI4Rhm4pBwFhIV7ZG8v/4/xdcPaXL8lJ9TX8qe\nn4tiYOkOPi6VemeEq7ba7wlgMisk0OwxKZbEQFPVyNlgp1sEQ0mpccoFJip8\nPS1xlDSuzoawKojgRyMX9IfGRB9TK85CqUgFQ2dMCx32sogaQCtr99HEyt35\nnBO7vyMeWvmCaCKAhzxkg4iyOhc/PWnllby45jW90yZIkcWHvNO7vfECzDrJ\ni48MQjNZX39STtCKWOCdsygnurE2XB4Z6UGx86ZFQG/hHULqD96v6qnZyxDh\nlSCWPe6BXY9Ldy9UkEtSwTihC8CkrJwSGyYhyzO2AZw2ApzProRZ7Le7dh6j\nB1T2dhCtclj3cjoCinTAluszpZvtHYIP2fOn8Wi9OPcQojbB7hEk8L1RxL+5\nq1qs2wcO4KjvIcB6xrnIr7glON3/UqTk2hJPzd8TyTiLt815XtSvto7/Q1Rl\nCLtcDUFIJYjTMIWgH09mc4ornH/q/pdM5yc+bMHo+f3w1nYlpqIYHApW2kCf\n8GfYEsXQJ5uNeYcrbpvZJIIRib6H4i1NS+OvJFrLfWnuraZYyWH7JzfHZqxH\nY96Q1PJowLB5laXkcIgyHkoczV+rHIaDmkIpvYm9sB7Pbmtdjay5qeYqrKej\nwzxW\r\n=M6fl\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEYCIQCX8DPPOu0+2BDFpNWzqP3/prSemZ8t1gXW1UsTtWZKYgIhAI+jXhdKK61wEewBe8lyDNsVc0EjEunR5uRb4D2+2Qkg"
          }
        ]
      },
      "maintainers": [
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.65.0_1583544171158_0.9863115552271433"
      },
      "_hasShrinkwrap": false
    },
    "0.66.0": {
      "name": "ts-json-schema-generator",
      "version": "0.66.0",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=6.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.4",
        "commander": "~5.0.0",
        "glob": "~7.1.6",
        "json-stable-stringify": "^1.0.1",
        "typescript": "~3.8.3"
      },
      "devDependencies": {
        "@types/glob": "^7.1.1",
        "@types/jest": "^25.2.1",
        "@types/json-stable-stringify": "^1.0.32",
        "@types/node": "^13.11.1",
        "@typescript-eslint/eslint-plugin": "^2.28.0",
        "@typescript-eslint/parser": "^2.28.0",
        "ajv": "~6.12.0",
        "chai": "~4.2.0",
        "eslint": "^6.8.0",
        "eslint-config-prettier": "^6.10.1",
        "eslint-plugin-prettier": "^3.1.3",
        "jest": "^25.3.0",
        "jest-junit": "^10.0.0",
        "prettier": "^2.0.4",
        "source-map-support": "~0.5.16",
        "ts-jest": "^25.4.0",
        "ts-node": "^8.8.2"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint '{src,test,factory}/**/*.ts'",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "FAST_TEST=1 jest test/ --verbose",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts"
      },
      "jest": {
        "transform": {
          "^.+\\.tsx?$": "ts-jest"
        },
        "testRegex": "(/__tests__/.*|(\\.|/)(test|spec))\\.(jsx?|tsx?)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "jsx",
          "json",
          "node"
        ],
        "testPathIgnorePatterns": [
          "node_modules",
          "test-runtime",
          "<rootDir>/build",
          "_site",
          "src",
          "dist"
        ],
        "coverageReporters": [
          "html",
          "cobertura"
        ],
        "coverageDirectory": "./coverage/",
        "collectCoverage": false,
        "testEnvironment": "node"
      },
      "gitHead": "b83428dbf564dd561bf20b60775607404e6d153a",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.66.0",
      "_nodeVersion": "13.13.0",
      "_npmVersion": "6.14.4",
      "dist": {
        "integrity": "sha512-6cs20m2UuSq3rt/rM3z/8btLJ8jzj9Imyqtc3bb9f5JP3d+7gIYkkTQ7hIXmoqQ8MyY56zeO4s/CkO4j5edFfg==",
        "shasum": "bbc85c9493dcfecde7b4a56a0648e12dd4681413",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.66.0.tgz",
        "fileCount": 447,
        "unpackedSize": 637399,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJemiRLCRA9TVsSAnZWagAA7FQP/R+WezFyEpBr1uhfw7bs\nfUnIwRiRAh7tNadtuahuE+NWOMnemuQ2ZAb46gLbiw9Y07rW5A3d6RMUkzXk\nWWdDO7j5008kYhajRHAs61kHvAgnvXhVw3zNAb7bUdSx9IEbkPsugqxl40xW\nJERZSjVifnEWDRApTi4GblEBkXsXkLWB3o5X5dVhMERBpAxmrcjb7Gvde0xJ\nZdh4dR47V+5nxPerLvvIf5KpfwvweqjxiLCGutrJ7MjzlGsjqc7SZn3mfjG9\notZK1BEiUPx+cUuEx6/csKxyvu6VUJ30XVQBKGj9bWWkqNZ/KUJAG9JmmcGW\nvp61QCtBSoixp2fs89Vzgn2PmnjTrMJJVonJk8jBxKVnB6gwT/Jg6ao7AWHu\nUbu+/WJxkBYdnEjSvczftnjxSf1O7gAWGYhIgiA9TjoJo1b9ZHeNxnGWrJLu\nzbm/Up8RuKjMGb7A7iDX5QYTOcLdnpEMCxz5Qq7witRox7OUW33Po2crg7Oi\nnEkBJkY7LKXfbC1l0UYN8mJCQxio5kjDVs0ockWSGOkMU3TnodABgiBa5LMK\nNwgWX409vJU+dhorCuVW2LkawQfkRhFfLC+UQMaJAuDHywj9+gXwMHBFc0IE\nAVfCQKwfJMmS/OS0Jwbxrd9YxnwKHt9ua4uXk1+UdYsdpgOpsDUFpb/ZUxb6\nwjy2\r\n=2EsR\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEQCIEVD3bWaXuuEOMvv4Em1ulWmd0tME1ONWI5nS5yOemo9AiBi63iD+imtgXRPIEncMDorF4vbzd8GJKKrL4nlYEA7XQ=="
          }
        ]
      },
      "maintainers": [
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.66.0_1587160138410_0.6908980205869903"
      },
      "_hasShrinkwrap": false
    },
    "0.67.0": {
      "name": "ts-json-schema-generator",
      "version": "0.67.0",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=6.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.4",
        "commander": "~5.0.0",
        "glob": "~7.1.6",
        "json-stable-stringify": "^1.0.1",
        "typescript": "~3.8.3"
      },
      "devDependencies": {
        "@types/glob": "^7.1.1",
        "@types/jest": "^25.2.1",
        "@types/json-stable-stringify": "^1.0.32",
        "@types/node": "^13.11.1",
        "@typescript-eslint/eslint-plugin": "^2.28.0",
        "@typescript-eslint/parser": "^2.28.0",
        "ajv": "~6.12.0",
        "chai": "~4.2.0",
        "eslint": "^6.8.0",
        "eslint-config-prettier": "^6.10.1",
        "eslint-plugin-prettier": "^3.1.3",
        "jest": "^25.3.0",
        "jest-junit": "^10.0.0",
        "prettier": "^2.0.4",
        "source-map-support": "~0.5.16",
        "ts-jest": "^25.4.0",
        "ts-node": "^8.8.2"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint '{src,test,factory}/**/*.ts'",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "FAST_TEST=1 jest test/ --verbose",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts"
      },
      "jest": {
        "transform": {
          "^.+\\.tsx?$": "ts-jest"
        },
        "testRegex": "(/__tests__/.*|(\\.|/)(test|spec))\\.(jsx?|tsx?)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "jsx",
          "json",
          "node"
        ],
        "testPathIgnorePatterns": [
          "node_modules",
          "test-runtime",
          "<rootDir>/build",
          "_site",
          "src",
          "dist"
        ],
        "coverageReporters": [
          "html",
          "cobertura"
        ],
        "coverageDirectory": "./coverage/",
        "collectCoverage": false,
        "testEnvironment": "node"
      },
      "gitHead": "d4bd9f16bdf34335a2ca6fe956ea236e98b3b4d5",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.67.0",
      "_nodeVersion": "13.13.0",
      "_npmVersion": "6.14.4",
      "dist": {
        "integrity": "sha512-si2LJza0A2AnOLH6+aWQfe9zsuGuJa/EkmboC+a8HEQLXT32acGrnp8sUlpngY9j0kMDF/Frm76t5zqT4bk4sA==",
        "shasum": "56c55d63ff88bee716052a47abe8723fd4dcc0ff",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.67.0.tgz",
        "fileCount": 447,
        "unpackedSize": 637399,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJem5zVCRA9TVsSAnZWagAAM4UP/RJi/yHE8P5jf3LPp9WC\nVVpEmnyGE4FeB0mH9ajL0056UpGi9z8fszKR9B5CPypax9aZcJMNvC5i0yWC\nd1BmBYw50tCzmDpkqJXbZ1Q5/UcoHohjilWu7v8aZH0skMgcbStIFSKlpg0W\nPfWqN7F8mdk66VM6B4ud5SgPlfEVugf0p788+zC13vuQHLkkQvmZReo8PvFB\n4te845Dc7SrxBZIeV1gZo/49kcZ34K8qVfN8bHAMAZM56lEqDiGsd+G4jSdH\n+9YU9GHNSlgMFWMKmpiL763rM42Vv7CStwqeJkfm75+ah++xeXMVGG5cXVoI\ntXSaOwV/j+9LRCw4n8mcyMmoZMiElOulsP46bD5VBnpBUAzSNwPfg4+1av4X\nheTeqGIiZeaer1ddtnf09iDQI21UpwkenoczLSIErhH73xRzEN1DmGZAkm/G\nrAHJH1YvGWrBhXTe0ODfKsZrsQvieZqBzuC7Y9BftPcDTcvkCbQJE7tqwStx\nPbbg5bbA/9rivUey1aVyO+WVjA9l9sGrQ1qNk6qVo/9S1DxF88ZFZlZ1UUC2\n+nTU3JEoCZ4Hoz7Nsvth0yiPOKe3aeBcAfPIA485YX308QINO4yB673aNy3O\n057OGgQryqt1DDfLOJLLVSbUX65wyq5tG+yKNPoklNBO6o43tA7eBwpZxQ38\ndwBe\r\n=k45T\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEYCIQDm6dWkCj7n7KFg2lTXZZmXshaHgq5QpK5uvaxzYDuoTQIhANJIrpK2H+X0BRAxEPCAMbbNcyqlT9sJnmQBvZHtmxzv"
          }
        ]
      },
      "maintainers": [
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.67.0_1587256532683_0.0036896387660059204"
      },
      "_hasShrinkwrap": false
    },
    "0.67.1": {
      "name": "ts-json-schema-generator",
      "version": "0.67.1",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=6.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.4",
        "commander": "~5.0.0",
        "glob": "~7.1.6",
        "json-stable-stringify": "^1.0.1",
        "typescript": "~3.8.3"
      },
      "devDependencies": {
        "@types/glob": "^7.1.1",
        "@types/jest": "^25.2.1",
        "@types/json-stable-stringify": "^1.0.32",
        "@types/node": "^13.11.1",
        "@typescript-eslint/eslint-plugin": "^2.28.0",
        "@typescript-eslint/parser": "^2.28.0",
        "ajv": "~6.12.0",
        "chai": "~4.2.0",
        "eslint": "^6.8.0",
        "eslint-config-prettier": "^6.10.1",
        "eslint-plugin-prettier": "^3.1.3",
        "jest": "^25.3.0",
        "jest-junit": "^10.0.0",
        "prettier": "^2.0.4",
        "source-map-support": "~0.5.16",
        "ts-jest": "^25.4.0",
        "ts-node": "^8.8.2"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint '{src,test,factory}/**/*.ts'",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "FAST_TEST=1 jest test/ --verbose",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts"
      },
      "jest": {
        "transform": {
          "^.+\\.tsx?$": "ts-jest"
        },
        "testRegex": "(/__tests__/.*|(\\.|/)(test|spec))\\.(jsx?|tsx?)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "jsx",
          "json",
          "node"
        ],
        "testPathIgnorePatterns": [
          "node_modules",
          "test-runtime",
          "<rootDir>/build",
          "_site",
          "src",
          "dist"
        ],
        "coverageReporters": [
          "html",
          "cobertura"
        ],
        "coverageDirectory": "./coverage/",
        "collectCoverage": false,
        "testEnvironment": "node"
      },
      "gitHead": "d48d62d483763c67f42d63329c03dfdb5df98643",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.67.1",
      "_nodeVersion": "13.13.0",
      "_npmVersion": "6.14.4",
      "dist": {
        "integrity": "sha512-trm0Z8yR0f9aAsobKxfZ0z3JCGjDXHP/U67uJdNlS9ghJZUmSzennqQjUOY+zfYUEkSt3r+ytfHMojNrj2wnIg==",
        "shasum": "8f1a9d1ea06d7ce47e51b34caf7271c211d7faea",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.67.1.tgz",
        "fileCount": 450,
        "unpackedSize": 640959,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJem52yCRA9TVsSAnZWagAAjOAP/36OedL/aZbUwijZQcR8\nHI3qvd59tlHd7bcc81sJrfYvq4O5LLf2uhJX5oEF4ZwOyWwl8T+lcnECKpa6\nGQhDaxdUxqjxyRLTcNsrjwb8Q7+Cc+zbG8rU2hzEafkTu3Ch0n7GjGLm+fcO\nvOrsaMxySVtEuEKdBG+Mk11tHX1TuKDpo9BpMXFUj8o0ZsnX4F3k+pdeXEkY\nAtoFO6AxQu1mi+x0B+dOVehFKAK9Hxaz6lIhmU1wzuRGGZXlzueisXsH65jt\nhVAB9LRU9UCwOd+a/kADiiE+UDlPdGJ15tV8E85rT3NqorpdNsbBL2U2XTW1\nMeda/wmNwe6qqIRf5lbLxsCGlLVvmO0meBNxwYJznyV2ytI62gEkBhA2zcDj\njo1cjdyiIfVfGu6oB6kHoXW2qdxzuGPbsgf3SabRgdxqJVNs/bHFjipivDUK\nw25zFbyb/3Htq+v2rVGKkArQw8zOSdwYsUorQrgfovpdAUKj8/MnQdFZYb/j\njiCKy6KkzpudqXf84Rr7K/L6CLpLmFeLTbtWM5+E7iTJFUQ99Bm18qq5Dgpv\nSyDGpSTwgiL7q2aveFJbdld/8s6gK0zSrGDpwJr15t5n0HCzmQCoTqGupXc8\nthFVNpFX85WJ4EgCjrwslWSW9lQG9VD314YNkPwoMgeGpGMooaOBhkKm/6hH\nEVmz\r\n=ryIv\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEQCICE5wltyzS8443VffZvCZmPwgkBUvBU3XSiMiGs7qWavAiBG+5vxSbDPIp3mPkt+po9lr59MhqqFiwYpB+uNl9ZoGQ=="
          }
        ]
      },
      "maintainers": [
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.67.1_1587256753951_0.8543184795016365"
      },
      "_hasShrinkwrap": false
    },
    "0.68.0": {
      "name": "ts-json-schema-generator",
      "version": "0.68.0",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=6.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.4",
        "commander": "~5.1.0",
        "glob": "~7.1.6",
        "json-stable-stringify": "^1.0.1",
        "typescript": "~3.9.2"
      },
      "devDependencies": {
        "@types/glob": "^7.1.1",
        "@types/jest": "^25.2.1",
        "@types/json-stable-stringify": "^1.0.32",
        "@types/node": "^14.0.1",
        "@typescript-eslint/eslint-plugin": "^2.33.0",
        "@typescript-eslint/parser": "^2.33.0",
        "ajv": "~6.12.2",
        "chai": "~4.2.0",
        "eslint": "^7.0.0",
        "eslint-config-prettier": "^6.11.0",
        "eslint-plugin-prettier": "^3.1.3",
        "jest": "^26.0.1",
        "jest-junit": "^10.0.0",
        "prettier": "^2.0.5",
        "source-map-support": "~0.5.19",
        "ts-jest": "^25.5.1",
        "ts-node": "^8.10.1"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint '{src,test,factory}/**/*.ts'",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "FAST_TEST=1 jest test/ --verbose",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts"
      },
      "jest": {
        "transform": {
          "^.+\\.tsx?$": "ts-jest"
        },
        "testRegex": "(/__tests__/.*|(\\.|/)(test|spec))\\.(jsx?|tsx?)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "jsx",
          "json",
          "node"
        ],
        "testPathIgnorePatterns": [
          "node_modules",
          "test-runtime",
          "<rootDir>/build",
          "_site",
          "src",
          "dist"
        ],
        "coverageReporters": [
          "html",
          "cobertura"
        ],
        "coverageDirectory": "./coverage/",
        "collectCoverage": false,
        "testEnvironment": "node"
      },
      "gitHead": "cf090f07a1e6468108e674b645bd20b7d12559b7",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.68.0",
      "_nodeVersion": "13.14.0",
      "_npmVersion": "6.14.4",
      "dist": {
        "integrity": "sha512-V8LxhAWJkOhApVBLOOFsIF1eR3Xi+aXhdhghKf64WkWYEVUFX/qw7IjOwQD0vJvSUWIBFVMa+97PHImqKNRYsQ==",
        "shasum": "327f380b0044f7e2668a8740194351669f8e506d",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.68.0.tgz",
        "fileCount": 450,
        "unpackedSize": 688407,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJevCIJCRA9TVsSAnZWagAAKdgP/iua5gAHf0q3TBZuTLyZ\nXia0yVCao4K+gnVY4+OY/3A6ihrSTux+JU4bnUj3KSOW/wMrmhaHCXK3QhtN\n44EHuAeZJwyq/awLnvL5JrD65xtO94SPs9JOlrcuky3s6aVn8kRYhfTm4zwe\nfdV2akB6gtoZjzjM3pFvGLFBjOLWfuW38hBB8y8jTwNJK/QRW7QCs24/vDnT\nZv27hEMkivj/2bxm9WNTrWxdLgRT91nrdZfuMSgyKHW1b50OB1Oblpoi3JoS\n6gcYavRwNXoF/XOgZPsQuSQv62h76rKlOaebbiA6ZKnQsNMwShFHeNg77+Ch\nI+6Sa3oN75aPKU2vx77iEwhvymPAGdnKeoC/qXvXqP8XG+vBHdnRvpU6B6EB\n7tYrPrhWpLYZjRzAf/Gk2YcBiSkvhA1sl2KXWcx9z4FQCS6kEYPz9uGiTnIj\nG+hQPh2e2sb6GJRHIiM4iBeKhohhpZCHmn2Q9VAAIVW7CQeLMdGOPuLWGzhC\n+E8R/IcVtj58R7+B9BU+kMijID6YYQmvHRibLxbx5EuhJcJGf7Fydv0tkfL6\niV4k1w0Quugujdbe4xxtL/BXTos8brYVAkFEn29hKhUyCXCyN3/K6ozlhxK+\nd40jeCIdkZ/cWsMnTkc9Vj6cCdS8//kNT5bakpQtw8FYLmk7D1ZJLAackIKh\nx8P1\r\n=/JP6\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIQCkQfNd9Av4psM6RpXcXEx7UKyKBN9mSw9rC1Yi6Btt5gIgSd8QdqiMxDvGMf7RoYHplI8rXcfG7SY+EjFv9YMSg9A="
          }
        ]
      },
      "maintainers": [
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.68.0_1589387784581_0.8228347579112694"
      },
      "_hasShrinkwrap": false
    },
    "0.68.1": {
      "name": "ts-json-schema-generator",
      "version": "0.68.1",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=6.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.4",
        "commander": "~5.1.0",
        "glob": "~7.1.6",
        "json-stable-stringify": "^1.0.1",
        "typescript": "~3.9.3"
      },
      "devDependencies": {
        "@types/glob": "^7.1.1",
        "@types/jest": "^25.2.3",
        "@types/json-stable-stringify": "^1.0.32",
        "@types/node": "^14.0.5",
        "@typescript-eslint/eslint-plugin": "^3.0.1",
        "@typescript-eslint/parser": "^3.0.1",
        "ajv": "~6.12.2",
        "chai": "~4.2.0",
        "codecov": "^3.7.0",
        "eslint": "^7.1.0",
        "eslint-config-prettier": "^6.11.0",
        "eslint-plugin-prettier": "^3.1.3",
        "jest": "^26.0.1",
        "jest-junit": "^10.0.0",
        "prettier": "^2.0.5",
        "source-map-support": "~0.5.19",
        "ts-jest": "^26.0.0",
        "ts-node": "^8.10.1"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint '{src,test,factory}/**/*.ts'",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "FAST_TEST=1 jest test/ --verbose",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts"
      },
      "jest": {
        "transform": {
          "^.+\\.tsx?$": "ts-jest"
        },
        "testRegex": "(/__tests__/.*|(\\.|/)(test|spec))\\.(jsx?|tsx?)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "jsx",
          "json",
          "node"
        ],
        "testPathIgnorePatterns": [
          "node_modules",
          "test-runtime",
          "<rootDir>/build",
          "_site",
          "src",
          "dist"
        ],
        "coverageReporters": [
          "html",
          "cobertura"
        ],
        "coverageDirectory": "./coverage/",
        "collectCoverage": false,
        "testEnvironment": "node"
      },
      "gitHead": "ea29da60a437c30f5069f48aaee0988d16e60bb4",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.68.1",
      "_nodeVersion": "10.20.1",
      "_npmVersion": "6.14.4",
      "dist": {
        "integrity": "sha512-2+bJQbczumnKdhLF3b0f8CDrBUNUeZLT/LrDeGAJ1yN0GFtVING5dIu2oeGWS6Lj0AhZc9ynCxLTzE9860plVQ==",
        "shasum": "39cddb11b0d223e9f60febeb01276e1e4c7cb087",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.68.1.tgz",
        "fileCount": 449,
        "unpackedSize": 688780,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJezBIdCRA9TVsSAnZWagAAHDkP/Ao0YON5UOEoGm06kDIP\n4d0C6iMZg2elV/OI6Ozm1fLiPfWPDrp9gVLvToAvH8xA4Yn/AG3fTShQhh7U\nkcT9WWSpVWU1F8WIZNI93ZmNVrZewPHY0pCc55c1sPShU6uVkig8n4+uP43W\nA+AV1zBSFhT8aMLHj82l00nZyprYJ87gLXx4I/KL5fJkUkSjvr5KRKnjCAPR\nNKBnSVNbNpWlRDaWZGMBoiG54B4iTuzTdG2XqC+eTdhyKDRPjQ8lQ42BqxE5\nRa359lWYKNBBcncz1CgaicmqJIqLG2LIUrPXvOOTDyw4kDyVuU/BcO2UQhXd\nPGbVarv+VpbSSuXj19886Gi6q9YXKMvkG4j+KIGv6Gi3YDQ/g09x1y2XTT//\nKjtq/5eBFDkzK5Lo82h09Bi3p0JoNJpoH6m4mM+LNeO4R+zKjn9LkZWIEutR\nokRIEOOICQKmQPyAkmfXdBohK+CDKeKEJu4WJnyTukp2vJyywPT0a7A1wHRN\npw0bMP9Jit4w3uwqqKUsOFs8rj8oi87zqSor7TZ17kEdp/d1zyO6qGteO/yM\nsF38Yel2yj2iwpBAalsEm2n23g89luPyXdiwghHTpWrKuAa+/pq+mHbMtBus\nxZeiFec1+IaNPfjfNGyCIdfQY8WfBgpJf7WYF2rU/17u9+LvW8jb0trFWwX4\n1Baq\r\n=LCap\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIQCoo0ea7CUjhHE3zDa9IjaefAdP1FtkT0tWDlzk8OegqwIgSFqhpqqMMERGvZ+wxjT3k9+twGU45kS3QMn5ZLGA8Ws="
          }
        ]
      },
      "maintainers": [
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.68.1_1590432285145_0.4353901998975378"
      },
      "_hasShrinkwrap": false
    },
    "0.69.0": {
      "name": "ts-json-schema-generator",
      "version": "0.69.0",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=6.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.4",
        "commander": "~5.1.0",
        "glob": "~7.1.6",
        "json-stable-stringify": "^1.0.1",
        "typescript": "~3.9.3"
      },
      "devDependencies": {
        "@types/glob": "^7.1.1",
        "@types/jest": "^25.2.3",
        "@types/json-stable-stringify": "^1.0.32",
        "@types/node": "^14.0.9",
        "@typescript-eslint/eslint-plugin": "^3.1.0",
        "@typescript-eslint/parser": "^3.1.0",
        "ajv": "~6.12.2",
        "chai": "~4.2.0",
        "codecov": "^3.7.0",
        "eslint": "^7.1.0",
        "eslint-config-prettier": "^6.11.0",
        "eslint-plugin-prettier": "^3.1.3",
        "jest": "^26.0.1",
        "jest-junit": "^10.0.0",
        "prettier": "^2.0.5",
        "source-map-support": "~0.5.19",
        "ts-jest": "^26.1.0",
        "ts-node": "^8.10.2"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint '{src,test,factory}/**/*.ts'",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "FAST_TEST=1 jest test/ --verbose",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts"
      },
      "jest": {
        "transform": {
          "^.+\\.tsx?$": "ts-jest"
        },
        "testRegex": "(/__tests__/.*|(\\.|/)(test|spec))\\.(jsx?|tsx?)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "jsx",
          "json",
          "node"
        ],
        "testPathIgnorePatterns": [
          "node_modules",
          "test-runtime",
          "<rootDir>/build",
          "_site",
          "src",
          "dist"
        ],
        "coverageReporters": [
          "html",
          "cobertura"
        ],
        "coverageDirectory": "./coverage/",
        "collectCoverage": false,
        "testEnvironment": "node"
      },
      "gitHead": "53b0625e9302b6753b57bdc6f1903fc7956e5704",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.69.0",
      "_nodeVersion": "10.20.1",
      "_npmVersion": "6.14.4",
      "dist": {
        "integrity": "sha512-1lSVRgf5oZzxIyeZ+CFdgi+paR57iP+2ph4JfwgSALBT2amaJ54E5Tyoi4X1MxqhOrBO3hRK+u/YDj30zs3gyw==",
        "shasum": "0b3d93dda4d401a5c691170e8d25b1b9c1673ddf",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.69.0.tgz",
        "fileCount": 449,
        "unpackedSize": 689939,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJe19m9CRA9TVsSAnZWagAAwkcQAI67Bqgl5Lolbb2SjRrL\nYGdjHVxD8f+Xw91mA5gM79X3QdSMLfOtXmDKB7cntQVWOqOaTBH09+R6w4h7\n10K4DaYTCZePfpeWpMJEHfLEpzMz1cQy8WtkxDNF2A6o72G18BonmzhXUj2/\nXL3XBZm40K7m8UXp6SaqGofYrANz0lplptFXuDwc9Dw0PkTQxuOp+TDSkrWn\nOMbUeB9miaP5fvHhKTvYZV/9xkYqrLFbKLBXDpIztNU7o5ZWR05LS9GOBW0v\nOCpOkpMMn8J1sZgfxSXJrYRVzRqnQbyjFLEHFUZ2bBLviGynL31joPHASxTo\n8L3BoULbaiX/Tu6lyHSW8oa63IP/a5PIXFnndu3g0vWGvBbqCKTm0U5KceRx\nt0sAXdYnw+UZyqovpjjJB6jrpelYkcHq5B8WPlIlTqg2Ja3g+o6Jv/8ggihZ\n1PIFmwnWe2K4ndcJNqgKk9cqo2hZNGzGVNvTqGLws5LWYh1kre9hU5D85fUg\n3ekxLCQLZHrwLvzSfqkGyLpCZRQZL5I4DT1yl2k/JPdvKrh5mDn1TQiqCU2q\nzrd/eZd8Bx/1VFyqDVhTEIRef7unE6cVO46qzNJxhfJaS++48IGN30SSR9zA\nonAY58iNqZ7kwLita2cqauxc6uxeLYx6wWcXtawFuB5cV6gzGomvmzkbaxUD\n5cdT\r\n=HFWD\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIQD0jd57fgjzSUFvogfAeg1W0XJwZ9Kt5tYslcGs3Xa7JQIgFjhOGRK9r2Z45EjKYV4nzHpGoYhrw7aS5zDrU/tBEMs="
          }
        ]
      },
      "maintainers": [
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.69.0_1591204284870_0.562341883251551"
      },
      "_hasShrinkwrap": false
    },
    "0.70.0": {
      "name": "ts-json-schema-generator",
      "version": "0.70.0",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=6.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.4",
        "commander": "~5.1.0",
        "glob": "~7.1.6",
        "json-stable-stringify": "^1.0.1",
        "typescript": "~3.9.5"
      },
      "devDependencies": {
        "@types/glob": "^7.1.1",
        "@types/jest": "^25.2.3",
        "@types/json-stable-stringify": "^1.0.32",
        "@types/node": "^14.0.10",
        "@typescript-eslint/eslint-plugin": "^3.1.0",
        "@typescript-eslint/parser": "^3.1.0",
        "ajv": "~6.12.2",
        "chai": "~4.2.0",
        "codecov": "^3.7.0",
        "eslint": "^7.1.0",
        "eslint-config-prettier": "^6.11.0",
        "eslint-plugin-prettier": "^3.1.3",
        "jest": "^26.0.1",
        "jest-junit": "^10.0.0",
        "prettier": "^2.0.5",
        "source-map-support": "~0.5.19",
        "ts-jest": "^26.1.0",
        "ts-node": "^8.10.2"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint '{src,test,factory}/**/*.ts'",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "FAST_TEST=1 jest test/ --verbose",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts"
      },
      "jest": {
        "transform": {
          "^.+\\.tsx?$": "ts-jest"
        },
        "testRegex": "(/__tests__/.*|(\\.|/)(test|spec))\\.(jsx?|tsx?)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "jsx",
          "json",
          "node"
        ],
        "testPathIgnorePatterns": [
          "node_modules",
          "test-runtime",
          "<rootDir>/build",
          "_site",
          "src",
          "dist"
        ],
        "coverageReporters": [
          "html",
          "cobertura"
        ],
        "coverageDirectory": "./coverage/",
        "collectCoverage": false,
        "testEnvironment": "node"
      },
      "gitHead": "050f58149172b0f8218697c181bb1a74ad65a1b4",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.70.0",
      "_nodeVersion": "10.20.1",
      "_npmVersion": "6.14.4",
      "dist": {
        "integrity": "sha512-WSz3m7YA0W/ay75lAlYRmZNE+93psQlO2lUoT13nINUC0ujwivSHAGZrbg2cE4ieHDVW1vv39VKy9OhPpsWK9g==",
        "shasum": "7f6425f4bb5c1d950412b4265e2aef9769bd6558",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.70.0.tgz",
        "fileCount": 449,
        "unpackedSize": 691316,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJe2TxsCRA9TVsSAnZWagAANtIP/1xax1ygN6fTOiZGoMFH\nhZU2haFRcmsR3kVx0Mq0NXg6rb0J1yye4IyaETgYM/0z2C28s0CaCz2sT39w\nN3mklPsaP1th00YYI5AyX+NfvfwMatw7Czcek0a+Z/1nyAK5sISDUV0uxWfu\n6JqQsYhRfw4cmz68x2AUhkOk+vi+KN2o+TcJZJWfRkpTITJ0ZLG3EFeVAgiQ\nA5eAJOlrEXiFvzhwrX8o2cJKwOZfLaFxHn2UG44wi61IuDRd/0LpC93ecMzb\nhfWOO4ptPL+YvXwtcK027Wk+CJclaLQQiYFhEX2K4JOlP6+usitdqR8gUsHL\n1dyGYRKY6aymPL9k2A9+4ZYrMPYZUbkjeXYNl+APO5X5F/Js1CO/oXyOlMfY\nYWZOk73oo4c8G3JB7fPo8irQ3U9pYbW4L0No3e1w8Afi+Ib3/oyct1BSPE6H\nGpJXEfntzgCKT5HXF8x7DxjWyE8QxNyjNz8QUuPmNm22KroyvshSiGWOAEYz\n6WyW3Svff5eRnmH0k6uj2XpV1izkHgFjpE2hHxuigVCr1OTcHE45KDr9hhfg\n52I3X3sqW0AguG3tIponBgmrcEUTPdPRByHTVp6dJYG6HbeI0kbEBEhtbBXz\nyKcXq6OsTjfynlFc5ImJUhQmyE9Fpocv+jKK+7NzgeqfvSNy2LJ0mb1pnT/Y\n9cwO\r\n=uoY7\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIDtBYBrOk69n/44eiwrMr2HQufOEvmMj1/zpX3nVS6WjAiEAvLBQxeBSQkuVo3HuDKPzOBAfJl48vURMjzwSQtx42kE="
          }
        ]
      },
      "maintainers": [
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.70.0_1591295083738_0.19071619619567004"
      },
      "_hasShrinkwrap": false
    },
    "0.70.1": {
      "name": "ts-json-schema-generator",
      "version": "0.70.1",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=6.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.4",
        "commander": "~5.1.0",
        "glob": "~7.1.6",
        "json-stable-stringify": "^1.0.1",
        "typescript": "~3.9.5"
      },
      "devDependencies": {
        "@types/glob": "^7.1.2",
        "@types/jest": "^25.2.3",
        "@types/json-stable-stringify": "^1.0.32",
        "@types/node": "^14.0.11",
        "@typescript-eslint/eslint-plugin": "^3.1.0",
        "@typescript-eslint/parser": "^3.1.0",
        "ajv": "~6.12.2",
        "chai": "~4.2.0",
        "codecov": "^3.7.0",
        "eslint": "^7.1.0",
        "eslint-config-prettier": "^6.11.0",
        "eslint-plugin-prettier": "^3.1.3",
        "jest": "^26.0.1",
        "jest-junit": "^10.0.0",
        "prettier": "^2.0.5",
        "source-map-support": "~0.5.19",
        "ts-jest": "^26.1.0",
        "ts-node": "^8.10.2"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint '{src,test,factory}/**/*.ts'",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "FAST_TEST=1 jest test/ --verbose",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts"
      },
      "jest": {
        "transform": {
          "^.+\\.tsx?$": "ts-jest"
        },
        "testRegex": "(/__tests__/.*|(\\.|/)(test|spec))\\.(jsx?|tsx?)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "jsx",
          "json",
          "node"
        ],
        "testPathIgnorePatterns": [
          "node_modules",
          "test-runtime",
          "<rootDir>/build",
          "_site",
          "src",
          "dist"
        ],
        "coverageReporters": [
          "html",
          "cobertura"
        ],
        "coverageDirectory": "./coverage/",
        "collectCoverage": false,
        "testEnvironment": "node"
      },
      "gitHead": "9d36d95739f5545069f00a633ad56424fa46d398",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.70.1",
      "_nodeVersion": "10.20.1",
      "_npmVersion": "6.14.4",
      "dist": {
        "integrity": "sha512-FFmqKicwyqyeU/16tyroYoYHJPCkh8eoD4kTJq+b6qcXoZIKrSQP13EB6h7S+wokcGmV9B92B5uF6lfLz75T3w==",
        "shasum": "a519c507e66bdb773e565e098009162e00b3096a",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.70.1.tgz",
        "fileCount": 449,
        "unpackedSize": 690312,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJe2cTlCRA9TVsSAnZWagAAXXkP/2+B30WojKvnBMzv/lAm\niy9ZSJ8dqsnTNQ4Gj2jATeN15vgX1eZnVv3itHdz+KGpWxfdsNQdDdiF7d5U\nJQEbIeMFepJBZonl6doE/A0q3jsA5LmzYJ0J/k1ZLO3KLktmA4Fv8dadEdo6\nnLCXW4DNeKe1ai+AZuzoM2TusQNgsYpeTHiW9BGByIqUnwqJkdL88mKiXgD/\ni2xek7TxP8C8QW+V7XV/r3MOPRHDQ5Kr2FvSn8TmjRBDhZCUY62lo2o+KNNz\n840YjqZ5miDoWjRyl0oX+svd6S0ppCTbfpqdYfJ7nUD9T5smpTgH41D1yAlu\nb27s4ABAX0/nI6PS0XljEwer8J5F3Mk/nA08NdSXGMkdjkgDgsBeBg1peS0c\n5lGMrebDjuiquWqSfmUOJO/e3F44ZaBWdmqIpGKsYzcdBsdUQVCSLFJ4QY+v\nH326QFlG9hrdDvMNdAUaw1+QebqkOOlBmUXtiVhIEL57ZZA1F09y8PzQg3pw\nvgA+mikhjcZQn8a8IrMQxLW64y4s3zOvJ7VmrCKQpWBHIq3XcuHCMea3kf0q\neSZHUvKW0VT9EeLoK1mXjvwktkJg8ZbFXEX5uxiuqAchc3cb3ZlGDSb58zmz\nsLA+n/HoH5oMihRRpB/OeOPTj6/+5hREC2h6AX+TBnuN0rgsbADaNjAgYQbB\nWWzG\r\n=1scg\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEYCIQDkPGCQznLaoIbmDxX5EfQVBm73uGzavASc11H66fz2UQIhAIEpSBqbCtUbOliiLBL3GkVBs6ZdizAEOnM8/4osU2vJ"
          }
        ]
      },
      "maintainers": [
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.70.1_1591330020993_0.9387996711197626"
      },
      "_hasShrinkwrap": false
    },
    "0.70.2": {
      "name": "ts-json-schema-generator",
      "version": "0.70.2",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=6.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.5",
        "commander": "~5.1.0",
        "glob": "~7.1.6",
        "json-stable-stringify": "^1.0.1",
        "typescript": "~3.9.5"
      },
      "devDependencies": {
        "@types/glob": "^7.1.2",
        "@types/jest": "^26.0.3",
        "@types/json-stable-stringify": "^1.0.32",
        "@types/node": "^14.0.14",
        "@typescript-eslint/eslint-plugin": "^3.4.0",
        "@typescript-eslint/parser": "^3.4.0",
        "ajv": "~6.12.2",
        "chai": "~4.2.0",
        "codecov": "^3.7.0",
        "eslint": "^7.3.1",
        "eslint-config-prettier": "^6.11.0",
        "eslint-plugin-prettier": "^3.1.4",
        "jest": "^26.1.0",
        "jest-junit": "^11.0.1",
        "prettier": "^2.0.5",
        "source-map-support": "~0.5.19",
        "ts-jest": "^26.1.1",
        "ts-node": "^8.10.2"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint '{src,test,factory}/**/*.ts'",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "FAST_TEST=1 jest test/ --verbose",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts"
      },
      "jest": {
        "transform": {
          "^.+\\.tsx?$": "ts-jest"
        },
        "testRegex": "(/__tests__/.*|(\\.|/)(test|spec))\\.(jsx?|tsx?)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "jsx",
          "json",
          "node"
        ],
        "testPathIgnorePatterns": [
          "node_modules",
          "test-runtime",
          "<rootDir>/build",
          "_site",
          "src",
          "dist"
        ],
        "coverageReporters": [
          "html",
          "cobertura"
        ],
        "coverageDirectory": "./coverage/",
        "collectCoverage": false,
        "testEnvironment": "node"
      },
      "gitHead": "a003d8b4313754f20ee5c972d616cc0d7a6b3a43",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.70.2",
      "_nodeVersion": "10.21.0",
      "_npmVersion": "6.14.4",
      "dist": {
        "integrity": "sha512-4miuxRyxYvwzCGGzxGvN39fwlY7HDlj1KRpZq8Hi3IegeAnguc9q4gDvcqMaDKoRiNNnV5fwplRWZFhRrtvr4Q==",
        "shasum": "71c9cecf982c402c95ca9f982177ae3eedcaad8e",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.70.2.tgz",
        "fileCount": 449,
        "unpackedSize": 694554,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJe96y+CRA9TVsSAnZWagAAPWYP+wci8SRJwJ58aAbBtLoz\ngbbkY36GPlSlpBLgaMHD30KV/jVt1RhJVZ0cJL03o6KiXolU7E4eLi+8reZ+\nZ0JS5N1WLdrrHTsfGDkEZQytB0eEGOiwl0+IULVsNTqJ4J7NH3vmKcR2Nixt\nYaE9ZdX+I2oyOhCfOvk0nBqhBAEuuFp5wUeCNAh5oJCzJdyVJodmkwZgIWtT\nn1mwZoVVjlu/cHZL8XT0PtYVb9QdYXs6WunEptNOaDugv5ZWmOzYWe/4VEU/\nwbiA/Hi8VuEdZLOQ523/5ywsqdprtXhDHObJu5k2DdN388nZd0JS9jiexyKi\nTVPah4uGM0LIm4T6WhPqw/tsc7gKiap0SzfIcIpwkoOU6pgR26Yw9odDxxIu\ntM6yCAZc0mo/XEQ5C33C6OaEtuPOYVGWY+UBvOfp8ExywSgz0/HhyFWsGygs\ngtR5C67RKaBXhrQx5c0vsoNlpy9fkw2xf0Xpq8U1xsXdHNrc3oPdkisDkbrz\nhRosp+3m1LPwc2fgmqVM5LRJpXx+Tnjd1Px/BPZyHWfPSS1MoIbVLxtetefT\nJuUDawMD4yRIbnhC1FMlmMpc+DsWveQ7OA4StIDXRsLhI0yhHEuR9ix0hWIo\npCDdpj39N52Xi1GwyNxdBb5zh7PxgY62wwWsJ2PjclkE8zt18bx8Z5xLzgWN\nmA4U\r\n=SFnV\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIQCVBgdHwZ9p5zYU2aAcF/i5drsK2MmEPOmiVQprnFHzoQIgSbXMiobBCUu9pNiJPVsumrRy1uu2PK7mcgZikKSuOaE="
          }
        ]
      },
      "maintainers": [
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.70.2_1593289917774_0.27519805252508034"
      },
      "_hasShrinkwrap": false
    },
    "0.71.0": {
      "name": "ts-json-schema-generator",
      "version": "0.71.0",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=6.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.5",
        "commander": "~6.0.0",
        "glob": "~7.1.6",
        "json-stable-stringify": "^1.0.1",
        "typescript": "~4.0.1-rc"
      },
      "devDependencies": {
        "@types/glob": "^7.1.3",
        "@types/jest": "^26.0.9",
        "@types/json-stable-stringify": "^1.0.32",
        "@types/node": "^14.0.27",
        "@typescript-eslint/eslint-plugin": "^3.9.0",
        "@typescript-eslint/parser": "^3.9.0",
        "ajv": "~6.12.3",
        "chai": "~4.2.0",
        "eslint": "^7.6.0",
        "eslint-config-prettier": "^6.11.0",
        "eslint-plugin-prettier": "^3.1.4",
        "jest": "^26.3.0",
        "jest-junit": "^11.1.0",
        "prettier": "^2.0.5",
        "source-map-support": "~0.5.19",
        "ts-jest": "^26.2.0",
        "ts-node": "^8.10.2"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint '{src,test,factory}/**/*.ts'",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "FAST_TEST=1 jest test/ --verbose",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts"
      },
      "jest": {
        "transform": {
          "^.+\\.tsx?$": "ts-jest"
        },
        "testRegex": "(/__tests__/.*|(\\.|/)(test|spec))\\.(jsx?|tsx?)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "jsx",
          "json",
          "node"
        ],
        "testPathIgnorePatterns": [
          "node_modules",
          "test-runtime",
          "<rootDir>/build",
          "_site",
          "src",
          "dist"
        ],
        "coverageReporters": [
          "html",
          "cobertura"
        ],
        "coverageDirectory": "./coverage/",
        "collectCoverage": false,
        "testEnvironment": "node"
      },
      "gitHead": "3134cb6cea2136f8583bc4a287178784114c90e5",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.71.0",
      "_nodeVersion": "10.22.0",
      "_npmVersion": "6.14.6",
      "dist": {
        "integrity": "sha512-cJdZO8dYPTF5CQWK92NnO1bIiojADsGRwOB06wA5O5U+4yn6o0b+Tqm35Zn9Akf7CWWeXAact80lb8mmY3lySg==",
        "shasum": "ce4cce8a02631a864c7352e2ea22d8d654258a94",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.71.0.tgz",
        "fileCount": 449,
        "unpackedSize": 738111,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJfMwsdCRA9TVsSAnZWagAAnmEP/iqXrZvPr5ZVk1zHjCjw\ngj7jZ6u+XRgOoRYZKB+abd6EUl/EK6K2hITc8t68V53dUpB8kjhkgsNuEBGd\nIA5G7T+ij2n/73Gp1otZliOCWoVJVmJSurcVlVS6XRCWK4IPMfnEd1yfN0uJ\nUC/p+qyqWydq3PLQ4UJhoeclf6Idn+bV5V1gfP5UwkjMkIpnJ86GHd/9cv93\nPozC8eMZZa8O2WinOm+jz0zodLBEyBOq4976E89StpXgYmXHQz2S3uZv4EeI\nCo29DX+4mnZJXQETEKkInBF4yWlvUCo47Huje/mB8W8pvKBisvpWMgqwgrr8\nWyGyEGK17snFVMNWjs9Wf2C3nM3VpT0YmJGXW0Iu/SSDQMEWkuC4a++uQ1Gm\nuz7qgXOzqHsFNfnq1gy0A5llgsTQcT3Xazx42+LalP6w3BSscUl474ELrV7S\n/SZSTxf3+5Q4L6ev2Hrb4JAiW4GnKwQdTOU+eyFB2eFkbE0B3wkxzdEr0tUW\n8XEEojNS3KNE4+/KmMsrVYsg983e9kI5JRN34LKr439PL4vRiaTdvoqbpX+Q\n3VBp422leDeEErxCHB8G+NZc5rAv+7HVbRts8k3Ome0mtAhFgK3jKzZdXpNw\nHZlmnoPtaDgHbxqh5LF8ACqQVhwmM2fpUuGoS1jTrfd8bPm5zoN98wH+z8gZ\n2qLU\r\n=eIDm\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIF5F3ArEfbkUkq3zerL/UBRKU0g1igtNFY/Tgf4VlO/2AiEA4v8RQIXEDxRZj0reT5g4UeMRnm8RtIaauUq4GmScy/c="
          }
        ]
      },
      "maintainers": [
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.71.0_1597180700424_0.6733398512407114"
      },
      "_hasShrinkwrap": false
    },
    "0.71.1": {
      "name": "ts-json-schema-generator",
      "version": "0.71.1",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=6.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.5",
        "commander": "~6.0.0",
        "glob": "~7.1.6",
        "json-stable-stringify": "^1.0.1",
        "typescript": "~4.0.1-rc"
      },
      "devDependencies": {
        "@types/glob": "^7.1.3",
        "@types/jest": "^26.0.9",
        "@types/json-stable-stringify": "^1.0.32",
        "@types/node": "^14.0.27",
        "@typescript-eslint/eslint-plugin": "^3.9.0",
        "@typescript-eslint/parser": "^3.9.0",
        "ajv": "~6.12.3",
        "chai": "~4.2.0",
        "eslint": "^7.6.0",
        "eslint-config-prettier": "^6.11.0",
        "eslint-plugin-prettier": "^3.1.4",
        "jest": "^26.4.0",
        "jest-junit": "^11.1.0",
        "prettier": "^2.0.5",
        "source-map-support": "~0.5.19",
        "ts-jest": "^26.2.0",
        "ts-node": "^8.10.2"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint '{src,test,factory}/**/*.ts'",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "FAST_TEST=1 jest test/ --verbose",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts"
      },
      "jest": {
        "transform": {
          "^.+\\.tsx?$": "ts-jest"
        },
        "testRegex": "(/__tests__/.*|(\\.|/)(test|spec))\\.(jsx?|tsx?)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "jsx",
          "json",
          "node"
        ],
        "testPathIgnorePatterns": [
          "node_modules",
          "test-runtime",
          "<rootDir>/build",
          "_site",
          "src",
          "dist"
        ],
        "coverageReporters": [
          "html",
          "cobertura"
        ],
        "coverageDirectory": "./coverage/",
        "collectCoverage": false,
        "testEnvironment": "node"
      },
      "gitHead": "97e8af5072f0feb5e6c5788b290a5b7262732fe9",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.71.1",
      "_nodeVersion": "10.22.0",
      "_npmVersion": "6.14.6",
      "dist": {
        "integrity": "sha512-I+c5Yzkj04qVxjHZqPCqfWid3EGPB8GivG1vTmuJUEYfN8m/11KFNEv2oTkL4iraZyemiOsS4R7fjVpH+YTLeA==",
        "shasum": "dbe7d19a1103b649adf0b68c24c4521a587f02c8",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.71.1.tgz",
        "fileCount": 449,
        "unpackedSize": 738295,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJfNJYICRA9TVsSAnZWagAAyw4P/0MSP8bC5sH6QkpQSnIc\nxLDDcRVnkzjrplRsIlGlR81O/o9mo+7OE3b6YufbBTM8gHWAXTRVCPU55Eu0\nG+q2Tqwq2F8v/dKQGui4rHPgcwKiClXQgXVko7uei7s71Bqenx7TR70eFon5\njsD1zzYVyiXeNwTGtp9nTXmD3eVgCGpU3g7C1EmNZb7NEBBwIFsrQYw7BDnD\nUh3nzRDxHX622rr4449a5k0NQuARkveuqkCxdPNM2E0rHc0LGdzUzbUMYzi/\nC6EcEFFWHqqrlDjxOs1UwOd4krvqeQbcCy/PF+aaX9jIHZ/w5z8JXsRbpJsu\ndZe7yh1epgVTtmLbOY94TPxylviDTZnNkaUNxvw1Yx8eRwCinriyKksiNDlb\n1pg8HC1cTWGzn33KzUQNEM0KmP8wUnMexGvCRGI940XO9s6ph11CPVMX5mtS\nJSvni5stgJplJvwfcRK5VndGjY9xENpMtEPfdCFlgRB1G2VmpCCg3Thfqx0V\nBsjHwTkvNDLgpedis9/L9/ywCS/87mniiVnod8KgyiPZvLl3ftuqaRYOWgIE\nG6Y3064BLO+9B4DBkmNN/Vs4N7H2lnX5DBvUBdzZ67wTKYrbBJsnLWgcxhbw\nsfLNnmzJ3wE+2t9tLH0V77jy664H/fthCKA0txjEMU7T/KOlmPPkdOTixVlE\n6JKA\r\n=YPUr\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEQCIDal6Fy3HVcwtvXsRfBz22GPLTkFBtfUHCEx3nikOTn0AiA3IgBuz52qxM39xncbWpcyxY28vERySnELoWTKw9RICg=="
          }
        ]
      },
      "maintainers": [
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.71.1_1597281799729_0.32372673482806946"
      },
      "_hasShrinkwrap": false
    },
    "0.71.2": {
      "name": "ts-json-schema-generator",
      "version": "0.71.2",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=6.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.5",
        "commander": "~6.0.0",
        "glob": "~7.1.6",
        "json-stable-stringify": "^1.0.1",
        "typescript": "~4.0.2"
      },
      "devDependencies": {
        "@types/glob": "^7.1.3",
        "@types/jest": "^26.0.10",
        "@types/json-stable-stringify": "^1.0.32",
        "@types/node": "^14.6.0",
        "@typescript-eslint/eslint-plugin": "^3.9.1",
        "@typescript-eslint/parser": "^3.9.1",
        "ajv": "~6.12.4",
        "chai": "~4.2.0",
        "eslint": "^7.7.0",
        "eslint-config-prettier": "^6.11.0",
        "eslint-plugin-prettier": "^3.1.4",
        "jest": "^26.4.1",
        "jest-junit": "^11.1.0",
        "prettier": "^2.0.5",
        "source-map-support": "~0.5.19",
        "ts-jest": "^26.2.0",
        "ts-node": "^8.10.2"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint '{src,test,factory}/**/*.ts'",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "FAST_TEST=1 jest test/ --verbose",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts"
      },
      "jest": {
        "transform": {
          "^.+\\.tsx?$": "ts-jest"
        },
        "testRegex": "(/__tests__/.*|(\\.|/)(test|spec))\\.(jsx?|tsx?)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "jsx",
          "json",
          "node"
        ],
        "testPathIgnorePatterns": [
          "node_modules",
          "test-runtime",
          "<rootDir>/build",
          "_site",
          "src",
          "dist"
        ],
        "coverageReporters": [
          "html",
          "cobertura"
        ],
        "coverageDirectory": "./coverage/",
        "collectCoverage": false,
        "testEnvironment": "node"
      },
      "gitHead": "24c1b9c66978b9b741a94330fc7e2df2f1a0a0b6",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.71.2",
      "_nodeVersion": "10.22.0",
      "_npmVersion": "6.14.6",
      "dist": {
        "integrity": "sha512-114F6jd8m9o3QOQoNe2ejbNkUabXgxVY7vCxWXlPpFPUKCr+YVGIhBiatIsgRP7jfreo/Ibo38t4XhJEMn+7SQ==",
        "shasum": "91303569da1334139ce96a2dc4af5b83c828070c",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.71.2.tgz",
        "fileCount": 449,
        "unpackedSize": 738290,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJfPrSJCRA9TVsSAnZWagAAkTEP/RvCEh1IcK3+2KLEDe7d\nLbiTi4nPvTdK7XG6yPrmRneshnf2PqbO+QhZv1BTvh1F9+eb6PtPsrSRQPuq\nm35fRQWcFEjPhCjkaTj4AN4UcCPeB4ydR5OQPcH47qW48b2hwxP4EXKCU4jS\nnqCpAD5xQg+8WNlYFS8z8dpFE+Nf80memRW/yg0v9U5biKkSirNaD/b8sJRY\neLS0d0niGeisW95ci+sl6tKBraIfm6l7eWjutLe7HL5FZ6W4m3Bq7oi5aHcs\nmS0KEgxWY3mHQfSJNVgYIfvYBRJAYiqLEUqUE2h9aTEFTCu2TS6hAYuvmvDn\n7jBX758VR5aGi8Qao7P3DqwmW/ZGLGzrSvGzUE6FZXPMguZcoXcpQKZcqCMT\ngaxT1uWAPe6Ixl6qZLp9jyH+LL00eb+jHuCsgUlAqIbhAowj9KRHgpmIBkq3\nHYTuP5gUrmRebeG0qTuZDSX6AlBVPljfo2ckIwJXe2e+rh2W6PTHwBGCHnAB\ngKEHPYFAeID4qdUpRzIwUV127P5VPGNQNImLTi9N0SNes8f5yyP8quUq7jZ8\n+qd13AnQkzLMZya2APMGuALshWVxl/ac5mElASoVLmpfW1pxJY6EyKvqLX97\n8MVDLE1aY/xFhffYkFUoZ28euFFeXDJZtuNvCQTUMTSG+0o3VoAIAWlVXi4s\n8oww\r\n=EBv5\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEQCIGnEGPpjUa2Vvd0N7FbjO1O7mAtkimlccJKJZnb2K5HuAiA599w+awZctTR0dzxYtOyQf5hnygonPY4upVLVq2Q5rQ=="
          }
        ]
      },
      "maintainers": [
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.71.2_1597944968611_0.9279630907197816"
      },
      "_hasShrinkwrap": false
    },
    "0.72.0": {
      "name": "ts-json-schema-generator",
      "version": "0.72.0",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=6.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.5",
        "commander": "~6.0.0",
        "glob": "~7.1.6",
        "json-stable-stringify": "^1.0.1",
        "typescript": "~4.0.2"
      },
      "devDependencies": {
        "@types/glob": "^7.1.3",
        "@types/jest": "^26.0.10",
        "@types/json-stable-stringify": "^1.0.32",
        "@types/node": "^14.6.0",
        "@typescript-eslint/eslint-plugin": "^3.9.1",
        "@typescript-eslint/parser": "^3.9.1",
        "ajv": "~6.12.4",
        "chai": "~4.2.0",
        "eslint": "^7.7.0",
        "eslint-config-prettier": "^6.11.0",
        "eslint-plugin-prettier": "^3.1.4",
        "jest": "^26.4.2",
        "jest-junit": "^11.1.0",
        "prettier": "^2.0.5",
        "source-map-support": "~0.5.19",
        "ts-jest": "^26.2.0",
        "ts-node": "^9.0.0"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint '{src,test,factory}/**/*.ts'",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "FAST_TEST=1 jest test/ --verbose",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts"
      },
      "jest": {
        "transform": {
          "^.+\\.tsx?$": "ts-jest"
        },
        "testRegex": "(/__tests__/.*|(\\.|/)(test|spec))\\.(jsx?|tsx?)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "jsx",
          "json",
          "node"
        ],
        "testPathIgnorePatterns": [
          "node_modules",
          "test-runtime",
          "<rootDir>/build",
          "_site",
          "src",
          "dist"
        ],
        "coverageReporters": [
          "html",
          "cobertura"
        ],
        "coverageDirectory": "./coverage/",
        "collectCoverage": false,
        "testEnvironment": "node"
      },
      "gitHead": "6f714eb28f691d4d85954628b1a11f023e71e5ef",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.72.0",
      "_nodeVersion": "10.22.0",
      "_npmVersion": "6.14.6",
      "dist": {
        "integrity": "sha512-/O2voMSB+Qexm8gvVTgoKZVkVg4LMQPZ0BDHufC94xRNRWhq1gzcWD3X+tOaDFKzs+xflMWzEn3hcQqYdIOACQ==",
        "shasum": "59cec0c72d98f32380261a4ff76a327b4353b3da",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.72.0.tgz",
        "fileCount": 449,
        "unpackedSize": 739391,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJfQVwXCRA9TVsSAnZWagAArs0P/iJ7XOOfM32xEDiHaLzH\nvQFqzK+5Sf2anfqHzcxjOIfN06f4tQ56DUYn3tGVaqXreWeyXOlYFH+WCG3E\njmikAkcXM71tUHXkc3HDN1eup9H/8XsNRhjziTsQsQAfHcLPz+fH5PwOWLCC\n1mmAu/yDgmI9IcxI8B38MDXxP5Iwu2ucLU0wMy6WusiMQqHQsVQwgqovyS1G\nuSbo8p8PSIlNS7hL3PwFzLSgC8zs/tzbZ2xgP5ElDJqb/5am2zFJB5jOrGHN\nqEwBIO1CnWYtxKmvY16R9YAKGlfuhqHfKnP4EPuchmOE+EcPauuPJTEpYqO+\nmkr8/FBOoLM9T1pYgoYmtQlIZV8OO/USoPo6gUDjUv6CmSjAy9KRDt285ZtG\n4ceuX2B3YAbGbITPH4pgqD3a7Fgnz92G02WH2cHMYJenfGfGAQ1AB/Q92LsD\nmuErZtvIuzPx6sOIzqF+cDWZzAj3ZSFlFSZ4wWGcqXNyfTF+7u0/I2mACWbG\nTHNceE86DGvJUsYUX414jLxiVqJWYBrErJLXvK3aJ+3R2wqfT3HVvwb3qbiE\nguPRk59OwscdJSffNGUx/GxgCLVZ5muM+qcVp3rKtvuaw0SNQwsJoYcSLFFD\nXOXTvQowZE+d0wpJMszy62t/jNDmRu/6bwiYxkAohtwJryiJ39oPWFmsl0KS\nw3d3\r\n=Bo8y\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIQC/FILRJ4njSOujfaCpVcGjvfdPTGU6Uo+mkIuiPG5tFgIgMq7pWV7Ow6623s1FU56nJx5bDft+iLj0UnctmNgqo20="
          }
        ]
      },
      "maintainers": [
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.72.0_1598118935395_0.2424145237366666"
      },
      "_hasShrinkwrap": false
    },
    "0.72.1": {
      "name": "ts-json-schema-generator",
      "version": "0.72.1",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=6.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.5",
        "commander": "~6.0.0",
        "glob": "~7.1.6",
        "json-stable-stringify": "^1.0.1",
        "typescript": "~4.0.2"
      },
      "devDependencies": {
        "@types/glob": "^7.1.3",
        "@types/jest": "^26.0.10",
        "@types/json-stable-stringify": "^1.0.32",
        "@types/node": "^14.6.0",
        "@typescript-eslint/eslint-plugin": "^3.9.1",
        "@typescript-eslint/parser": "^3.9.1",
        "ajv": "~6.12.4",
        "chai": "~4.2.0",
        "eslint": "^7.7.0",
        "eslint-config-prettier": "^6.11.0",
        "eslint-plugin-prettier": "^3.1.4",
        "jest": "^26.4.2",
        "jest-junit": "^11.1.0",
        "prettier": "^2.0.5",
        "source-map-support": "~0.5.19",
        "ts-jest": "^26.2.0",
        "ts-node": "^9.0.0"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint '{src,test,factory}/**/*.ts'",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "FAST_TEST=1 jest test/ --verbose",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts"
      },
      "jest": {
        "transform": {
          "^.+\\.tsx?$": "ts-jest"
        },
        "testRegex": "(/__tests__/.*|(\\.|/)(test|spec))\\.(jsx?|tsx?)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "jsx",
          "json",
          "node"
        ],
        "testPathIgnorePatterns": [
          "node_modules",
          "test-runtime",
          "<rootDir>/build",
          "_site",
          "src",
          "dist"
        ],
        "coverageReporters": [
          "html",
          "cobertura"
        ],
        "coverageDirectory": "./coverage/",
        "collectCoverage": false,
        "testEnvironment": "node"
      },
      "gitHead": "aac44747f8bd7191226a65dba94f6471608c1f6a",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.72.1",
      "_nodeVersion": "10.22.0",
      "_npmVersion": "6.14.6",
      "dist": {
        "integrity": "sha512-mE88MjQ1HuSP4V4IQZf8jqDoNJa03cnlmycgCWmLdCOBe/a6rSrW57fKl9AAC9dtrXYXR7h56qonYJ/LaocR3w==",
        "shasum": "ea0e534257963bea8977be23e046f330b3489adc",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.72.1.tgz",
        "fileCount": 449,
        "unpackedSize": 739391,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJfQVxQCRA9TVsSAnZWagAATSgQAJQSi733AY8Fb7MTuE2k\nVwf8KPVKUcB9D/h4nejUrezPIS6TXW8alX+iy42yuitFdEvyIhITjsIkry8c\nMXKp+KzW7zCGkaaoIaF4ltBp1GTcL8shS+XdB+3KxesfM8mzruRIhjCJyhKf\n7bz+vmJlCQ+cU+sa0K2NO/ULCy2MVqy4HapDQCHonjDR02v2xIik7mRTL6ym\neVPVlcYvp+jOOiSkRt84kkO4PJVAl8sONtpp/vGXaE6kI9SxuA8EIxDNhUPL\nhWsLWmTiWO5g4XvhQQ/laqoUY6GaoZ/YFSvBguMT97BVcs2kn7HrBM5jV+Bs\nfZeYIHKc42WBC7TdP7hxYQwQHiBsniL2kV7MJ7gXu1g0c7bIVuRa3ggbTQA4\nVLcG+VPa23wsikeB+ywAKYomcpgzcnnx5PzumqOgR+iKSXWJPNXWTKkUXlLP\nWcBsl25UmRnt2OP3C/CQDoxRNM6FUKqnwTRwrhrk8PBm7ebeTGqofrFIX7Ne\nt4g8aFz6Ut7P+wufE70JmS0b7dF55KXvmjsIiXtf+ZC505BflgWleczuii+K\nJgI2BwBKAwibSDbNxdfFhOw89CKXLgRoeJ0m2zZUKmqVwPB45YNLDsB/h6DI\n4123oyNen/uYzIlmf399DD550VaY356lrCVv7itHEXCiFomj9NROfX3nI7SB\n7nOE\r\n=UAya\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIQCo24X42B0thXFdRrBOaVtZmTtoZRXhN2PrNG81M/yJwAIgJxrahHaiGDZg6rOZi4uXlYTndzDkNjgNARM9hv9IDfI="
          }
        ]
      },
      "maintainers": [
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.72.1_1598118992403_0.9690062881742627"
      },
      "_hasShrinkwrap": false
    },
    "0.73.0": {
      "name": "ts-json-schema-generator",
      "version": "0.73.0",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=6.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.6",
        "commander": "~6.1.0",
        "glob": "~7.1.6",
        "json-stable-stringify": "^1.0.1",
        "typescript": "~4.0.2"
      },
      "devDependencies": {
        "@types/glob": "^7.1.3",
        "@types/jest": "^26.0.12",
        "@types/json-stable-stringify": "^1.0.32",
        "@types/node": "^14.6.2",
        "@typescript-eslint/eslint-plugin": "^4.0.1",
        "@typescript-eslint/parser": "^4.0.1",
        "ajv": "~6.12.4",
        "chai": "~4.2.0",
        "eslint": "^7.8.1",
        "eslint-config-prettier": "^6.11.0",
        "eslint-plugin-prettier": "^3.1.4",
        "jest": "^26.4.2",
        "jest-junit": "^11.1.0",
        "prettier": "^2.1.1",
        "source-map-support": "~0.5.19",
        "ts-jest": "^26.3.0",
        "ts-node": "^9.0.0"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint '{src,test,factory}/**/*.ts'",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "FAST_TEST=1 jest test/ --verbose",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts"
      },
      "jest": {
        "transform": {
          "^.+\\.tsx?$": "ts-jest"
        },
        "testRegex": "(/__tests__/.*|(\\.|/)(test|spec))\\.(jsx?|tsx?)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "jsx",
          "json",
          "node"
        ],
        "testPathIgnorePatterns": [
          "node_modules",
          "test-runtime",
          "<rootDir>/build",
          "_site",
          "src",
          "dist"
        ],
        "coverageReporters": [
          "html",
          "cobertura"
        ],
        "coverageDirectory": "./coverage/",
        "collectCoverage": false,
        "testEnvironment": "node"
      },
      "gitHead": "b83873c6145d54e814651038c806619dfa225ea9",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.73.0",
      "_nodeVersion": "10.22.0",
      "_npmVersion": "6.14.6",
      "dist": {
        "integrity": "sha512-qcKsEfEuA2FTOUmrjGangKlKhJww9OOKGeqgz9e/xT/F0iI2sV4VZaahd53Dk4rnzhc0NzfYTQEu8h8NAEleJg==",
        "shasum": "5767330e8287b87ee2e3cd71bfbb6b4e5f10a19b",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.73.0.tgz",
        "fileCount": 449,
        "unpackedSize": 738087,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJfTsKDCRA9TVsSAnZWagAA5RsP/RNKLznpT+AtJD5DXvqi\nJeyG1V37c0Vlc2oM0KE3NbChIGBrk40YLaCUdGPeLsO1fyGDRQZ9X0l/A+dN\nuqmaicL4FSot/OWIt5OeJBZcS95AbV21FIO2sUlwwUsgt0uy1p3PZNCnkfoy\nPUusWwgRaTlliraVMvlMdml18GF1/mB/ckYZijxFabU6PlFYzEHGSTRBjwiC\n2VUZPSryq07YDiLvhQz8764eRIgWXlrguVJjgZMN2j6tp1hu1OleARXPt2RS\nQRskBnFwBrtVpXeM1/9W0i+ORo5g9Pvlg6vS/Yn34agpcOnWfn5JrC01x6Hr\neuTiX26Z6sZwFySb+J4WpL2+qUDtviiGoowhwOLxwhtq1YB992Cj3BtrdZp4\nA9n3Y6YMTZjJEa6OAiilG+f+upGXuDyQtIGXFeAdbtstA/B4XJICwu9kzC47\nJVTyARhJ0pd+qhb73reuEFsVPxHp/19uzWG/ZEdqsKB2M69CZhDDZ7xTnV+1\nbYCvG9mi8o3JsaD15pT2qYXYyL2XqF6d5NrhVX8J2SZFIpfKj+EKVB/G2py9\nKeeNLG6qzNP6AmKFdj7sCUpNg/Ff3gZ8+joOijq3ba7jqUDTmTbWLMRwAXdd\naKwpKBHO0sd42z/tVxN6IDcGeiJj5f3sVyFaj1pjH/iDDgFGjJ56orp7R3nT\nB8/b\r\n=ivY0\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIQCk3eDWGRmgdyRVJMmJG4Pzj845iJ6VXsvPUA7zSDm6CAIgCoRZ2hwV75bOJBURyldQucblxtbpUgray7+QP5ZqZsQ="
          }
        ]
      },
      "maintainers": [
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.73.0_1598997122707_0.6873853988086336"
      },
      "_hasShrinkwrap": false
    },
    "0.74.0": {
      "name": "ts-json-schema-generator",
      "version": "0.74.0",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=6.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.6",
        "commander": "~6.1.0",
        "glob": "~7.1.6",
        "json-stable-stringify": "^1.0.1",
        "typescript": "~4.0.3"
      },
      "devDependencies": {
        "@types/glob": "^7.1.3",
        "@types/jest": "^26.0.14",
        "@types/json-stable-stringify": "^1.0.32",
        "@types/node": "^14.11.1",
        "@typescript-eslint/eslint-plugin": "^4.1.1",
        "@typescript-eslint/parser": "^4.1.1",
        "ajv": "~6.12.5",
        "chai": "~4.2.0",
        "eslint": "^7.9.0",
        "eslint-config-prettier": "^6.11.0",
        "eslint-plugin-prettier": "^3.1.4",
        "jest": "^26.4.2",
        "jest-junit": "^11.1.0",
        "prettier": "^2.1.2",
        "source-map-support": "~0.5.19",
        "ts-jest": "^26.3.0",
        "ts-node": "^9.0.0"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint '{src,test,factory}/**/*.ts'",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "FAST_TEST=1 jest test/ --verbose",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts"
      },
      "jest": {
        "transform": {
          "^.+\\.tsx?$": "ts-jest"
        },
        "testRegex": "(/__tests__/.*|(\\.|/)(test|spec))\\.(jsx?|tsx?)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "jsx",
          "json",
          "node"
        ],
        "testPathIgnorePatterns": [
          "node_modules",
          "test-runtime",
          "<rootDir>/build",
          "_site",
          "src",
          "dist"
        ],
        "coverageReporters": [
          "html",
          "cobertura"
        ],
        "coverageDirectory": "./coverage/",
        "collectCoverage": false,
        "testEnvironment": "node"
      },
      "gitHead": "f9cfcce2451c5dbf3e4a90df1f292c7b44faec50",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.74.0",
      "_nodeVersion": "10.22.0",
      "_npmVersion": "6.14.6",
      "dist": {
        "integrity": "sha512-B85sggBl7aKpV0ZWF/IffDPLYaNBFGNosFy+xyoonL+mBM/ZLoOpkinGWKFb+DbcDkJzKtLcnZM3bVwCIsGrqA==",
        "shasum": "172788878aa37086a0680ae12936a3e7d80f5250",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.74.0.tgz",
        "fileCount": 449,
        "unpackedSize": 587785,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJfZR18CRA9TVsSAnZWagAAxyYQAI4PHEiJADDVrlrbCKDf\nIWXw1hKbYf4iXWl9x5Op6zLNoSer0i37XFfS9HDXywMbvPj67cL0Su1Zpk16\nmPod0oo4/c/40XHm3SXJZhcSkdoqPYXDZsHb5yG9CDAAxFOoj4rVSSyag3aT\nkbYQWXVwsW4ARfhv5hXK2XgE8g56Z8zciVkaRASb7IB9AXDlySdvTgSSOy0D\ngTvr6y3QxsAxJkL1i8W/yonjeoAkqFoVovQo6Vw/pt+U7QkgK1fKUXEwodzv\npAwBkdXLOqhRnZ6jUShuSYd0fVRSjlvUh/sLHKEiuXPRrEgC/Ln1kAmSIr1X\ngmd9KnsISRkeXTRos8ymjcL1vkPyn+gOos2X4jdGuA24FX16pl132H5Yv6rr\nKiWoZ6Kipq7etZEHmG9ujb75zM0MAt+7Yxc9qgnri1G4tBwiIiih6Juj7XvA\nNmWmb+gqYwFgz3qb7s6ExORsIvFtEbw87sy9G0kLMBE4UikhgUjLCMXpZqXy\nW1fnSvXCZBuWdeK+mjluP2LX8UfRKxOaS/wTpIWya3iUkiLW0hZH5OwqYfKF\nRue4h3okQnwQpXw+gXx7WYwBKFvJ3jaD59rtcGAA016e4m2J266cuLFnG5gV\nHJeylAAegK64W81o1vpbQbprd1lSWcvd0jyahmgIxUruVhirgkiEqC5q3+Bs\nomUs\r\n=vJif\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEQCIB0S/n2zsI8/TuVCOfZkHBEkoI+clpPzA0R8pYfIF2QtAiB1LGSflcUVKHi+Npn84R0/9ZabTQEJU2Up4us132mURw=="
          }
        ]
      },
      "maintainers": [
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.74.0_1600462203664_0.7221179898363572"
      },
      "_hasShrinkwrap": false
    },
    "0.75.0": {
      "name": "ts-json-schema-generator",
      "version": "0.75.0",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=6.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.6",
        "commander": "~6.1.0",
        "glob": "~7.1.6",
        "json-stable-stringify": "^1.0.1",
        "typescript": "~4.0.3"
      },
      "devDependencies": {
        "@types/glob": "^7.1.3",
        "@types/jest": "^26.0.14",
        "@types/json-stable-stringify": "^1.0.32",
        "@types/node": "^14.11.2",
        "@typescript-eslint/eslint-plugin": "^4.3.0",
        "@typescript-eslint/parser": "^4.3.0",
        "ajv": "~6.12.5",
        "chai": "~4.2.0",
        "eslint": "^7.10.0",
        "eslint-config-prettier": "^6.12.0",
        "eslint-plugin-prettier": "^3.1.4",
        "jest": "^26.4.2",
        "jest-junit": "^11.1.0",
        "prettier": "^2.1.2",
        "source-map-support": "~0.5.19",
        "ts-jest": "^26.4.1",
        "ts-node": "^9.0.0"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint '{src,test,factory}/**/*.ts'",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "FAST_TEST=1 jest test/ --verbose",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts"
      },
      "jest": {
        "transform": {
          "^.+\\.tsx?$": "ts-jest"
        },
        "testRegex": "(/__tests__/.*|(\\.|/)(test|spec))\\.(jsx?|tsx?)$",
        "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "jsx",
          "json",
          "node"
        ],
        "testPathIgnorePatterns": [
          "node_modules",
          "test-runtime",
          "<rootDir>/build",
          "_site",
          "src",
          "dist"
        ],
        "coverageReporters": [
          "html",
          "cobertura"
        ],
        "coverageDirectory": "./coverage/",
        "collectCoverage": false,
        "testEnvironment": "node"
      },
      "gitHead": "26b37acfe320fcf4c70f446cf2b0e1c3f8909d4d",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.75.0",
      "_nodeVersion": "10.22.1",
      "_npmVersion": "6.14.6",
      "dist": {
        "integrity": "sha512-TKsk/NAxK+44Tr3k1ldg1Fx1VhNVbHbmp0So9eXm7j7cGAtrLw5LlQYBHQIfj0eIT+RQxuuPFFpNyD7X2rm29w==",
        "shasum": "c52932548654620e77940346631b4a238e9c0438",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.75.0.tgz",
        "fileCount": 452,
        "unpackedSize": 587778,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJfd2FfCRA9TVsSAnZWagAAYSMP/0uDa6X3myd8L35F959H\nHgqN6dfiO3zwI90FRGRTl72vdBiV8hqUfvvtk6nzUpGB9KKL+ia+G6a/IfVK\nZU7CXzdtndD4AQ1ZitYQ7gLjfdLgMSTi1yHGZOC6JqXCejtWSbO1dAVwjwUr\nZp1j8y1G8nYwTZfD6I6bLSrYanVTg9wpGmSYOB2pS3c9Zz9hHmcOTOcn4irC\nGcX+AEnZ+Ut2G72FWT5I6q0f0XXDPlyxHFItYgmQNLiQfI04J2m25nF1/KWR\nu6T/m4rU+GIvBswt598YTQpWf+/5ObyjrD5KunDDEtn9jYWko2++9CC3vnDk\n14klWqAprkQKxdb4Xe5Rccizuh/ey2oD6wn3Zl6cd6cZYu/1j7ydVcmxtgLT\nLn8DKNtsAWsiN+urlvCfqRGD04Y7pHOxOwwWROdiWkgpE67NoyCnZFczjCuN\nf+eunRd0E1gDA+LKSJdQwkIyI2pZNkT3xpHVfOpEOEzyIIpxRPsc2fK2yebz\nH2bQehV9UqyczCbbSa3yYNHMvUo7qlKUzFw0TT87wUODuZn2pizGbNLfFc46\nFlsZDx1y6zbtiJSM7WB0vXJkRGUA0ALuFSlL9cOzFCJZAz6LXAnSlMU/5n2y\nq5BXO5u3XOKyr4GHAbWDqbwHJsjtowxpMSLgDhZWc+vQ35O+t5SJlGWkxltr\ntpBY\r\n=Lmay\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEQCIAVK8fUlqfRJwmn4/fgwgvyYgkKiNGIqsCmCQUstX+3vAiAhbbQWuujvY3bt3Zwfqvbg4yCdErR50bFio9qJafzeAA=="
          }
        ]
      },
      "maintainers": [
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.75.0_1601659231172_0.39132754928468283"
      },
      "_hasShrinkwrap": false
    },
    "0.76.0": {
      "name": "ts-json-schema-generator",
      "version": "0.76.0",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "MooYeol Prescott Lee",
          "email": "mooyoul@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=10.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.6",
        "commander": "^6.1.0",
        "fast-json-stable-stringify": "^2.1.0",
        "glob": "^7.1.6",
        "json-stable-stringify": "^1.0.1",
        "typescript": "~4.0.3"
      },
      "devDependencies": {
        "@babel/core": "^7.11.6",
        "@babel/preset-env": "^7.11.5",
        "@babel/preset-typescript": "^7.10.4",
        "@types/fast-json-stable-stringify": "^2.0.0",
        "@types/glob": "^7.1.3",
        "@types/jest": "^26.0.14",
        "@types/json-stable-stringify": "^1.0.32",
        "@types/node": "^14.11.8",
        "@typescript-eslint/eslint-plugin": "^4.4.0",
        "@typescript-eslint/parser": "^4.4.0",
        "ajv": "~6.12.5",
        "chai": "~4.2.0",
        "eslint": "^7.11.0",
        "eslint-config-prettier": "^6.12.0",
        "eslint-plugin-prettier": "^3.1.4",
        "jest": "^26.5.2",
        "jest-junit": "^12.0.0",
        "prettier": "^2.1.2",
        "ts-node": "^9.0.0"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint '{src,test,factory}/**/*.ts'",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "FAST_TEST=1 jest test/ --verbose",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts"
      },
      "gitHead": "76b13bb916047e9be7c8af9721ec5b3146df041f",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.76.0",
      "_nodeVersion": "10.22.1",
      "_npmVersion": "6.14.6",
      "dist": {
        "integrity": "sha512-siwDA3janPf+tblrIFpSVV8yF+XAqni9VMvfmaRGH09Csha1kk4bOZpXG43mnblmwItzjZ1HJpT3wcQv2jHTIw==",
        "shasum": "39f7861536a0343d635cd8b8da59bda3d7725d13",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.76.0.tgz",
        "fileCount": 147,
        "unpackedSize": 192277,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJfgTmaCRA9TVsSAnZWagAA/boQAIcHNDxmS6JFqQhH5NHF\n3TV0YuTN8aGPHEf/7SbYZJkuEKBlf+5qIX+4AvT6YqrBHpuTwpJcRJzo0osa\nO6cluDPmWWvvSbkRkMxZ393Ocor3IDYsw6uFBJaYC4rechaz4ftONW9WpNVr\nuhu26wA25mCcI4rUiP+zxbSiZ4UdGboTYqi5nmgr5Hv6IbitSapydqJdfuoH\n3TtPcmSLdaPZguf5AyLTfsxIWizuXEnxbPEGYd7xlpRhLjQPulYiYBXpuPXb\nWQqJFF0liDqzWnAEgP9I+Y+eJZKwUzFGGf11sBoGW3c6sai2ZjELj4ravw7K\nneksdaRRy9BQtm2noM+Db4WE4Ik5iuQ2dIsM4B+ksn2nxyRzfp3v7LzXX+vy\nrdg2BQ9J+TcdGQSlEjGlTBcPw/6wxjelW7pJUrutRsnecXTXTSzxHxNlYaPs\nC7SG8pg6p6KRjzoGM0poVu7D56mkHGnsds6nYuAAjqUJAgHVzHEH6zsHdUBs\nOf0z+PjhC8StBbKRlRwSH1Wyztob6R+a4AwHCT0nWYkGtCJRlv3NoFxkAJfV\nnSDLUnUxp36tmw9pd4q6lfWtE8iwIUJDHHfwVdQH2Sup9LruuwyX28yn4NOw\n3gBE9JArjs7nBiDmtdNViZr1S1yF/MaNBZAZArp2AbkMrQBwJwffmBn+PxY2\nUunE\r\n=myXR\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEYCIQD2xdPFYJAwFRc9NyE25nrRX9b44nM4miuRaQKOEVhFuAIhANekbuGrYq/jBbp1EcO0XgMENblqdOlEhple+Vl4rdLS"
          }
        ]
      },
      "maintainers": [
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.76.0_1602304410353_0.5597785492508405"
      },
      "_hasShrinkwrap": false
    },
    "0.76.1": {
      "name": "ts-json-schema-generator",
      "version": "0.76.1",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "MooYeol Prescott Lee",
          "email": "mooyoul@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=10.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.6",
        "commander": "^6.1.0",
        "fast-json-stable-stringify": "^2.1.0",
        "glob": "^7.1.6",
        "json-stable-stringify": "^1.0.1",
        "typescript": "~4.0.3"
      },
      "devDependencies": {
        "@babel/core": "^7.11.6",
        "@babel/preset-env": "^7.11.5",
        "@babel/preset-typescript": "^7.10.4",
        "@types/fast-json-stable-stringify": "^2.0.0",
        "@types/glob": "^7.1.3",
        "@types/jest": "^26.0.14",
        "@types/json-stable-stringify": "^1.0.32",
        "@types/node": "^14.11.8",
        "@typescript-eslint/eslint-plugin": "^4.4.0",
        "@typescript-eslint/parser": "^4.4.0",
        "ajv": "~6.12.5",
        "chai": "~4.2.0",
        "eslint": "^7.11.0",
        "eslint-config-prettier": "^6.12.0",
        "eslint-plugin-prettier": "^3.1.4",
        "jest": "^26.5.2",
        "jest-junit": "^12.0.0",
        "prettier": "^2.1.2",
        "ts-node": "^9.0.0"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint '{src,test,factory}/**/*.ts'",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "FAST_TEST=1 jest test/ --verbose",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts"
      },
      "gitHead": "43dae4172df52fd234cd10601ab09b1969699428",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.76.1",
      "_nodeVersion": "10.22.1",
      "_npmVersion": "6.14.6",
      "dist": {
        "integrity": "sha512-EfO0eN4+OvvcqWzRxw6KzSMjST7bwOOQKk3BYMccw+TnpEhSId285K34Ahwy67H8YpuZ+Ut3PWszgwxwwLcydA==",
        "shasum": "04c8b8202eb744607630dc810af095f62c8cf840",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.76.1.tgz",
        "fileCount": 597,
        "unpackedSize": 784391,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJfgdKYCRA9TVsSAnZWagAAT2EQAJrqU14z9sXcdfxZMNfV\nTih9osFSusduz8oG2mj2w/nO4StFlK+b7dGslH/THQ2WZRGKxk5PYPW1Bp+u\n7VuGrTFTVIERF+9uiBkrkjuVAfAhoKqYO2BfgTgc9LmUh/meU/uY2r1R7hL9\nxsxzKOXgVdqZqEzov6lmSb+9e8H/f60RxPn9vOsVgYTXYvnvCRwHhnHfGiwN\nJndlPtdwR0uYbTdb37WXsum/dCbAKXn/G/gp5bycGswxMNdD91zGlVKqb77g\nhFOOTN3pP8ENHluTLxrJBCAQ356wcX71CaHx3MZ9eGwS1JZuVF2vY48NFROo\nmzVS9mQLjyK46rFEB6HpQ0IJx7ldJ5/gksntUMkJ0AnEnlDKsYgwRCqCe0In\nEAOfnHRzvmQCJt46YTYK6ogZ276Vem2IkYXoE2Bvu8C7mxs9MvYnbua7kIej\njyR4zfgAbRO8Kjzdh7pv7czzv+1pGyBup9mZlFX0FvdTFUJePVTDyTR/SBRw\n9gy9lhTnGhe6qH6zlDFz7Iip7yOshCuR0DdbqUXxtBd34J/q98kaAbJsA4ZI\nlytXB6yHaK0DGSPzI98shCyLTf+lOOlf/LnS3HCdJ3XC8w6642COsDfPdiJY\n9auDy8u0J7AGK1Gl+ziHjbb+Yy+aq7zAY/f78TaoxEnyZxqjRiT37+tUJ2eD\nQE8f\r\n=ob3s\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIQDsyCXCfXjnoy/6ayjuRL+LUJfclaPCLVd71rgXW1oXDgIgNGOJvWvtNQ8Ab3K87S8An7rmR8kC7hoqu7MXGg/s8wM="
          }
        ]
      },
      "maintainers": [
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.76.1_1602343575365_0.8914455461581785"
      },
      "_hasShrinkwrap": false
    },
    "0.77.0": {
      "name": "ts-json-schema-generator",
      "version": "0.77.0",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "MooYeol Prescott Lee",
          "email": "mooyoul@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=10.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.6",
        "commander": "^6.1.0",
        "fast-json-stable-stringify": "^2.1.0",
        "glob": "^7.1.6",
        "json-stable-stringify": "^1.0.1",
        "typescript": "~4.0.3"
      },
      "devDependencies": {
        "@babel/core": "^7.12.3",
        "@babel/preset-env": "^7.12.1",
        "@babel/preset-typescript": "^7.12.1",
        "@types/fast-json-stable-stringify": "^2.0.0",
        "@types/glob": "^7.1.3",
        "@types/jest": "^26.0.14",
        "@types/json-stable-stringify": "^1.0.32",
        "@types/node": "^14.11.10",
        "@typescript-eslint/eslint-plugin": "^4.4.1",
        "@typescript-eslint/parser": "^4.4.1",
        "ajv": "~6.12.6",
        "chai": "~4.2.0",
        "eslint": "^7.11.0",
        "eslint-config-prettier": "^6.13.0",
        "eslint-plugin-prettier": "^3.1.4",
        "jest": "^26.5.3",
        "jest-junit": "^12.0.0",
        "prettier": "^2.1.2",
        "ts-node": "^9.0.0"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint '{src,test,factory}/**/*.ts'",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "FAST_TEST=1 jest test/ --verbose",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts"
      },
      "gitHead": "cc337d81ee0eef61dcd135056fc1a5de12b5ebf0",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.77.0",
      "_nodeVersion": "10.22.1",
      "_npmVersion": "6.14.6",
      "dist": {
        "integrity": "sha512-cM+9NfO/jFVEQNLog1XAYmBk9k5fRwTqP7rp1c2IMBREuOjIpiSkgv3/QjoH89UXhh8Ik6Wc8FT0mg7wssazcw==",
        "shasum": "6b7f659ecda9a2be05babfef97ce2633364e3357",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.77.0.tgz",
        "fileCount": 597,
        "unpackedSize": 786948,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJfjPi3CRA9TVsSAnZWagAAHpIQAJWZUCZyqcA1InwkC90p\nOqNL4JdRDT8S20DCv328yvpQKESNjCVBAhid2HoCgcNb4hm8ljb7FG9lRlPx\nomiCV+I1zTDqeAJ4PFWwJ7bAvzXiMSFWFcnBKPmWr7vg5XknESfkYXnlkJ9b\nmMlZmSg0Jz0m2K6MNY250mJLQIBzpTUVJ9v3bg/bEInXWlfbZl/X6w4H1VCR\nGXgs45ro2gts1YbO3+cWXa1DPngVNcjGKp/2l31Tpu5Qlk2EyADTOZrxeH/J\nHkwOM7o9gNzfkqLceRWpikkGNO7RPLcAuhNuxRVV1BN87ZcNrOSuMTDsBWfs\nDaluuBk7Hl9NAJmpvu5el+1rX8+20VpxyPl9F42GbAmbNsXEgcCMvckGgM1u\nfpjnjs/g1fRfaDyBImxrJ8RG2n+bibsXRCXjD5R78kon/8/iRuhso7XOQOTn\nA6JSV5bgX3QxxAJaBCaWUp0VPjMw24jUdKVdgKyIkwR7Mk8/dWAzcE4S2x2m\njge+pRMpB2/RvUzy5S4nanmHOe2+H4P41hKNvFWON1beaOy5B0SmOclEgoJz\nEsWqsHpP8+/tG6bx5k63QanTH/5L9JPnawbMCoggTDwHJ8YHizXkz+wo++qu\nfCPCqOXP4B9qM4N6IDcA6TH7nO9hPiZffpCg19hw++bMZrkIHIpVu8F587Lf\n2W9U\r\n=O6T5\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEYCIQDdXOm5Vl3hUD6HW5LnOeLzfQCOtaReknlrvChq0GHyBwIhANT5iKTQivbzuFBJXPfrYpQNeO3h9bbOvlpl4hLogArQ"
          }
        ]
      },
      "maintainers": [
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.77.0_1603074230594_0.8592649894691673"
      },
      "_hasShrinkwrap": false
    },
    "0.78.0": {
      "name": "ts-json-schema-generator",
      "version": "0.78.0",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "MooYeol Prescott Lee",
          "email": "mooyoul@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=10.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.6",
        "commander": "^6.2.0",
        "fast-json-stable-stringify": "^2.1.0",
        "glob": "^7.1.6",
        "json-stable-stringify": "^1.0.1",
        "typescript": "~4.0.5"
      },
      "devDependencies": {
        "@babel/core": "^7.12.3",
        "@babel/preset-env": "^7.12.1",
        "@babel/preset-typescript": "^7.12.1",
        "@types/fast-json-stable-stringify": "^2.0.0",
        "@types/glob": "^7.1.3",
        "@types/jest": "^26.0.15",
        "@types/json-stable-stringify": "^1.0.32",
        "@types/node": "^14.14.7",
        "@typescript-eslint/eslint-plugin": "^4.7.0",
        "@typescript-eslint/parser": "^4.7.0",
        "ajv": "~6.12.6",
        "chai": "~4.2.0",
        "eslint": "^7.13.0",
        "eslint-config-prettier": "^6.15.0",
        "eslint-plugin-prettier": "^3.1.4",
        "jest": "^26.6.3",
        "jest-junit": "^12.0.0",
        "prettier": "^2.1.2",
        "ts-node": "^9.0.0"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint '{src,test,factory}/**/*.ts'",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "FAST_TEST=1 jest test/ --verbose",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts"
      },
      "gitHead": "88b89080b4cb488ef0aa9e9cc6572026bbc49947",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.78.0",
      "_nodeVersion": "10.23.0",
      "_npmVersion": "6.14.8",
      "dist": {
        "integrity": "sha512-hJ0Z8qLKJ73Trs54O7IZsAj4eoyigL6W3Zm/tQr3YFRHvuyjQAhYvEq1Q2OAi8MO4RQJAOot2XdfL78nuQI0mQ==",
        "shasum": "784cb795e6f4eefd1d9ee0ed94c1a154cfd0b084",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.78.0.tgz",
        "fileCount": 601,
        "unpackedSize": 792295,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJfqsVECRA9TVsSAnZWagAAWSwP/3QMQYYQvKefeeIFCdxY\nLIaz0RqlFR5hTGrrwEY55DdXaQjvsdo53K9hLMFuH+5mlQhV3RMJiPkUgPeU\nm6FDzS5pKJSTtg9IsvkpZk+1kFHUc1BFQ5v/J184Yj6IqXLOyaVIf3W7wvFX\nxXkogi8uWuL7cQQFGGPS+6ZVrIImj7FXyZ53nPlk3J+wikz3zMmqGSoidy36\nHog91YBrgX7j8nZaf2Im6cEksTgIMI3YZcut71FX48c/EvXKMbFrP9GI4q30\nGEZcq4vlQ8CGn6TmTBGTnyGbQ9VgfBALdOMzO56EXD4sm6dd1v/nwEXlK1eZ\nI0tqdOeJFCG38A/ZfgJJ7r4a2IBTr0CDPvL8SS7iUElNYN2aCbjF7dGBBbSg\nRE5Rjg/ckS/K0w2gGLH5AYWYCQ4/UlUJXSLFQKyNpiA7IG1iBYteO3jFAESr\nB9b/eAEhDPLM5M2QeI6n9qOxSjd8XUg5yl0AL734vCB5u2GyKr26vJocFbx4\nI2jj3jYBRKgCFXH6gbHD2e4409QPxT4SBkpmExVFtAjAmvCbE9tNeDuCrCi9\npwKWsKnp69yTBRSyvMgQszLHvrUGDfBu9R3M0WxSW4325DGajH1hRv0qm9wS\ng0wos7TPSaw5/hVwt4M0XQt35sQgfFzDqAUQkjsA980ElIYe96uUVYt24Nxm\nyiDf\r\n=ZeXH\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIQDHjZiiKbf664UBdhAsowtOx1eaGU/at8tQlNwZzRh5PgIgI0VJvxNPqquZdPhmssXIDgrPEfKFfApQTVrMOuqqtWc="
          }
        ]
      },
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "maintainers": [
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.78.0_1605027140302_0.575839486128539"
      },
      "_hasShrinkwrap": false
    },
    "0.79.0": {
      "name": "ts-json-schema-generator",
      "version": "0.79.0",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "MooYeol Prescott Lee",
          "email": "mooyoul@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=10.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.6",
        "commander": "^6.2.0",
        "fast-json-stable-stringify": "^2.1.0",
        "glob": "^7.1.6",
        "json-stable-stringify": "^1.0.1"
      },
      "peerDependencies": {
        "typescript": "*"
      },
      "devDependencies": {
        "@babel/core": "^7.12.9",
        "@babel/preset-env": "^7.12.7",
        "@babel/preset-typescript": "^7.12.7",
        "@types/fast-json-stable-stringify": "^2.0.0",
        "@types/glob": "^7.1.3",
        "@types/jest": "^26.0.15",
        "@types/json-stable-stringify": "^1.0.32",
        "@types/node": "^14.14.10",
        "@typescript-eslint/eslint-plugin": "^4.8.2",
        "@typescript-eslint/parser": "^4.8.2",
        "ajv": "^6.12.6",
        "chai": "^4.2.0",
        "eslint": "^7.14.0",
        "eslint-config-prettier": "^6.15.0",
        "eslint-plugin-prettier": "^3.1.4",
        "jest": "^26.6.3",
        "jest-junit": "^12.0.0",
        "prettier": "^2.2.0",
        "ts-node": "^9.0.0",
        "typescript": "~4.1.2"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint '{src,test,factory}/**/*.ts'",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "FAST_TEST=1 jest test/ --verbose",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts"
      },
      "gitHead": "513acb9a806f0ca3a03f6037e724c47c31edf9e2",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.79.0",
      "_nodeVersion": "10.23.0",
      "_npmVersion": "6.14.8",
      "dist": {
        "integrity": "sha512-lODFOSy7lyY0xvFarxLfZZ+w45GZ8TG0OMjTCslGn+EKK69+WhNvl0ZEe5+5nT/gWe9Uo7Xfj9QmDmH4nh0U7Q==",
        "shasum": "9aaf1da4b042d9c7539d4e320a0858a9f1ca6f93",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.79.0.tgz",
        "fileCount": 601,
        "unpackedSize": 792419,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJfwAyECRA9TVsSAnZWagAA5YsP/37XRWAC7EdAmKagcELr\nv5CgRLpmEtFljcLCgxnNOd2EDF1W5GwS7o49E0l8I150pEMNRZ5Lt+wgJqEQ\n2QGcJa5f4LJFDxVc8pxayixOHbifirayXW3XjbL6GUo/RXi0g794+QJYUL+E\nUD1F+fQFJf8+ZUxjfH5hxdZ31xQRfV9mooo7xsTyCOdmFiV0m58gHAaNQzcY\nos5zJUhI+UA1tcLnMjDNS3hmYYPulhTVLeUqTvpn9pE3MlsyW1pbIugEjjL9\n7qoQn/zJOiSCsbVxAuv79OjpLN3gQloZzHScT/8/pILV/Y0cJKOL3VQOmXj1\nrOAXW++RzfwinLWflUqWoS4rfO+lN9coR/eanWRZzRJSXwbNrV+w8NBb4JDL\nAuuG2NYGvFmdxbEFWrkz0GD+7PlCPjGnzJs11xdfVr/zVNswft2r/2IS0uBf\n4hEEKZZo2v3C/+3FZCDaTO2PJ+SiK7zL52QE322+sis6u1ftAbnN/3QXIRgR\nT1YgTVmsAzlNZ6NGk8H5YjTfiImAknX7lqvAbtwpYAlJ+kB9eeTAtRfTQ47v\ntSQcTyeqgbyi+ux++sHXtwfHpouheGbHF29+BEAbVvq49KR755YE49v2fZNb\nfFafultGZlQU7bP79UYwEt6wSh1Vf0ujMQ8Le+aU+HO0Caw69OmTnUCEz1aA\n98Ur\r\n=CzRQ\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIAUqgHLHSe3Hy2ws2ra5itEhTUFM45S9S0/STXkMt72dAiEAvoWIgYRP8+J+Gs56I3+IzSfhZnlNQqMjVGrDBo4vE+c="
          }
        ]
      },
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "maintainers": [
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.79.0_1606421636196_0.1689689483613619"
      },
      "_hasShrinkwrap": false
    },
    "0.80.0": {
      "name": "ts-json-schema-generator",
      "version": "0.80.0",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "MooYeol Prescott Lee",
          "email": "mooyoul@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=10.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.6",
        "commander": "^6.2.0",
        "fast-json-stable-stringify": "^2.1.0",
        "glob": "^7.1.6",
        "json-stable-stringify": "^1.0.1",
        "typescript": "~4.1.2"
      },
      "devDependencies": {
        "@babel/core": "^7.12.9",
        "@babel/preset-env": "^7.12.7",
        "@babel/preset-typescript": "^7.12.7",
        "@types/fast-json-stable-stringify": "^2.0.0",
        "@types/glob": "^7.1.3",
        "@types/jest": "^26.0.15",
        "@types/json-stable-stringify": "^1.0.32",
        "@types/node": "^14.14.10",
        "@typescript-eslint/eslint-plugin": "^4.9.0",
        "@typescript-eslint/parser": "^4.9.0",
        "ajv": "^6.12.6",
        "chai": "^4.2.0",
        "eslint": "^7.14.0",
        "eslint-config-prettier": "^6.15.0",
        "eslint-plugin-prettier": "^3.1.4",
        "jest": "^26.6.3",
        "jest-junit": "^12.0.0",
        "prettier": "^2.2.1",
        "ts-node": "^9.0.0"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint '{src,test,factory}/**/*.ts'",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "FAST_TEST=1 jest test/ --verbose",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts"
      },
      "gitHead": "04593fd89a53bac9821c204f9ed87c9633e0efa9",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.80.0",
      "_nodeVersion": "10.23.0",
      "_npmVersion": "6.14.8",
      "dist": {
        "integrity": "sha512-NoHuSwTBlaRKGeDwprk/P5CCas1LnZbHnAo1Ff5LoPtySNzMO6M3citdBhwh4tBAcmQ/dNfQminvKzqlW+yXQw==",
        "shasum": "a106f93bab914199512ee2aa75caf903bb6a7245",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.80.0.tgz",
        "fileCount": 601,
        "unpackedSize": 792368,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJfxl2ZCRA9TVsSAnZWagAAA2kP/jeDt9Pbr5ZuNHce5hJT\nbAQirenI1H2h4BAvxtPF9FVGBszJXbSgUnBYJF19AYBygHxSipvhiXg09uiS\nDb3RDKvR4r0ibq5jernx/+uQHyjf09oWX2jjmTm8LkcZSDFf0jR0P/Kpg0bw\nkw3HjDwcZO+So6BMClZ7dvhOy1uAb/jwJGoc4j/37IPAdcMLUYrIKZH8gMXB\nwo8Ma9WgN8uSjAhfRj7FK+hEOwJ0atULoNfYK6y/tzBW8dmrQzpTyLEfGU0S\nKb45JQBQ0Lz0kNSANP24f/IWjK3LlkI+r/lgtPMNs8pzV0FBJGBdt35Hqm7V\npNw2+Istdqw8FpynCSFezMfoCva29d6V+oMuxEr+vP4OdHnznmtWOC2RwxNM\nPmNH8ASetPwFmNWD+l0ps1sSlyR8IM2jk7o88HynVgSd7/IZFKFGsoRDHhLM\nFRDMWKywBTngWYhv14xEXnBVLrma3wTfi7kO6Rxskyx/e/hfFgK1bkUzTUld\nk+PsV/AqRwKaZUwD9ja+ul5OzmmuV1H/U9AQSSymi/qEnsmQZPjpDkS6sPww\niLvCrulkFGbAc2p4GdcmRb1iwHwrwZC23RyTBmWFHHlK3+jxP8QmLC6x4Ulf\ne86wX1LSNn/l9XzjruIIr/VmHjixZ/yVrRnGGcp8SGEBdJuucRWOWpNMf8Cp\nAPiD\r\n=+zfY\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIQDRfpNWohQoiUvfEbU4SSN4cg1T5BeL/R0PA3TtQcKlAwIgXno7505tLVrbRZ8M34s6/nqbonihVCeGQDSd36l3jTs="
          }
        ]
      },
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "maintainers": [
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.80.0_1606835609012_0.6847105544338268"
      },
      "_hasShrinkwrap": false
    },
    "0.80.1": {
      "name": "ts-json-schema-generator",
      "version": "0.80.1",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "MooYeol Prescott Lee",
          "email": "mooyoul@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=10.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.6",
        "commander": "^6.2.1",
        "fast-json-stable-stringify": "^2.1.0",
        "glob": "^7.1.6",
        "json-stable-stringify": "^1.0.1",
        "typescript": "~4.1.3"
      },
      "devDependencies": {
        "@babel/core": "^7.12.10",
        "@babel/preset-env": "^7.12.10",
        "@babel/preset-typescript": "^7.12.7",
        "@types/fast-json-stable-stringify": "^2.0.0",
        "@types/glob": "^7.1.3",
        "@types/jest": "^26.0.19",
        "@types/json-stable-stringify": "^1.0.32",
        "@types/node": "^14.14.13",
        "@typescript-eslint/eslint-plugin": "^4.10.0",
        "@typescript-eslint/parser": "^4.10.0",
        "ajv": "^6.12.6",
        "chai": "^4.2.0",
        "eslint": "^7.15.0",
        "eslint-config-prettier": "^7.0.0",
        "eslint-plugin-prettier": "^3.3.0",
        "jest": "^26.6.3",
        "jest-junit": "^12.0.0",
        "prettier": "^2.2.1",
        "ts-node": "^9.1.1"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint '{src,test,factory}/**/*.ts'",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "FAST_TEST=1 jest test/ --verbose",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts"
      },
      "gitHead": "eceadc7fea47741a9d94044b1c00a21ac0e008a4",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.80.1",
      "_nodeVersion": "10.23.0",
      "_npmVersion": "6.14.8",
      "dist": {
        "integrity": "sha512-7TnsN8Qy9rhPtP514hFuyjoHlYFTWx+WTtLTsFRe5pvJi47+JKxCJfdAwdBR1eliz5jgwf7VjOFP94U3NADipg==",
        "shasum": "2e8cb00eb8ecf42e985c7b8b29d5ec2222539dbe",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.80.1.tgz",
        "fileCount": 601,
        "unpackedSize": 794177,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJf2G6GCRA9TVsSAnZWagAAeoQP/RB4sQyYGe7JJqAxjmH2\nh17aKtddFFJ5219jNQIq7wCkjglDrYmyQDPcmo71ZAebhkgNPypZk4vYnFUc\n7K1lIiFtlxdHouHVn2MaH4O/vJh5if5wEc8TvOmQzWPSp7QexjiXuvcb5sVA\n9zWD68zbBtVur8LRPtH6xEP0XM1+wuNsbnBSUxNCf+oV31bUiOVbntPDH1IY\npvWzKMyvhbytYdFl0f4456UIq5K3g3Pgxmz2Y4WeqfxTXtXZcbFjQfkxFrfM\njMbye+w8pqTZtXIy5SFEvN22Cm02ZDWxmxIpyUCbIFfqk4fL/jJNQ7fhkjZT\n996AQUG1w/z61uzvE/XL71SV61kX4if7pUrNP3I19kGincKMU/53MQUh74WR\nX30VV2jlFHGkHSFsRcJpQtSL2t8BAz098mMFm7KXTvRD+GBggKUYQ3K/SP9b\n0IFxrahQb3beUNlixL0n6a49IeqGnOFBtV81ZrG28nd4SXYCidTSgpzXV+Fi\nzUC8YLVw8iPYPuB8tHeg5HfWSR/S57Vz+nRjt4qPB/DGZOTULCn7uCGLkS+P\nMxZpkwd/xKuE+djOKF63CxlCme7X7zdh73K0pzZ+gjbl6aACwUC85dkORmYq\nVwNARSvRvvf1gVLZDZtZIYVCwzkJNR8HOM4LxyGJ6pORL8IKxuj8hm+F3ZaN\nxGEC\r\n=vpBQ\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEYCIQCJLP2PDHfmG2k30/O9l7w84lKHWoNU2BuzXAgFC0SwVQIhAJgFEurxvgKRbPxVAgwhhqhuURozitmlojLveCr20vfs"
          }
        ]
      },
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "maintainers": [
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.80.1_1608019590092_0.3873202153409492"
      },
      "_hasShrinkwrap": false
    },
    "0.81.0": {
      "name": "ts-json-schema-generator",
      "version": "0.81.0",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "MooYeol Prescott Lee",
          "email": "mooyoul@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=10.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.6",
        "commander": "^6.2.1",
        "fast-json-stable-stringify": "^2.1.0",
        "glob": "^7.1.6",
        "json-stable-stringify": "^1.0.1",
        "typescript": "~4.1.3"
      },
      "devDependencies": {
        "@babel/core": "^7.12.10",
        "@babel/preset-env": "^7.12.11",
        "@babel/preset-typescript": "^7.12.7",
        "@types/fast-json-stable-stringify": "^2.0.0",
        "@types/glob": "^7.1.3",
        "@types/jest": "^26.0.19",
        "@types/json-stable-stringify": "^1.0.32",
        "@types/node": "^14.14.14",
        "@typescript-eslint/eslint-plugin": "^4.11.0",
        "@typescript-eslint/parser": "^4.11.0",
        "ajv": "^7.0.2",
        "ajv-formats": "^1.5.1",
        "chai": "^4.2.0",
        "eslint": "^7.16.0",
        "eslint-config-prettier": "^7.1.0",
        "eslint-plugin-prettier": "^3.3.0",
        "jest": "^26.6.3",
        "jest-junit": "^12.0.0",
        "prettier": "^2.2.1",
        "ts-node": "^9.1.1"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint '{src,test,factory}/**/*.ts'",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "FAST_TEST=1 jest test/ --verbose",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts"
      },
      "gitHead": "63079cbf8883a0733d5d11f515a2c23f30edd2e4",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.81.0",
      "_nodeVersion": "10.23.0",
      "_npmVersion": "6.14.8",
      "dist": {
        "integrity": "sha512-cIqUMqpBjaKHJEPKzEDhrYkErpeN3AJe5SWaPnh7uvwlRP14PxmGiOuyAigcOJ3U9AS8zxsSsDkixHBaS5ERWA==",
        "shasum": "04a963388f568d585ccf8484caaf1ee9daddc848",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.81.0.tgz",
        "fileCount": 601,
        "unpackedSize": 826808,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJf4R8LCRA9TVsSAnZWagAAGaQP/Asaliwp93chs7qYBjQ+\nbIiXak+Mx9dUGxASKCAGTbjY9tKWleaAEAm0WO4UPGstlQBsGUV1ogWo+8zb\nri8vj/t/FXewmIVto2HCoMB08P75pHI3yUEApyHgOLe8MAk3pJ+4gMLgd4zE\nxw5qIjYev4UDVk4iemDxS8VyzCgvk3dbVs3tQ4RkHduDXHH4B/7K+QpHLJoT\nzD6w9bA5/KRUqnH5JwAd1LKadw7DGLyciW1/pROHjbLpjdYDn6BxsENbYb61\n3AwqgQaEIjGt6rxMpglAVp/Le26LMgPwgfXyD3M7V725Eamf3RhP8N+Fajj4\nCGRG/LU3/udtVfRTyPXoNb/O3ZsWeIz92vexEmNKXL4UsNim7Po9swtG8XIy\nt0C3EIedjxZUmAULIaZkLfu5ELxWmneq1kXhjuDVQCO/tQu1Fj3r+IyhPddJ\nC/+ghX67A7RwYycs7QQOTd9JFI+DaSShow3boLuz+3KxTO1GlArO3sPvw0Fd\nmKSeIMMTwHKAgOp+59ZlZ5KGHc/z4gnRgZeXKFnC7gOf9l0+dslwmHX1OVhk\n5CnZzBmjs0zZ0rwSMb8JqXMRJd1yK3Al29dMZ8pc1EJI3hTl/22uzHSyrXGD\n5BL2RlXy+VkemRGIrwmFWZuHhprovJ4LAPj03Z34M2EN7WaFKeCf7zJhxNwR\nl6rL\r\n=kTSM\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEYCIQCp7jSHQd5OirEKNGxmIttLX/7n3MRNPMYaiTKWtUzhhAIhAKNFiPSz7fk6h/Sf50/HlYmHN2Vhnd0Y1egcvzRjvBu0"
          }
        ]
      },
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "maintainers": [
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.81.0_1608589067231_0.981482885161441"
      },
      "_hasShrinkwrap": false
    },
    "0.82.0": {
      "name": "ts-json-schema-generator",
      "version": "0.82.0",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "MooYeol Prescott Lee",
          "email": "mooyoul@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=10.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.6",
        "commander": "^6.2.1",
        "fast-json-stable-stringify": "^2.1.0",
        "glob": "^7.1.6",
        "json-stable-stringify": "^1.0.1",
        "typescript": "~4.1.3"
      },
      "devDependencies": {
        "@babel/core": "^7.12.10",
        "@babel/preset-env": "^7.12.11",
        "@babel/preset-typescript": "^7.12.7",
        "@types/fast-json-stable-stringify": "^2.0.0",
        "@types/glob": "^7.1.3",
        "@types/jest": "^26.0.19",
        "@types/json-stable-stringify": "^1.0.32",
        "@types/node": "^14.14.14",
        "@typescript-eslint/eslint-plugin": "^4.11.0",
        "@typescript-eslint/parser": "^4.11.0",
        "ajv": "^7.0.2",
        "ajv-formats": "^1.5.1",
        "chai": "^4.2.0",
        "eslint": "^7.16.0",
        "eslint-config-prettier": "^7.1.0",
        "eslint-plugin-prettier": "^3.3.0",
        "jest": "^26.6.3",
        "jest-junit": "^12.0.0",
        "prettier": "^2.2.1",
        "ts-node": "^9.1.1"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint '{src,test,factory}/**/*.ts'",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "FAST_TEST=1 jest test/ --verbose",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts"
      },
      "gitHead": "5a40e85eaa8e8096362fca156e5a60eb23ad423b",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.82.0",
      "_nodeVersion": "10.23.0",
      "_npmVersion": "6.14.8",
      "dist": {
        "integrity": "sha512-g5/h3jmN7DqYTOx7OhTvWS638CJWzyoqlsKwe2eksvK8mnFHTnOZGvZITmPkRDPFUFwSUMo0J+Vm3A+Y8EDsEg==",
        "shasum": "fb249250bc7b1c703af78230748a55605e6f71c8",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.82.0.tgz",
        "fileCount": 613,
        "unpackedSize": 834959,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJf4zHXCRA9TVsSAnZWagAAowkP+gM0fjrnXpIRcIP4mbTk\neOFLDSOnRoNVlC9Xn68bABZRlUE4ewiJ+SyHxnkCrN5aWnBlNsAftWJELR8B\ndNUqb8q4OeHW0NejAgjdGpoYGpavW3ckahjuQYrqRO3SSivbebZB83F61k1A\n/l0H8mBVt0tWsVHflpQp9owMZ0sqxA7ZLl07rK+nDLR9lexxWQghJOVD0Npf\nRnMQmA43+OcfW3KSDz2l/4m2niZZNZ0zGD3OxpQH4AeqaDjWOl69dKKVeNYk\n45fdbcUxKKCVQ08zHIzsmriVGt8Xa7qyp4Ux3YjW4ny7WMHrnqAa4b7/H1lS\nNTEgcx8FaBsdtN1dqAKJR/GBSnm6wAeeCqGX3/Prrz8cj1h53WADPWtOInKc\nrG0v+VL+6okcE4YFtTk5+gfy5LJZfwL/6f/u8iDbaoLa9hwtccT5JqwHaUbR\n036AH/2E57HEZlE9/V7CaMqLi+P11LI8+bRJhP12/x6r25KnCu74dMKuyOBB\nzo25sCQcEFaux9m846bHXhwqa9k4HgQnKdeE87joYEbI6vPNOynebzjME9Lz\n1M177xyg7Ob5lM7hdC9LDN5bXN1wHrPrW5XFabMsYa6JIF1dazHtf46ob7ik\n8u78uK2TchHk4hqJDcv1yb5TbbgnjL0y92f2S0qTHbWeFMvLQvVZeMJLZ0D5\nTZb6\r\n=HIhM\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEQCID1UIr2FE1euXlBj4bkS6ApeCvOqEyBXL6he2Ul3oaJDAiAK2MiRLBvT/I4/Le6WHDWHu5gcwkt6UuPF+DzMsS5eRw=="
          }
        ]
      },
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "maintainers": [
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.82.0_1608724950884_0.0570715881756414"
      },
      "_hasShrinkwrap": false
    },
    "0.83.0": {
      "name": "ts-json-schema-generator",
      "version": "0.83.0",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "MooYeol Prescott Lee",
          "email": "mooyoul@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=10.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.6",
        "commander": "^7.0.0",
        "fast-json-stable-stringify": "^2.1.0",
        "glob": "^7.1.6",
        "json-stable-stringify": "^1.0.1",
        "typescript": "~4.1.3"
      },
      "devDependencies": {
        "@babel/core": "^7.12.10",
        "@babel/preset-env": "^7.12.11",
        "@babel/preset-typescript": "^7.12.7",
        "@types/fast-json-stable-stringify": "^2.0.0",
        "@types/glob": "^7.1.3",
        "@types/jest": "^26.0.20",
        "@types/json-stable-stringify": "^1.0.32",
        "@types/node": "^14.14.21",
        "@typescript-eslint/eslint-plugin": "^4.13.0",
        "@typescript-eslint/parser": "^4.13.0",
        "ajv": "^7.0.3",
        "ajv-formats": "^1.5.1",
        "chai": "^4.2.0",
        "eslint": "^7.17.0",
        "eslint-config-prettier": "^7.1.0",
        "eslint-plugin-prettier": "^3.3.1",
        "jest": "^26.6.3",
        "jest-junit": "^12.0.0",
        "prettier": "^2.2.1",
        "ts-node": "^9.1.1"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint '{src,test,factory}/**/*.ts'",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "FAST_TEST=1 jest test/ --verbose",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts"
      },
      "gitHead": "b3669f570fc9b56f6a9655c3c0585c73b4bfd3bf",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.83.0",
      "_nodeVersion": "10.23.1",
      "_npmVersion": "6.14.10",
      "dist": {
        "integrity": "sha512-0JoWkco5+YFmhPlXBMFhhH3ZzfJZI5jiLYFJ7lUy+8ty1GEOUbueRsBVT3z8kKkw3wkq2cLHX9ivXaK+9IIKCg==",
        "shasum": "cb374389622abcbe7f11764e6f7ef513125d18ed",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.83.0.tgz",
        "fileCount": 589,
        "unpackedSize": 565190,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJgAhHHCRA9TVsSAnZWagAAxLAP/i5qNoZAa/vP6W+8AjZQ\nzTUwjmy0Yj4frVErMccpOvr/tEQYd/d8y5bn2KWyBO7QuH/S1YTmgBt6f1hs\njelI8AF5gcWRacLWtsK00TNx2m15vHIzGK4uW3I1JvR4MPCL1Q2lIRsVudJz\n/WZHVpPKYlbzwsxSNKYzWlP9btDXUxPX8Jx0EVnjyZjsOVbDHwrYtjJMXMrx\nFo0d3jD1i+esSz24pv3NOvCYsJrhj7G5oU/TVz7x5vhsQMz1NnRmLu7L+l5G\nGjhtUxRlRbINAPXu9b9MFDOyNGLXOSTn4ruJz6WVChJt74PbPnB7NAxQiJcK\nZLj6A2nkFHeCcB9corC+UkV76VtXw/L8/6nE0cQMEvCTG4w48qj8F+j0Twb5\ne7JxFL+ZjUZGj+UBJQf7m07M+ZAStkh2urXNzGUta9WPzRV/I0PPWvwZlw1S\nL1G7RcUaX+vwLLo3FSPwhYOhpsGuuUScYUwpvMQ3tFmM0JDhicEjSqNdFXIN\n+f8L6MzNeh/l3MXfAwlU0e9JauG1U9JW89q7IfItUVVVAi1AcsGz3n+1k7ol\np5BAvnp/Mr+yjnsZu8EXyF2jh5abwnJ5j0U4wveiDpcpxnKs7nUoDNcG6u0q\nYxteLA9jfExKBxPxhyuayj0KSLtHRn0mI1GhdIN00CdoiIRNnRl1l8J5MOOc\nJfpg\r\n=LLZh\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIQDipCnwguRdHB9DP+P8sfzClS81A/OytYukHSJe2BshYAIgRJP7I2x7CRu1zj5dW0QIQUqEeZgUYfQh4+pLuJ9o/qs="
          }
        ]
      },
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "maintainers": [
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.83.0_1610748358988_0.716884419737031"
      },
      "_hasShrinkwrap": false
    },
    "0.83.1": {
      "name": "ts-json-schema-generator",
      "version": "0.83.1",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "MooYeol Prescott Lee",
          "email": "mooyoul@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=10.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.6",
        "commander": "^7.0.0",
        "fast-json-stable-stringify": "^2.1.0",
        "glob": "^7.1.6",
        "json-stable-stringify": "^1.0.1",
        "typescript": "~4.1.3"
      },
      "devDependencies": {
        "@babel/core": "^7.12.10",
        "@babel/preset-env": "^7.12.11",
        "@babel/preset-typescript": "^7.12.7",
        "@semantic-release/git": "^9.0.0",
        "@types/fast-json-stable-stringify": "^2.0.0",
        "@types/glob": "^7.1.3",
        "@types/jest": "^26.0.20",
        "@types/json-stable-stringify": "^1.0.32",
        "@types/node": "^14.14.21",
        "@typescript-eslint/eslint-plugin": "^4.13.0",
        "@typescript-eslint/parser": "^4.13.0",
        "ajv": "^7.0.3",
        "ajv-formats": "^1.5.1",
        "chai": "^4.2.0",
        "eslint": "^7.18.0",
        "eslint-config-prettier": "^7.1.0",
        "eslint-plugin-prettier": "^3.3.1",
        "jest": "^26.6.3",
        "jest-junit": "^12.0.0",
        "prettier": "^2.2.1",
        "semantic-release": "^17.3.3",
        "ts-node": "^9.1.1"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint '{src,test,factory}/**/*.ts'",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "FAST_TEST=1 jest test/ --verbose",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts"
      },
      "release": {
        "plugins": [
          "@semantic-release/commit-analyzer",
          "@semantic-release/release-notes-generator",
          "@semantic-release/github",
          "@semantic-release/npm",
          [
            "@semantic-release/git",
            {
              "assets": [
                "package.json"
              ],
              "message": "chore(release): ${nextRelease.version}"
            }
          ]
        ]
      },
      "gitHead": "b758bd64a4e5a81e66d794a5faf4dcaa275f6c3e",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.83.1",
      "_nodeVersion": "10.23.1",
      "_npmVersion": "6.14.11",
      "dist": {
        "integrity": "sha512-JHzVF5rbJ8ynSFJ1YEKRDFx64AsG514UwZfHpPno11XWSTH7HG8iL/wi7J/DxF4VyQCvgzoRuMJ1ZgGbkF0shQ==",
        "shasum": "ae5e61090c5d3d280bea33446103729315270179",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.83.1.tgz",
        "fileCount": 591,
        "unpackedSize": 573928,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJgAt52CRA9TVsSAnZWagAAfKUP/1Mnq2umH1wNP6diXcap\nyIe2Qk1wMARqirfeof0KCv+WuLHT9vJXNRCa7c5K7OLlIB/A1nki3BmQcNJS\nLpszrvTIj4nHP0VHv0Ko9IktYWu8HiHyayMK16IaAYsB7rHvnJT9t7mFQ07Z\nj/rgC2hVAzPE2PVYoK6Xn9P3UALaLdF+Gywu+w9aKi9xxu0k94iHn55WWl3r\nebwwr+sYtpkNsrIJVPCsr4z0ovrDEr3Spej+plTuaSPPlEWbq3QUZXdyprz1\ncp9sFPwTqi50VUOt4ud3972kygPhf5oxuUJAxbA1T4LMm+xOdLu1Z/VZn5Mg\nwAkvckMVlbjEee9SHg13/M9We8rsTgxrrU7bQDQp18COfKcP+KjUopCRRhar\nrF4N8/xy3EpzC62wfyqVZSIrDwMt6kxieaIAYwW5IN0VcwDqoFNW9fork/nr\nnaF309R9thrXZafpnMcwTvZ2dCqjIokBiL+q7VZ9C6+TeO+o/xgUQJhrsh1F\nm5pbe+ybRjCIVP7uHAjTO/dzOSyBtEc83l3ukXPFEFQMH4SuHxUiOwvj6J6I\nKYKhaFcDKZ7/yxQ/dHnH3IQrahP4ion7uTRyE6oqfJjKot5gshfSD+yDQQf3\nEcej3m7W9dJIqkgEbpwbHb/6bLaoP6oooFrUB4Nq8x/bF3raYbwxU4H80I2u\nmkmy\r\n=029a\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIQDHqah9kWzRQDIgJZOM/8KH3lgIuD3m/J95c2DOSy7I/AIgeLOr5T6P1kiuQL0WaLD130khZb5y3lhsHbPLYfJGWHc="
          }
        ]
      },
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "maintainers": [
        {
          "name": "jheer",
          "email": "jeffrey.heer@gmail.com"
        },
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "kanitw",
          "email": "kanitw@gmail.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.83.1_1610800758256_0.687143622854623"
      },
      "_hasShrinkwrap": false
    },
    "0.83.2": {
      "name": "ts-json-schema-generator",
      "version": "0.83.2",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "MooYeol Prescott Lee",
          "email": "mooyoul@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=10.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.6",
        "commander": "^7.0.0",
        "fast-json-stable-stringify": "^2.1.0",
        "glob": "^7.1.6",
        "json-stable-stringify": "^1.0.1",
        "typescript": "~4.1.3"
      },
      "devDependencies": {
        "@babel/core": "^7.12.10",
        "@babel/preset-env": "^7.12.11",
        "@babel/preset-typescript": "^7.12.7",
        "@semantic-release/git": "^9.0.0",
        "@types/fast-json-stable-stringify": "^2.0.0",
        "@types/glob": "^7.1.3",
        "@types/jest": "^26.0.20",
        "@types/json-stable-stringify": "^1.0.32",
        "@types/node": "^14.14.21",
        "@typescript-eslint/eslint-plugin": "^4.13.0",
        "@typescript-eslint/parser": "^4.13.0",
        "ajv": "^7.0.3",
        "ajv-formats": "^1.5.1",
        "chai": "^4.2.0",
        "eslint": "^7.18.0",
        "eslint-config-prettier": "^7.1.0",
        "eslint-plugin-prettier": "^3.3.1",
        "jest": "^26.6.3",
        "jest-junit": "^12.0.0",
        "prettier": "^2.2.1",
        "semantic-release": "^17.3.3",
        "ts-node": "^9.1.1"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint '{src,test,factory}/**/*.ts'",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "FAST_TEST=1 jest test/ --verbose",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts"
      },
      "release": {
        "plugins": [
          "@semantic-release/commit-analyzer",
          "@semantic-release/release-notes-generator",
          "@semantic-release/github",
          "@semantic-release/npm",
          [
            "@semantic-release/git",
            {
              "assets": [
                "package.json"
              ],
              "message": "chore(release): ${nextRelease.version}"
            }
          ]
        ]
      },
      "gitHead": "92d57c2f3d226b98ee1fec57334322ac93c54a20",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.83.2",
      "_nodeVersion": "10.23.1",
      "_npmVersion": "6.14.11",
      "dist": {
        "integrity": "sha512-hG7B9xLwMdUf9gGYaXDx65j2N+7zoX6TFn8I2Hk58yyUTRv7vrpB+/U3jsUEUCHxF527RAi6XGRGwiHSKFRuLg==",
        "shasum": "7ca84afdd0d4fd8af91e462e001861dafe3a2809",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.83.2.tgz",
        "fileCount": 597,
        "unpackedSize": 593348,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJgAuH1CRA9TVsSAnZWagAAJ5kQAKJp00g9fx0y5/U5AmeK\n/GgU9lv9/dOPqQM5w6Dzglhvj42CFxqAyiNzUJzLJQYehC2u06WJpgtrUQ6d\nLE4U7LXdFAawd9rAA6Dh69QqgUtLSVelayO6gycT3AkuT+p98ShTxXwusN80\nChNnxZXq8/hh76stJtItVjRin4kiFWd4Dp9VjRz6CDEngTPfSR6iaptUubxu\nau8ev3xAq5y+OLWE29NZ6PzmLyHWZAcYFvzoZtQmReC1HhniCAtR2DK9LXHU\n5L308BJTa59Zx2SMpUC7giWWdFn5awg50Qy69OX8A2SgtiWNhLCEmdXaDVSi\n7i+VrcbUU3rT+qlO/DHbPMvKOSBdcXJ83bxtBLk6Sgo2E+gRlpCBApLQ4FvL\n2taX7XA1t7V6cjseaHbhBDsHOCl9pd8M2BFonkMAu8zHmWjPqHdaS5D15lst\nWMzrqCHx9xCz/Dxpvd0am4TzJVhgO9IOGo9jdyzQK0p8HnQQRKt+ILtc9ktE\nHbLSq/TPXjYTHCw4dZoDC0ky0f7sWZjG4E+O2j0qmJaxSRQDsVBglfQwhqDp\nmqh0sOqhiX2QgvAw+0e66yb/gqiP3PGvM3geOEl8VDOY02sebHGuuX15wvzY\nQXQmtX8QHIHAaG2yssq7ZGcfrvqq1tkw9EosaHYsvN5TPztFjyE0kVnsqtxb\ngKJT\r\n=1QtY\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIQD+OpLVqqbIzZ+/uVfPOSUyD96TdtStCxIssxIO1jAkzQIgS8S5dvrWwpAVUfZA3FTUAeZhFTCLHSYlimWd26RJs5I="
          }
        ]
      },
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "maintainers": [
        {
          "name": "jheer",
          "email": "jeffrey.heer@gmail.com"
        },
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "kanitw",
          "email": "kanitw@gmail.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.83.2_1610801652665_0.9208233103613153"
      },
      "_hasShrinkwrap": false
    },
    "0.84.0": {
      "name": "ts-json-schema-generator",
      "version": "0.84.0",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "MooYeol Prescott Lee",
          "email": "mooyoul@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=10.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.6",
        "commander": "^7.0.0",
        "fast-json-stable-stringify": "^2.1.0",
        "glob": "^7.1.6",
        "json-stable-stringify": "^1.0.1",
        "typescript": "~4.1.3"
      },
      "devDependencies": {
        "@babel/core": "^7.12.10",
        "@babel/preset-env": "^7.12.11",
        "@babel/preset-typescript": "^7.12.7",
        "@semantic-release/git": "^9.0.0",
        "@types/fast-json-stable-stringify": "^2.0.0",
        "@types/glob": "^7.1.3",
        "@types/jest": "^26.0.20",
        "@types/json-stable-stringify": "^1.0.32",
        "@types/node": "^14.14.21",
        "@typescript-eslint/eslint-plugin": "^4.13.0",
        "@typescript-eslint/parser": "^4.13.0",
        "ajv": "^7.0.3",
        "ajv-formats": "^1.5.1",
        "chai": "^4.2.0",
        "eslint": "^7.18.0",
        "eslint-config-prettier": "^7.1.0",
        "eslint-plugin-prettier": "^3.3.1",
        "jest": "^26.6.3",
        "jest-junit": "^12.0.0",
        "prettier": "^2.2.1",
        "semantic-release": "^17.3.3",
        "ts-node": "^9.1.1"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint '{src,test,factory}/**/*.ts'",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "FAST_TEST=1 jest test/ --verbose",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts"
      },
      "release": {
        "plugins": [
          "@semantic-release/commit-analyzer",
          "@semantic-release/release-notes-generator",
          "@semantic-release/github",
          "@semantic-release/npm",
          [
            "@semantic-release/git",
            {
              "assets": [
                "package.json"
              ],
              "message": "chore(release): ${nextRelease.version}"
            }
          ]
        ]
      },
      "gitHead": "eb0676aa291df284d716288b5199d108c10ffb20",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.84.0",
      "_nodeVersion": "10.23.2",
      "_npmVersion": "6.14.11",
      "dist": {
        "integrity": "sha512-3u3Uf7S45epPRb5zgnDPqKxBlCVHYGATdnhNNfeVpHpgFDaASyOWoBgijS5x3FnmDMnHpDb4B9+AvZ49gxrksQ==",
        "shasum": "af0446e5758fdce31634944ccaa68ea5b98fe3df",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.84.0.tgz",
        "fileCount": 597,
        "unpackedSize": 596314,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJgHUcXCRA9TVsSAnZWagAAQxAP/22X5cJ0y1NJP6A5DVk8\n01UDjgc8pnaxBuVjWxu8LktdhImsUrWF6yHhnty7Lhpnn8ehCv9+9ObeUaES\nCEsPXsAaaNlK5RPqLu0RCQgcx8jdg+xj4LGf8kqkigHwxna7dIjp0vX+3T8D\no/oMHqgTF/E82PYZaTnbFILsgG9i3HDCTKsWTy6Q3qQKcVRgIEsqKy4QWYpP\nu/M9z1TypnmaChjYVIi510prSNychWEnFinVUX3RKXoIX+YXNdYfRnWV7+OE\n/R5v3P1VTNuunq3maGvzaNQd6ClpqRBm4wm9MLhVsI31DE7sSXcjNHLBmMoA\nNDXl/2HkfnMOQWDcjk0Hrpfo26Nh+U9YUi5L1e2J1jDnCyE3loyGQ1zw+dpB\nCH/ERFAtfBVKrKcKFE6ltzHpEHVwVGwo9rKJT4KfRt4MsoapeyuBggScm1tb\n3fkcvtUPIZQOz+yzWb0xgUZL8Ki1I5/ft7Qr8C50BYWJNhZBUBrYjIqr5jic\nQzmKIzl0Ov/l/GnKcULlFznYafsIjBmJlQ9oQ9ta9FzpBFYeE4PnkUyYG0bQ\n+5R8D8lcYAJXgFV4F25vbvx/JT3x/r7Kg/zDTtVbt1huoGzGrIJI8AJsf3jF\nbE8W75ZmeElzHspwfiK8Nsx71uCK8rRZ41bHvJXon5WoHzvHjx/QfhmXkl5J\n0YDq\r\n=GJxV\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEYCIQCvuN5yIQsAuVW7uKW6NPtJe6kk3AjDhPURDbmu/75h7wIhALRWhGE4M34JlPgraHEC3dtOZowkOrdm+Ax/DdvE118H"
          }
        ]
      },
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "maintainers": [
        {
          "name": "jheer",
          "email": "jeffrey.heer@gmail.com"
        },
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "kanitw",
          "email": "kanitw@gmail.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.84.0_1612531479484_0.7481864730552374"
      },
      "_hasShrinkwrap": false
    },
    "0.85.0": {
      "name": "ts-json-schema-generator",
      "version": "0.85.0",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "MooYeol Prescott Lee",
          "email": "mooyoul@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=10.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.7",
        "commander": "^7.1.0",
        "fast-json-stable-stringify": "^2.1.0",
        "glob": "^7.1.6",
        "json-stable-stringify": "^1.0.1",
        "typescript": "~4.1.5"
      },
      "devDependencies": {
        "@babel/core": "^7.12.16",
        "@babel/preset-env": "^7.12.16",
        "@babel/preset-typescript": "^7.12.16",
        "@semantic-release/git": "^9.0.0",
        "@types/fast-json-stable-stringify": "^2.0.0",
        "@types/glob": "^7.1.3",
        "@types/jest": "^26.0.20",
        "@types/json-stable-stringify": "^1.0.32",
        "@types/node": "^14.14.28",
        "@typescript-eslint/eslint-plugin": "^4.15.1",
        "@typescript-eslint/parser": "^4.15.1",
        "ajv": "^7.1.1",
        "ajv-formats": "^1.5.1",
        "chai": "^4.3.0",
        "eslint": "^7.20.0",
        "eslint-config-prettier": "^7.2.0",
        "eslint-plugin-prettier": "^3.3.1",
        "jest": "^26.6.3",
        "jest-junit": "^12.0.0",
        "prettier": "^2.2.1",
        "semantic-release": "^17.3.9",
        "ts-node": "^9.1.1"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint {src,test,factory}/**/*.ts",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "FAST_TEST=1 jest test/ --verbose",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts"
      },
      "release": {
        "plugins": [
          "@semantic-release/commit-analyzer",
          "@semantic-release/release-notes-generator",
          "@semantic-release/github",
          "@semantic-release/npm",
          [
            "@semantic-release/git",
            {
              "assets": [
                "package.json"
              ],
              "message": "chore(release): ${nextRelease.version}"
            }
          ]
        ]
      },
      "gitHead": "6c6f9c987b7a2ba01270806ed1ba8108750a9ed0",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.85.0",
      "_nodeVersion": "10.23.2",
      "_npmVersion": "6.14.11",
      "dist": {
        "integrity": "sha512-uatTN99wJ1G5MmhFf8t8o35CrhBtthGm5TjXWyFWqRnU87dlMSlLBBNVkX/GgbgxhbDz/efHqbz0psbPtB6SvQ==",
        "shasum": "fa17433cbd40889cba42d5545aef1ca54388155f",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.85.0.tgz",
        "fileCount": 597,
        "unpackedSize": 597658,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJgLPhMCRA9TVsSAnZWagAAD6EP+wYHzhxscgslR1cQGfYb\nDZPHZQhoZVZ4rY5P6Vr9r7AFmY1Dd/1jjAl/1jdN4t1hd00Bn/pfmtY9J2YM\n0hCaQ8+2m+KtqyJGvKtFB2e9tlTbku1BQQy5OYmQSvkFBZ/dwJmZfQ9Af6Sd\nqMyywGZWh26DJb3E36bIj5qGr4EIi61RcLBEbSwX/mO/FH1GX5QAPCqb5YRd\n7/hFxZzKy/sU56QrbsusSApapr234DSBWXo6xKFTV4kFA46bcxYo24UxfbLS\nnUpXe0f+8O5vXjTT3CrNnjJ+T6WNtMpkZHW/kf3KuZCTKBBrx51wWEK0OeRI\nxB4n890SnGWPmwJyB3bjKEj+wo1k7avjH52+VmCbSKzQcXTLlJYaenXVbeTy\n8m1+l/4w8BCYtUD6sdkIa6kUkluTnLpSdmhN1iN70OW5tsIWh4Li/+NUjsmI\nFeH5Ww1DQkx+cUBtm8q1TOFY4d2vLyWUqEmiU9UCJw7mcnNImSYoZUE5C0Il\n3aoEvh6sRR5YIsYppJj/6ss6a+/QFEK8mLqO+swbL/nSHoZyHLvimqm3o2Rg\ns1f4H/gTIFve2q+ssDSG3p6eEgZmEgsTn9waw/P/Y1LUaxDn7BOG5DOL65Z7\n20nAKgnRWFVQXS+LNSuI/tjmklggFEbeNafo6SOw5IFKgQ/bFN7X+1tmeYH3\nNwtk\r\n=s9lO\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIQCVdwmxay5vpew8lbeqq5g4maGxF9F9NhmwsEh5vZCTpQIgXjeTOO3+TJJV2Db848+XDt84Lueoc6ghcVtEyTWsxXU="
          }
        ]
      },
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "maintainers": [
        {
          "name": "jheer",
          "email": "jeffrey.heer@gmail.com"
        },
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "kanitw",
          "email": "kanitw@gmail.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.85.0_1613559883611_0.6553496834617287"
      },
      "_hasShrinkwrap": false
    },
    "0.86.0": {
      "name": "ts-json-schema-generator",
      "version": "0.86.0",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "MooYeol Prescott Lee",
          "email": "mooyoul@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=10.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.7",
        "commander": "^7.1.0",
        "fast-json-stable-stringify": "^2.1.0",
        "glob": "^7.1.6",
        "json-stable-stringify": "^1.0.1",
        "typescript": "~4.1.5"
      },
      "devDependencies": {
        "@babel/core": "^7.12.16",
        "@babel/preset-env": "^7.12.16",
        "@babel/preset-typescript": "^7.12.16",
        "@semantic-release/git": "^9.0.0",
        "@types/fast-json-stable-stringify": "^2.0.0",
        "@types/glob": "^7.1.3",
        "@types/jest": "^26.0.20",
        "@types/json-stable-stringify": "^1.0.32",
        "@types/node": "^14.14.28",
        "@typescript-eslint/eslint-plugin": "^4.15.1",
        "@typescript-eslint/parser": "^4.15.1",
        "ajv": "^7.1.1",
        "ajv-formats": "^1.5.1",
        "chai": "^4.3.0",
        "eslint": "^7.20.0",
        "eslint-config-prettier": "^7.2.0",
        "eslint-plugin-prettier": "^3.3.1",
        "jest": "^26.6.3",
        "jest-junit": "^12.0.0",
        "prettier": "^2.2.1",
        "semantic-release": "^17.3.9",
        "ts-node": "^9.1.1"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint {src,test,factory}/**/*.ts",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "FAST_TEST=1 jest test/ --verbose",
        "test:coverage": "yarn jest test/ --collectCoverage=true",
        "test:update": "cross-env UPDATE_SCHEMA=true test",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts"
      },
      "release": {
        "plugins": [
          "@semantic-release/commit-analyzer",
          "@semantic-release/release-notes-generator",
          "@semantic-release/github",
          "@semantic-release/npm",
          [
            "@semantic-release/git",
            {
              "assets": [
                "package.json"
              ],
              "message": "chore(release): ${nextRelease.version}"
            }
          ]
        ]
      },
      "gitHead": "3cc3f8a32e6b3de5b0130abe96c8ffe28c47c845",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.86.0",
      "_nodeVersion": "10.23.2",
      "_npmVersion": "6.14.11",
      "dist": {
        "integrity": "sha512-8SFNH1FGGvMsJ5rF+0/nmI2+Liw76FS3LTe/fI40dytPinpjasRqGGW+uYaHUE3+GGPwB7gCnSDdbrs3zWgQ1g==",
        "shasum": "1f36f80249ab13e52225d00f2a83bd6352f4d673",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.86.0.tgz",
        "fileCount": 605,
        "unpackedSize": 606343,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJgLRWoCRA9TVsSAnZWagAAY2YP/2sZbbSOpCZ/7coFai0V\nbygjqHrpQ84buzsrwCbmqAVXHPI7k8fRdxdAwGqwEg1NZzlYZdpqo5/aNsXD\nM0mT/5V1v1HYo25SpfnuylHYTsvqVL0pPTBu7pnaG7DFpknyElgSFm7e/kE2\nfQCQ3PFNqYxqxdV6MMSLFC2xdBtOKffAMkNqTezcamBp634yiaZY8aZTN15g\nPcOGGzreiAVXZbfTSUy0RyRF3K2dyNpsrIdMS88C4328dZudZXUZn7yM+XFb\ncLxL4aFIFVh7LXBhBdXJo/9OvtUuhzm4/NuQ2Voj432UD6ewa5nTD+5TwDsR\ndmwVV8iQ58p3u5MPIU4uaIKcnT1kDyk6EkjYeoex7VpJbOntrfTiqmKGz94o\nPqiJ52xQCuyzkJsyfZR7TU5kBqfwXMTYqu2gtRUWBP9Eq+VeVmrE1JOEOd+U\nWQGZETgqAVVKy4nnjsaN1yU+l+jIsOUzig1mdhTyeZONKdXf+2l+GBXaUNRT\nuxIGOD/JJQkbAH7KEygaKGkuDblBHnjryGE+74arQFEm7lNgyOZhFmj2i/Gs\nqpsZiA+v/aMVcUAt1LPQKBA/VYvSxLEM0PANtFZMzAnEJBnR2BpPZZsxb7/f\nKf1hMxrTtFV8TkQGdua0tj+lJRAupnlE+FxkvJXrqtZuXFHrhIynEyK92oNY\nJhBt\r\n=Fgx2\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIQDwdq0k8pNdlB5h4CkbivZjpfwuiktWYKMVnBuS6ZjsXQIgF7D5XmmJn1oyDdFZla51q95USLeFnvKgaVE+Dd4qX1k="
          }
        ]
      },
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "maintainers": [
        {
          "name": "jheer",
          "email": "jeffrey.heer@gmail.com"
        },
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "kanitw",
          "email": "kanitw@gmail.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.86.0_1613567399617_0.516547485276257"
      },
      "_hasShrinkwrap": false
    },
    "0.86.1": {
      "name": "ts-json-schema-generator",
      "version": "0.86.1",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "MooYeol Prescott Lee",
          "email": "mooyoul@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=10.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.7",
        "commander": "^7.1.0",
        "fast-json-stable-stringify": "^2.1.0",
        "glob": "^7.1.6",
        "json-stable-stringify": "^1.0.1",
        "typescript": "~4.1.5"
      },
      "devDependencies": {
        "@babel/core": "^7.12.16",
        "@babel/preset-env": "^7.12.16",
        "@babel/preset-typescript": "^7.12.16",
        "@semantic-release/git": "^9.0.0",
        "@types/fast-json-stable-stringify": "^2.0.0",
        "@types/glob": "^7.1.3",
        "@types/jest": "^26.0.20",
        "@types/json-stable-stringify": "^1.0.32",
        "@types/node": "^14.14.28",
        "@typescript-eslint/eslint-plugin": "^4.15.1",
        "@typescript-eslint/parser": "^4.15.1",
        "ajv": "^7.1.1",
        "ajv-formats": "^1.5.1",
        "chai": "^4.3.0",
        "eslint": "^7.20.0",
        "eslint-config-prettier": "^7.2.0",
        "eslint-plugin-prettier": "^3.3.1",
        "jest": "^26.6.3",
        "jest-junit": "^12.0.0",
        "prettier": "^2.2.1",
        "semantic-release": "^17.3.9",
        "ts-node": "^9.1.1"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint {src,test,factory}/**/*.ts",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "FAST_TEST=1 jest test/ --verbose",
        "test:coverage": "yarn jest test/ --collectCoverage=true",
        "test:update": "UPDATE_SCHEMA=true yarn test:fast",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts"
      },
      "release": {
        "plugins": [
          "@semantic-release/commit-analyzer",
          "@semantic-release/release-notes-generator",
          "@semantic-release/github",
          "@semantic-release/npm",
          [
            "@semantic-release/git",
            {
              "assets": [
                "package.json"
              ],
              "message": "chore(release): ${nextRelease.version}"
            }
          ]
        ]
      },
      "gitHead": "1a077fdf29e2321881c10641030bfa7d407512c9",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.86.1",
      "_nodeVersion": "10.23.2",
      "_npmVersion": "6.14.11",
      "dist": {
        "integrity": "sha512-DWapm+mShf3+YS76VPvd/FSa9i4R/rBkJYmCiGDKRnvDgrwNFOXms0jc8HFjDG168wWmhU+wPTQf/PN+/mw9Cg==",
        "shasum": "f3eedfd246ee08af385f9e70e649118c478244ed",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.86.1.tgz",
        "fileCount": 597,
        "unpackedSize": 597905,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJgLVqVCRA9TVsSAnZWagAALaYP+QDYlaCzN37DP5GNu/xX\nd9G+PzzUwrxVpBka3bQHAglBxz2FoE+xpyRQJd/GR0l9RSqhU+xSHXR5+or1\nJUpSKOyr+W/hGd3BJo3lzO59VPEQk4eyaSfAxukCW5ZaYiKwFWner5GHRPpl\n7TdH4xj5HGgQkbWdyga/1IPsmjq2NoBE3zYgXJWWV47B+91rD4UjM+vL9DfZ\nEAIF0XpPXaUkmPFu9kn/yaQBjPEfTwOsWwRYWm4b1YMSyG8b9MYys/r7SiwE\nUtg80lAnniL1eBtDDgHtlnPNxLZXDSsqi8iZh7eLreyd7IPKmsaJeIuqZc8v\nhGP3L7+vA5rhPNGBQm1tzibeAbF8XXHkkHuJeH9zkQdF1njxFI7BslRxaD83\n4+nDHZIS2vYk5Hgk+L8QK9G3ilkb4QAJ/ifj8v5UmHVkSIizntZjGKEedJyg\n9KiHUWM9nSqojBSkR4OJYGcXoy3WRoNiYffrr9SiCOunJyR8CpMn2gu1Cy+x\n0LlrFkVBQ7ydQK195ae7eJwhsolKDxZaciqLafd8mo3Ulvg81X2V5OWXqgba\nVGMPMk0zDQ6zneJsxgH8jtceqJq57qaNVHCqyC/AP/sG0ucpiq5O8tW/sbIP\nQy/19C+DEu2KbcpJwLHqSgFJopVMRHd2owjtHPnG5jSBD7fOQdCgrtNs9LYe\nNUxp\r\n=FBIr\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEYCIQCvqufKpKfyscKsZIZx7tWD6AXZhGiNM0xs9Qvo2X1ZWQIhAOEsNViokLG6QHXDQuw96fOVoeAzpetiWXGMIOPFSuyc"
          }
        ]
      },
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "maintainers": [
        {
          "name": "jheer",
          "email": "jeffrey.heer@gmail.com"
        },
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "kanitw",
          "email": "kanitw@gmail.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.86.1_1613585044780_0.04210535636214363"
      },
      "_hasShrinkwrap": false
    },
    "0.87.0": {
      "name": "ts-json-schema-generator",
      "version": "0.87.0",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "MooYeol Prescott Lee",
          "email": "mooyoul@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=10.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.7",
        "commander": "^7.1.0",
        "fast-json-stable-stringify": "^2.1.0",
        "glob": "^7.1.6",
        "json-stable-stringify": "^1.0.1",
        "typescript": "~4.2.2"
      },
      "devDependencies": {
        "@babel/core": "^7.13.1",
        "@babel/preset-env": "^7.13.5",
        "@babel/preset-typescript": "^7.13.0",
        "@semantic-release/git": "^9.0.0",
        "@types/fast-json-stable-stringify": "^2.0.0",
        "@types/glob": "^7.1.3",
        "@types/jest": "^26.0.20",
        "@types/json-stable-stringify": "^1.0.32",
        "@types/node": "^14.14.31",
        "@typescript-eslint/eslint-plugin": "^4.15.2",
        "@typescript-eslint/parser": "^4.15.2",
        "ajv": "^7.1.1",
        "ajv-formats": "^1.5.1",
        "chai": "^4.3.0",
        "cross-env": "^7.0.3",
        "eslint": "^7.20.0",
        "eslint-config-prettier": "^8.1.0",
        "eslint-plugin-prettier": "^3.3.1",
        "jest": "^26.6.3",
        "jest-junit": "^12.0.0",
        "prettier": "^2.2.1",
        "semantic-release": "^17.4.0",
        "ts-node": "^9.1.1",
        "vega": "^5.19.1",
        "vega-lite": "^5.0.0"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint {src,test,factory}/**/*.ts",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "cross-env FAST_TEST=1 jest test/ --verbose",
        "test:coverage": "yarn jest test/ --collectCoverage=true",
        "test:update": "cross-env UPDATE_SCHEMA=true yarn test:fast",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts"
      },
      "release": {
        "plugins": [
          "@semantic-release/commit-analyzer",
          "@semantic-release/release-notes-generator",
          "@semantic-release/github",
          "@semantic-release/npm",
          [
            "@semantic-release/git",
            {
              "assets": [
                "package.json"
              ],
              "message": "chore(release): ${nextRelease.version}"
            }
          ]
        ]
      },
      "gitHead": "2ce734854adb6f3ffabb2103eaf147c8d407a071",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.87.0",
      "_nodeVersion": "10.23.3",
      "_npmVersion": "6.14.11",
      "dist": {
        "integrity": "sha512-IQtUn5/OIajmY+D4XWEDpR+XiGIuifQ5pkQdnwX58x9H97/YN5wuE7ZmyK9K3GBBVPG2hI2ibE5705mS0Tnhzg==",
        "shasum": "15296374177408f583860e8fd373d834a5e11aa4",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.87.0.tgz",
        "fileCount": 597,
        "unpackedSize": 598504,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJgOOoXCRA9TVsSAnZWagAAQN0P/2Iy+XfEruGHf9jKAgQH\nXiqVAayPhtjMEJl26YAv/HUCqYc/+KDZIG91q4pKKtZrGtzKIrb37JVI7pC1\nlb87jTjeuisEEqPowXJwf4RRoIZoXdJE4yfuRqTlSJVa4kvqEczqPMDg7SD6\nQxKla0udwwrftse+LLPkTxLBcLOKbguTXgaoZyrrTSjfDJspU8+AL3HjKfoF\n4WQ8E3xVH0Au0zIjSnVGqeW2dJSQXMA059+2XGGn7VKcoaLwaAG+dM3cYpzz\nZm4AWrI5ehDdFJnymUMiqmM7nxbwSctdIxur2TAd3hcuZm2kiudJdOyTA7jx\nqEL186LVuexJAeFwjOom6nGU6UVMV6t+s+YsZN/9E43DAA7NV0LCGoHhvBH/\nYyfcl8MJyB20VxEOPtSHiFTXWSbnLBidhCxX6Wj0DUlsXwpcVryCns/aD52y\nBxl1QPVBuwxgIHRxaF93upS2V4/r5Uc72IIMRuRh8ZxlMNign+iL8JIfbB6J\nmZZ4QIn1+/dDoiiTAuFzg2SRC+IdJHxoa5FE0S/4lLbO7dUCnUhhlcUviuiw\nDKZbYBDGeALdqEJuqOgQum/osakeVAq22rqeWo1l6CjtWtW0o7YvdAwG2NVg\nd4/K4+PrVjyhFurEzd2xT6tPxVLuwhhsTjI8IkijqT8Je9339NdftzaiMY1h\nux3x\r\n=l02d\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIGFzI6OkO5AeOqeYCShyW9YzVkfyWBTGKg5P2SH7vX6tAiEAvuky6Eo1BqEQ+r7YqfkonHWQlB206IMbScib6QdT+6E="
          }
        ]
      },
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "maintainers": [
        {
          "name": "jheer",
          "email": "jeffrey.heer@gmail.com"
        },
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "kanitw",
          "email": "kanitw@gmail.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.87.0_1614342678608_0.8717693163119944"
      },
      "_hasShrinkwrap": false
    },
    "0.88.0": {
      "name": "ts-json-schema-generator",
      "version": "0.88.0",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "MooYeol Prescott Lee",
          "email": "mooyoul@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=10.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.7",
        "commander": "^7.1.0",
        "fast-json-stable-stringify": "^2.1.0",
        "glob": "^7.1.6",
        "json-stable-stringify": "^1.0.1",
        "typescript": "~4.2.2"
      },
      "devDependencies": {
        "@babel/core": "^7.13.1",
        "@babel/preset-env": "^7.13.5",
        "@babel/preset-typescript": "^7.13.0",
        "@semantic-release/git": "^9.0.0",
        "@types/fast-json-stable-stringify": "^2.0.0",
        "@types/glob": "^7.1.3",
        "@types/jest": "^26.0.20",
        "@types/json-stable-stringify": "^1.0.32",
        "@types/node": "^14.14.31",
        "@typescript-eslint/eslint-plugin": "^4.15.2",
        "@typescript-eslint/parser": "^4.15.2",
        "ajv": "^7.1.1",
        "ajv-formats": "^1.5.1",
        "chai": "^4.3.0",
        "cross-env": "^7.0.3",
        "eslint": "^7.20.0",
        "eslint-config-prettier": "^8.1.0",
        "eslint-plugin-prettier": "^3.3.1",
        "jest": "^26.6.3",
        "jest-junit": "^12.0.0",
        "prettier": "^2.2.1",
        "semantic-release": "^17.4.0",
        "ts-node": "^9.1.1",
        "vega": "^5.19.1",
        "vega-lite": "^5.0.0"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint {src,test,factory}/**/*.ts",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "cross-env FAST_TEST=1 jest test/ --verbose",
        "test:coverage": "yarn jest test/ --collectCoverage=true",
        "test:update": "cross-env UPDATE_SCHEMA=true yarn test:fast",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts"
      },
      "release": {
        "plugins": [
          "@semantic-release/commit-analyzer",
          "@semantic-release/release-notes-generator",
          "@semantic-release/github",
          "@semantic-release/npm",
          [
            "@semantic-release/git",
            {
              "assets": [
                "package.json"
              ],
              "message": "chore(release): ${nextRelease.version}"
            }
          ]
        ]
      },
      "gitHead": "77c4a814bc027c49d1de5e36b2a8324175ef9f15",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.88.0",
      "_nodeVersion": "10.23.3",
      "_npmVersion": "6.14.11",
      "dist": {
        "integrity": "sha512-MJbQ4ATFVZSrxAmnPMUWXkgMdQvDDKvzY70KhJ9M+xVg7q1Ng2OGN4Nmq7pbf2WHuZb/Ewns4mdZj+5DH/6wNQ==",
        "shasum": "9e2c0a1d1e40b3c7125c6aa170b6e500112aa7cf",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.88.0.tgz",
        "fileCount": 601,
        "unpackedSize": 601393,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJgOlPwCRA9TVsSAnZWagAAaYUP/2G7KFQUkE2FQ8dxirVL\nQl3+6pTJVBeSN0IoQFiQ2SZFoDcJBYNNIjCQEAOU5ONHfYPH5gRuOnF8W1yP\nFyq6dAMgzptM1KqG2HucqDQCxp4aAh22hmC1DvqOLk8UOWGLc2yTP07g6mF7\nOUVlrSJCP5SobcVYIL7VkB14kIyNAe2wrrCq+vsGz4+9onLu5LRvwRYirAAv\nlXKaKF4yFQHca40LwhH5ijBVnNakZ10iUejGIym31hNa+iSuuuMQ8jnZKr31\n4+2/mVZDWZSHDiJxfdvMTG6rAJ5zCzRtgnY9YXHI4F2p/autn4ldCXKdPmgO\nspeslCVhNQh+ZxN3FOzFVUWGTNYNAzEikUuZ3VQXHSLtjrizDLxutVtsQ92O\nFxG7PBMGy8l7xK8nE3RINxLUzmGhYI2AdC99a3uMV2Xuw9vwS+P5vkpYyIr0\ndBGOdgtN3xfdeoty7Pkj5AfDPqbmJds8OIdBbt/ao9DTtXMTsKOu1cYpwhWU\nhvV1z/UeP7Bl1ZARaRJu0ABO7Ugblk4TFhpvLjnURoa+3sKDJFRkCzHdlvd+\nMkjutGImKhLYAkvvKA1hKs3S8n9Mn9L+xwpPmmjw5xjznanHzDjnPDSYLEfr\nIxIVrlhmsPbZ0GSGM77AbQ5/ndNn3l+6HQ5jXjubwGJ9odKhxgs7bzGRoNp/\nA5Ei\r\n=Lykm\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEQCIHucDgf+/JkKRUm8bVl+zcEzMzGdnvbks21eHj+829VDAiBIwriYPMDgxnZeM56+/SuKcC6Vk4kPCUWcX53EUsyabQ=="
          }
        ]
      },
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "maintainers": [
        {
          "name": "jheer",
          "email": "jeffrey.heer@gmail.com"
        },
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "kanitw",
          "email": "kanitw@gmail.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.88.0_1614435312146_0.6708990178978524"
      },
      "_hasShrinkwrap": false
    },
    "0.89.0": {
      "name": "ts-json-schema-generator",
      "version": "0.89.0",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "MooYeol Prescott Lee",
          "email": "mooyoul@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=10.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.7",
        "commander": "^7.1.0",
        "fast-json-stable-stringify": "^2.1.0",
        "glob": "^7.1.6",
        "json-stable-stringify": "^1.0.1",
        "typescript": "~4.2.2"
      },
      "devDependencies": {
        "@babel/core": "^7.13.1",
        "@babel/preset-env": "^7.13.5",
        "@babel/preset-typescript": "^7.13.0",
        "@semantic-release/git": "^9.0.0",
        "@types/fast-json-stable-stringify": "^2.0.0",
        "@types/glob": "^7.1.3",
        "@types/jest": "^26.0.20",
        "@types/json-stable-stringify": "^1.0.32",
        "@types/node": "^14.14.31",
        "@typescript-eslint/eslint-plugin": "^4.15.2",
        "@typescript-eslint/parser": "^4.15.2",
        "ajv": "^7.1.1",
        "ajv-formats": "^1.5.1",
        "chai": "^4.3.0",
        "cross-env": "^7.0.3",
        "eslint": "^7.20.0",
        "eslint-config-prettier": "^8.1.0",
        "eslint-plugin-prettier": "^3.3.1",
        "jest": "^26.6.3",
        "jest-junit": "^12.0.0",
        "prettier": "^2.2.1",
        "semantic-release": "^17.4.0",
        "ts-node": "^9.1.1",
        "vega": "^5.19.1",
        "vega-lite": "^5.0.0"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint {src,test,factory}/**/*.ts",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "cross-env FAST_TEST=1 jest test/ --verbose",
        "test:coverage": "yarn jest test/ --collectCoverage=true",
        "test:update": "cross-env UPDATE_SCHEMA=true yarn test:fast",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts"
      },
      "release": {
        "plugins": [
          "@semantic-release/commit-analyzer",
          "@semantic-release/release-notes-generator",
          "@semantic-release/github",
          "@semantic-release/npm",
          [
            "@semantic-release/git",
            {
              "assets": [
                "package.json"
              ],
              "message": "chore(release): ${nextRelease.version}"
            }
          ]
        ]
      },
      "gitHead": "70afc127513129deca87188c596364bae4b8d6b9",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.89.0",
      "_nodeVersion": "10.24.0",
      "_npmVersion": "6.14.11",
      "dist": {
        "integrity": "sha512-1jmG5toW9CeswDbcYUwg9Z0bi9ZQtO/Dg9eJd7TxJgZWgj0bPxGZahkyoqomDrN0CruVNgquB2Y2wNDcVUO7qQ==",
        "shasum": "3335c9a9b337427f7354dcee1e0ffcfad2d9e90e",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.89.0.tgz",
        "fileCount": 601,
        "unpackedSize": 601484,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJgS5OpCRA9TVsSAnZWagAA8m4P/A83k1azb9bPrZRGi2YV\n1vaH2DcOiNVHt5MqhU/f0quLhx6Ms3yU/EitQym+WxnLleKjYrMmpCa9xcfH\nsDGdFubKGxl2ZdghZxE3NV94vaB0zbFMpr1jtNAmjgdmMZFUQlqNZIwNLb5d\nFVkxU4pXiJ+Q2m2Tpl9bgu/RFpEhDaKyZ2kYSe9epCi9cu5b7IZYbAFvSxAZ\nt4LLoCiTCEMlWDsJPv+686qBhZ6Kbhvk52Gf5SHaUVN61HuHrVVW7Vnz8ypH\noTkJ2bTyO6XqF89QdZDhWy0MHXej5oyO9+m+thPJNQJybyq/9i04l/Iq2mXa\nA8RCuTYkGlNfRrCx7wTWQB2x4Gj1cFsUYor3TP6SjeN3WrPH4cqTV5ZHlUTu\nkUTs/lglsuyPn0KQ9xPI685sk5YIWNicbGDdkA0+MNgoQ8Q1uGt7pSZlZbbI\nlm4j6ow6qOItjN+KHj30OHqeiA8RShm1xJIm+lx8rExSGTdIl7pvKK6IWqLy\n66JPBQ33tqYb5KFJwrPCK21tyM9dyvWTjSJ5ihnTt463NfWesOzPiusnPkFp\nygiglxWZY9kuPzSfAnHpazXgVS7ysH4I/NITsUgy75Q+93IU47Pp43nSODPk\nEHIhf5v6SX1aOFm7M37M3iRWtXoTtOEqUqiLopdlTuobnqWBTW5B6GnDTk3u\nmhaQ\r\n=aS2h\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIHVwiLMa+Arxh8ltwTanaPG0iZJkfcdhnBHbMUmtzMtFAiEAogFqQmWdTBIlSuV0APG2WKamS4u4QmPz0QAWxRmYb8w="
          }
        ]
      },
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "maintainers": [
        {
          "name": "jheer",
          "email": "jeffrey.heer@gmail.com"
        },
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "kanitw",
          "email": "kanitw@gmail.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.89.0_1615565737351_0.9125682863768154"
      },
      "_hasShrinkwrap": false
    },
    "0.89.1": {
      "name": "ts-json-schema-generator",
      "version": "0.89.1",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "MooYeol Prescott Lee",
          "email": "mooyoul@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=10.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.7",
        "commander": "^7.2.0",
        "fast-json-stable-stringify": "^2.1.0",
        "glob": "^7.1.6",
        "json-stable-stringify": "^1.0.1",
        "typescript": "~4.2.3"
      },
      "devDependencies": {
        "@babel/core": "^7.13.10",
        "@babel/preset-env": "^7.13.12",
        "@babel/preset-typescript": "^7.13.0",
        "@semantic-release/git": "^9.0.0",
        "@types/fast-json-stable-stringify": "^2.0.0",
        "@types/glob": "^7.1.3",
        "@types/jest": "^26.0.22",
        "@types/json-stable-stringify": "^1.0.32",
        "@types/node": "^14.14.36",
        "@typescript-eslint/eslint-plugin": "^4.19.0",
        "@typescript-eslint/parser": "^4.19.0",
        "ajv": "^7.2.4",
        "ajv-formats": "^1.5.1",
        "chai": "^4.3.4",
        "cross-env": "^7.0.3",
        "eslint": "^7.22.0",
        "eslint-config-prettier": "^8.1.0",
        "eslint-plugin-prettier": "^3.3.1",
        "jest": "^26.6.3",
        "jest-junit": "^12.0.0",
        "prettier": "^2.2.1",
        "semantic-release": "^17.4.2",
        "ts-node": "^9.1.1",
        "vega": "^5.20.0",
        "vega-lite": "^5.0.0"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint {src,test,factory}/**/*.ts",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "cross-env FAST_TEST=1 jest test/ --verbose",
        "test:coverage": "yarn jest test/ --collectCoverage=true",
        "test:update": "cross-env UPDATE_SCHEMA=true yarn test:fast",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts"
      },
      "release": {
        "plugins": [
          "@semantic-release/commit-analyzer",
          "@semantic-release/release-notes-generator",
          "@semantic-release/github",
          "@semantic-release/npm",
          [
            "@semantic-release/git",
            {
              "assets": [
                "package.json"
              ],
              "message": "chore(release): ${nextRelease.version}"
            }
          ]
        ]
      },
      "gitHead": "8af917045baaf3b711ebc901b11c1b146d35ff3a",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.89.1",
      "_nodeVersion": "10.24.0",
      "_npmVersion": "6.14.12",
      "dist": {
        "integrity": "sha512-RjdA8r/hh6lFCnhkFXVzVKB2LhciLrTXO+IuVMmA1CtY/wA4hrjUVfQl7HwJq5UxCwaXAUma6v+SqTuhy3rcQg==",
        "shasum": "c844760539bbb94019cd5c02acb1f08a9e9b71ea",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.89.1.tgz",
        "fileCount": 601,
        "unpackedSize": 601558,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJgXin4CRA9TVsSAnZWagAAK4AP/injcjtSY58ypVQXYLPV\nMLgBtM4/M6POjN6Je0h+ECnf8Oj7p3Vd2EUwS+3V/kueKHTL28dlTyE+rnYQ\nGq5P67AYVepkXCKInN7BBWtpA5k19pcVCblpmn3QNPa/TOh/MCnDuJ0MWP53\nzbNHvj6u5k+ZwGd2QJhxjww7QBH3nIqTObPzEPrqM3BFolAKVj1WA8IfP6AC\nKGI/WnnsRp/c3475cR9X2NoV4bmLDVHJOQ2G0AhDmMJfxBG2HVJS14AxDv3L\n7MZab2RFrAjbMigsSaOq8qARUJb51q724h0VTvi/vFFv03VZVIySyDL1CBlu\ngSrx7D8nEtFBpC5LDqs2FmKQ80Vv6L66yO3Z/PRBolDvzAikbU0vD4tcXmR0\n0n/C3grsoOzFsqINeXecNIQPHjgRTJSb7LfHz81Fwb+QE4rFlJL38Dw2Qcdh\n9wERzioZHWML4eZGVmpaHST8MFRvyftO3Bd8tCo7itSJVbnQs+jfm14bLILk\n8Xt3wNcij8v1xbn+s+AOHX+U28JKi/QK3Mww31dGRMG6/GwlP2cYhwwQeran\nwR+Bq0RZfbpQjO7A4KbL3pgC+4r68sg3rsqu4loBlGAnCKCwAeiRsde38XgF\n6nUeSm7z4Hz5fns2OgzQg+bhflZ/bVqbHUqy9ZZdSQgkAkYTGdxMpsmjvnZX\naM2r\r\n=6lZ/\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIQD4TAla+XDR424StfxdSX5K3on7ECk0C4On5VdUqTP3ogIgHnvcGlm7XdV5a/4NjkrSLxMB8UKMS5uphCtSLDMgjQ0="
          }
        ]
      },
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "maintainers": [
        {
          "name": "jheer",
          "email": "jeffrey.heer@gmail.com"
        },
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "kanitw",
          "email": "kanitw@gmail.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.89.1_1616783864180_0.2678561498596832"
      },
      "_hasShrinkwrap": false
    },
    "0.89.2": {
      "name": "ts-json-schema-generator",
      "version": "0.89.2",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "MooYeol Prescott Lee",
          "email": "mooyoul@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=10.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.7",
        "commander": "^7.2.0",
        "fast-json-stable-stringify": "^2.1.0",
        "glob": "^7.1.6",
        "json-stable-stringify": "^1.0.1",
        "typescript": "~4.2.3"
      },
      "devDependencies": {
        "@babel/core": "^7.13.14",
        "@babel/preset-env": "^7.13.12",
        "@babel/preset-typescript": "^7.13.0",
        "@semantic-release/git": "^9.0.0",
        "@types/fast-json-stable-stringify": "^2.0.0",
        "@types/glob": "^7.1.3",
        "@types/jest": "^26.0.22",
        "@types/json-stable-stringify": "^1.0.32",
        "@types/node": "^14.14.37",
        "@typescript-eslint/eslint-plugin": "^4.20.0",
        "@typescript-eslint/parser": "^4.20.0",
        "ajv": "^8.0.5",
        "ajv-formats": "^2.0.2",
        "chai": "^4.3.4",
        "cross-env": "^7.0.3",
        "eslint": "^7.23.0",
        "eslint-config-prettier": "^8.1.0",
        "eslint-plugin-prettier": "^3.3.1",
        "jest": "^26.6.3",
        "jest-junit": "^12.0.0",
        "prettier": "^2.2.1",
        "semantic-release": "^17.4.2",
        "ts-node": "^9.1.1",
        "vega": "^5.20.2",
        "vega-lite": "^5.0.0"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint {src,test,factory}/**/*.ts",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "cross-env FAST_TEST=1 jest test/ --verbose",
        "test:coverage": "yarn jest test/ --collectCoverage=true",
        "test:update": "cross-env UPDATE_SCHEMA=true yarn test:fast",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts"
      },
      "release": {
        "plugins": [
          "@semantic-release/commit-analyzer",
          "@semantic-release/release-notes-generator",
          "@semantic-release/github",
          "@semantic-release/npm",
          [
            "@semantic-release/git",
            {
              "assets": [
                "package.json"
              ],
              "message": "chore(release): ${nextRelease.version}"
            }
          ]
        ]
      },
      "gitHead": "e31ecaf05630a70a53df841e59cb1342576607a9",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.89.2",
      "_nodeVersion": "10.24.0",
      "_npmVersion": "7.8.0",
      "dist": {
        "integrity": "sha512-fDKE80NvNgIomhuddRvuAyLKkI5RHdkvR19RckzyM2lLA/jWeFlCigZNjIqbsmw3duE1JSxuHHG3aEgJJUB/Cw==",
        "shasum": "077bd74e0846ab233acdce91b6fbf0cffd5e7954",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.89.2.tgz",
        "fileCount": 623,
        "unpackedSize": 877753,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJgak7HCRA9TVsSAnZWagAAHK4P/jVyVciQU1FRLy8jjmeJ\ntmkinRb/x4TxB8tth8T9vPEME9A1NAZfALZpTuuT2YjF1hKuUn86Kxfc+zGX\nKO77BxPAeBV74X+eFWKiBdaoADvOyPSMXGD0kIt9a/foabhtHJWT+4YpAXfs\n7Kc7ctgLup0eAEsPdwWxs8BtyRDfLfcopkNnWtpMAnDamFoFSiU8zPLqrfRY\nXVpR4geuEmmjaFPIQnTJEliZQ1W7TCa+DO2jfcXbn7b8GDprnH+4OvGn4iAs\nhT4iNiDPSYZHKO9BoSXz97nwoqxvmn9bhx5YJtMkmyrhxiDqo2q/EFoTYDBf\nY94nTSC8xlmQvv6+m4ema5lxMaotk4SX/kvWBvYaQJfzPtnJ7DZdzdW8Egj1\nCyFQ2VUEkfoWXNC8DcJEkWMS1kyVpYZrfqAaj04FjPo0KG+ouQsch46sEjGt\nvKCDf7l5lKut3K3OdAKbsg3XkZXnQDNnOvDmuYyN27fFoW646gxIaC6v5r98\nhm4KZ54waJXgW2wjOHuVwlLJvgfskxjkPiXvdrMrHZf5j7k9VT6M58GX4wXI\ngFLDdGRw4IxHwZAXCsepMPGy2A++4gWhpKcgBXMVEuY2jZLSHXOik0dYg8jQ\nh5zCTLWqlVRbv1vP7vVAQ/Z5RvynCJYiQvuu+W5cYB7/DGilixTs0bPOOL2e\n4guD\r\n=L2Vd\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEQCIFlz/oWUzwWBJxMFGui1uWc3/uOpVMEo75/5NHGG25q9AiAOkD+w6AfTHfQLVrMIPE7faILTMucXVnMan0i6EigNDQ=="
          }
        ]
      },
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "maintainers": [
        {
          "name": "jheer",
          "email": "jeffrey.heer@gmail.com"
        },
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "kanitw",
          "email": "kanitw@gmail.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.89.2_1617579719093_0.8345472483614385"
      },
      "_hasShrinkwrap": false
    },
    "0.89.3": {
      "name": "ts-json-schema-generator",
      "version": "0.89.3",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "MooYeol Prescott Lee",
          "email": "mooyoul@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=10.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.7",
        "commander": "^7.2.0",
        "fast-json-stable-stringify": "^2.1.0",
        "glob": "^7.1.6",
        "json-stable-stringify": "^1.0.1",
        "typescript": "~4.2.3"
      },
      "devDependencies": {
        "@babel/core": "^7.13.14",
        "@babel/preset-env": "^7.13.12",
        "@babel/preset-typescript": "^7.13.0",
        "@semantic-release/git": "^9.0.0",
        "@types/fast-json-stable-stringify": "^2.0.0",
        "@types/glob": "^7.1.3",
        "@types/jest": "^26.0.22",
        "@types/json-stable-stringify": "^1.0.32",
        "@types/node": "^14.14.37",
        "@typescript-eslint/eslint-plugin": "^4.20.0",
        "@typescript-eslint/parser": "^4.20.0",
        "ajv": "^8.0.5",
        "ajv-formats": "^2.0.2",
        "chai": "^4.3.4",
        "cross-env": "^7.0.3",
        "eslint": "^7.23.0",
        "eslint-config-prettier": "^8.1.0",
        "eslint-plugin-prettier": "^3.3.1",
        "jest": "^26.6.3",
        "jest-junit": "^12.0.0",
        "prettier": "^2.2.1",
        "semantic-release": "^17.4.2",
        "ts-node": "^9.1.1",
        "vega": "^5.20.2",
        "vega-lite": "^5.0.0"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint {src,test,factory}/**/*.ts",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "cross-env FAST_TEST=1 jest test/ --verbose",
        "test:coverage": "yarn jest test/ --collectCoverage=true",
        "test:update": "cross-env UPDATE_SCHEMA=true yarn test:fast",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts"
      },
      "release": {
        "plugins": [
          "@semantic-release/commit-analyzer",
          "@semantic-release/release-notes-generator",
          "@semantic-release/github",
          "@semantic-release/npm",
          [
            "@semantic-release/git",
            {
              "assets": [
                "package.json"
              ],
              "message": "chore(release): ${nextRelease.version}"
            }
          ]
        ]
      },
      "gitHead": "6ba526ae2905180c5b20d500aaa429e7c968ae1a",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.89.3",
      "_nodeVersion": "10.24.0",
      "_npmVersion": "7.8.0",
      "dist": {
        "integrity": "sha512-QXS/onFnVhUCgDsH0kr5ueZJIJlAgdIuF85CsJx5YE2SrqtcJn7hvwAMajRK0Hi3iUfS+b19TI7Bc6/11ECKFw==",
        "shasum": "619bbf451c7c71ef03be59232c5ac3512bcac671",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.89.3.tgz",
        "fileCount": 623,
        "unpackedSize": 878022,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJgcMOQCRA9TVsSAnZWagAAJecP/2scetyatdIx9j1wF9pE\ncamRFUHBWh1NgSvAOdtAvHjcj55+Sdhh1iElN1YU+ci/TnBoKyNuJuNlA3OQ\nlBV5Q2Wd+iwZWhnuNo75Z5Jb1XzsAwPDUx9w9Pf43Dt7IK2gGgs3HXEX0xKJ\ni9pEipB+TrL7a1yBrqvJB2vJGp5wSP69u3/40kRPDDWXnAJPq9Q0yNNxsBbD\n6KrvtEp+5JqySdb793xkwpnwsvlJZqgwcEN9CO4Ty9aNNgfdgspoltfu8bgk\nG6H/iY0NWTgp8B6ITvST2nlo+N1Dzg9SkLpAPBZZrc6WBEwT0oe6SDtRp7a7\neQUg+a8dx+VGT7Q4E5ER0c4OUs7ExAoXZBQ+S2MLBN3IPVrgX3YPfoEVQUuz\nQ1fFm72DTJVMOwA+iYj+0nF9vI1TVVs0FHuXgj//9dIfc0qO9jBSSKPsFYxh\nfV248ZTPkkSlRkl8M0I9zAYTndI3R5ZpoWEYI+4huzdLxBvy5ryTbQox+qqr\nfFDOFt5uUl/9Mo5KW8ol3ylbtw1yI+RXbrxCQC9EUJ3lhP+uxJCY4gfqK3YN\n6LTM7RTqX2p1W1Rl9dFgf5PuSw3XB2bnS3OLAvnAJy2XCIgliwFArhv5l9i/\n1RpV1nASy9lppYkIgc2W1mpq/5sC83mJvMR+rHAhbsryjPuvAAKr4eFgsBuL\nIWSf\r\n=Ch2a\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIQD4aDohslnTRvy+tRG0gMxHsv26rLgup9JyRw0eMfhfoAIgJYCjagmm5mAxqaOV7N2GSHHUut5HCBsczyDFuSabrZI="
          }
        ]
      },
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "maintainers": [
        {
          "name": "jheer",
          "email": "jeffrey.heer@gmail.com"
        },
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "kanitw",
          "email": "kanitw@gmail.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.89.3_1618002832362_0.8698714190637173"
      },
      "_hasShrinkwrap": false
    },
    "0.90.0": {
      "name": "ts-json-schema-generator",
      "version": "0.90.0",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "MooYeol Prescott Lee",
          "email": "mooyoul@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=10.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.7",
        "commander": "^7.2.0",
        "fast-json-stable-stringify": "^2.1.0",
        "glob": "^7.1.6",
        "json-stable-stringify": "^1.0.1",
        "typescript": "~4.2.3"
      },
      "devDependencies": {
        "@babel/core": "^7.13.14",
        "@babel/preset-env": "^7.13.12",
        "@babel/preset-typescript": "^7.13.0",
        "@semantic-release/git": "^9.0.0",
        "@types/fast-json-stable-stringify": "^2.0.0",
        "@types/glob": "^7.1.3",
        "@types/jest": "^26.0.22",
        "@types/json-stable-stringify": "^1.0.32",
        "@types/node": "^14.14.37",
        "@typescript-eslint/eslint-plugin": "^4.20.0",
        "@typescript-eslint/parser": "^4.20.0",
        "ajv": "^8.0.5",
        "ajv-formats": "^2.0.2",
        "chai": "^4.3.4",
        "cross-env": "^7.0.3",
        "eslint": "^7.23.0",
        "eslint-config-prettier": "^8.1.0",
        "eslint-plugin-prettier": "^3.3.1",
        "jest": "^26.6.3",
        "jest-junit": "^12.0.0",
        "prettier": "^2.2.1",
        "semantic-release": "^17.4.2",
        "ts-node": "^9.1.1",
        "vega": "^5.20.2",
        "vega-lite": "^5.0.0"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint {src,test,factory}/**/*.ts",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "cross-env FAST_TEST=1 jest test/ --verbose",
        "test:coverage": "yarn jest test/ --collectCoverage=true",
        "test:update": "cross-env UPDATE_SCHEMA=true yarn test:fast",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts"
      },
      "release": {
        "plugins": [
          "@semantic-release/commit-analyzer",
          "@semantic-release/release-notes-generator",
          "@semantic-release/github",
          "@semantic-release/npm",
          [
            "@semantic-release/git",
            {
              "assets": [
                "package.json"
              ],
              "message": "chore(release): ${nextRelease.version}"
            }
          ]
        ]
      },
      "gitHead": "a6db8b010fcd9db1b7f097ae9bc8efb9c3295dcb",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.90.0",
      "_nodeVersion": "10.24.0",
      "_npmVersion": "7.8.0",
      "dist": {
        "integrity": "sha512-BAbZVcNowsHTUgoZfwhM5Uv7EUiweXkb/9EOIO0Rj07qHNMOg/fQt1NrcjpvNpvs96qSaWK2jXsnTKwkbftH4g==",
        "shasum": "10ab74cc474d50b982ee5560062c17a3b4d98451",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.90.0.tgz",
        "fileCount": 623,
        "unpackedSize": 879362,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJgdz24CRA9TVsSAnZWagAA4/MP/0pKIycMISG1bCVKfJ/t\n/HTR8ABx7V2nFcXCjuyvP7y6CtTNGIOqVzFeNCdv9EtJPV/2YmXXlOzLys6B\nt2I9My49ZsUngT8+jtyjf+W4UarRUCtpyq3sZ0Lj8w4kuw9gxm4Gx45fdZUg\nh55z/hzFQVrcqnjcFZVFRjxxzjy0HXK6N6OO3uAcy1R18N48vvZdS7ynXlt0\na1O0KcNUeUkxvcW/u/EfWRRGAI4EWaE5GegcHeWP5HZLQh5pHxsf54GNTTS+\nU5FOmWG5IrO1/Xc/psi4ff4ADTFKjvY9VIXw6WOVKtoDuDihNKca+6SdJFzJ\n+DbTvSUDDTltqmeKGwew+CqA2hgSLl9dK0Tq2AG3LymEjmA5tiExZeYBNKeR\nyatCH6JcBnKxGQ/NaZF/wiPGXuJPChrECZCB5826vaY/ohKfw6/jGg8u8yn5\nrC5Q31JJDzt6LAG1FqKHIBXxTDlhyufgQdMUssRE4jxwagk/saPZKkdBCT97\nHn5PF2wIiGLF1f7ri2zIkdWBI0fmqgNjsO3PJC1ttvG0URlL01Zk+lJ9Pp/n\nfRK5fDc0r+qyMP0pso14LRnIbH2rhTZR4M7iBcDD4Cn4R11uaJiFzIysvuW8\nZubrhcwHCItLf9/dbaSUOcbV/c32jz3ZAnUs2ICTEJF+vh87cXKY94mCwGB6\nsYM4\r\n=lTzu\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIEdOkFWpLtommQu2fVg97tgvsxYPMcHUrNDOO+uut8kZAiEA77YlmvZZH92q76/kC3obRJ1o06fZUPJVwDnIVR02eP8="
          }
        ]
      },
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "maintainers": [
        {
          "name": "jheer",
          "email": "jeffrey.heer@gmail.com"
        },
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "kanitw",
          "email": "kanitw@gmail.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.90.0_1618427319660_0.5074584336336319"
      },
      "_hasShrinkwrap": false
    },
    "0.91.0": {
      "name": "ts-json-schema-generator",
      "version": "0.91.0",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "MooYeol Prescott Lee",
          "email": "mooyoul@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=10.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.7",
        "commander": "^7.2.0",
        "fast-json-stable-stringify": "^2.1.0",
        "glob": "^7.1.6",
        "json-stable-stringify": "^1.0.1",
        "typescript": "~4.2.3"
      },
      "devDependencies": {
        "@babel/core": "^7.13.14",
        "@babel/preset-env": "^7.13.12",
        "@babel/preset-typescript": "^7.13.0",
        "@semantic-release/git": "^9.0.0",
        "@types/fast-json-stable-stringify": "^2.0.0",
        "@types/glob": "^7.1.3",
        "@types/jest": "^26.0.22",
        "@types/json-stable-stringify": "^1.0.32",
        "@types/node": "^14.14.37",
        "@typescript-eslint/eslint-plugin": "^4.20.0",
        "@typescript-eslint/parser": "^4.20.0",
        "ajv": "^8.0.5",
        "ajv-formats": "^2.0.2",
        "chai": "^4.3.4",
        "cross-env": "^7.0.3",
        "eslint": "^7.23.0",
        "eslint-config-prettier": "^8.1.0",
        "eslint-plugin-prettier": "^3.3.1",
        "jest": "^26.6.3",
        "jest-junit": "^12.0.0",
        "prettier": "^2.2.1",
        "semantic-release": "^17.4.2",
        "ts-node": "^9.1.1",
        "vega": "^5.20.2",
        "vega-lite": "^5.0.0"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint {src,test,factory}/**/*.ts",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "cross-env FAST_TEST=1 jest test/ --verbose",
        "test:coverage": "yarn jest test/ --collectCoverage=true",
        "test:update": "cross-env UPDATE_SCHEMA=true yarn test:fast",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts"
      },
      "release": {
        "plugins": [
          "@semantic-release/commit-analyzer",
          "@semantic-release/release-notes-generator",
          "@semantic-release/github",
          "@semantic-release/npm",
          [
            "@semantic-release/git",
            {
              "assets": [
                "package.json"
              ],
              "message": "chore(release): ${nextRelease.version}"
            }
          ]
        ]
      },
      "gitHead": "40b16b80994fc9c7bfde07148c4f31050fcb43c0",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.91.0",
      "_nodeVersion": "10.24.1",
      "_npmVersion": "7.8.0",
      "dist": {
        "integrity": "sha512-+B0By9MyPFA7zQjPt/UgJkY+HuoiIawy5WTdH/Vss21qvvBlOhx3tlGWfu/cQhN2qfVohsfyMa3YFCaUArxyzg==",
        "shasum": "93ecf4f7122ad7dbe67f6c6175f7c5ba0a547a48",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.91.0.tgz",
        "fileCount": 631,
        "unpackedSize": 891474,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJggZuICRA9TVsSAnZWagAAcBUP+wU9vOBxe9KJssnfgz29\nep9nXzg2D+oJNHOgb8XRF6YejGRGjZNxNZptsoZKdq7VNb8S7CqdAZ4RJv6u\nYrD1Nq6/SImS2wLFm47xtZ/ysyanl1xWDH26sKeCnFXr8fpsL1qa+DDKSUIP\nzUOgzxoOMG/U/uDqpCzcB71oVbPWJmfqgXXnuukgafEtr4Mqn/8Ic4IsEMVf\n6cmjJ0HCbWgB+eZwkTKvyMuRPxJ2vMoqfPZoNCcpvk+eUzUisO1XnnMsLMwD\nYBPEgF5DCLt/g0KFs4iDXD6S0LtJMYS6Epij+QQPvafBjY0n1FvTad7hFO43\nD23kqDNN5izdz7043E3pFcnzd7S4M8sSuPw9KXuClwLEKxQqrhgM82NLKjhY\nFKSsJ4HK2NxPQFqQDQmr1254VJFC2C5vV3+RH8xhimVTHp9H2sadeFpWe/xo\nhJJ4TUK/SmAzQCYuWR81rmKmWx1GL9h7/oqvTKrwG0hK9FNwWe90Xu68Vdql\nV+FpZ9O/p0aOCvan83TdOzwNt0YGHeGB2vEyuHjoSo0eqBjXk9soLhhm6XZn\n+motYRTGGOsHVjyWd5ypYtP21t8EQEHdGdtJUMm3qCnDIBWbGInwQfL+p3GF\nlCM42WN7BNa1JKoVG6IoO2lW8R/4exl+EWdonhu98w8tqCh2++DvaCHxpDXA\nxJgz\r\n=qDO/\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEYCIQDQ0uXvLFlqVOHCtjhk7+NU5Ozo6SzgP/JHnu+a6ke45gIhAOJiIfWTXD7WfuJ++a4SNvIaiD/c4z2dzqlUZpHVydq8"
          }
        ]
      },
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "maintainers": [
        {
          "name": "jheer",
          "email": "jeffrey.heer@gmail.com"
        },
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "kanitw",
          "email": "kanitw@gmail.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.91.0_1619106695784_0.44994436057001375"
      },
      "_hasShrinkwrap": false
    },
    "0.92.0": {
      "name": "ts-json-schema-generator",
      "version": "0.92.0",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "MooYeol Prescott Lee",
          "email": "mooyoul@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=10.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.7",
        "commander": "^7.2.0",
        "fast-json-stable-stringify": "^2.1.0",
        "glob": "^7.1.6",
        "json-stable-stringify": "^1.0.1",
        "typescript": "~4.2.4"
      },
      "devDependencies": {
        "@babel/core": "^7.13.16",
        "@babel/preset-env": "^7.13.15",
        "@babel/preset-typescript": "^7.13.0",
        "@semantic-release/git": "^9.0.0",
        "@types/fast-json-stable-stringify": "^2.0.0",
        "@types/glob": "^7.1.3",
        "@types/jest": "^26.0.23",
        "@types/json-stable-stringify": "^1.0.32",
        "@types/node": "^15.0.0",
        "@typescript-eslint/eslint-plugin": "^4.22.0",
        "@typescript-eslint/parser": "^4.22.0",
        "ajv": "^8.1.0",
        "ajv-formats": "^2.0.2",
        "chai": "^4.3.4",
        "cross-env": "^7.0.3",
        "eslint": "^7.25.0",
        "eslint-config-prettier": "^8.3.0",
        "eslint-plugin-prettier": "^3.4.0",
        "jest": "^26.6.3",
        "jest-junit": "^12.0.0",
        "prettier": "^2.2.1",
        "semantic-release": "^17.4.2",
        "ts-node": "^9.1.1",
        "vega": "^5.20.2",
        "vega-lite": "^5.1.0"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint {src,test,factory}/**/*.ts",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "cross-env FAST_TEST=1 jest test/ --verbose",
        "test:coverage": "yarn jest test/ --collectCoverage=true",
        "test:update": "cross-env UPDATE_SCHEMA=true yarn test:fast",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts"
      },
      "release": {
        "plugins": [
          "@semantic-release/commit-analyzer",
          "@semantic-release/release-notes-generator",
          "@semantic-release/github",
          "@semantic-release/npm",
          [
            "@semantic-release/git",
            {
              "assets": [
                "package.json"
              ],
              "message": "chore(release): ${nextRelease.version}"
            }
          ]
        ]
      },
      "gitHead": "2308f9ad5b4a3930dab3ae16a94422ae0ef2c325",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.92.0",
      "_nodeVersion": "14.16.1",
      "_npmVersion": "7.11.1",
      "dist": {
        "integrity": "sha512-tuk8I+UF/r2RpgyWxKjlKa+q8JQqTbSZ5iuWnf4TYzJkyH0tgPgynGy0jkWHotNZgbT6+TPvzlShXo5aXgI6Iw==",
        "shasum": "a77dd06ad6ba302d7fddb9fa18ad9754994c6b71",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.92.0.tgz",
        "fileCount": 631,
        "unpackedSize": 896218,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJglcR2CRA9TVsSAnZWagAAeYIQAJWfeW4SV1sA+w0ScdKd\nb9wKm4NDBcWZJyXhx3wJzB4O1BW5hw8bPf7w7ichoTWc9GCc76gT5+l5iXN8\nDIMcQCVP2BsL0CT9Z93u27cGL1n7Ff6BEj5P0ydT0KTnGVMOfeJ4CxIILTzZ\nzezxWaueOP3vAvrM9a3xHkmTGqXzekQSbAwZRrFMOHUpd5amESm6e4oUTbT+\nct0gZQoz9I949hW4l1uDDgVF9rLspdQgYoCInY6LI72GVxowxMtiBDnQPLTM\ngBYyR19HHrL1LYaLKXVHzjE9ccMYxhgbCsy9MOKgXP3rQB3DsNj7AnBbAsnf\npT2Xpag9KZ8GC8hOGMqhkO/A1w0PX6AUnVzuzgzNjScXzgsLGxs4r8CDvi8d\nX49FDZtx2RXJdiIoIR5x5/OhzKd+QMYPp9iSRJNNZYdORVubRdZR51y40f4E\nxoGOn3P5CKjThmZx3L3aM1zY64NpYbkCUaC1sJKzt/ld11BFXCW2CVnPwr92\n2RVP1K9sY5cQyPrvXVydVAf+YVeyyR4uAxSbgALIVz6L6bGaZqcMGCgz/vgy\n2Og79f5CuvU1K7e7XbnoIVs8PIiAwaCMPMgW99pyI5CPidOUIOo9FLbL3F8s\nI/KMyLg3S38YjeUZJoAZ+J3WAGdMd9y+XJWmjMwHLjbeSow4M13c+7+JIgTf\neA4Q\r\n=C3xd\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEQCIByPQYZLTts1TwP66BPmkWOho/nTuFTO9V81iGruGSitAiB8znw6v/XcMOWU6XnaKGB134GXE9Q8IugVHNdzRZdvLQ=="
          }
        ]
      },
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "maintainers": [
        {
          "name": "jheer",
          "email": "jeffrey.heer@gmail.com"
        },
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "kanitw",
          "email": "kanitw@gmail.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.92.0_1620427893619_0.7190104601013154"
      },
      "_hasShrinkwrap": false
    },
    "0.93.0": {
      "name": "ts-json-schema-generator",
      "version": "0.93.0",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "MooYeol Prescott Lee",
          "email": "mooyoul@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=10.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.7",
        "commander": "^7.2.0",
        "fast-json-stable-stringify": "^2.1.0",
        "glob": "^7.1.7",
        "json-stable-stringify": "^1.0.1",
        "typescript": "~4.3.2"
      },
      "devDependencies": {
        "@babel/core": "^7.14.3",
        "@babel/preset-env": "^7.14.2",
        "@babel/preset-typescript": "^7.13.0",
        "@semantic-release/git": "^9.0.0",
        "@types/glob": "^7.1.3",
        "@types/jest": "^26.0.23",
        "@types/json-stable-stringify": "^1.0.32",
        "@types/node": "^15.6.1",
        "@typescript-eslint/eslint-plugin": "^4.25.0",
        "@typescript-eslint/parser": "^4.25.0",
        "ajv": "^8.5.0",
        "ajv-formats": "^2.1.0",
        "chai": "^4.3.4",
        "cross-env": "^7.0.3",
        "eslint": "^7.27.0",
        "eslint-config-prettier": "^8.3.0",
        "eslint-plugin-prettier": "^3.4.0",
        "jest": "^27.0.1",
        "jest-junit": "^12.1.0",
        "prettier": "^2.3.0",
        "semantic-release": "^17.4.3",
        "ts-node": "^10.0.0",
        "vega": "^5.20.2",
        "vega-lite": "^5.1.0"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint {src,test,factory}/**/*.ts",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "cross-env FAST_TEST=1 jest test/ --verbose",
        "test:coverage": "yarn jest test/ --collectCoverage=true",
        "test:update": "cross-env UPDATE_SCHEMA=true yarn test:fast",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts"
      },
      "release": {
        "plugins": [
          "@semantic-release/commit-analyzer",
          "@semantic-release/release-notes-generator",
          "@semantic-release/github",
          "@semantic-release/npm",
          [
            "@semantic-release/git",
            {
              "assets": [
                "package.json"
              ],
              "message": "chore(release): ${nextRelease.version}"
            }
          ]
        ]
      },
      "gitHead": "cd1ec8321569d9e17d42f10051881dccb6d7e0ae",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.93.0",
      "_nodeVersion": "14.17.0",
      "_npmVersion": "7.14.0",
      "dist": {
        "integrity": "sha512-JYacSIgw4KqsOXF/zRSY4pE/v6jUk7aMDXhwK5MdopN0UeKH58TRZHrQADy9uxTf78jqUfFLzARQKNOb9H+jVQ==",
        "shasum": "3d6adf99446a1b3d0887dbad7cca015a49394d3a",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.93.0.tgz",
        "fileCount": 631,
        "unpackedSize": 715939,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJgrrSzCRA9TVsSAnZWagAAK8cQAJjHTlEzwH1dC+PxVnQD\n5CHbZAz5564vqjV7XcWuZ1Cw4HXfbUXO0Z7/rhNmmR5YR7vpFe5Hj04iTmOs\nIqfDOBZtpTGIDDC3qTEtc0q2PrdlUDlFTQ/4gfjZqaTb6MGjfZo4rPNJg0JD\nVoXyG3P6vv9t8G66WFMzObinQ57CxTb3gH1S3xDbeFKCOK1QFKXvoJLHfOVZ\nzv/Y9uihs1m6ciiHoNxnlgKCnpJPLaGbEVVbFUFDKK0WMHQOSWIKHmad4Guy\nL/NemEaEpsSUhDusYK2MlM3fA1KPLS4MbcV8R82F2Mwb+ABZkK4mMy9I35k7\nB0A14GLp6mbrpzhP8YBOx88C+su6CngfYYplI+aLs+WcCpcwr8QWN23rLVHz\nEnKwQbCWgXErFutMGrsGrSzJ6ArH6PCBLMoEQPAbmsPKNEhtkpg7rL8Oc69e\n1sLHjf3YUdZNxBlw/PFEr4wzjKGZhMwBbk1h+8gHEOFaHZ5NTE/VALXNOur0\nJ2lvbHNtYIno3ryk+VTQk37CHIJVJqiJjfAdzQzMBGa2UGhFcZOawcRZ0O1L\nt79jBuf5oJvwbBoINb2AHWCuXjqRSac9jCYA++2JZqvpODWUHJwA+O/9WGKE\nlw3S/zGklgVCzHMxPAUTTnofTzdZ4nCpKjpBn6jTnFewzI64irKunpnIirfv\nq7nn\r\n=pw0q\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEYCIQCbJZ2HY4J1EvL6UKBAex0MtFi673an4JihvFZhMjstKwIhAPtowURISRFLzrwjofRoYSXz1LiV7zu5bjRthUXTvKSr"
          }
        ]
      },
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "maintainers": [
        {
          "name": "jheer",
          "email": "jeffrey.heer@gmail.com"
        },
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "kanitw",
          "email": "kanitw@gmail.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.93.0_1622062259159_0.22537797945901294"
      },
      "_hasShrinkwrap": false
    },
    "0.94.0": {
      "name": "ts-json-schema-generator",
      "version": "0.94.0",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "MooYeol Prescott Lee",
          "email": "mooyoul@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=10.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.7",
        "commander": "^8.0.0",
        "fast-json-stable-stringify": "^2.1.0",
        "glob": "^7.1.7",
        "json-stable-stringify": "^1.0.1",
        "typescript": "~4.3.4"
      },
      "devDependencies": {
        "@babel/core": "^7.14.6",
        "@babel/preset-env": "^7.14.7",
        "@babel/preset-typescript": "^7.14.5",
        "@semantic-release/git": "^9.0.0",
        "@types/glob": "^7.1.3",
        "@types/jest": "^26.0.23",
        "@types/json-stable-stringify": "^1.0.32",
        "@types/node": "^15.12.5",
        "@typescript-eslint/eslint-plugin": "^4.28.1",
        "@typescript-eslint/parser": "^4.28.1",
        "ajv": "^8.6.0",
        "ajv-formats": "^2.1.0",
        "chai": "^4.3.4",
        "cross-env": "^7.0.3",
        "eslint": "^7.29.0",
        "eslint-config-prettier": "^8.3.0",
        "eslint-plugin-prettier": "^3.4.0",
        "jest": "^27.0.6",
        "jest-junit": "^12.2.0",
        "prettier": "^2.3.2",
        "semantic-release": "^17.4.4",
        "ts-node": "^10.0.0",
        "vega": "^5.20.2",
        "vega-lite": "^5.1.0"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint {src,test,factory}/**/*.ts",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "cross-env FAST_TEST=1 jest test/ --verbose",
        "test:coverage": "yarn jest test/ --collectCoverage=true",
        "test:update": "cross-env UPDATE_SCHEMA=true yarn test:fast",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts"
      },
      "release": {
        "plugins": [
          "@semantic-release/commit-analyzer",
          "@semantic-release/release-notes-generator",
          "@semantic-release/github",
          "@semantic-release/npm",
          [
            "@semantic-release/git",
            {
              "assets": [
                "package.json"
              ],
              "message": "chore(release): ${nextRelease.version}"
            }
          ]
        ]
      },
      "gitHead": "f76840ac17ff557844a422dfe82786096c5edd48",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.94.0",
      "_nodeVersion": "14.17.1",
      "_npmVersion": "7.19.0",
      "dist": {
        "integrity": "sha512-kqcwnQCcUH/LshYxasQwY+opzfbGs9UhYLhp1vW5NH6Qgxv4UA6j6qJ3ocGI0KWTzjnmPxolaouw0K+dfgAZKQ==",
        "shasum": "e06298c9988e3718e993a4ce806d5909cf43a0c0",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.94.0.tgz",
        "fileCount": 631,
        "unpackedSize": 719199,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJg4NpuCRA9TVsSAnZWagAAk3UP/391dYsoecn+ByPUKe2q\n7ch5e9LMVHWx2qGDxqHdh1WxE96P8IaVUMwvN6ylnU8/f9U4hF3HuS65/doy\neVKnFdbffDXb9gsFXEbKUEC1cZyBkao+U2dmCcxAfmyRhWh0wXzV5A35e/WC\nUYnPA+Szmpk3TV6dcSqmwb9AeqfZO4YGg1LhClo30lRl6dccD0XLrXpSJRxS\nuFKhBqUaXL8h8DtX1grmtYAcY0hC4Qv/Oq577QWuP9kM+dPyudlrkVrG6M/e\nWbpUxed8Qj1AjaLE4LVc+gYcneqkHyLV/EbRvUeZOAfSZF8f2pDdZJopEEKU\nbnDHDdcM/FyeY8pDKJ0Y30xpcU2ncaOGle8O7+QumYiuc+5iOcQW1N5S2Iav\ndVYy52tdFFlgC3duOIfBFtJ8mrWxFzzldSJsQm2oPORPDK3JHbzWkRPcZEt3\nZhzYN1/YGfaK23QFXkyQ/Qee5Wnr/5Jgi5q/6etNEGq2z8LFpkQwU+r/E1UB\n3emG/hYVV0I1oQEfhxSe00iFLbGgtG4vju50T978ldqS6ydAgRn0YYILlMYr\nnGIzyf0PCQvemB49Cl+IujrzZqpWXGwyC2rJSdIcb6eaGIG93QbKcwE+PeP3\ngyGPdntIxEBG4hF6BSTMlSqmfRse3LUKYXVWdZBtaLsu20bEX0YSR5kzn3Y9\nmiJz\r\n=jc7d\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIH2YibE9ddaQa+cfaVEPpJv2a47hXxBgBkr88pTKvr+YAiEAzzyazQgasYqCwh7lmsxvahqC3aSp0Jq1VTwo9cytVqM="
          }
        ]
      },
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "maintainers": [
        {
          "name": "jheer",
          "email": "jeffrey.heer@gmail.com"
        },
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "kanitw",
          "email": "kanitw@gmail.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.94.0_1625348717492_0.28120066363997664"
      },
      "_hasShrinkwrap": false
    },
    "0.94.1": {
      "name": "ts-json-schema-generator",
      "version": "0.94.1",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "MooYeol Prescott Lee",
          "email": "mooyoul@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=10.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.7",
        "commander": "^8.0.0",
        "fast-json-stable-stringify": "^2.1.0",
        "glob": "^7.1.7",
        "json-stable-stringify": "^1.0.1",
        "typescript": "~4.3.4"
      },
      "devDependencies": {
        "@babel/core": "^7.14.6",
        "@babel/preset-env": "^7.14.7",
        "@babel/preset-typescript": "^7.14.5",
        "@semantic-release/git": "^9.0.0",
        "@types/glob": "^7.1.3",
        "@types/jest": "^26.0.23",
        "@types/json-stable-stringify": "^1.0.32",
        "@types/node": "^16.0.0",
        "@typescript-eslint/eslint-plugin": "^4.28.1",
        "@typescript-eslint/parser": "^4.28.1",
        "ajv": "^8.6.0",
        "ajv-formats": "^2.1.0",
        "chai": "^4.3.4",
        "cross-env": "^7.0.3",
        "eslint": "^7.29.0",
        "eslint-config-prettier": "^8.3.0",
        "eslint-plugin-prettier": "^3.4.0",
        "jest": "^27.0.6",
        "jest-junit": "^12.2.0",
        "prettier": "^2.3.2",
        "semantic-release": "^17.4.4",
        "ts-node": "^10.0.0",
        "vega": "^5.20.2",
        "vega-lite": "^5.1.0"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint \"{src,test,factory}/**/*.ts\"",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "cross-env FAST_TEST=1 jest test/ --verbose",
        "test:coverage": "yarn jest test/ --collectCoverage=true",
        "test:update": "cross-env UPDATE_SCHEMA=true yarn test:fast",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts"
      },
      "release": {
        "plugins": [
          "@semantic-release/commit-analyzer",
          "@semantic-release/release-notes-generator",
          "@semantic-release/github",
          "@semantic-release/npm",
          [
            "@semantic-release/git",
            {
              "assets": [
                "package.json"
              ],
              "message": "chore(release): ${nextRelease.version}"
            }
          ]
        ]
      },
      "gitHead": "b57186465b6e4e67234800ba82014f0576e2ff2b",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.94.1",
      "_nodeVersion": "14.17.1",
      "_npmVersion": "7.19.0",
      "dist": {
        "integrity": "sha512-v2onRxViC7Q5jAvzwfhevbWrd6EUQ/v+s2ey1RcX2oZ67ENdTumwkr434BtbW286P8z/SNmkmLE8I1AOcSbWSw==",
        "shasum": "cfecf63cdb2bbbed30c8da2bfc74a8dfb30aa14e",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.94.1.tgz",
        "fileCount": 631,
        "unpackedSize": 725746,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJg5ichCRA9TVsSAnZWagAA6AYP/3/1GrInGx55B4eLOiqj\nF5FCvnyvxOTAlRGndOgKyNlvz07P8/SrJlvYsbL7Rg+sjNRHmeGGkaNqwM7i\n08VHfcMvJkNxoQl4vLe2agz2EloUDK3tGm+4SpPjPH3YtXmkONpTLnVS9Hhi\nRF5PDBX5G7hwRj4UzqEkMD5Ek5W2T2ZDLRsIw983+L4SJQK0xNzv++D6aCc1\n24G9Js49iXBT5D6RIxhlYEZP1U/KEioILE+yOmesWCSszLEgXawCPj+MaDJW\nMTexZTtzPbttnsQv/p1HWTI6JLkgW2nm4Z4RC7+yx5ksXn2GCF5+A1zNxE+T\ne7m+zoH5fITIAaQoquwskjkV/oTwK3kjb/EkaKCroLuYBOFqfRJ86NVRZEPK\no7MIXO2myNmEkzg7vJvoSGT/yoyfZ5TxY4b8kVwTy03r4iGQ9qn8m2GoWzvI\nSj//iDwM/truR3GsxDBVC/kMK21bfy/lCXYDa26nRHqJKlwmDZohLIgcTqSQ\nOSi5lY13fSCxyYGa8fJjY0k7bOwmoPt4n63JoSIdq2NUP1Cz9MeiViEiC9Ro\nzktWrJSe9BWlQl//M1aslt8dTJJ++2Bfq6JM/ae3ZK/9D5K3gMZ8xheGjEhQ\njM5bvIDLQIv8wfqDQRf4lAusxJOwppNgLwuicwzgbGfkn6N762HK/91u9oIB\n7k5y\r\n=f1mq\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEYCIQCRruGz81rdAVb+soTmgzoHoX+LCnVNZxPflb13VWafiAIhAO56/7GjxkdhZ51BEArFifBvD6DFbkQfayX3YVgQ0H+4"
          }
        ]
      },
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "maintainers": [
        {
          "name": "jheer",
          "email": "jeffrey.heer@gmail.com"
        },
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "kanitw",
          "email": "kanitw@gmail.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.94.1_1625696032544_0.30591446582825443"
      },
      "_hasShrinkwrap": false
    },
    "0.94.2--canary.856.f772d29.0": {
      "name": "ts-json-schema-generator",
      "version": "0.94.2--canary.856.f772d29.0",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "MooYeol Prescott Lee",
          "email": "mooyoul@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=10.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.7",
        "commander": "^8.0.0",
        "fast-json-stable-stringify": "^2.1.0",
        "glob": "^7.1.7",
        "json-stable-stringify": "^1.0.1",
        "typescript": "~4.3.4"
      },
      "devDependencies": {
        "@auto-it/conventional-commits": "^10.29.3",
        "@auto-it/first-time-contributor": "^10.29.3",
        "@babel/core": "^7.14.6",
        "@babel/preset-env": "^7.14.7",
        "@babel/preset-typescript": "^7.14.5",
        "@semantic-release/git": "^9.0.0",
        "@types/glob": "^7.1.3",
        "@types/jest": "^26.0.23",
        "@types/json-stable-stringify": "^1.0.32",
        "@types/node": "^16.0.0",
        "@typescript-eslint/eslint-plugin": "^4.28.1",
        "@typescript-eslint/parser": "^4.28.1",
        "ajv": "^8.6.0",
        "ajv-formats": "^2.1.0",
        "auto": "^10.29.3",
        "chai": "^4.3.4",
        "cross-env": "^7.0.3",
        "eslint": "^7.29.0",
        "eslint-config-prettier": "^8.3.0",
        "eslint-plugin-prettier": "^3.4.0",
        "jest": "^27.0.6",
        "jest-junit": "^12.2.0",
        "prettier": "^2.3.2",
        "semantic-release": "^17.4.4",
        "ts-node": "^10.0.0",
        "vega": "^5.20.2",
        "vega-lite": "^5.1.0"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint \"{src,test,factory}/**/*.ts\"",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "cross-env FAST_TEST=1 jest test/ --verbose",
        "test:coverage": "yarn jest test/ --collectCoverage=true",
        "test:update": "cross-env UPDATE_SCHEMA=true yarn test:fast",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts",
        "release": "yarn build && auto shipit"
      },
      "release": {
        "plugins": [
          "@semantic-release/commit-analyzer",
          "@semantic-release/release-notes-generator",
          "@semantic-release/github",
          "@semantic-release/npm",
          [
            "@semantic-release/git",
            {
              "assets": [
                "package.json"
              ],
              "message": "chore(release): ${nextRelease.version}"
            }
          ]
        ]
      },
      "readme": "# ts-json-schema-generator\n\n![Test](https://github.com/vega/ts-json-schema-generator/workflows/Test/badge.svg)\n[![codecov](https://codecov.io/gh/vega/ts-json-schema-generator/branch/master/graph/badge.svg)](https://codecov.io/gh/vega/ts-json-schema-generator)\n[![npm version](https://img.shields.io/npm/v/ts-json-schema-generator.svg)](https://www.npmjs.com/package/ts-json-schema-generator)\n\nExtended version of [https://github.com/xiag-ag/typescript-to-json-schema](https://github.com/xiag-ag/typescript-to-json-schema).\n\nInspired by [`YousefED/typescript-json-schema`](https://github.com/YousefED/typescript-json-schema). Here's the differences list:\n\n-   this implementation avoids the use of `typeChecker.getTypeAtLocation()` (so probably it keeps correct type aliases)\n-   processing AST and formatting JSON schema have been split into two independent steps\n-   not exported types, interfaces, enums are not exposed in the `definitions` section in the JSON schema\n\n## Contributors\n\nThis project is made possible by a [community of contributors](https://github.com/vega/ts-json-schema-generator/graphs/contributors). We welcome contributions of any kind (issues, code, documentation, examples, tests,...). Please read our [code of conduct](https://github.com/vega/vega/blob/master/CODE_OF_CONDUCT.md).\n\n## CLI Usage\n\n```bash\nnpm install --save ts-json-schema-generator\n./node_modules/.bin/ts-json-schema-generator --path 'my/project/**/*.ts' --type 'My.Type.Name'\n```\n\nNote that different platforms (e.g. Windows) may use different path separators so you may have to adjust the command above.\n\n## Programmatic Usage\n\n```js\n// main.js\n\nconst tsj = require(\"ts-json-schema-generator\");\nconst fs = require(\"fs\");\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst output_path = \"path/to/output/file\";\n\nconst schema = tsj.createGenerator(config).createSchema(config.type);\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\nRun the schema generator via `node main.js`.\n\n### Custom formatting\n\nExtending the built-in formatting is possible by creating a custom formatter and adding it to the main formatter:\n\n1. First we create a formatter, in this case for formatting function types:\n\n```ts\n// my-function-formatter.ts\nimport { BaseType, Definition, FunctionType, SubTypeFormatter } from \"ts-json-schema-generator\";\nimport ts from \"typescript\";\n\nexport class MyFunctionTypeFormatter implements SubTypeFormatter {\n    // You can skip this line if you don't need childTypeFormatter\n    public constructor(private childTypeFormatter: TypeFormatter) {}\n\n    public supportsType(type: FunctionType): boolean {\n        return type instanceof FunctionType;\n    }\n\n    public getDefinition(type: FunctionType): Definition {\n        // Return a custom schema for the function property.\n        return {\n            type: \"object\",\n            properties: {\n                isFunction: {\n                    type: \"boolean\",\n                    const: true,\n                },\n            },\n        };\n    }\n\n    // If this type does NOT HAVE children, generally all you need is:\n    public getChildren(type: FunctionType): BaseType[] {\n        return [];\n    }\n\n    // However, if children ARE supported, you'll need something similar to\n    // this (see src/TypeFormatter/{Array,Definition,etc}.ts for some examples):\n    public getChildren(type: FunctionType): BaseType[] {\n        return this.childTypeFormatter.getChildren(type.getType());\n    }\n}\n```\n\n2. Then we add the formatter as a child to the core formatter using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyFunctionTypeFormatter } from \"./my-function-formatter.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\n// We configure the formatter an add our custom formatter to it.\nconst formatter = createFormatter(config, (fmt, circularReferenceTypeFormatter) => {\n    // If your formatter DOES NOT support children, e.g. getChildren() { return [] }:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter());\n    // If your formatter DOES support children, you'll need this reference too:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter(circularReferenceTypeFormatter));\n});\n\nconst program = createProgram(config);\nconst parser = createParser(program, config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n### Custom parsing\n\nSimilar to custom formatting, extending the built-in parsing works practically the same way:\n\n1. First we create a parser, in this case for parsing construct types:\n\n```ts\n// my-constructor-parser.ts\nimport { Context, StringType, ReferenceType, BaseType, SubNodeParser } from \"ts-json-schema-generator\";\nimport ts from \"typescript\";\n\nexport class MyConstructorParser implements SubNodeParser {\n    supportsNode(node: ts.Node): boolean {\n        return node.kind === ts.SyntaxKind.ConstructorType;\n    }\n    createType(node: ts.Node, context: Context, reference?: ReferenceType): BaseType | undefined {\n        return new StringType(); // Treat constructors as strings in this example\n    }\n}\n```\n\n2. Then we add the parser as a child to the core parser using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyConstructorParser } from \"./my-constructor-parser.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst program = createProgram(config);\n\n// We configure the parser an add our custom parser to it.\nconst parser = createParser(program, config, (prs) => {\n    prs.addNodeParser(new MyConstructorParser());\n});\n\nconst formatter = createFormatter(config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n## Options\n\n```\n-p, --path 'index.ts'\n    The path to the TypeScript source file. If this is not provided, the type will be searched in the project specified in the `.tsconfig`.\n\n-t, --type 'My.Type.Name'\n    The type the generated schema will represent. If omitted, the generated schema will contain all\n    types found in the files matching path. The same is true if '*' is specified.\n\n-i, --id 'generatedSchemaId'\n    The `$id` of the generated schema. If omitted, there will be no `$id`.\n\n-e, --expose <all|none|export>\n    all: Create shared $ref definitions for all types.\n    none: Do not create shared $ref definitions.\n    export (default): Create shared $ref definitions only for exported types (not tagged as `@internal`).\n\n-f, --tsconfig 'my/project/tsconfig.json'\n    Use a custom tsconfig file for processing typescript (see https://www.typescriptlang.org/docs/handbook/tsconfig-json.html) instead of the default:\n    {\n        \"compilerOptions\": {\n            \"noEmit\": true,\n            \"emitDecoratorMetadata\": true,\n            \"experimentalDecorators\": true,\n            \"target\": \"ES5\",\n            \"module\": \"CommonJS\",\n            \"strictNullChecks\": false,\n        }\n    }\n\n-j, --jsDoc <extended|none|basic>\n    none: Do not use JsDoc annotations.\n    basic: Read JsDoc annotations to provide schema properties.\n    extended (default): Also read @nullable, and @asType annotations.\n\n--unstable\n    Do not sort properties.\n\n--strict-tuples\n    Do not allow additional items on tuples.\n\n--no-top-ref\n    Do not create a top-level $ref definition.\n\n--no-type-check\n    Skip type checks for better performance.\n\n--no-ref-encode\n    Do not encode references. According to the standard, references must be valid URIs but some tools do not support encoded references.\n\n--validation-keywords\n    Provide additional validation keywords to include.\n\n-o, --out\n    Specify the output file path. Without this option, the generator logs the response in the console.\n\n--additional-properties <true|false>\n    Controls whether or not to allow additional properties for objects that have no index signature.\n\n    true: Additional properties are allowed\n    false (default): Additional properties are not allowed\n```\n\n## Current state\n\n-   `interface` types\n-   `enum` types\n-   `union`, `tuple`, `type[]` types\n-   `Date`, `RegExp` types\n-   `string`, `boolean`, `number` types\n-   `\"value\"`, `123`, `true`, `false`, `null`, `undefined` literals\n-   type aliases\n-   generics\n-   `typeof`\n-   `keyof`\n-   conditional types\n\n## Run locally\n\n`yarn --silent run run --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\n## Debug\n\n`yarn --silent run debug --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\nAnd connect via the debugger protocol.\n\n[AST Explorer](https://astexplorer.net/) is amazing for developers of this tool!\n\n## Publish\n\nTo publish a new version, run the workflow at https://github.com/vega/ts-json-schema-generator/actions?query=workflow%3APublish.\n",
      "readmeFilename": "README.md",
      "gitHead": "f772d2913b547473c73d5189c1b8fe30ca8d3b79",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.94.2--canary.856.f772d29.0",
      "_nodeVersion": "14.17.3",
      "_npmVersion": "7.19.0",
      "dist": {
        "integrity": "sha512-3l75cZWdOveX/isfwg5wUu4bw0fsg6DEAXhGJPwJEpZRHAH7JCZwzTGFNe/+g1ZcYOHWvxbZTrgqISe6/Tqisw==",
        "shasum": "24f5328ed319f004205f96dcb98847eaa924cb9c",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.94.2--canary.856.f772d29.0.tgz",
        "fileCount": 631,
        "unpackedSize": 741577,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJg8OEgCRA9TVsSAnZWagAA+DkP/AhWyJ/2pccWBrkMyeHQ\nWxBo7besecYZj/8h4NrGRUq4TfAEnmzfycNM+5EMlD1o5t+ZV3ObuZ8oQ4T4\nfApDDK12Q15cNrj9Kr3Xj/wX21ixkvQOXR1tXbfUXBRZBabeX54FSsOcdxmD\nV+rjBYux4eSChZRdzuI4Z4qlhtqXRKwqfBOmcMyYpmOrADdan7rCgxHoM6Zf\nkkXQ3VRJlodqPZO9viHQVdgfjUrHFhD7IWymFloWUkde6m71yvT9PCRFKtqg\neKwRKPcPnpd2HbmN89TOBzoOei5sehP8V2INXOcXBJWs3A/cYZh89cQ2KJBb\nflFzoFUSHz0cYQIAyOLfQ0aZh5yHDOQapTJLh5Eo/5HMu6IQvLLtk3IAkF9X\nOuXXvpooJ0I9IikJuJJpN9q+w4u/zaY+xNnr2GXSOoToCFPFRWENl1ymglch\nNB9UwEnY9meZfscrTGj8z+xxZCjhKrpF/G2gJjc1UbNosGSk69cqGPAMS7hK\nBxZKG7Lq6M9dLcbjncp/amw85hSIzAxDKcxchwohNrSq3vOonzbwWvHEvWUg\nLFFGGsfkh6inM1C94+XmNweMbPPfhgnfi5Mggvsxra4c1UdDoEkCzkyyXFRY\nmdlqA6Gp4udjpZD1/5k039hYLIhAnTsxjJQ4/p53CYL3hur+l4g+kqzSOjVK\nRRQE\r\n=eh5f\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEQCIGfWcTrbuRhLVkneJTvBj1FKZNpRLlbdgw9rqHpVk24IAiBzwkW9P/0AzoByEx0LnVSdM5pOQ1c6j7Q3GyK6VKqcaw=="
          }
        ]
      },
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "maintainers": [
        {
          "name": "jheer",
          "email": "jeffrey.heer@gmail.com"
        },
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "kanitw",
          "email": "kanitw@gmail.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.94.2--canary.856.f772d29.0_1626399008485_0.5150975404028095"
      },
      "_hasShrinkwrap": false
    },
    "0.94.2--canary.856.e019c4a.0": {
      "name": "ts-json-schema-generator",
      "version": "0.94.2--canary.856.e019c4a.0",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "MooYeol Prescott Lee",
          "email": "mooyoul@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=10.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.7",
        "commander": "^8.0.0",
        "fast-json-stable-stringify": "^2.1.0",
        "glob": "^7.1.7",
        "json-stable-stringify": "^1.0.1",
        "typescript": "~4.3.4"
      },
      "devDependencies": {
        "@auto-it/conventional-commits": "^10.29.3",
        "@auto-it/first-time-contributor": "^10.29.3",
        "@babel/core": "^7.14.6",
        "@babel/preset-env": "^7.14.7",
        "@babel/preset-typescript": "^7.14.5",
        "@types/glob": "^7.1.3",
        "@types/jest": "^26.0.23",
        "@types/json-stable-stringify": "^1.0.32",
        "@types/node": "^16.0.0",
        "@typescript-eslint/eslint-plugin": "^4.28.1",
        "@typescript-eslint/parser": "^4.28.1",
        "ajv": "^8.6.0",
        "ajv-formats": "^2.1.0",
        "auto": "^10.29.3",
        "chai": "^4.3.4",
        "cross-env": "^7.0.3",
        "eslint": "^7.29.0",
        "eslint-config-prettier": "^8.3.0",
        "eslint-plugin-prettier": "^3.4.0",
        "jest": "^27.0.6",
        "jest-junit": "^12.2.0",
        "prettier": "^2.3.2",
        "ts-node": "^10.0.0",
        "vega": "^5.20.2",
        "vega-lite": "^5.1.0"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint \"{src,test,factory}/**/*.ts\"",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "cross-env FAST_TEST=1 jest test/ --verbose",
        "test:coverage": "yarn jest test/ --collectCoverage=true",
        "test:update": "cross-env UPDATE_SCHEMA=true yarn test:fast",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts",
        "release": "yarn build && auto shipit"
      },
      "readme": "# ts-json-schema-generator\n\n![Test](https://github.com/vega/ts-json-schema-generator/workflows/Test/badge.svg)\n[![codecov](https://codecov.io/gh/vega/ts-json-schema-generator/branch/master/graph/badge.svg)](https://codecov.io/gh/vega/ts-json-schema-generator)\n[![npm version](https://img.shields.io/npm/v/ts-json-schema-generator.svg)](https://www.npmjs.com/package/ts-json-schema-generator)\n\nExtended version of [https://github.com/xiag-ag/typescript-to-json-schema](https://github.com/xiag-ag/typescript-to-json-schema).\n\nInspired by [`YousefED/typescript-json-schema`](https://github.com/YousefED/typescript-json-schema). Here's the differences list:\n\n-   this implementation avoids the use of `typeChecker.getTypeAtLocation()` (so probably it keeps correct type aliases)\n-   processing AST and formatting JSON schema have been split into two independent steps\n-   not exported types, interfaces, enums are not exposed in the `definitions` section in the JSON schema\n\n## Contributors\n\nThis project is made possible by a [community of contributors](https://github.com/vega/ts-json-schema-generator/graphs/contributors). We welcome contributions of any kind (issues, code, documentation, examples, tests,...). Please read our [code of conduct](https://github.com/vega/vega/blob/master/CODE_OF_CONDUCT.md).\n\n## CLI Usage\n\n```bash\nnpm install --save ts-json-schema-generator\n./node_modules/.bin/ts-json-schema-generator --path 'my/project/**/*.ts' --type 'My.Type.Name'\n```\n\nNote that different platforms (e.g. Windows) may use different path separators so you may have to adjust the command above.\n\n## Programmatic Usage\n\n```js\n// main.js\n\nconst tsj = require(\"ts-json-schema-generator\");\nconst fs = require(\"fs\");\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst output_path = \"path/to/output/file\";\n\nconst schema = tsj.createGenerator(config).createSchema(config.type);\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\nRun the schema generator via `node main.js`.\n\n### Custom formatting\n\nExtending the built-in formatting is possible by creating a custom formatter and adding it to the main formatter:\n\n1. First we create a formatter, in this case for formatting function types:\n\n```ts\n// my-function-formatter.ts\nimport { BaseType, Definition, FunctionType, SubTypeFormatter } from \"ts-json-schema-generator\";\nimport ts from \"typescript\";\n\nexport class MyFunctionTypeFormatter implements SubTypeFormatter {\n    // You can skip this line if you don't need childTypeFormatter\n    public constructor(private childTypeFormatter: TypeFormatter) {}\n\n    public supportsType(type: FunctionType): boolean {\n        return type instanceof FunctionType;\n    }\n\n    public getDefinition(type: FunctionType): Definition {\n        // Return a custom schema for the function property.\n        return {\n            type: \"object\",\n            properties: {\n                isFunction: {\n                    type: \"boolean\",\n                    const: true,\n                },\n            },\n        };\n    }\n\n    // If this type does NOT HAVE children, generally all you need is:\n    public getChildren(type: FunctionType): BaseType[] {\n        return [];\n    }\n\n    // However, if children ARE supported, you'll need something similar to\n    // this (see src/TypeFormatter/{Array,Definition,etc}.ts for some examples):\n    public getChildren(type: FunctionType): BaseType[] {\n        return this.childTypeFormatter.getChildren(type.getType());\n    }\n}\n```\n\n2. Then we add the formatter as a child to the core formatter using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyFunctionTypeFormatter } from \"./my-function-formatter.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\n// We configure the formatter an add our custom formatter to it.\nconst formatter = createFormatter(config, (fmt, circularReferenceTypeFormatter) => {\n    // If your formatter DOES NOT support children, e.g. getChildren() { return [] }:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter());\n    // If your formatter DOES support children, you'll need this reference too:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter(circularReferenceTypeFormatter));\n});\n\nconst program = createProgram(config);\nconst parser = createParser(program, config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n### Custom parsing\n\nSimilar to custom formatting, extending the built-in parsing works practically the same way:\n\n1. First we create a parser, in this case for parsing construct types:\n\n```ts\n// my-constructor-parser.ts\nimport { Context, StringType, ReferenceType, BaseType, SubNodeParser } from \"ts-json-schema-generator\";\nimport ts from \"typescript\";\n\nexport class MyConstructorParser implements SubNodeParser {\n    supportsNode(node: ts.Node): boolean {\n        return node.kind === ts.SyntaxKind.ConstructorType;\n    }\n    createType(node: ts.Node, context: Context, reference?: ReferenceType): BaseType | undefined {\n        return new StringType(); // Treat constructors as strings in this example\n    }\n}\n```\n\n2. Then we add the parser as a child to the core parser using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyConstructorParser } from \"./my-constructor-parser.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst program = createProgram(config);\n\n// We configure the parser an add our custom parser to it.\nconst parser = createParser(program, config, (prs) => {\n    prs.addNodeParser(new MyConstructorParser());\n});\n\nconst formatter = createFormatter(config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n## Options\n\n```\n-p, --path 'index.ts'\n    The path to the TypeScript source file. If this is not provided, the type will be searched in the project specified in the `.tsconfig`.\n\n-t, --type 'My.Type.Name'\n    The type the generated schema will represent. If omitted, the generated schema will contain all\n    types found in the files matching path. The same is true if '*' is specified.\n\n-i, --id 'generatedSchemaId'\n    The `$id` of the generated schema. If omitted, there will be no `$id`.\n\n-e, --expose <all|none|export>\n    all: Create shared $ref definitions for all types.\n    none: Do not create shared $ref definitions.\n    export (default): Create shared $ref definitions only for exported types (not tagged as `@internal`).\n\n-f, --tsconfig 'my/project/tsconfig.json'\n    Use a custom tsconfig file for processing typescript (see https://www.typescriptlang.org/docs/handbook/tsconfig-json.html) instead of the default:\n    {\n        \"compilerOptions\": {\n            \"noEmit\": true,\n            \"emitDecoratorMetadata\": true,\n            \"experimentalDecorators\": true,\n            \"target\": \"ES5\",\n            \"module\": \"CommonJS\",\n            \"strictNullChecks\": false,\n        }\n    }\n\n-j, --jsDoc <extended|none|basic>\n    none: Do not use JsDoc annotations.\n    basic: Read JsDoc annotations to provide schema properties.\n    extended (default): Also read @nullable, and @asType annotations.\n\n--unstable\n    Do not sort properties.\n\n--strict-tuples\n    Do not allow additional items on tuples.\n\n--no-top-ref\n    Do not create a top-level $ref definition.\n\n--no-type-check\n    Skip type checks for better performance.\n\n--no-ref-encode\n    Do not encode references. According to the standard, references must be valid URIs but some tools do not support encoded references.\n\n--validation-keywords\n    Provide additional validation keywords to include.\n\n-o, --out\n    Specify the output file path. Without this option, the generator logs the response in the console.\n\n--additional-properties <true|false>\n    Controls whether or not to allow additional properties for objects that have no index signature.\n\n    true: Additional properties are allowed\n    false (default): Additional properties are not allowed\n```\n\n## Current state\n\n-   `interface` types\n-   `enum` types\n-   `union`, `tuple`, `type[]` types\n-   `Date`, `RegExp` types\n-   `string`, `boolean`, `number` types\n-   `\"value\"`, `123`, `true`, `false`, `null`, `undefined` literals\n-   type aliases\n-   generics\n-   `typeof`\n-   `keyof`\n-   conditional types\n\n## Run locally\n\n`yarn --silent run run --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\n## Debug\n\n`yarn --silent run debug --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\nAnd connect via the debugger protocol.\n\n[AST Explorer](https://astexplorer.net/) is amazing for developers of this tool!\n\n## Publish\n\nTo publish a new version, run the workflow at https://github.com/vega/ts-json-schema-generator/actions?query=workflow%3APublish.\n",
      "readmeFilename": "README.md",
      "gitHead": "e019c4a2da5864e29fec30e5c3cccbaf9e91156c",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.94.2--canary.856.e019c4a.0",
      "_nodeVersion": "14.17.3",
      "_npmVersion": "6.14.13",
      "dist": {
        "integrity": "sha512-T050g9C48fU40VBNotYUURjMtD0y2IF0Tkd0rOZZ+nFjp+xo9Z4lBVl5sIf7YluJoy/KQmt6msI6LpJlCYElqA==",
        "shasum": "e02e35a3a4b85f256dcdc480b0a6b96fddaac2e0",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.94.2--canary.856.e019c4a.0.tgz",
        "fileCount": 609,
        "unpackedSize": 617404,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJg8OZfCRA9TVsSAnZWagAA4I4QAIHgtUesPPFepjnAbT9E\nuOwg51KbSiLSC3FnyL2gVxdD84s4SBwwkrG/y7RLipvQV7MBH/jrCw0TDYwM\n09BwCXbYSZRKs19P/YT0u/YkOjk7MOduXupSJQWg7mCXwq5SjB/aUwDZAT1G\nvdEShVTcl6MSJKuaC++yYxCOV9oZdxfV/VJkWI0KhBf3+hcMKCNBeeye+AXi\n7f46RKQ133eQt50nvj0L2FnyyZZ/6ghBLkkJIErjsHghLM/3QNIZ4t8TLwWt\n9voJrTtyblAQfq69DGMulRf21uN2ISWj5k6Sdc261FqzosvOxpG0pNDsrA3j\nO2hh3h7S3QB67vi8XmsWbp9LrQBLzJMpvGqsDcYE80KauS4JuvEmFxlPvw/G\nF6XMBh6VWb3VWh/crRB5kfh4TmmarFvmQbKTHDvn7HKRPZjKZ2DajS4OMJiR\nXoxRu+BAxDY+CJ/63xxOpvY4f5N41fwkK3y8VNmrNSCDcPTI+vHhvVI/ecuf\nyz0EgPcYBaBj4SYj9fOS/dIHXiciy5uzGpubN/pCv8C9Ce/XRTAayENUc1kT\nkXBNki1wNLdL2LoKDVP0gyr22pYg3I6OFTyRa5983HFOc/YMpS1n7DEoS3Eh\nKHWBEX2bkwYAb3/w2I8TULbX7MEpOWn14d49OpZ8AdVPb3OWgTZOI9SH89VE\nXVgD\r\n=eDDP\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIQDHbyD0vFLye1awkLBhwopAcYOaTh3DfO4Ro6GKNaSzfgIgNJ/Ng6RodEjlj04HIPfawHejoBTmHM8SPHCk26iY0Ks="
          }
        ]
      },
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "maintainers": [
        {
          "name": "jheer",
          "email": "jeffrey.heer@gmail.com"
        },
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "kanitw",
          "email": "kanitw@gmail.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.94.2--canary.856.e019c4a.0_1626400351690_0.14055088199939414"
      },
      "_hasShrinkwrap": false
    },
    "0.95.0": {
      "name": "ts-json-schema-generator",
      "version": "0.95.0",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "MooYeol Prescott Lee",
          "email": "mooyoul@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=10.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.7",
        "commander": "^8.0.0",
        "fast-json-stable-stringify": "^2.1.0",
        "glob": "^7.1.7",
        "json-stable-stringify": "^1.0.1",
        "json5": "^2.2.0",
        "typescript": "~4.3.4"
      },
      "devDependencies": {
        "@auto-it/conventional-commits": "^10.29.3",
        "@auto-it/first-time-contributor": "^10.29.3",
        "@babel/core": "^7.14.6",
        "@babel/preset-env": "^7.14.7",
        "@babel/preset-typescript": "^7.14.5",
        "@types/glob": "^7.1.3",
        "@types/jest": "^26.0.23",
        "@types/json-stable-stringify": "^1.0.32",
        "@types/node": "^16.0.0",
        "@typescript-eslint/eslint-plugin": "^4.28.1",
        "@typescript-eslint/parser": "^4.28.1",
        "ajv": "^8.6.0",
        "ajv-formats": "^2.1.0",
        "auto": "^10.29.3",
        "chai": "^4.3.4",
        "cross-env": "^7.0.3",
        "eslint": "^7.29.0",
        "eslint-config-prettier": "^8.3.0",
        "eslint-plugin-prettier": "^3.4.0",
        "jest": "^27.0.6",
        "jest-junit": "^12.2.0",
        "prettier": "^2.3.2",
        "ts-node": "^10.0.0",
        "vega": "^5.20.2",
        "vega-lite": "^5.1.0"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint \"{src,test,factory}/**/*.ts\"",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "cross-env FAST_TEST=1 jest test/ --verbose",
        "test:coverage": "yarn jest test/ --collectCoverage=true",
        "test:update": "cross-env UPDATE_SCHEMA=true yarn test:fast",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts",
        "release": "yarn build && auto shipit"
      },
      "gitHead": "22bc8e04bb9eac505894ed3d55ad4fc4e5431322",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.95.0",
      "_nodeVersion": "14.17.3",
      "_npmVersion": "6.14.13",
      "dist": {
        "integrity": "sha512-qyArLCOmy0UnnGeCewpZgaGglPMmawAhsuYDRDa1BeZiyE+M/I2dH+dSMtFj8kVbWSEayfVmQIF9UBINBfeKSg==",
        "shasum": "726cd4e0979cb772da57a6d7581474e87015adfc",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.95.0.tgz",
        "fileCount": 610,
        "unpackedSize": 622744,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJg+dSKCRA9TVsSAnZWagAA6fAQAJnHVgZ5KYb4CINxt6Xi\ne13+CE6y/qtr54Vu8juTx8QOvIELVWtygo01rDtSzM2PaRU6JACgWhmg8CWw\nX9WdDsFMxPXi8vV8XFqGKlWnIc1h2MC+CuXGO3xbTgmAr2iAeblSNjEydbXW\nb8NEcnsx+a1QmBuCdybWE98jwzpuO98yafkU2JTOFt1WOEkad3lsfdlgi0X+\nA6YJXLwJXd7ias/Mq8eM0Ksx3qs6cOTurhMw3k80D7HXWT1Z6S4Yy4l0NapI\nKs8QhloQk7jxa4JPZiFCLuD3yfIHHIcKL4pCLUD1pHHEp8aY4zbXkyV4oJoU\nXKxLkXJ8JWuoeMVA5oaST7RNdzZMQJvdjZ4Yb3bvc4dDAPIBa4wfHUs3VxDo\n5y1VQyZy1+aV8zz99KWli9P7NyF/J+i8gKfBMqg1i/1T4ZXKx3ih6Bb5uwEP\ntode3OPGctOSpK5NAjC9X0duAdiXjeO7FyptFJz7iE1hT/qIr393x9ilqru+\nlDiFirBQ043/hKPryjc7flInj8yKozurvdoATnFmGVm9uUUK2AuE87lGvbkZ\njRCd8M2n2NR1qs2w3CvYo0blT7cuU4httY10pqJxzcFpFgIY2ncdXNu3Kmrl\n2phJT9fj9cbhxZMamFfqUSEW/U25NnYuOf1D9f2PyXoO3cO63LAxMZAw03Bx\ndr4G\r\n=KbG9\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEYCIQCFa1syKCnwIZNgBNlYU0bHuMw6W3ssxgmnN3zMG1b/jwIhAL+4hQmcfzEcSteGEO6zwZs8klGE/00nPIh5PF2DvnMF"
          }
        ]
      },
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "maintainers": [
        {
          "name": "jheer",
          "email": "jeffrey.heer@gmail.com"
        },
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "kanitw",
          "email": "kanitw@gmail.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.95.0_1626985610625_0.69273026475754"
      },
      "_hasShrinkwrap": false
    },
    "0.95.1--canary.880.58f5731.0": {
      "name": "ts-json-schema-generator",
      "version": "0.95.1--canary.880.58f5731.0",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "MooYeol Prescott Lee",
          "email": "mooyoul@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=10.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.7",
        "commander": "^8.0.0",
        "fast-json-stable-stringify": "^2.1.0",
        "glob": "^7.1.7",
        "json-stable-stringify": "^1.0.1",
        "json5": "^2.2.0",
        "typescript": "~4.3.4"
      },
      "devDependencies": {
        "@auto-it/conventional-commits": "^10.29.3",
        "@auto-it/first-time-contributor": "^10.29.3",
        "@babel/core": "^7.14.6",
        "@babel/preset-env": "^7.14.7",
        "@babel/preset-typescript": "^7.14.5",
        "@types/glob": "^7.1.3",
        "@types/jest": "^26.0.23",
        "@types/json-stable-stringify": "^1.0.32",
        "@types/node": "^16.0.0",
        "@typescript-eslint/eslint-plugin": "^4.28.1",
        "@typescript-eslint/parser": "^4.28.1",
        "ajv": "^8.6.0",
        "ajv-formats": "^2.1.0",
        "auto": "^10.29.3",
        "chai": "^4.3.4",
        "cross-env": "^7.0.3",
        "eslint": "^7.29.0",
        "eslint-config-prettier": "^8.3.0",
        "eslint-plugin-prettier": "^3.4.0",
        "jest": "^27.0.6",
        "jest-junit": "^12.2.0",
        "prettier": "^2.3.2",
        "ts-node": "^10.0.0",
        "vega": "^5.20.2",
        "vega-lite": "^5.1.0"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint \"{src,test,factory}/**/*.ts\"",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "cross-env FAST_TEST=1 jest test/ --verbose",
        "test:coverage": "yarn jest test/ --collectCoverage=true",
        "test:update": "cross-env UPDATE_SCHEMA=true yarn test:fast",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts",
        "release": "yarn build && auto shipit"
      },
      "readme": "# ts-json-schema-generator\n\n![Test](https://github.com/vega/ts-json-schema-generator/workflows/Test/badge.svg)\n[![codecov](https://codecov.io/gh/vega/ts-json-schema-generator/branch/master/graph/badge.svg)](https://codecov.io/gh/vega/ts-json-schema-generator)\n[![npm version](https://img.shields.io/npm/v/ts-json-schema-generator.svg)](https://www.npmjs.com/package/ts-json-schema-generator)\n\nExtended version of [https://github.com/xiag-ag/typescript-to-json-schema](https://github.com/xiag-ag/typescript-to-json-schema).\n\nInspired by [`YousefED/typescript-json-schema`](https://github.com/YousefED/typescript-json-schema). Here's the differences list:\n\n-   this implementation avoids the use of `typeChecker.getTypeAtLocation()` (so probably it keeps correct type aliases)\n-   processing AST and formatting JSON schema have been split into two independent steps\n-   not exported types, interfaces, enums are not exposed in the `definitions` section in the JSON schema\n\n## Contributors\n\nThis project is made possible by a [community of contributors](https://github.com/vega/ts-json-schema-generator/graphs/contributors). We welcome contributions of any kind (issues, code, documentation, examples, tests,...). Please read our [code of conduct](https://github.com/vega/vega/blob/master/CODE_OF_CONDUCT.md).\n\n## CLI Usage\n\n```bash\nnpm install --save ts-json-schema-generator\n./node_modules/.bin/ts-json-schema-generator --path 'my/project/**/*.ts' --type 'My.Type.Name'\n```\n\nNote that different platforms (e.g. Windows) may use different path separators so you may have to adjust the command above.\n\n## Programmatic Usage\n\n```js\n// main.js\n\nconst tsj = require(\"ts-json-schema-generator\");\nconst fs = require(\"fs\");\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst output_path = \"path/to/output/file\";\n\nconst schema = tsj.createGenerator(config).createSchema(config.type);\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\nRun the schema generator via `node main.js`.\n\n### Custom formatting\n\nExtending the built-in formatting is possible by creating a custom formatter and adding it to the main formatter:\n\n1. First we create a formatter, in this case for formatting function types:\n\n```ts\n// my-function-formatter.ts\nimport { BaseType, Definition, FunctionType, SubTypeFormatter } from \"ts-json-schema-generator\";\nimport ts from \"typescript\";\n\nexport class MyFunctionTypeFormatter implements SubTypeFormatter {\n    // You can skip this line if you don't need childTypeFormatter\n    public constructor(private childTypeFormatter: TypeFormatter) {}\n\n    public supportsType(type: FunctionType): boolean {\n        return type instanceof FunctionType;\n    }\n\n    public getDefinition(type: FunctionType): Definition {\n        // Return a custom schema for the function property.\n        return {\n            type: \"object\",\n            properties: {\n                isFunction: {\n                    type: \"boolean\",\n                    const: true,\n                },\n            },\n        };\n    }\n\n    // If this type does NOT HAVE children, generally all you need is:\n    public getChildren(type: FunctionType): BaseType[] {\n        return [];\n    }\n\n    // However, if children ARE supported, you'll need something similar to\n    // this (see src/TypeFormatter/{Array,Definition,etc}.ts for some examples):\n    public getChildren(type: FunctionType): BaseType[] {\n        return this.childTypeFormatter.getChildren(type.getType());\n    }\n}\n```\n\n2. Then we add the formatter as a child to the core formatter using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyFunctionTypeFormatter } from \"./my-function-formatter.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\n// We configure the formatter an add our custom formatter to it.\nconst formatter = createFormatter(config, (fmt, circularReferenceTypeFormatter) => {\n    // If your formatter DOES NOT support children, e.g. getChildren() { return [] }:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter());\n    // If your formatter DOES support children, you'll need this reference too:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter(circularReferenceTypeFormatter));\n});\n\nconst program = createProgram(config);\nconst parser = createParser(program, config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n### Custom parsing\n\nSimilar to custom formatting, extending the built-in parsing works practically the same way:\n\n1. First we create a parser, in this case for parsing construct types:\n\n```ts\n// my-constructor-parser.ts\nimport { Context, StringType, ReferenceType, BaseType, SubNodeParser } from \"ts-json-schema-generator\";\nimport ts from \"typescript\";\n\nexport class MyConstructorParser implements SubNodeParser {\n    supportsNode(node: ts.Node): boolean {\n        return node.kind === ts.SyntaxKind.ConstructorType;\n    }\n    createType(node: ts.Node, context: Context, reference?: ReferenceType): BaseType | undefined {\n        return new StringType(); // Treat constructors as strings in this example\n    }\n}\n```\n\n2. Then we add the parser as a child to the core parser using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyConstructorParser } from \"./my-constructor-parser.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst program = createProgram(config);\n\n// We configure the parser an add our custom parser to it.\nconst parser = createParser(program, config, (prs) => {\n    prs.addNodeParser(new MyConstructorParser());\n});\n\nconst formatter = createFormatter(config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n## Options\n\n```\n-p, --path 'index.ts'\n    The path to the TypeScript source file. If this is not provided, the type will be searched in the project specified in the `.tsconfig`.\n\n-t, --type 'My.Type.Name'\n    The type the generated schema will represent. If omitted, the generated schema will contain all\n    types found in the files matching path. The same is true if '*' is specified.\n\n-i, --id 'generatedSchemaId'\n    The `$id` of the generated schema. If omitted, there will be no `$id`.\n\n-e, --expose <all|none|export>\n    all: Create shared $ref definitions for all types.\n    none: Do not create shared $ref definitions.\n    export (default): Create shared $ref definitions only for exported types (not tagged as `@internal`).\n\n-f, --tsconfig 'my/project/tsconfig.json'\n    Use a custom tsconfig file for processing typescript (see https://www.typescriptlang.org/docs/handbook/tsconfig-json.html) instead of the default:\n    {\n        \"compilerOptions\": {\n            \"noEmit\": true,\n            \"emitDecoratorMetadata\": true,\n            \"experimentalDecorators\": true,\n            \"target\": \"ES5\",\n            \"module\": \"CommonJS\",\n            \"strictNullChecks\": false,\n        }\n    }\n\n-j, --jsDoc <extended|none|basic>\n    none: Do not use JsDoc annotations.\n    basic: Read JsDoc annotations to provide schema properties.\n    extended (default): Also read @nullable, and @asType annotations.\n\n--unstable\n    Do not sort properties.\n\n--strict-tuples\n    Do not allow additional items on tuples.\n\n--no-top-ref\n    Do not create a top-level $ref definition.\n\n--no-type-check\n    Skip type checks for better performance.\n\n--no-ref-encode\n    Do not encode references. According to the standard, references must be valid URIs but some tools do not support encoded references.\n\n--validation-keywords\n    Provide additional validation keywords to include.\n\n-o, --out\n    Specify the output file path. Without this option, the generator logs the response in the console.\n\n--additional-properties <true|false>\n    Controls whether or not to allow additional properties for objects that have no index signature.\n\n    true: Additional properties are allowed\n    false (default): Additional properties are not allowed\n```\n\n## Current state\n\n-   `interface` types\n-   `enum` types\n-   `union`, `tuple`, `type[]` types\n-   `Date`, `RegExp` types\n-   `string`, `boolean`, `number` types\n-   `\"value\"`, `123`, `true`, `false`, `null`, `undefined` literals\n-   type aliases\n-   generics\n-   `typeof`\n-   `keyof`\n-   conditional types\n\n## Run locally\n\n`yarn --silent run run --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\n## Debug\n\n`yarn --silent run debug --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\nAnd connect via the debugger protocol.\n\n[AST Explorer](https://astexplorer.net/) is amazing for developers of this tool!\n\n## Publish\n\nPublishing is handled by a 2-branch [pre-release process](https://intuit.github.io/auto/docs/generated/shipit#next-branch-default), configured in `publish-auto.yml`. All changes should be based off the default `next` branch, and are published automatically.\n\n- PRs made into the default branch are auto-deployed to the `next` pre-release tag on NPM. The result can be installed with `npm install ts-json-schema-generator@next`\n  - When merging into `next`, please use the `squash and merge` strategy. \n- To release a new stable version, open a PR from `next` into `stable` using this [compare link](https://github.com/vega/ts-json-schema-generator/compare/stable...next).\n  - When merging from `next` into `stable`, please use the `create a merge commit` strategy.\n",
      "readmeFilename": "README.md",
      "gitHead": "58f57311c9e86344a14ea2a1178d2f05f22cf1c2",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.95.1--canary.880.58f5731.0",
      "_nodeVersion": "14.17.3",
      "_npmVersion": "6.14.13",
      "dist": {
        "integrity": "sha512-eSUx5kki/27Kzy2go4hAur2XRaXMgElNtrc+o0fwT0F7OBPMxPg0SqasCzBz0V72wLAdU48IVMduSVO8jiKY/w==",
        "shasum": "5edf2965955d07b59bb4ddc30f1c332e7508e7a4",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.95.1--canary.880.58f5731.0.tgz",
        "fileCount": 609,
        "unpackedSize": 618335,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJhAYwYCRA9TVsSAnZWagAAQWEQAJagZ9Ij3lBBbc1iZzHH\nt0+qdyjlS0cW7RkKraJ5I2Mju6wgZYbKYxjzejEb10m4wRFMjXynqL6+gaKG\n5uUNVgTL9P1i8EVUlwuCBM187QpsT6jrN3YWOAUrfqk1zvMTcpEyo5pAzPi6\nPRtg7aH3aACbaJX0BwKKMuSmnJwo55W/kfUGhGcSs01VkCcIU9mOLiUSmmnY\nUPjULXRW/TEZ1cMYmmnmtXjzmh79PnqYw5WUi7+7SHAfSbLzJUjkKpYOoCYb\ntrA7MXCQ1EbMTk7h++Iaaamf0IlCne5YCFjWU125C9qJxLpddw6i37Bbp+q3\nnKKCHh1Gq9mJDNdQgzMcCUBM1GqNkNMOSzCq6RriO2Wc1bW/iNwfdXongbhH\n9nCc29JfK/i04wJKT/Kc7jqYo4HE2bOeYhdyDgtiZWJUKDKnnM4kTqI0+khl\nfy/W6L9yd0rmJ6KPRktsQAN/RocebDf2tpdyoeKVhJy6hwwTxhFZ1n/J2GmJ\n9wSrJBmKbXhHlq+AcSoWeHRT7Gb0NcliyeUyYd71iV1lj5Oq3JmXwsCvUNWp\nmsyKr94aMYJGcf47CDTM0mLzRKzzwvwwy3PEz7KLbRxdv8L1Cm7zhNua1E5R\ncbJoc2vpauymFG/xmI6iuqazwl2cL4JCExeynwDShGjYUd6b+z/PucUCxClh\nzX5E\r\n=Borm\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEYCIQC/kohdMgbopguM5+7FWSLAiiqVAKrbFo8Nr5cwQdh7ugIhAPxq+FKNidSVxG9iHEMWjnGcfJqt8AkXXe5TkcPCXsE4"
          }
        ]
      },
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "maintainers": [
        {
          "name": "jheer",
          "email": "jeffrey.heer@gmail.com"
        },
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "kanitw",
          "email": "kanitw@gmail.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.95.1--canary.880.58f5731.0_1627491352551_0.9773268556294727"
      },
      "_hasShrinkwrap": false
    },
    "0.95.1--canary.941.6142f46.0": {
      "name": "ts-json-schema-generator",
      "version": "0.95.1--canary.941.6142f46.0",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "MooYeol Prescott Lee",
          "email": "mooyoul@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=10.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.7",
        "commander": "^8.0.0",
        "fast-json-stable-stringify": "^2.1.0",
        "glob": "^7.1.7",
        "json-stable-stringify": "^1.0.1",
        "json5": "^2.2.0",
        "typescript": "~4.4.2"
      },
      "devDependencies": {
        "@auto-it/conventional-commits": "^10.29.3",
        "@auto-it/first-time-contributor": "^10.29.3",
        "@babel/core": "^7.14.6",
        "@babel/preset-env": "^7.14.7",
        "@babel/preset-typescript": "^7.14.5",
        "@types/glob": "^7.1.3",
        "@types/jest": "^27.0.1",
        "@types/json-stable-stringify": "^1.0.32",
        "@types/node": "^16.0.0",
        "@typescript-eslint/eslint-plugin": "^4.28.1",
        "@typescript-eslint/parser": "^4.28.1",
        "ajv": "^8.6.0",
        "ajv-formats": "^2.1.0",
        "auto": "^10.29.3",
        "chai": "^4.3.4",
        "cross-env": "^7.0.3",
        "eslint": "^7.29.0",
        "eslint-config-prettier": "^8.3.0",
        "eslint-plugin-prettier": "^4.0.0",
        "jest": "^27.0.6",
        "jest-junit": "^12.2.0",
        "prettier": "^2.3.2",
        "ts-node": "^10.0.0",
        "vega": "^5.20.2",
        "vega-lite": "^5.1.0"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint \"{src,test,factory}/**/*.ts\"",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "cross-env FAST_TEST=1 jest test/ --verbose",
        "test:coverage": "yarn jest test/ --collectCoverage=true",
        "test:update": "cross-env UPDATE_SCHEMA=true yarn test:fast",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts",
        "release": "yarn build && auto shipit"
      },
      "readme": "# ts-json-schema-generator\n\n![Test](https://github.com/vega/ts-json-schema-generator/workflows/Test/badge.svg)\n[![codecov](https://codecov.io/gh/vega/ts-json-schema-generator/branch/master/graph/badge.svg)](https://codecov.io/gh/vega/ts-json-schema-generator)\n[![npm version](https://img.shields.io/npm/v/ts-json-schema-generator.svg)](https://www.npmjs.com/package/ts-json-schema-generator)\n\nExtended version of [https://github.com/xiag-ag/typescript-to-json-schema](https://github.com/xiag-ag/typescript-to-json-schema).\n\nInspired by [`YousefED/typescript-json-schema`](https://github.com/YousefED/typescript-json-schema). Here's the differences list:\n\n-   this implementation avoids the use of `typeChecker.getTypeAtLocation()` (so probably it keeps correct type aliases)\n-   processing AST and formatting JSON schema have been split into two independent steps\n-   not exported types, interfaces, enums are not exposed in the `definitions` section in the JSON schema\n\n## Contributors\n\nThis project is made possible by a [community of contributors](https://github.com/vega/ts-json-schema-generator/graphs/contributors). We welcome contributions of any kind (issues, code, documentation, examples, tests,...). Please read our [code of conduct](https://github.com/vega/vega/blob/master/CODE_OF_CONDUCT.md).\n\n## CLI Usage\n\n```bash\nnpm install --save ts-json-schema-generator\n./node_modules/.bin/ts-json-schema-generator --path 'my/project/**/*.ts' --type 'My.Type.Name'\n```\n\nNote that different platforms (e.g. Windows) may use different path separators so you may have to adjust the command above.\n\n## Programmatic Usage\n\n```js\n// main.js\n\nconst tsj = require(\"ts-json-schema-generator\");\nconst fs = require(\"fs\");\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst output_path = \"path/to/output/file\";\n\nconst schema = tsj.createGenerator(config).createSchema(config.type);\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\nRun the schema generator via `node main.js`.\n\n### Custom formatting\n\nExtending the built-in formatting is possible by creating a custom formatter and adding it to the main formatter:\n\n1. First we create a formatter, in this case for formatting function types:\n\n```ts\n// my-function-formatter.ts\nimport { BaseType, Definition, FunctionType, SubTypeFormatter } from \"ts-json-schema-generator\";\nimport ts from \"typescript\";\n\nexport class MyFunctionTypeFormatter implements SubTypeFormatter {\n    // You can skip this line if you don't need childTypeFormatter\n    public constructor(private childTypeFormatter: TypeFormatter) {}\n\n    public supportsType(type: FunctionType): boolean {\n        return type instanceof FunctionType;\n    }\n\n    public getDefinition(type: FunctionType): Definition {\n        // Return a custom schema for the function property.\n        return {\n            type: \"object\",\n            properties: {\n                isFunction: {\n                    type: \"boolean\",\n                    const: true,\n                },\n            },\n        };\n    }\n\n    // If this type does NOT HAVE children, generally all you need is:\n    public getChildren(type: FunctionType): BaseType[] {\n        return [];\n    }\n\n    // However, if children ARE supported, you'll need something similar to\n    // this (see src/TypeFormatter/{Array,Definition,etc}.ts for some examples):\n    public getChildren(type: FunctionType): BaseType[] {\n        return this.childTypeFormatter.getChildren(type.getType());\n    }\n}\n```\n\n2. Then we add the formatter as a child to the core formatter using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyFunctionTypeFormatter } from \"./my-function-formatter.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\n// We configure the formatter an add our custom formatter to it.\nconst formatter = createFormatter(config, (fmt, circularReferenceTypeFormatter) => {\n    // If your formatter DOES NOT support children, e.g. getChildren() { return [] }:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter());\n    // If your formatter DOES support children, you'll need this reference too:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter(circularReferenceTypeFormatter));\n});\n\nconst program = createProgram(config);\nconst parser = createParser(program, config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n### Custom parsing\n\nSimilar to custom formatting, extending the built-in parsing works practically the same way:\n\n1. First we create a parser, in this case for parsing construct types:\n\n```ts\n// my-constructor-parser.ts\nimport { Context, StringType, ReferenceType, BaseType, SubNodeParser } from \"ts-json-schema-generator\";\nimport ts from \"typescript\";\n\nexport class MyConstructorParser implements SubNodeParser {\n    supportsNode(node: ts.Node): boolean {\n        return node.kind === ts.SyntaxKind.ConstructorType;\n    }\n    createType(node: ts.Node, context: Context, reference?: ReferenceType): BaseType | undefined {\n        return new StringType(); // Treat constructors as strings in this example\n    }\n}\n```\n\n2. Then we add the parser as a child to the core parser using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyConstructorParser } from \"./my-constructor-parser.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst program = createProgram(config);\n\n// We configure the parser an add our custom parser to it.\nconst parser = createParser(program, config, (prs) => {\n    prs.addNodeParser(new MyConstructorParser());\n});\n\nconst formatter = createFormatter(config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n## Options\n\n```\n-p, --path 'index.ts'\n    The path to the TypeScript source file. If this is not provided, the type will be searched in the project specified in the `.tsconfig`.\n\n-t, --type 'My.Type.Name'\n    The type the generated schema will represent. If omitted, the generated schema will contain all\n    types found in the files matching path. The same is true if '*' is specified.\n\n-i, --id 'generatedSchemaId'\n    The `$id` of the generated schema. If omitted, there will be no `$id`.\n\n-e, --expose <all|none|export>\n    all: Create shared $ref definitions for all types.\n    none: Do not create shared $ref definitions.\n    export (default): Create shared $ref definitions only for exported types (not tagged as `@internal`).\n\n-f, --tsconfig 'my/project/tsconfig.json'\n    Use a custom tsconfig file for processing typescript (see https://www.typescriptlang.org/docs/handbook/tsconfig-json.html) instead of the default:\n    {\n        \"compilerOptions\": {\n            \"noEmit\": true,\n            \"emitDecoratorMetadata\": true,\n            \"experimentalDecorators\": true,\n            \"target\": \"ES5\",\n            \"module\": \"CommonJS\",\n            \"strictNullChecks\": false,\n        }\n    }\n\n-j, --jsDoc <extended|none|basic>\n    none: Do not use JsDoc annotations.\n    basic: Read JsDoc annotations to provide schema properties.\n    extended (default): Also read @nullable, and @asType annotations.\n\n--unstable\n    Do not sort properties.\n\n--strict-tuples\n    Do not allow additional items on tuples.\n\n--no-top-ref\n    Do not create a top-level $ref definition.\n\n--no-type-check\n    Skip type checks for better performance.\n\n--no-ref-encode\n    Do not encode references. According to the standard, references must be valid URIs but some tools do not support encoded references.\n\n--validation-keywords\n    Provide additional validation keywords to include.\n\n-o, --out\n    Specify the output file path. Without this option, the generator logs the response in the console.\n\n--additional-properties <true|false>\n    Controls whether or not to allow additional properties for objects that have no index signature.\n\n    true: Additional properties are allowed\n    false (default): Additional properties are not allowed\n```\n\n## Current state\n\n-   `interface` types\n-   `enum` types\n-   `union`, `tuple`, `type[]` types\n-   `Date`, `RegExp` types\n-   `string`, `boolean`, `number` types\n-   `\"value\"`, `123`, `true`, `false`, `null`, `undefined` literals\n-   type aliases\n-   generics\n-   `typeof`\n-   `keyof`\n-   conditional types\n\n## Run locally\n\n`yarn --silent run run --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\n## Debug\n\n`yarn --silent run debug --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\nAnd connect via the debugger protocol.\n\n[AST Explorer](https://astexplorer.net/) is amazing for developers of this tool!\n\n## Publish\n\nPublishing is handled by a 2-branch [pre-release process](https://intuit.github.io/auto/docs/generated/shipit#next-branch-default), configured in `publish-auto.yml`. All changes should be based off the default `next` branch, and are published automatically.\n\n- PRs made into the default branch are auto-deployed to the `next` pre-release tag on NPM. The result can be installed with `npm install ts-json-schema-generator@next`\n  - When merging into `next`, please use the `squash and merge` strategy. \n- To release a new stable version, open a PR from `next` into `stable` using this [compare link](https://github.com/vega/ts-json-schema-generator/compare/stable...next).\n  - When merging from `next` into `stable`, please use the `create a merge commit` strategy.\n",
      "readmeFilename": "README.md",
      "gitHead": "6142f46a653c6597a3b34479124fb527b3b4e14a",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.95.1--canary.941.6142f46.0",
      "_nodeVersion": "14.17.6",
      "_npmVersion": "6.14.15",
      "dist": {
        "integrity": "sha512-wzuANSI7ssbLDtF5k4jEjJ43mynjXyGYVgt79RbxFgXuoQbi8Bz0fNGEVHCpgUe4yaGeOo7VKQnextT9bxTFew==",
        "shasum": "702db920ad4f9cb97f822a1fc87c7e9ecb9de359",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.95.1--canary.941.6142f46.0.tgz",
        "fileCount": 609,
        "unpackedSize": 619333,
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIQD6MPv3sC9cd8wHG5l9RDeFXJobyGSmXlbZIX7wX17WrgIgH+Gas17ilaOE+srMM8afIutUPxtdgiECoT5evbNWTXo="
          }
        ]
      },
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "maintainers": [
        {
          "name": "jheer",
          "email": "jeffrey.heer@gmail.com"
        },
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "kanitw",
          "email": "kanitw@gmail.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.95.1--canary.941.6142f46.0_1631895498597_0.941515252669425"
      },
      "_hasShrinkwrap": false
    },
    "0.95.1--canary.942.488f6c9.0": {
      "name": "ts-json-schema-generator",
      "version": "0.95.1--canary.942.488f6c9.0",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "MooYeol Prescott Lee",
          "email": "mooyoul@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=10.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.7",
        "commander": "^8.0.0",
        "fast-json-stable-stringify": "^2.1.0",
        "glob": "^7.1.7",
        "json-stable-stringify": "^1.0.1",
        "json5": "^2.2.0",
        "typescript": "~4.4.2"
      },
      "devDependencies": {
        "@auto-it/conventional-commits": "^10.29.3",
        "@auto-it/first-time-contributor": "^10.29.3",
        "@babel/core": "^7.14.6",
        "@babel/preset-env": "^7.14.7",
        "@babel/preset-typescript": "^7.14.5",
        "@types/glob": "^7.1.3",
        "@types/jest": "^27.0.1",
        "@types/json-stable-stringify": "^1.0.32",
        "@types/node": "^16.0.0",
        "@typescript-eslint/eslint-plugin": "^4.28.1",
        "@typescript-eslint/parser": "^4.28.1",
        "ajv": "^8.6.0",
        "ajv-formats": "^2.1.0",
        "auto": "^10.29.3",
        "chai": "^4.3.4",
        "cross-env": "^7.0.3",
        "eslint": "^7.29.0",
        "eslint-config-prettier": "^8.3.0",
        "eslint-plugin-prettier": "^4.0.0",
        "jest": "^27.0.6",
        "jest-junit": "^12.2.0",
        "prettier": "^2.3.2",
        "ts-node": "^10.0.0",
        "vega": "^5.20.2",
        "vega-lite": "^5.1.0"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint \"{src,test,factory}/**/*.ts\"",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "cross-env FAST_TEST=1 jest test/ --verbose",
        "test:coverage": "yarn jest test/ --collectCoverage=true",
        "test:update": "cross-env UPDATE_SCHEMA=true yarn test:fast",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts",
        "release": "yarn build && auto shipit"
      },
      "readme": "# ts-json-schema-generator\n\n![Test](https://github.com/vega/ts-json-schema-generator/workflows/Test/badge.svg)\n[![codecov](https://codecov.io/gh/vega/ts-json-schema-generator/branch/master/graph/badge.svg)](https://codecov.io/gh/vega/ts-json-schema-generator)\n[![npm version](https://img.shields.io/npm/v/ts-json-schema-generator.svg)](https://www.npmjs.com/package/ts-json-schema-generator)\n\nExtended version of [https://github.com/xiag-ag/typescript-to-json-schema](https://github.com/xiag-ag/typescript-to-json-schema).\n\nInspired by [`YousefED/typescript-json-schema`](https://github.com/YousefED/typescript-json-schema). Here's the differences list:\n\n-   this implementation avoids the use of `typeChecker.getTypeAtLocation()` (so probably it keeps correct type aliases)\n-   processing AST and formatting JSON schema have been split into two independent steps\n-   not exported types, interfaces, enums are not exposed in the `definitions` section in the JSON schema\n\n## Contributors\n\nThis project is made possible by a [community of contributors](https://github.com/vega/ts-json-schema-generator/graphs/contributors). We welcome contributions of any kind (issues, code, documentation, examples, tests,...). Please read our [code of conduct](https://github.com/vega/vega/blob/master/CODE_OF_CONDUCT.md).\n\n## CLI Usage\n\n```bash\nnpm install --save ts-json-schema-generator\n./node_modules/.bin/ts-json-schema-generator --path 'my/project/**/*.ts' --type 'My.Type.Name'\n```\n\nNote that different platforms (e.g. Windows) may use different path separators so you may have to adjust the command above.\n\n## Programmatic Usage\n\n```js\n// main.js\n\nconst tsj = require(\"ts-json-schema-generator\");\nconst fs = require(\"fs\");\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst output_path = \"path/to/output/file\";\n\nconst schema = tsj.createGenerator(config).createSchema(config.type);\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\nRun the schema generator via `node main.js`.\n\n### Custom formatting\n\nExtending the built-in formatting is possible by creating a custom formatter and adding it to the main formatter:\n\n1. First we create a formatter, in this case for formatting function types:\n\n```ts\n// my-function-formatter.ts\nimport { BaseType, Definition, FunctionType, SubTypeFormatter } from \"ts-json-schema-generator\";\nimport ts from \"typescript\";\n\nexport class MyFunctionTypeFormatter implements SubTypeFormatter {\n    // You can skip this line if you don't need childTypeFormatter\n    public constructor(private childTypeFormatter: TypeFormatter) {}\n\n    public supportsType(type: FunctionType): boolean {\n        return type instanceof FunctionType;\n    }\n\n    public getDefinition(type: FunctionType): Definition {\n        // Return a custom schema for the function property.\n        return {\n            type: \"object\",\n            properties: {\n                isFunction: {\n                    type: \"boolean\",\n                    const: true,\n                },\n            },\n        };\n    }\n\n    // If this type does NOT HAVE children, generally all you need is:\n    public getChildren(type: FunctionType): BaseType[] {\n        return [];\n    }\n\n    // However, if children ARE supported, you'll need something similar to\n    // this (see src/TypeFormatter/{Array,Definition,etc}.ts for some examples):\n    public getChildren(type: FunctionType): BaseType[] {\n        return this.childTypeFormatter.getChildren(type.getType());\n    }\n}\n```\n\n2. Then we add the formatter as a child to the core formatter using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyFunctionTypeFormatter } from \"./my-function-formatter.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\n// We configure the formatter an add our custom formatter to it.\nconst formatter = createFormatter(config, (fmt, circularReferenceTypeFormatter) => {\n    // If your formatter DOES NOT support children, e.g. getChildren() { return [] }:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter());\n    // If your formatter DOES support children, you'll need this reference too:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter(circularReferenceTypeFormatter));\n});\n\nconst program = createProgram(config);\nconst parser = createParser(program, config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n### Custom parsing\n\nSimilar to custom formatting, extending the built-in parsing works practically the same way:\n\n1. First we create a parser, in this case for parsing construct types:\n\n```ts\n// my-constructor-parser.ts\nimport { Context, StringType, ReferenceType, BaseType, SubNodeParser } from \"ts-json-schema-generator\";\nimport ts from \"typescript\";\n\nexport class MyConstructorParser implements SubNodeParser {\n    supportsNode(node: ts.Node): boolean {\n        return node.kind === ts.SyntaxKind.ConstructorType;\n    }\n    createType(node: ts.Node, context: Context, reference?: ReferenceType): BaseType | undefined {\n        return new StringType(); // Treat constructors as strings in this example\n    }\n}\n```\n\n2. Then we add the parser as a child to the core parser using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyConstructorParser } from \"./my-constructor-parser.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst program = createProgram(config);\n\n// We configure the parser an add our custom parser to it.\nconst parser = createParser(program, config, (prs) => {\n    prs.addNodeParser(new MyConstructorParser());\n});\n\nconst formatter = createFormatter(config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n## Options\n\n```\n-p, --path 'index.ts'\n    The path to the TypeScript source file. If this is not provided, the type will be searched in the project specified in the `.tsconfig`.\n\n-t, --type 'My.Type.Name'\n    The type the generated schema will represent. If omitted, the generated schema will contain all\n    types found in the files matching path. The same is true if '*' is specified.\n\n-i, --id 'generatedSchemaId'\n    The `$id` of the generated schema. If omitted, there will be no `$id`.\n\n-e, --expose <all|none|export>\n    all: Create shared $ref definitions for all types.\n    none: Do not create shared $ref definitions.\n    export (default): Create shared $ref definitions only for exported types (not tagged as `@internal`).\n\n-f, --tsconfig 'my/project/tsconfig.json'\n    Use a custom tsconfig file for processing typescript (see https://www.typescriptlang.org/docs/handbook/tsconfig-json.html) instead of the default:\n    {\n        \"compilerOptions\": {\n            \"noEmit\": true,\n            \"emitDecoratorMetadata\": true,\n            \"experimentalDecorators\": true,\n            \"target\": \"ES5\",\n            \"module\": \"CommonJS\",\n            \"strictNullChecks\": false,\n        }\n    }\n\n-j, --jsDoc <extended|none|basic>\n    none: Do not use JsDoc annotations.\n    basic: Read JsDoc annotations to provide schema properties.\n    extended (default): Also read @nullable, and @asType annotations.\n\n--unstable\n    Do not sort properties.\n\n--strict-tuples\n    Do not allow additional items on tuples.\n\n--no-top-ref\n    Do not create a top-level $ref definition.\n\n--no-type-check\n    Skip type checks for better performance.\n\n--no-ref-encode\n    Do not encode references. According to the standard, references must be valid URIs but some tools do not support encoded references.\n\n--validation-keywords\n    Provide additional validation keywords to include.\n\n-o, --out\n    Specify the output file path. Without this option, the generator logs the response in the console.\n\n--additional-properties <true|false>\n    Controls whether or not to allow additional properties for objects that have no index signature.\n\n    true: Additional properties are allowed\n    false (default): Additional properties are not allowed\n```\n\n## Current state\n\n-   `interface` types\n-   `enum` types\n-   `union`, `tuple`, `type[]` types\n-   `Date`, `RegExp` types\n-   `string`, `boolean`, `number` types\n-   `\"value\"`, `123`, `true`, `false`, `null`, `undefined` literals\n-   type aliases\n-   generics\n-   `typeof`\n-   `keyof`\n-   conditional types\n\n## Run locally\n\n`yarn --silent run run --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\n## Debug\n\n`yarn --silent run debug --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\nAnd connect via the debugger protocol.\n\n[AST Explorer](https://astexplorer.net/) is amazing for developers of this tool!\n\n## Publish\n\nPublishing is handled by a 2-branch [pre-release process](https://intuit.github.io/auto/docs/generated/shipit#next-branch-default), configured in `publish-auto.yml`. All changes should be based off the default `next` branch, and are published automatically.\n\n- PRs made into the default branch are auto-deployed to the `next` pre-release tag on NPM. The result can be installed with `npm install ts-json-schema-generator@next`\n  - When merging into `next`, please use the `squash and merge` strategy. \n- To release a new stable version, open a PR from `next` into `stable` using this [compare link](https://github.com/vega/ts-json-schema-generator/compare/stable...next).\n  - When merging from `next` into `stable`, please use the `create a merge commit` strategy.\n",
      "readmeFilename": "README.md",
      "gitHead": "488f6c9aca40eeff5ab609a540e48fc3a4f614f0",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.95.1--canary.942.488f6c9.0",
      "_nodeVersion": "14.17.6",
      "_npmVersion": "6.14.15",
      "dist": {
        "integrity": "sha512-v3hUX9xssJe6QPpgRIq/Bnbi4AxQ1xFm1Y57pdAha1LxVWWijs9Fip9iuW1sdrSYdsmwVzgiNEN88ZLDSBypjg==",
        "shasum": "01760d723d656821232c5ed32c982ffebc107e34",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.95.1--canary.942.488f6c9.0.tgz",
        "fileCount": 609,
        "unpackedSize": 619340,
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIDccn9HsnQLkUNJJRAHzuhHAxlOwkd+Iw2gHXrTehilTAiEAn4fZJY05EjRD4B2uUEfrfVK6w+CNf/dbzZ5hUJPvG3U="
          }
        ]
      },
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "maintainers": [
        {
          "name": "jheer",
          "email": "jeffrey.heer@gmail.com"
        },
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "kanitw",
          "email": "kanitw@gmail.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.95.1--canary.942.488f6c9.0_1631895807106_0.9532714308254686"
      },
      "_hasShrinkwrap": false
    },
    "0.95.1--canary.941.ae0db8a.0": {
      "name": "ts-json-schema-generator",
      "version": "0.95.1--canary.941.ae0db8a.0",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "MooYeol Prescott Lee",
          "email": "mooyoul@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=10.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.7",
        "commander": "^8.0.0",
        "fast-json-stable-stringify": "^2.1.0",
        "glob": "^7.1.7",
        "json-stable-stringify": "^1.0.1",
        "json5": "^2.2.0",
        "typescript": "~4.4.2"
      },
      "devDependencies": {
        "@auto-it/conventional-commits": "^10.29.3",
        "@auto-it/first-time-contributor": "^10.29.3",
        "@babel/core": "^7.14.6",
        "@babel/preset-env": "^7.14.7",
        "@babel/preset-typescript": "^7.14.5",
        "@types/glob": "^7.1.3",
        "@types/jest": "^27.0.1",
        "@types/json-stable-stringify": "^1.0.32",
        "@types/node": "^16.0.0",
        "@typescript-eslint/eslint-plugin": "^4.28.1",
        "@typescript-eslint/parser": "^4.28.1",
        "ajv": "^8.6.0",
        "ajv-formats": "^2.1.0",
        "auto": "^10.29.3",
        "chai": "^4.3.4",
        "cross-env": "^7.0.3",
        "eslint": "^7.29.0",
        "eslint-config-prettier": "^8.3.0",
        "eslint-plugin-prettier": "^4.0.0",
        "jest": "^27.0.6",
        "jest-junit": "^12.2.0",
        "prettier": "^2.3.2",
        "ts-node": "^10.0.0",
        "vega": "^5.20.2",
        "vega-lite": "^5.1.0"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint \"{src,test,factory}/**/*.ts\"",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "cross-env FAST_TEST=1 jest test/ --verbose",
        "test:coverage": "yarn jest test/ --collectCoverage=true",
        "test:update": "cross-env UPDATE_SCHEMA=true yarn test:fast",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts",
        "release": "yarn build && auto shipit"
      },
      "readme": "# ts-json-schema-generator\n\n![Test](https://github.com/vega/ts-json-schema-generator/workflows/Test/badge.svg)\n[![codecov](https://codecov.io/gh/vega/ts-json-schema-generator/branch/master/graph/badge.svg)](https://codecov.io/gh/vega/ts-json-schema-generator)\n[![npm version](https://img.shields.io/npm/v/ts-json-schema-generator.svg)](https://www.npmjs.com/package/ts-json-schema-generator)\n\nExtended version of [https://github.com/xiag-ag/typescript-to-json-schema](https://github.com/xiag-ag/typescript-to-json-schema).\n\nInspired by [`YousefED/typescript-json-schema`](https://github.com/YousefED/typescript-json-schema). Here's the differences list:\n\n-   this implementation avoids the use of `typeChecker.getTypeAtLocation()` (so probably it keeps correct type aliases)\n-   processing AST and formatting JSON schema have been split into two independent steps\n-   not exported types, interfaces, enums are not exposed in the `definitions` section in the JSON schema\n\n## Contributors\n\nThis project is made possible by a [community of contributors](https://github.com/vega/ts-json-schema-generator/graphs/contributors). We welcome contributions of any kind (issues, code, documentation, examples, tests,...). Please read our [code of conduct](https://github.com/vega/vega/blob/master/CODE_OF_CONDUCT.md).\n\n## CLI Usage\n\n```bash\nnpm install --save ts-json-schema-generator\n./node_modules/.bin/ts-json-schema-generator --path 'my/project/**/*.ts' --type 'My.Type.Name'\n```\n\nNote that different platforms (e.g. Windows) may use different path separators so you may have to adjust the command above.\n\n## Programmatic Usage\n\n```js\n// main.js\n\nconst tsj = require(\"ts-json-schema-generator\");\nconst fs = require(\"fs\");\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst output_path = \"path/to/output/file\";\n\nconst schema = tsj.createGenerator(config).createSchema(config.type);\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\nRun the schema generator via `node main.js`.\n\n### Custom formatting\n\nExtending the built-in formatting is possible by creating a custom formatter and adding it to the main formatter:\n\n1. First we create a formatter, in this case for formatting function types:\n\n```ts\n// my-function-formatter.ts\nimport { BaseType, Definition, FunctionType, SubTypeFormatter } from \"ts-json-schema-generator\";\nimport ts from \"typescript\";\n\nexport class MyFunctionTypeFormatter implements SubTypeFormatter {\n    // You can skip this line if you don't need childTypeFormatter\n    public constructor(private childTypeFormatter: TypeFormatter) {}\n\n    public supportsType(type: FunctionType): boolean {\n        return type instanceof FunctionType;\n    }\n\n    public getDefinition(type: FunctionType): Definition {\n        // Return a custom schema for the function property.\n        return {\n            type: \"object\",\n            properties: {\n                isFunction: {\n                    type: \"boolean\",\n                    const: true,\n                },\n            },\n        };\n    }\n\n    // If this type does NOT HAVE children, generally all you need is:\n    public getChildren(type: FunctionType): BaseType[] {\n        return [];\n    }\n\n    // However, if children ARE supported, you'll need something similar to\n    // this (see src/TypeFormatter/{Array,Definition,etc}.ts for some examples):\n    public getChildren(type: FunctionType): BaseType[] {\n        return this.childTypeFormatter.getChildren(type.getType());\n    }\n}\n```\n\n2. Then we add the formatter as a child to the core formatter using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyFunctionTypeFormatter } from \"./my-function-formatter.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\n// We configure the formatter an add our custom formatter to it.\nconst formatter = createFormatter(config, (fmt, circularReferenceTypeFormatter) => {\n    // If your formatter DOES NOT support children, e.g. getChildren() { return [] }:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter());\n    // If your formatter DOES support children, you'll need this reference too:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter(circularReferenceTypeFormatter));\n});\n\nconst program = createProgram(config);\nconst parser = createParser(program, config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n### Custom parsing\n\nSimilar to custom formatting, extending the built-in parsing works practically the same way:\n\n1. First we create a parser, in this case for parsing construct types:\n\n```ts\n// my-constructor-parser.ts\nimport { Context, StringType, ReferenceType, BaseType, SubNodeParser } from \"ts-json-schema-generator\";\nimport ts from \"typescript\";\n\nexport class MyConstructorParser implements SubNodeParser {\n    supportsNode(node: ts.Node): boolean {\n        return node.kind === ts.SyntaxKind.ConstructorType;\n    }\n    createType(node: ts.Node, context: Context, reference?: ReferenceType): BaseType | undefined {\n        return new StringType(); // Treat constructors as strings in this example\n    }\n}\n```\n\n2. Then we add the parser as a child to the core parser using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyConstructorParser } from \"./my-constructor-parser.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst program = createProgram(config);\n\n// We configure the parser an add our custom parser to it.\nconst parser = createParser(program, config, (prs) => {\n    prs.addNodeParser(new MyConstructorParser());\n});\n\nconst formatter = createFormatter(config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n## Options\n\n```\n-p, --path 'index.ts'\n    The path to the TypeScript source file. If this is not provided, the type will be searched in the project specified in the `.tsconfig`.\n\n-t, --type 'My.Type.Name'\n    The type the generated schema will represent. If omitted, the generated schema will contain all\n    types found in the files matching path. The same is true if '*' is specified.\n\n-i, --id 'generatedSchemaId'\n    The `$id` of the generated schema. If omitted, there will be no `$id`.\n\n-e, --expose <all|none|export>\n    all: Create shared $ref definitions for all types.\n    none: Do not create shared $ref definitions.\n    export (default): Create shared $ref definitions only for exported types (not tagged as `@internal`).\n\n-f, --tsconfig 'my/project/tsconfig.json'\n    Use a custom tsconfig file for processing typescript (see https://www.typescriptlang.org/docs/handbook/tsconfig-json.html) instead of the default:\n    {\n        \"compilerOptions\": {\n            \"noEmit\": true,\n            \"emitDecoratorMetadata\": true,\n            \"experimentalDecorators\": true,\n            \"target\": \"ES5\",\n            \"module\": \"CommonJS\",\n            \"strictNullChecks\": false,\n        }\n    }\n\n-j, --jsDoc <extended|none|basic>\n    none: Do not use JsDoc annotations.\n    basic: Read JsDoc annotations to provide schema properties.\n    extended (default): Also read @nullable, and @asType annotations.\n\n--unstable\n    Do not sort properties.\n\n--strict-tuples\n    Do not allow additional items on tuples.\n\n--no-top-ref\n    Do not create a top-level $ref definition.\n\n--no-type-check\n    Skip type checks for better performance.\n\n--no-ref-encode\n    Do not encode references. According to the standard, references must be valid URIs but some tools do not support encoded references.\n\n--validation-keywords\n    Provide additional validation keywords to include.\n\n-o, --out\n    Specify the output file path. Without this option, the generator logs the response in the console.\n\n--additional-properties <true|false>\n    Controls whether or not to allow additional properties for objects that have no index signature.\n\n    true: Additional properties are allowed\n    false (default): Additional properties are not allowed\n```\n\n## Current state\n\n-   `interface` types\n-   `enum` types\n-   `union`, `tuple`, `type[]` types\n-   `Date`, `RegExp` types\n-   `string`, `boolean`, `number` types\n-   `\"value\"`, `123`, `true`, `false`, `null`, `undefined` literals\n-   type aliases\n-   generics\n-   `typeof`\n-   `keyof`\n-   conditional types\n\n## Run locally\n\n`yarn --silent run run --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\n## Debug\n\n`yarn --silent run debug --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\nAnd connect via the debugger protocol.\n\n[AST Explorer](https://astexplorer.net/) is amazing for developers of this tool!\n\n## Publish\n\nPublishing is handled by a 2-branch [pre-release process](https://intuit.github.io/auto/docs/generated/shipit#next-branch-default), configured in `publish-auto.yml`. All changes should be based off the default `next` branch, and are published automatically.\n\n- PRs made into the default branch are auto-deployed to the `next` pre-release tag on NPM. The result can be installed with `npm install ts-json-schema-generator@next`\n  - When merging into `next`, please use the `squash and merge` strategy. \n- To release a new stable version, open a PR from `next` into `stable` using this [compare link](https://github.com/vega/ts-json-schema-generator/compare/stable...next).\n  - When merging from `next` into `stable`, please use the `create a merge commit` strategy.\n",
      "readmeFilename": "README.md",
      "gitHead": "ae0db8adb88177460c190601077308a4d59f2b49",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.95.1--canary.941.ae0db8a.0",
      "_nodeVersion": "14.17.6",
      "_npmVersion": "6.14.15",
      "dist": {
        "integrity": "sha512-GR2i+aQt2QloqNv7+dG3zIsJcDjdRVnktNVsuVAGF4vQSbd3+7f2vdouojeRk9LGRNjthnyo6sy9DOG8W/r7VQ==",
        "shasum": "c09ebc7bda89ab3f5ec940211297e4a87c1e8fea",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.95.1--canary.941.ae0db8a.0.tgz",
        "fileCount": 609,
        "unpackedSize": 619333,
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEQCIA+8Mz6YFEVrzU9aE1mnCMEPsyFuUfLLFfi9hXGOf8QGAiB/Ob0T7hgoJXGbNZaKgnPxSeCCwIe+37+8BxCTsDvH0Q=="
          }
        ]
      },
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "maintainers": [
        {
          "name": "jheer",
          "email": "jeffrey.heer@gmail.com"
        },
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "kanitw",
          "email": "kanitw@gmail.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.95.1--canary.941.ae0db8a.0_1631896740199_0.030359551969054044"
      },
      "_hasShrinkwrap": false
    },
    "0.95.1--canary.954.5c1fbdb.0": {
      "name": "ts-json-schema-generator",
      "version": "0.95.1--canary.954.5c1fbdb.0",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "MooYeol Prescott Lee",
          "email": "mooyoul@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=10.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.9",
        "commander": "^8.2.0",
        "fast-json-stable-stringify": "^2.1.0",
        "glob": "^7.1.7",
        "json-stable-stringify": "^1.0.1",
        "json5": "^2.2.0",
        "typescript": "~4.4.3"
      },
      "devDependencies": {
        "@auto-it/conventional-commits": "^10.32.0",
        "@auto-it/first-time-contributor": "^10.32.0",
        "@babel/core": "^7.15.5",
        "@babel/preset-env": "^7.15.6",
        "@babel/preset-typescript": "^7.15.0",
        "@types/glob": "^7.1.4",
        "@types/jest": "^27.0.1",
        "@types/json-stable-stringify": "^1.0.33",
        "@types/node": "^16.9.4",
        "@typescript-eslint/eslint-plugin": "^4.31.1",
        "@typescript-eslint/parser": "^4.31.1",
        "ajv": "^8.6.3",
        "ajv-formats": "^2.1.1",
        "auto": "^10.32.0",
        "chai": "^4.3.4",
        "cross-env": "^7.0.3",
        "eslint": "^7.32.0",
        "eslint-config-prettier": "^8.3.0",
        "eslint-plugin-prettier": "^4.0.0",
        "jest": "^27.2.0",
        "jest-junit": "^12.2.0",
        "prettier": "^2.4.1",
        "ts-node": "^10.2.1",
        "vega": "^5.20.2",
        "vega-lite": "^5.1.1"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint \"{src,test,factory}/**/*.ts\"",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "cross-env FAST_TEST=1 jest test/ --verbose",
        "test:coverage": "yarn jest test/ --collectCoverage=true",
        "test:update": "cross-env UPDATE_SCHEMA=true yarn test:fast",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts",
        "release": "yarn build && auto shipit"
      },
      "readme": "# ts-json-schema-generator\n\n![Test](https://github.com/vega/ts-json-schema-generator/workflows/Test/badge.svg)\n[![codecov](https://codecov.io/gh/vega/ts-json-schema-generator/branch/master/graph/badge.svg)](https://codecov.io/gh/vega/ts-json-schema-generator)\n[![npm version](https://img.shields.io/npm/v/ts-json-schema-generator.svg)](https://www.npmjs.com/package/ts-json-schema-generator)\n\nExtended version of [https://github.com/xiag-ag/typescript-to-json-schema](https://github.com/xiag-ag/typescript-to-json-schema).\n\nInspired by [`YousefED/typescript-json-schema`](https://github.com/YousefED/typescript-json-schema). Here's the differences list:\n\n-   this implementation avoids the use of `typeChecker.getTypeAtLocation()` (so probably it keeps correct type aliases)\n-   processing AST and formatting JSON schema have been split into two independent steps\n-   not exported types, interfaces, enums are not exposed in the `definitions` section in the JSON schema\n\n## Contributors\n\nThis project is made possible by a [community of contributors](https://github.com/vega/ts-json-schema-generator/graphs/contributors). We welcome contributions of any kind (issues, code, documentation, examples, tests,...). Please read our [code of conduct](https://github.com/vega/vega/blob/master/CODE_OF_CONDUCT.md).\n\n## CLI Usage\n\n```bash\nnpm install --save ts-json-schema-generator\n./node_modules/.bin/ts-json-schema-generator --path 'my/project/**/*.ts' --type 'My.Type.Name'\n```\n\nNote that different platforms (e.g. Windows) may use different path separators so you may have to adjust the command above.\n\n## Programmatic Usage\n\n```js\n// main.js\n\nconst tsj = require(\"ts-json-schema-generator\");\nconst fs = require(\"fs\");\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst output_path = \"path/to/output/file\";\n\nconst schema = tsj.createGenerator(config).createSchema(config.type);\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\nRun the schema generator via `node main.js`.\n\n### Custom formatting\n\nExtending the built-in formatting is possible by creating a custom formatter and adding it to the main formatter:\n\n1. First we create a formatter, in this case for formatting function types:\n\n```ts\n// my-function-formatter.ts\nimport { BaseType, Definition, FunctionType, SubTypeFormatter } from \"ts-json-schema-generator\";\nimport ts from \"typescript\";\n\nexport class MyFunctionTypeFormatter implements SubTypeFormatter {\n    // You can skip this line if you don't need childTypeFormatter\n    public constructor(private childTypeFormatter: TypeFormatter) {}\n\n    public supportsType(type: FunctionType): boolean {\n        return type instanceof FunctionType;\n    }\n\n    public getDefinition(type: FunctionType): Definition {\n        // Return a custom schema for the function property.\n        return {\n            type: \"object\",\n            properties: {\n                isFunction: {\n                    type: \"boolean\",\n                    const: true,\n                },\n            },\n        };\n    }\n\n    // If this type does NOT HAVE children, generally all you need is:\n    public getChildren(type: FunctionType): BaseType[] {\n        return [];\n    }\n\n    // However, if children ARE supported, you'll need something similar to\n    // this (see src/TypeFormatter/{Array,Definition,etc}.ts for some examples):\n    public getChildren(type: FunctionType): BaseType[] {\n        return this.childTypeFormatter.getChildren(type.getType());\n    }\n}\n```\n\n2. Then we add the formatter as a child to the core formatter using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyFunctionTypeFormatter } from \"./my-function-formatter.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\n// We configure the formatter an add our custom formatter to it.\nconst formatter = createFormatter(config, (fmt, circularReferenceTypeFormatter) => {\n    // If your formatter DOES NOT support children, e.g. getChildren() { return [] }:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter());\n    // If your formatter DOES support children, you'll need this reference too:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter(circularReferenceTypeFormatter));\n});\n\nconst program = createProgram(config);\nconst parser = createParser(program, config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n### Custom parsing\n\nSimilar to custom formatting, extending the built-in parsing works practically the same way:\n\n1. First we create a parser, in this case for parsing construct types:\n\n```ts\n// my-constructor-parser.ts\nimport { Context, StringType, ReferenceType, BaseType, SubNodeParser } from \"ts-json-schema-generator\";\nimport ts from \"typescript\";\n\nexport class MyConstructorParser implements SubNodeParser {\n    supportsNode(node: ts.Node): boolean {\n        return node.kind === ts.SyntaxKind.ConstructorType;\n    }\n    createType(node: ts.Node, context: Context, reference?: ReferenceType): BaseType | undefined {\n        return new StringType(); // Treat constructors as strings in this example\n    }\n}\n```\n\n2. Then we add the parser as a child to the core parser using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyConstructorParser } from \"./my-constructor-parser.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst program = createProgram(config);\n\n// We configure the parser an add our custom parser to it.\nconst parser = createParser(program, config, (prs) => {\n    prs.addNodeParser(new MyConstructorParser());\n});\n\nconst formatter = createFormatter(config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n## Options\n\n```\n-p, --path 'index.ts'\n    The path to the TypeScript source file. If this is not provided, the type will be searched in the project specified in the `.tsconfig`.\n\n-t, --type 'My.Type.Name'\n    The type the generated schema will represent. If omitted, the generated schema will contain all\n    types found in the files matching path. The same is true if '*' is specified.\n\n-i, --id 'generatedSchemaId'\n    The `$id` of the generated schema. If omitted, there will be no `$id`.\n\n-e, --expose <all|none|export>\n    all: Create shared $ref definitions for all types.\n    none: Do not create shared $ref definitions.\n    export (default): Create shared $ref definitions only for exported types (not tagged as `@internal`).\n\n-f, --tsconfig 'my/project/tsconfig.json'\n    Use a custom tsconfig file for processing typescript (see https://www.typescriptlang.org/docs/handbook/tsconfig-json.html) instead of the default:\n    {\n        \"compilerOptions\": {\n            \"noEmit\": true,\n            \"emitDecoratorMetadata\": true,\n            \"experimentalDecorators\": true,\n            \"target\": \"ES5\",\n            \"module\": \"CommonJS\",\n            \"strictNullChecks\": false,\n        }\n    }\n\n-j, --jsDoc <extended|none|basic>\n    none: Do not use JsDoc annotations.\n    basic: Read JsDoc annotations to provide schema properties.\n    extended (default): Also read @nullable, and @asType annotations.\n\n--unstable\n    Do not sort properties.\n\n--strict-tuples\n    Do not allow additional items on tuples.\n\n--no-top-ref\n    Do not create a top-level $ref definition.\n\n--no-type-check\n    Skip type checks for better performance.\n\n--no-ref-encode\n    Do not encode references. According to the standard, references must be valid URIs but some tools do not support encoded references.\n\n--validation-keywords\n    Provide additional validation keywords to include.\n\n-o, --out\n    Specify the output file path. Without this option, the generator logs the response in the console.\n\n--additional-properties <true|false>\n    Controls whether or not to allow additional properties for objects that have no index signature.\n\n    true: Additional properties are allowed\n    false (default): Additional properties are not allowed\n```\n\n## Current state\n\n-   `interface` types\n-   `enum` types\n-   `union`, `tuple`, `type[]` types\n-   `Date`, `RegExp` types\n-   `string`, `boolean`, `number` types\n-   `\"value\"`, `123`, `true`, `false`, `null`, `undefined` literals\n-   type aliases\n-   generics\n-   `typeof`\n-   `keyof`\n-   conditional types\n\n## Run locally\n\n`yarn --silent run run --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\n## Debug\n\n`yarn --silent run debug --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\nAnd connect via the debugger protocol.\n\n[AST Explorer](https://astexplorer.net/) is amazing for developers of this tool!\n\n## Publish\n\nPublishing is handled by a 2-branch [pre-release process](https://intuit.github.io/auto/docs/generated/shipit#next-branch-default), configured in `publish-auto.yml`. All changes should be based off the default `next` branch, and are published automatically.\n\n- PRs made into the default branch are auto-deployed to the `next` pre-release tag on NPM. The result can be installed with `npm install ts-json-schema-generator@next`\n  - When merging into `next`, please use the `squash and merge` strategy. \n- To release a new stable version, open a PR from `next` into `stable` using this [compare link](https://github.com/vega/ts-json-schema-generator/compare/stable...next).\n  - When merging from `next` into `stable`, please use the `create a merge commit` strategy.\n",
      "readmeFilename": "README.md",
      "gitHead": "5c1fbdbe58edaeb4faf51ed2f05fc7fddbd0820d",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.95.1--canary.954.5c1fbdb.0",
      "_nodeVersion": "14.17.6",
      "_npmVersion": "6.14.15",
      "dist": {
        "integrity": "sha512-d9vrxC5GDbLFK0YZ/r/iHX6uk+Uc/9g1K54kqGgq5uyUgY0RGIB79BvRr9fQLksoTEyC9RhoMK2co1L4RMT1kw==",
        "shasum": "6d964ae122890cf86b0cc2df1a3a72591030cde4",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.95.1--canary.954.5c1fbdb.0.tgz",
        "fileCount": 609,
        "unpackedSize": 619340,
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEYCIQDLAwHZkAUw4Tb6Y7WxNqaippK1RRNRzignX8lf+71XwwIhAP+0ArqN00aJOqkZI/N+n0zbwgEg/OKNxjke57eQ3Rt3"
          }
        ]
      },
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "maintainers": [
        {
          "name": "jheer",
          "email": "jeffrey.heer@gmail.com"
        },
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "kanitw",
          "email": "kanitw@gmail.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.95.1--canary.954.5c1fbdb.0_1632143099328_0.19257130053265437"
      },
      "_hasShrinkwrap": false
    },
    "0.96.0-next.0": {
      "name": "ts-json-schema-generator",
      "version": "0.96.0-next.0",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "MooYeol Prescott Lee",
          "email": "mooyoul@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=10.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.9",
        "commander": "^8.2.0",
        "fast-json-stable-stringify": "^2.1.0",
        "glob": "^7.1.7",
        "json-stable-stringify": "^1.0.1",
        "json5": "^2.2.0",
        "typescript": "~4.4.3"
      },
      "devDependencies": {
        "@auto-it/conventional-commits": "^10.32.0",
        "@auto-it/first-time-contributor": "^10.32.0",
        "@babel/core": "^7.15.5",
        "@babel/preset-env": "^7.15.6",
        "@babel/preset-typescript": "^7.15.0",
        "@types/glob": "^7.1.4",
        "@types/jest": "^27.0.1",
        "@types/json-stable-stringify": "^1.0.33",
        "@types/node": "^16.9.4",
        "@typescript-eslint/eslint-plugin": "^4.31.1",
        "@typescript-eslint/parser": "^4.31.1",
        "ajv": "^8.6.3",
        "ajv-formats": "^2.1.1",
        "auto": "^10.32.0",
        "chai": "^4.3.4",
        "cross-env": "^7.0.3",
        "eslint": "^7.32.0",
        "eslint-config-prettier": "^8.3.0",
        "eslint-plugin-prettier": "^4.0.0",
        "jest": "^27.2.0",
        "jest-junit": "^12.2.0",
        "prettier": "^2.4.1",
        "ts-node": "^10.2.1",
        "vega": "^5.20.2",
        "vega-lite": "^5.1.1"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint \"{src,test,factory}/**/*.ts\"",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "cross-env FAST_TEST=1 jest test/ --verbose",
        "test:coverage": "yarn jest test/ --collectCoverage=true",
        "test:update": "cross-env UPDATE_SCHEMA=true yarn test:fast",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts",
        "release": "yarn build && auto shipit"
      },
      "readme": "# ts-json-schema-generator\n\n![Test](https://github.com/vega/ts-json-schema-generator/workflows/Test/badge.svg)\n[![codecov](https://codecov.io/gh/vega/ts-json-schema-generator/branch/master/graph/badge.svg)](https://codecov.io/gh/vega/ts-json-schema-generator)\n[![npm version](https://img.shields.io/npm/v/ts-json-schema-generator.svg)](https://www.npmjs.com/package/ts-json-schema-generator)\n\nExtended version of [https://github.com/xiag-ag/typescript-to-json-schema](https://github.com/xiag-ag/typescript-to-json-schema).\n\nInspired by [`YousefED/typescript-json-schema`](https://github.com/YousefED/typescript-json-schema). Here's the differences list:\n\n-   this implementation avoids the use of `typeChecker.getTypeAtLocation()` (so probably it keeps correct type aliases)\n-   processing AST and formatting JSON schema have been split into two independent steps\n-   not exported types, interfaces, enums are not exposed in the `definitions` section in the JSON schema\n\n## Contributors\n\nThis project is made possible by a [community of contributors](https://github.com/vega/ts-json-schema-generator/graphs/contributors). We welcome contributions of any kind (issues, code, documentation, examples, tests,...). Please read our [code of conduct](https://github.com/vega/vega/blob/master/CODE_OF_CONDUCT.md).\n\n## CLI Usage\n\n```bash\nnpm install --save ts-json-schema-generator\n./node_modules/.bin/ts-json-schema-generator --path 'my/project/**/*.ts' --type 'My.Type.Name'\n```\n\nNote that different platforms (e.g. Windows) may use different path separators so you may have to adjust the command above.\n\n## Programmatic Usage\n\n```js\n// main.js\n\nconst tsj = require(\"ts-json-schema-generator\");\nconst fs = require(\"fs\");\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst output_path = \"path/to/output/file\";\n\nconst schema = tsj.createGenerator(config).createSchema(config.type);\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\nRun the schema generator via `node main.js`.\n\n### Custom formatting\n\nExtending the built-in formatting is possible by creating a custom formatter and adding it to the main formatter:\n\n1. First we create a formatter, in this case for formatting function types:\n\n```ts\n// my-function-formatter.ts\nimport { BaseType, Definition, FunctionType, SubTypeFormatter } from \"ts-json-schema-generator\";\nimport ts from \"typescript\";\n\nexport class MyFunctionTypeFormatter implements SubTypeFormatter {\n    // You can skip this line if you don't need childTypeFormatter\n    public constructor(private childTypeFormatter: TypeFormatter) {}\n\n    public supportsType(type: FunctionType): boolean {\n        return type instanceof FunctionType;\n    }\n\n    public getDefinition(type: FunctionType): Definition {\n        // Return a custom schema for the function property.\n        return {\n            type: \"object\",\n            properties: {\n                isFunction: {\n                    type: \"boolean\",\n                    const: true,\n                },\n            },\n        };\n    }\n\n    // If this type does NOT HAVE children, generally all you need is:\n    public getChildren(type: FunctionType): BaseType[] {\n        return [];\n    }\n\n    // However, if children ARE supported, you'll need something similar to\n    // this (see src/TypeFormatter/{Array,Definition,etc}.ts for some examples):\n    public getChildren(type: FunctionType): BaseType[] {\n        return this.childTypeFormatter.getChildren(type.getType());\n    }\n}\n```\n\n2. Then we add the formatter as a child to the core formatter using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyFunctionTypeFormatter } from \"./my-function-formatter.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\n// We configure the formatter an add our custom formatter to it.\nconst formatter = createFormatter(config, (fmt, circularReferenceTypeFormatter) => {\n    // If your formatter DOES NOT support children, e.g. getChildren() { return [] }:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter());\n    // If your formatter DOES support children, you'll need this reference too:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter(circularReferenceTypeFormatter));\n});\n\nconst program = createProgram(config);\nconst parser = createParser(program, config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n### Custom parsing\n\nSimilar to custom formatting, extending the built-in parsing works practically the same way:\n\n1. First we create a parser, in this case for parsing construct types:\n\n```ts\n// my-constructor-parser.ts\nimport { Context, StringType, ReferenceType, BaseType, SubNodeParser } from \"ts-json-schema-generator\";\nimport ts from \"typescript\";\n\nexport class MyConstructorParser implements SubNodeParser {\n    supportsNode(node: ts.Node): boolean {\n        return node.kind === ts.SyntaxKind.ConstructorType;\n    }\n    createType(node: ts.Node, context: Context, reference?: ReferenceType): BaseType | undefined {\n        return new StringType(); // Treat constructors as strings in this example\n    }\n}\n```\n\n2. Then we add the parser as a child to the core parser using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyConstructorParser } from \"./my-constructor-parser.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst program = createProgram(config);\n\n// We configure the parser an add our custom parser to it.\nconst parser = createParser(program, config, (prs) => {\n    prs.addNodeParser(new MyConstructorParser());\n});\n\nconst formatter = createFormatter(config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n## Options\n\n```\n-p, --path 'index.ts'\n    The path to the TypeScript source file. If this is not provided, the type will be searched in the project specified in the `.tsconfig`.\n\n-t, --type 'My.Type.Name'\n    The type the generated schema will represent. If omitted, the generated schema will contain all\n    types found in the files matching path. The same is true if '*' is specified.\n\n-i, --id 'generatedSchemaId'\n    The `$id` of the generated schema. If omitted, there will be no `$id`.\n\n-e, --expose <all|none|export>\n    all: Create shared $ref definitions for all types.\n    none: Do not create shared $ref definitions.\n    export (default): Create shared $ref definitions only for exported types (not tagged as `@internal`).\n\n-f, --tsconfig 'my/project/tsconfig.json'\n    Use a custom tsconfig file for processing typescript (see https://www.typescriptlang.org/docs/handbook/tsconfig-json.html) instead of the default:\n    {\n        \"compilerOptions\": {\n            \"noEmit\": true,\n            \"emitDecoratorMetadata\": true,\n            \"experimentalDecorators\": true,\n            \"target\": \"ES5\",\n            \"module\": \"CommonJS\",\n            \"strictNullChecks\": false,\n        }\n    }\n\n-j, --jsDoc <extended|none|basic>\n    none: Do not use JsDoc annotations.\n    basic: Read JsDoc annotations to provide schema properties.\n    extended (default): Also read @nullable, and @asType annotations.\n\n--unstable\n    Do not sort properties.\n\n--strict-tuples\n    Do not allow additional items on tuples.\n\n--no-top-ref\n    Do not create a top-level $ref definition.\n\n--no-type-check\n    Skip type checks for better performance.\n\n--no-ref-encode\n    Do not encode references. According to the standard, references must be valid URIs but some tools do not support encoded references.\n\n--validation-keywords\n    Provide additional validation keywords to include.\n\n-o, --out\n    Specify the output file path. Without this option, the generator logs the response in the console.\n\n--additional-properties <true|false>\n    Controls whether or not to allow additional properties for objects that have no index signature.\n\n    true: Additional properties are allowed\n    false (default): Additional properties are not allowed\n```\n\n## Current state\n\n-   `interface` types\n-   `enum` types\n-   `union`, `tuple`, `type[]` types\n-   `Date`, `RegExp` types\n-   `string`, `boolean`, `number` types\n-   `\"value\"`, `123`, `true`, `false`, `null`, `undefined` literals\n-   type aliases\n-   generics\n-   `typeof`\n-   `keyof`\n-   conditional types\n\n## Run locally\n\n`yarn --silent run run --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\n## Debug\n\n`yarn --silent run debug --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\nAnd connect via the debugger protocol.\n\n[AST Explorer](https://astexplorer.net/) is amazing for developers of this tool!\n\n## Publish\n\nPublishing is handled by a 2-branch [pre-release process](https://intuit.github.io/auto/docs/generated/shipit#next-branch-default), configured in `publish-auto.yml`. All changes should be based off the default `next` branch, and are published automatically.\n\n- PRs made into the default branch are auto-deployed to the `next` pre-release tag on NPM. The result can be installed with `npm install ts-json-schema-generator@next`\n  - When merging into `next`, please use the `squash and merge` strategy. \n- To release a new stable version, open a PR from `next` into `stable` using this [compare link](https://github.com/vega/ts-json-schema-generator/compare/stable...next).\n  - When merging from `next` into `stable`, please use the `create a merge commit` strategy.\n",
      "readmeFilename": "README.md",
      "gitHead": "f0fdcb6511d79132baa583f87266c2ae931bfeb5",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.96.0-next.0",
      "_nodeVersion": "14.17.6",
      "_npmVersion": "6.14.15",
      "dist": {
        "integrity": "sha512-uLTXxqLx6ZweBcw0OplZAmz8OAg2iPte6+T644LJLcH1ZvflBH+paQk/huTC5PQXr1S43nVWxoMUH8YxlviwNg==",
        "shasum": "77c40e36840cdabc9c43df39ec58717aa059bcf2",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.96.0-next.0.tgz",
        "fileCount": 609,
        "unpackedSize": 621378,
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEQCIHzvdkLbzY9QavAJmLu2OlfqJNLUEJ0oRDvxDhm8XmbuAiBV2L/dDaTMA0v50lzZoluPRy47OEcvTocIgrWZSIm3QA=="
          }
        ]
      },
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "maintainers": [
        {
          "name": "jheer",
          "email": "jeffrey.heer@gmail.com"
        },
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "kanitw",
          "email": "kanitw@gmail.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.96.0-next.0_1632409565059_0.45570949919326154"
      },
      "_hasShrinkwrap": false
    },
    "0.96.0-next.1": {
      "name": "ts-json-schema-generator",
      "version": "0.96.0-next.1",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "MooYeol Prescott Lee",
          "email": "mooyoul@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=10.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.9",
        "commander": "^8.2.0",
        "fast-json-stable-stringify": "^2.1.0",
        "glob": "^7.1.7",
        "json-stable-stringify": "^1.0.1",
        "json5": "^2.2.0",
        "typescript": "~4.4.3"
      },
      "devDependencies": {
        "@auto-it/conventional-commits": "^10.32.0",
        "@auto-it/first-time-contributor": "^10.32.0",
        "@babel/core": "^7.15.5",
        "@babel/preset-env": "^7.15.6",
        "@babel/preset-typescript": "^7.15.0",
        "@types/glob": "^7.1.4",
        "@types/jest": "^27.0.1",
        "@types/json-stable-stringify": "^1.0.33",
        "@types/node": "^16.9.4",
        "@typescript-eslint/eslint-plugin": "^4.31.1",
        "@typescript-eslint/parser": "^4.31.1",
        "ajv": "^8.6.3",
        "ajv-formats": "^2.1.1",
        "auto": "^10.32.0",
        "chai": "^4.3.4",
        "cross-env": "^7.0.3",
        "eslint": "^7.32.0",
        "eslint-config-prettier": "^8.3.0",
        "eslint-plugin-prettier": "^4.0.0",
        "jest": "^27.2.0",
        "jest-junit": "^12.2.0",
        "prettier": "^2.4.1",
        "ts-node": "^10.2.1",
        "vega": "^5.20.2",
        "vega-lite": "^5.1.1"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint \"{src,test,factory}/**/*.ts\"",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "cross-env FAST_TEST=1 jest test/ --verbose",
        "test:coverage": "yarn jest test/ --collectCoverage=true",
        "test:update": "cross-env UPDATE_SCHEMA=true yarn test:fast",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts",
        "release": "yarn build && auto shipit"
      },
      "readme": "# ts-json-schema-generator\n\n![Test](https://github.com/vega/ts-json-schema-generator/workflows/Test/badge.svg)\n[![codecov](https://codecov.io/gh/vega/ts-json-schema-generator/branch/master/graph/badge.svg)](https://codecov.io/gh/vega/ts-json-schema-generator)\n[![npm version](https://img.shields.io/npm/v/ts-json-schema-generator.svg)](https://www.npmjs.com/package/ts-json-schema-generator)\n\nExtended version of [https://github.com/xiag-ag/typescript-to-json-schema](https://github.com/xiag-ag/typescript-to-json-schema).\n\nInspired by [`YousefED/typescript-json-schema`](https://github.com/YousefED/typescript-json-schema). Here's the differences list:\n\n-   this implementation avoids the use of `typeChecker.getTypeAtLocation()` (so probably it keeps correct type aliases)\n-   processing AST and formatting JSON schema have been split into two independent steps\n-   not exported types, interfaces, enums are not exposed in the `definitions` section in the JSON schema\n\n## Contributors\n\nThis project is made possible by a [community of contributors](https://github.com/vega/ts-json-schema-generator/graphs/contributors). We welcome contributions of any kind (issues, code, documentation, examples, tests,...). Please read our [code of conduct](https://github.com/vega/vega/blob/master/CODE_OF_CONDUCT.md).\n\n## CLI Usage\n\n```bash\nnpm install --save ts-json-schema-generator\n./node_modules/.bin/ts-json-schema-generator --path 'my/project/**/*.ts' --type 'My.Type.Name'\n```\n\nNote that different platforms (e.g. Windows) may use different path separators so you may have to adjust the command above.\n\n## Programmatic Usage\n\n```js\n// main.js\n\nconst tsj = require(\"ts-json-schema-generator\");\nconst fs = require(\"fs\");\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst output_path = \"path/to/output/file\";\n\nconst schema = tsj.createGenerator(config).createSchema(config.type);\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\nRun the schema generator via `node main.js`.\n\n### Custom formatting\n\nExtending the built-in formatting is possible by creating a custom formatter and adding it to the main formatter:\n\n1. First we create a formatter, in this case for formatting function types:\n\n```ts\n// my-function-formatter.ts\nimport { BaseType, Definition, FunctionType, SubTypeFormatter } from \"ts-json-schema-generator\";\nimport ts from \"typescript\";\n\nexport class MyFunctionTypeFormatter implements SubTypeFormatter {\n    // You can skip this line if you don't need childTypeFormatter\n    public constructor(private childTypeFormatter: TypeFormatter) {}\n\n    public supportsType(type: FunctionType): boolean {\n        return type instanceof FunctionType;\n    }\n\n    public getDefinition(type: FunctionType): Definition {\n        // Return a custom schema for the function property.\n        return {\n            type: \"object\",\n            properties: {\n                isFunction: {\n                    type: \"boolean\",\n                    const: true,\n                },\n            },\n        };\n    }\n\n    // If this type does NOT HAVE children, generally all you need is:\n    public getChildren(type: FunctionType): BaseType[] {\n        return [];\n    }\n\n    // However, if children ARE supported, you'll need something similar to\n    // this (see src/TypeFormatter/{Array,Definition,etc}.ts for some examples):\n    public getChildren(type: FunctionType): BaseType[] {\n        return this.childTypeFormatter.getChildren(type.getType());\n    }\n}\n```\n\n2. Then we add the formatter as a child to the core formatter using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyFunctionTypeFormatter } from \"./my-function-formatter.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\n// We configure the formatter an add our custom formatter to it.\nconst formatter = createFormatter(config, (fmt, circularReferenceTypeFormatter) => {\n    // If your formatter DOES NOT support children, e.g. getChildren() { return [] }:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter());\n    // If your formatter DOES support children, you'll need this reference too:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter(circularReferenceTypeFormatter));\n});\n\nconst program = createProgram(config);\nconst parser = createParser(program, config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n### Custom parsing\n\nSimilar to custom formatting, extending the built-in parsing works practically the same way:\n\n1. First we create a parser, in this case for parsing construct types:\n\n```ts\n// my-constructor-parser.ts\nimport { Context, StringType, ReferenceType, BaseType, SubNodeParser } from \"ts-json-schema-generator\";\nimport ts from \"typescript\";\n\nexport class MyConstructorParser implements SubNodeParser {\n    supportsNode(node: ts.Node): boolean {\n        return node.kind === ts.SyntaxKind.ConstructorType;\n    }\n    createType(node: ts.Node, context: Context, reference?: ReferenceType): BaseType | undefined {\n        return new StringType(); // Treat constructors as strings in this example\n    }\n}\n```\n\n2. Then we add the parser as a child to the core parser using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyConstructorParser } from \"./my-constructor-parser.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst program = createProgram(config);\n\n// We configure the parser an add our custom parser to it.\nconst parser = createParser(program, config, (prs) => {\n    prs.addNodeParser(new MyConstructorParser());\n});\n\nconst formatter = createFormatter(config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n## Options\n\n```\n-p, --path 'index.ts'\n    The path to the TypeScript source file. If this is not provided, the type will be searched in the project specified in the `.tsconfig`.\n\n-t, --type 'My.Type.Name'\n    The type the generated schema will represent. If omitted, the generated schema will contain all\n    types found in the files matching path. The same is true if '*' is specified.\n\n-i, --id 'generatedSchemaId'\n    The `$id` of the generated schema. If omitted, there will be no `$id`.\n\n-e, --expose <all|none|export>\n    all: Create shared $ref definitions for all types.\n    none: Do not create shared $ref definitions.\n    export (default): Create shared $ref definitions only for exported types (not tagged as `@internal`).\n\n-f, --tsconfig 'my/project/tsconfig.json'\n    Use a custom tsconfig file for processing typescript (see https://www.typescriptlang.org/docs/handbook/tsconfig-json.html) instead of the default:\n    {\n        \"compilerOptions\": {\n            \"noEmit\": true,\n            \"emitDecoratorMetadata\": true,\n            \"experimentalDecorators\": true,\n            \"target\": \"ES5\",\n            \"module\": \"CommonJS\",\n            \"strictNullChecks\": false,\n        }\n    }\n\n-j, --jsDoc <extended|none|basic>\n    none: Do not use JsDoc annotations.\n    basic: Read JsDoc annotations to provide schema properties.\n    extended (default): Also read @nullable, and @asType annotations.\n\n--unstable\n    Do not sort properties.\n\n--strict-tuples\n    Do not allow additional items on tuples.\n\n--no-top-ref\n    Do not create a top-level $ref definition.\n\n--no-type-check\n    Skip type checks for better performance.\n\n--no-ref-encode\n    Do not encode references. According to the standard, references must be valid URIs but some tools do not support encoded references.\n\n--validation-keywords\n    Provide additional validation keywords to include.\n\n-o, --out\n    Specify the output file path. Without this option, the generator logs the response in the console.\n\n--additional-properties <true|false>\n    Controls whether or not to allow additional properties for objects that have no index signature.\n\n    true: Additional properties are allowed\n    false (default): Additional properties are not allowed\n```\n\n## Current state\n\n-   `interface` types\n-   `enum` types\n-   `union`, `tuple`, `type[]` types\n-   `Date`, `RegExp` types\n-   `string`, `boolean`, `number` types\n-   `\"value\"`, `123`, `true`, `false`, `null`, `undefined` literals\n-   type aliases\n-   generics\n-   `typeof`\n-   `keyof`\n-   conditional types\n\n## Run locally\n\n`yarn --silent run run --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\n## Debug\n\n`yarn --silent run debug --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\nAnd connect via the debugger protocol.\n\n[AST Explorer](https://astexplorer.net/) is amazing for developers of this tool!\n\n## Publish\n\nPublishing is handled by a 2-branch [pre-release process](https://intuit.github.io/auto/docs/generated/shipit#next-branch-default), configured in `publish-auto.yml`. All changes should be based off the default `next` branch, and are published automatically.\n\n- PRs made into the default branch are auto-deployed to the `next` pre-release tag on NPM. The result can be installed with `npm install ts-json-schema-generator@next`\n  - When merging into `next`, please use the `squash and merge` strategy. \n- To release a new stable version, open a PR from `next` into `stable` using this [compare link](https://github.com/vega/ts-json-schema-generator/compare/stable...next).\n  - When merging from `next` into `stable`, please use the `create a merge commit` strategy.\n",
      "readmeFilename": "README.md",
      "gitHead": "c6d7eabcdb93d03b265d4b824eb69cfbe8bb2b98",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.96.0-next.1",
      "_nodeVersion": "14.18.0",
      "_npmVersion": "6.14.15",
      "dist": {
        "integrity": "sha512-us3YKajV4x1ze33hhgAuOznnEgt5uprmdzLc3b8RRz4lAtkgHZ4yRQ3bxAVBwoiP4gmG2y5SusV7c53+0TDT9g==",
        "shasum": "5af72bb7b0fa7be669da5a615c15badf17545fa8",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.96.0-next.1.tgz",
        "fileCount": 609,
        "unpackedSize": 621436,
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEYCIQCUp3rvXFsWHhIURiSqKpKTtxK4y0bRaUcenV+2ltiLWwIhALvtToHaB2Gvb7gPlkeMHo0M50jLLm0QAVJjsjNE3iGF"
          }
        ]
      },
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "maintainers": [
        {
          "name": "jheer",
          "email": "jeffrey.heer@gmail.com"
        },
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "kanitw",
          "email": "kanitw@gmail.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.96.0-next.1_1633398126132_0.22661842908707275"
      },
      "_hasShrinkwrap": false
    },
    "0.96.0-next.2": {
      "name": "ts-json-schema-generator",
      "version": "0.96.0-next.2",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "MooYeol Prescott Lee",
          "email": "mooyoul@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=10.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.9",
        "commander": "^8.2.0",
        "fast-json-stable-stringify": "^2.1.0",
        "glob": "^7.1.7",
        "json-stable-stringify": "^1.0.1",
        "json5": "^2.2.0",
        "typescript": "~4.4.3"
      },
      "devDependencies": {
        "@auto-it/conventional-commits": "^10.32.0",
        "@auto-it/first-time-contributor": "^10.32.0",
        "@babel/core": "^7.15.5",
        "@babel/preset-env": "^7.15.6",
        "@babel/preset-typescript": "^7.15.0",
        "@types/glob": "^7.1.4",
        "@types/jest": "^27.0.1",
        "@types/json-stable-stringify": "^1.0.33",
        "@types/node": "^16.9.4",
        "@typescript-eslint/eslint-plugin": "^4.31.1",
        "@typescript-eslint/parser": "^4.31.1",
        "ajv": "^8.6.3",
        "ajv-formats": "^2.1.1",
        "auto": "^10.32.0",
        "chai": "^4.3.4",
        "cross-env": "^7.0.3",
        "eslint": "^7.32.0",
        "eslint-config-prettier": "^8.3.0",
        "eslint-plugin-prettier": "^4.0.0",
        "jest": "^27.2.0",
        "jest-junit": "^12.2.0",
        "prettier": "^2.4.1",
        "ts-node": "^10.2.1",
        "vega": "^5.20.2",
        "vega-lite": "^5.1.1"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint \"{src,test,factory}/**/*.ts\"",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "cross-env FAST_TEST=1 jest test/ --verbose",
        "test:coverage": "yarn jest test/ --collectCoverage=true",
        "test:update": "cross-env UPDATE_SCHEMA=true yarn test:fast",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts",
        "release": "yarn build && auto shipit"
      },
      "readme": "# ts-json-schema-generator\n\n![Test](https://github.com/vega/ts-json-schema-generator/workflows/Test/badge.svg)\n[![codecov](https://codecov.io/gh/vega/ts-json-schema-generator/branch/master/graph/badge.svg)](https://codecov.io/gh/vega/ts-json-schema-generator)\n[![npm version](https://img.shields.io/npm/v/ts-json-schema-generator.svg)](https://www.npmjs.com/package/ts-json-schema-generator)\n\nExtended version of [https://github.com/xiag-ag/typescript-to-json-schema](https://github.com/xiag-ag/typescript-to-json-schema).\n\nInspired by [`YousefED/typescript-json-schema`](https://github.com/YousefED/typescript-json-schema). Here's the differences list:\n\n-   this implementation avoids the use of `typeChecker.getTypeAtLocation()` (so probably it keeps correct type aliases)\n-   processing AST and formatting JSON schema have been split into two independent steps\n-   not exported types, interfaces, enums are not exposed in the `definitions` section in the JSON schema\n\n## Contributors\n\nThis project is made possible by a [community of contributors](https://github.com/vega/ts-json-schema-generator/graphs/contributors). We welcome contributions of any kind (issues, code, documentation, examples, tests,...). Please read our [code of conduct](https://github.com/vega/vega/blob/master/CODE_OF_CONDUCT.md).\n\n## CLI Usage\n\n```bash\nnpm install --save ts-json-schema-generator\n./node_modules/.bin/ts-json-schema-generator --path 'my/project/**/*.ts' --type 'My.Type.Name'\n```\n\nNote that different platforms (e.g. Windows) may use different path separators so you may have to adjust the command above.\n\n## Programmatic Usage\n\n```js\n// main.js\n\nconst tsj = require(\"ts-json-schema-generator\");\nconst fs = require(\"fs\");\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst output_path = \"path/to/output/file\";\n\nconst schema = tsj.createGenerator(config).createSchema(config.type);\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\nRun the schema generator via `node main.js`.\n\n### Custom formatting\n\nExtending the built-in formatting is possible by creating a custom formatter and adding it to the main formatter:\n\n1. First we create a formatter, in this case for formatting function types:\n\n```ts\n// my-function-formatter.ts\nimport { BaseType, Definition, FunctionType, SubTypeFormatter } from \"ts-json-schema-generator\";\nimport ts from \"typescript\";\n\nexport class MyFunctionTypeFormatter implements SubTypeFormatter {\n    // You can skip this line if you don't need childTypeFormatter\n    public constructor(private childTypeFormatter: TypeFormatter) {}\n\n    public supportsType(type: FunctionType): boolean {\n        return type instanceof FunctionType;\n    }\n\n    public getDefinition(type: FunctionType): Definition {\n        // Return a custom schema for the function property.\n        return {\n            type: \"object\",\n            properties: {\n                isFunction: {\n                    type: \"boolean\",\n                    const: true,\n                },\n            },\n        };\n    }\n\n    // If this type does NOT HAVE children, generally all you need is:\n    public getChildren(type: FunctionType): BaseType[] {\n        return [];\n    }\n\n    // However, if children ARE supported, you'll need something similar to\n    // this (see src/TypeFormatter/{Array,Definition,etc}.ts for some examples):\n    public getChildren(type: FunctionType): BaseType[] {\n        return this.childTypeFormatter.getChildren(type.getType());\n    }\n}\n```\n\n2. Then we add the formatter as a child to the core formatter using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyFunctionTypeFormatter } from \"./my-function-formatter.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\n// We configure the formatter an add our custom formatter to it.\nconst formatter = createFormatter(config, (fmt, circularReferenceTypeFormatter) => {\n    // If your formatter DOES NOT support children, e.g. getChildren() { return [] }:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter());\n    // If your formatter DOES support children, you'll need this reference too:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter(circularReferenceTypeFormatter));\n});\n\nconst program = createProgram(config);\nconst parser = createParser(program, config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n### Custom parsing\n\nSimilar to custom formatting, extending the built-in parsing works practically the same way:\n\n1. First we create a parser, in this case for parsing construct types:\n\n```ts\n// my-constructor-parser.ts\nimport { Context, StringType, ReferenceType, BaseType, SubNodeParser } from \"ts-json-schema-generator\";\nimport ts from \"typescript\";\n\nexport class MyConstructorParser implements SubNodeParser {\n    supportsNode(node: ts.Node): boolean {\n        return node.kind === ts.SyntaxKind.ConstructorType;\n    }\n    createType(node: ts.Node, context: Context, reference?: ReferenceType): BaseType | undefined {\n        return new StringType(); // Treat constructors as strings in this example\n    }\n}\n```\n\n2. Then we add the parser as a child to the core parser using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyConstructorParser } from \"./my-constructor-parser.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst program = createProgram(config);\n\n// We configure the parser an add our custom parser to it.\nconst parser = createParser(program, config, (prs) => {\n    prs.addNodeParser(new MyConstructorParser());\n});\n\nconst formatter = createFormatter(config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n## Options\n\n```\n-p, --path 'index.ts'\n    The path to the TypeScript source file. If this is not provided, the type will be searched in the project specified in the `.tsconfig`.\n\n-t, --type 'My.Type.Name'\n    The type the generated schema will represent. If omitted, the generated schema will contain all\n    types found in the files matching path. The same is true if '*' is specified.\n\n-i, --id 'generatedSchemaId'\n    The `$id` of the generated schema. If omitted, there will be no `$id`.\n\n-e, --expose <all|none|export>\n    all: Create shared $ref definitions for all types.\n    none: Do not create shared $ref definitions.\n    export (default): Create shared $ref definitions only for exported types (not tagged as `@internal`).\n\n-f, --tsconfig 'my/project/tsconfig.json'\n    Use a custom tsconfig file for processing typescript (see https://www.typescriptlang.org/docs/handbook/tsconfig-json.html) instead of the default:\n    {\n        \"compilerOptions\": {\n            \"noEmit\": true,\n            \"emitDecoratorMetadata\": true,\n            \"experimentalDecorators\": true,\n            \"target\": \"ES5\",\n            \"module\": \"CommonJS\",\n            \"strictNullChecks\": false,\n        }\n    }\n\n-j, --jsDoc <extended|none|basic>\n    none: Do not use JsDoc annotations.\n    basic: Read JsDoc annotations to provide schema properties.\n    extended (default): Also read @nullable, and @asType annotations.\n\n--unstable\n    Do not sort properties.\n\n--strict-tuples\n    Do not allow additional items on tuples.\n\n--no-top-ref\n    Do not create a top-level $ref definition.\n\n--no-type-check\n    Skip type checks for better performance.\n\n--no-ref-encode\n    Do not encode references. According to the standard, references must be valid URIs but some tools do not support encoded references.\n\n--validation-keywords\n    Provide additional validation keywords to include.\n\n-o, --out\n    Specify the output file path. Without this option, the generator logs the response in the console.\n\n--additional-properties <true|false>\n    Controls whether or not to allow additional properties for objects that have no index signature.\n\n    true: Additional properties are allowed\n    false (default): Additional properties are not allowed\n```\n\n## Current state\n\n-   `interface` types\n-   `enum` types\n-   `union`, `tuple`, `type[]` types\n-   `Date`, `RegExp` types\n-   `string`, `boolean`, `number` types\n-   `\"value\"`, `123`, `true`, `false`, `null`, `undefined` literals\n-   type aliases\n-   generics\n-   `typeof`\n-   `keyof`\n-   conditional types\n\n## Run locally\n\n`yarn --silent run run --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\n## Debug\n\n`yarn --silent run debug --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\nAnd connect via the debugger protocol.\n\n[AST Explorer](https://astexplorer.net/) is amazing for developers of this tool!\n\n## Publish\n\nPublishing is handled by a 2-branch [pre-release process](https://intuit.github.io/auto/docs/generated/shipit#next-branch-default), configured in `publish-auto.yml`. All changes should be based off the default `next` branch, and are published automatically.\n\n- PRs made into the default branch are auto-deployed to the `next` pre-release tag on NPM. The result can be installed with `npm install ts-json-schema-generator@next`\n  - When merging into `next`, please use the `squash and merge` strategy. \n- To release a new stable version, open a PR from `next` into `stable` using this [compare link](https://github.com/vega/ts-json-schema-generator/compare/stable...next).\n  - When merging from `next` into `stable`, please use the `create a merge commit` strategy.\n",
      "readmeFilename": "README.md",
      "gitHead": "ce3f7b3b258f61d7bde8cc5aa0dc0a1cc1d7c0ec",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.96.0-next.2",
      "_nodeVersion": "14.18.0",
      "_npmVersion": "6.14.15",
      "dist": {
        "integrity": "sha512-ClVxso/IxisYWyLLpr/gnaL4uTxyice5GlSexEGcB7w4UsAqFBb9rJzEcoSgtM85Q2LGtT7HjdDKOfozV5k8oQ==",
        "shasum": "da387b8abe15c143efafa53b56f4cfde1fc144b2",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.96.0-next.2.tgz",
        "fileCount": 609,
        "unpackedSize": 621448,
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIQD7T4pTS5IW5iyL303VbKJeitQiHY+WO1NUOrLSRj8dHwIgWRy/AESeL+TFxm0fXCn8hK9NoKW6Yvpg665g8NlijsE="
          }
        ]
      },
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "maintainers": [
        {
          "name": "jheer",
          "email": "jeffrey.heer@gmail.com"
        },
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "kanitw",
          "email": "kanitw@gmail.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.96.0-next.2_1633451275115_0.07742423853671121"
      },
      "_hasShrinkwrap": false
    },
    "0.96.0": {
      "name": "ts-json-schema-generator",
      "version": "0.96.0",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "MooYeol Prescott Lee",
          "email": "mooyoul@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=10.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.9",
        "commander": "^8.2.0",
        "fast-json-stable-stringify": "^2.1.0",
        "glob": "^7.2.0",
        "json-stable-stringify": "^1.0.1",
        "json5": "^2.2.0",
        "typescript": "~4.4.3"
      },
      "devDependencies": {
        "@auto-it/conventional-commits": "^10.32.1",
        "@auto-it/first-time-contributor": "^10.32.1",
        "@babel/core": "^7.15.5",
        "@babel/preset-env": "^7.15.6",
        "@babel/preset-typescript": "^7.15.0",
        "@types/glob": "^7.1.4",
        "@types/jest": "^27.0.2",
        "@types/json-stable-stringify": "^1.0.33",
        "@types/node": "^16.10.2",
        "@typescript-eslint/eslint-plugin": "^4.33.0",
        "@typescript-eslint/parser": "^4.33.0",
        "ajv": "^8.6.3",
        "ajv-formats": "^2.1.1",
        "auto": "^10.32.1",
        "chai": "^4.3.4",
        "cross-env": "^7.0.3",
        "eslint": "^7.32.0",
        "eslint-config-prettier": "^8.3.0",
        "eslint-plugin-prettier": "^4.0.0",
        "jest": "^27.2.4",
        "jest-junit": "^13.0.0",
        "prettier": "^2.4.1",
        "ts-node": "^10.2.1",
        "vega": "^5.21.0",
        "vega-lite": "^5.1.1"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint \"{src,test,factory}/**/*.ts\"",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "cross-env FAST_TEST=1 jest test/ --verbose",
        "test:coverage": "yarn jest test/ --collectCoverage=true",
        "test:update": "cross-env UPDATE_SCHEMA=true yarn test:fast",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts",
        "release": "yarn build && auto shipit"
      },
      "gitHead": "47936528db183db0a74bc94f3045af7b009e3d8c",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.96.0",
      "_nodeVersion": "14.18.0",
      "_npmVersion": "6.14.15",
      "dist": {
        "integrity": "sha512-41w/r/2xFeVh8HWHLgGlh0877aOkLERJ5LIzk2y+MXxqL84JF44e6OLKkgIF60m3s9/FlzDA5mUfmxYP6E82yQ==",
        "shasum": "b15147ed1b43eee47e4eed7d95c90a3f456b8128",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.96.0.tgz",
        "fileCount": 610,
        "unpackedSize": 643843,
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIQCmWF4HEH/uphDL+71LN7ORQ4OcjLoj3XrRjoNzYNdDhwIgUvBapF/WqbYhHDOamr9xOw2DRdjoDGur9I/38obg9FA="
          }
        ]
      },
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "maintainers": [
        {
          "name": "jheer",
          "email": "jeffrey.heer@gmail.com"
        },
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "kanitw",
          "email": "kanitw@gmail.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.96.0_1633452961159_0.16572120525086032"
      },
      "_hasShrinkwrap": false
    },
    "0.96.1--canary.978.8eee423.0": {
      "name": "ts-json-schema-generator",
      "version": "0.96.1--canary.978.8eee423.0",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "MooYeol Prescott Lee",
          "email": "mooyoul@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=10.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.9",
        "commander": "^8.2.0",
        "fast-json-stable-stringify": "^2.1.0",
        "glob": "^7.2.0",
        "json-stable-stringify": "^1.0.1",
        "json5": "^2.2.0",
        "typescript": "~4.4.3"
      },
      "devDependencies": {
        "@auto-it/conventional-commits": "^10.32.1",
        "@auto-it/first-time-contributor": "^10.32.1",
        "@babel/core": "^7.15.8",
        "@babel/preset-env": "^7.15.8",
        "@babel/preset-typescript": "^7.15.0",
        "@types/glob": "^7.1.4",
        "@types/jest": "^27.0.2",
        "@types/json-stable-stringify": "^1.0.33",
        "@types/node": "^16.10.3",
        "@typescript-eslint/eslint-plugin": "^4.33.0",
        "@typescript-eslint/parser": "^4.33.0",
        "ajv": "^8.6.3",
        "ajv-formats": "^2.1.1",
        "auto": "^10.32.1",
        "chai": "^4.3.4",
        "cross-env": "^7.0.3",
        "eslint": "^7.32.0",
        "eslint-config-prettier": "^8.3.0",
        "eslint-plugin-prettier": "^4.0.0",
        "jest": "^27.2.4",
        "jest-junit": "^13.0.0",
        "prettier": "^2.4.1",
        "ts-node": "^10.2.1",
        "vega": "^5.21.0",
        "vega-lite": "^5.1.1"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint \"{src,test,factory}/**/*.ts\"",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "cross-env FAST_TEST=1 jest test/ --verbose",
        "test:coverage": "yarn jest test/ --collectCoverage=true",
        "test:update": "cross-env UPDATE_SCHEMA=true yarn test:fast",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts",
        "release": "yarn build && auto shipit"
      },
      "readme": "# ts-json-schema-generator\n\n![Test](https://github.com/vega/ts-json-schema-generator/workflows/Test/badge.svg)\n[![codecov](https://codecov.io/gh/vega/ts-json-schema-generator/branch/master/graph/badge.svg)](https://codecov.io/gh/vega/ts-json-schema-generator)\n[![npm version](https://img.shields.io/npm/v/ts-json-schema-generator.svg)](https://www.npmjs.com/package/ts-json-schema-generator)\n\nExtended version of [https://github.com/xiag-ag/typescript-to-json-schema](https://github.com/xiag-ag/typescript-to-json-schema).\n\nInspired by [`YousefED/typescript-json-schema`](https://github.com/YousefED/typescript-json-schema). Here's the differences list:\n\n-   this implementation avoids the use of `typeChecker.getTypeAtLocation()` (so probably it keeps correct type aliases)\n-   processing AST and formatting JSON schema have been split into two independent steps\n-   not exported types, interfaces, enums are not exposed in the `definitions` section in the JSON schema\n\n## Contributors\n\nThis project is made possible by a [community of contributors](https://github.com/vega/ts-json-schema-generator/graphs/contributors). We welcome contributions of any kind (issues, code, documentation, examples, tests,...). Please read our [code of conduct](https://github.com/vega/vega/blob/master/CODE_OF_CONDUCT.md).\n\n## CLI Usage\n\n```bash\nnpm install --save ts-json-schema-generator\n./node_modules/.bin/ts-json-schema-generator --path 'my/project/**/*.ts' --type 'My.Type.Name'\n```\n\nNote that different platforms (e.g. Windows) may use different path separators so you may have to adjust the command above.\n\n## Programmatic Usage\n\n```js\n// main.js\n\nconst tsj = require(\"ts-json-schema-generator\");\nconst fs = require(\"fs\");\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst output_path = \"path/to/output/file\";\n\nconst schema = tsj.createGenerator(config).createSchema(config.type);\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\nRun the schema generator via `node main.js`.\n\n### Custom formatting\n\nExtending the built-in formatting is possible by creating a custom formatter and adding it to the main formatter:\n\n1. First we create a formatter, in this case for formatting function types:\n\n```ts\n// my-function-formatter.ts\nimport { BaseType, Definition, FunctionType, SubTypeFormatter } from \"ts-json-schema-generator\";\nimport ts from \"typescript\";\n\nexport class MyFunctionTypeFormatter implements SubTypeFormatter {\n    // You can skip this line if you don't need childTypeFormatter\n    public constructor(private childTypeFormatter: TypeFormatter) {}\n\n    public supportsType(type: FunctionType): boolean {\n        return type instanceof FunctionType;\n    }\n\n    public getDefinition(type: FunctionType): Definition {\n        // Return a custom schema for the function property.\n        return {\n            type: \"object\",\n            properties: {\n                isFunction: {\n                    type: \"boolean\",\n                    const: true,\n                },\n            },\n        };\n    }\n\n    // If this type does NOT HAVE children, generally all you need is:\n    public getChildren(type: FunctionType): BaseType[] {\n        return [];\n    }\n\n    // However, if children ARE supported, you'll need something similar to\n    // this (see src/TypeFormatter/{Array,Definition,etc}.ts for some examples):\n    public getChildren(type: FunctionType): BaseType[] {\n        return this.childTypeFormatter.getChildren(type.getType());\n    }\n}\n```\n\n2. Then we add the formatter as a child to the core formatter using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyFunctionTypeFormatter } from \"./my-function-formatter.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\n// We configure the formatter an add our custom formatter to it.\nconst formatter = createFormatter(config, (fmt, circularReferenceTypeFormatter) => {\n    // If your formatter DOES NOT support children, e.g. getChildren() { return [] }:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter());\n    // If your formatter DOES support children, you'll need this reference too:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter(circularReferenceTypeFormatter));\n});\n\nconst program = createProgram(config);\nconst parser = createParser(program, config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n### Custom parsing\n\nSimilar to custom formatting, extending the built-in parsing works practically the same way:\n\n1. First we create a parser, in this case for parsing construct types:\n\n```ts\n// my-constructor-parser.ts\nimport { Context, StringType, ReferenceType, BaseType, SubNodeParser } from \"ts-json-schema-generator\";\nimport ts from \"typescript\";\n\nexport class MyConstructorParser implements SubNodeParser {\n    supportsNode(node: ts.Node): boolean {\n        return node.kind === ts.SyntaxKind.ConstructorType;\n    }\n    createType(node: ts.Node, context: Context, reference?: ReferenceType): BaseType | undefined {\n        return new StringType(); // Treat constructors as strings in this example\n    }\n}\n```\n\n2. Then we add the parser as a child to the core parser using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyConstructorParser } from \"./my-constructor-parser.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst program = createProgram(config);\n\n// We configure the parser an add our custom parser to it.\nconst parser = createParser(program, config, (prs) => {\n    prs.addNodeParser(new MyConstructorParser());\n});\n\nconst formatter = createFormatter(config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n## Options\n\n```\n-p, --path 'index.ts'\n    The path to the TypeScript source file. If this is not provided, the type will be searched in the project specified in the `.tsconfig`.\n\n-t, --type 'My.Type.Name'\n    The type the generated schema will represent. If omitted, the generated schema will contain all\n    types found in the files matching path. The same is true if '*' is specified.\n\n-i, --id 'generatedSchemaId'\n    The `$id` of the generated schema. If omitted, there will be no `$id`.\n\n-e, --expose <all|none|export>\n    all: Create shared $ref definitions for all types.\n    none: Do not create shared $ref definitions.\n    export (default): Create shared $ref definitions only for exported types (not tagged as `@internal`).\n\n-f, --tsconfig 'my/project/tsconfig.json'\n    Use a custom tsconfig file for processing typescript (see https://www.typescriptlang.org/docs/handbook/tsconfig-json.html) instead of the default:\n    {\n        \"compilerOptions\": {\n            \"noEmit\": true,\n            \"emitDecoratorMetadata\": true,\n            \"experimentalDecorators\": true,\n            \"target\": \"ES5\",\n            \"module\": \"CommonJS\",\n            \"strictNullChecks\": false,\n        }\n    }\n\n-j, --jsDoc <extended|none|basic>\n    none: Do not use JsDoc annotations.\n    basic: Read JsDoc annotations to provide schema properties.\n    extended (default): Also read @nullable, and @asType annotations.\n\n--unstable\n    Do not sort properties.\n\n--strict-tuples\n    Do not allow additional items on tuples.\n\n--no-top-ref\n    Do not create a top-level $ref definition.\n\n--no-type-check\n    Skip type checks for better performance.\n\n--no-ref-encode\n    Do not encode references. According to the standard, references must be valid URIs but some tools do not support encoded references.\n\n--validation-keywords\n    Provide additional validation keywords to include.\n\n-o, --out\n    Specify the output file path. Without this option, the generator logs the response in the console.\n\n--additional-properties <true|false>\n    Controls whether or not to allow additional properties for objects that have no index signature.\n\n    true: Additional properties are allowed\n    false (default): Additional properties are not allowed\n```\n\n## Current state\n\n-   `interface` types\n-   `enum` types\n-   `union`, `tuple`, `type[]` types\n-   `Date`, `RegExp` types\n-   `string`, `boolean`, `number` types\n-   `\"value\"`, `123`, `true`, `false`, `null`, `undefined` literals\n-   type aliases\n-   generics\n-   `typeof`\n-   `keyof`\n-   conditional types\n\n## Run locally\n\n`yarn --silent run run --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\n## Debug\n\n`yarn --silent run debug --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\nAnd connect via the debugger protocol.\n\n[AST Explorer](https://astexplorer.net/) is amazing for developers of this tool!\n\n## Publish\n\nPublishing is handled by a 2-branch [pre-release process](https://intuit.github.io/auto/docs/generated/shipit#next-branch-default), configured in `publish-auto.yml`. All changes should be based off the default `next` branch, and are published automatically.\n\n-   PRs made into the default branch are auto-deployed to the `next` pre-release tag on NPM. The result can be installed with `npm install ts-json-schema-generator@next`\n    -   When merging into `next`, please use the `squash and merge` strategy.\n-   To release a new stable version, open a PR from `next` into `stable` using this [compare link](https://github.com/vega/ts-json-schema-generator/compare/stable...next).\n    -   When merging from `next` into `stable`, please use the `create a merge commit` strategy.\n",
      "readmeFilename": "README.md",
      "gitHead": "8eee423c38248b8ff96d630571a336d024b0ad38",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.96.1--canary.978.8eee423.0",
      "_nodeVersion": "14.18.0",
      "_npmVersion": "6.14.15",
      "dist": {
        "integrity": "sha512-shlkNMJlJpXaVaSUoUoJ0tSSrOQRrcJq2JQp5sijg/H5UyK0D7KNRxJoebeaZcsKb6dvyoybVReQsOUtL0majg==",
        "shasum": "c02647765affd96eefcf68904ee5415412f18088",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.96.1--canary.978.8eee423.0.tgz",
        "fileCount": 610,
        "unpackedSize": 626112,
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIG3cj7DEhHEkR9kUaw53K3XQHaoy37InstbXWHK1OJWNAiEApzbC9VuKR9J1sCcLKkw7iHmSOw5QJE3z1t3r67tMPzs="
          }
        ]
      },
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "maintainers": [
        {
          "name": "jheer",
          "email": "jeffrey.heer@gmail.com"
        },
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "kanitw",
          "email": "kanitw@gmail.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.96.1--canary.978.8eee423.0_1633574451493_0.5336536068240765"
      },
      "_hasShrinkwrap": false
    },
    "0.96.1--canary.979.51a876b.0": {
      "name": "ts-json-schema-generator",
      "version": "0.96.1--canary.979.51a876b.0",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "MooYeol Prescott Lee",
          "email": "mooyoul@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=10.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.9",
        "commander": "^8.2.0",
        "fast-json-stable-stringify": "^2.1.0",
        "glob": "^7.2.0",
        "json-stable-stringify": "^1.0.1",
        "json5": "^2.2.0",
        "typescript": "~4.4.3"
      },
      "devDependencies": {
        "@auto-it/conventional-commits": "^10.32.1",
        "@auto-it/first-time-contributor": "^10.32.1",
        "@babel/core": "^7.15.5",
        "@babel/preset-env": "^7.15.6",
        "@babel/preset-typescript": "^7.15.0",
        "@types/glob": "^7.1.4",
        "@types/jest": "^27.0.2",
        "@types/json-stable-stringify": "^1.0.33",
        "@types/node": "^16.10.2",
        "@typescript-eslint/eslint-plugin": "^4.33.0",
        "@typescript-eslint/parser": "^4.33.0",
        "ajv": "^8.6.3",
        "ajv-formats": "^2.1.1",
        "auto": "^10.32.1",
        "chai": "^4.3.4",
        "cross-env": "^7.0.3",
        "eslint": "^7.32.0",
        "eslint-config-prettier": "^8.3.0",
        "eslint-plugin-prettier": "^4.0.0",
        "jest": "^27.2.4",
        "jest-junit": "^13.0.0",
        "prettier": "^2.4.1",
        "ts-node": "^10.2.1",
        "vega": "^5.21.0",
        "vega-lite": "^5.1.1"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint \"{src,test,factory}/**/*.ts\"",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "cross-env FAST_TEST=1 jest test/ --verbose",
        "test:coverage": "yarn jest test/ --collectCoverage=true",
        "test:update": "cross-env UPDATE_SCHEMA=true yarn test:fast",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts",
        "release": "yarn build && auto shipit"
      },
      "readme": "# ts-json-schema-generator\n\n![Test](https://github.com/vega/ts-json-schema-generator/workflows/Test/badge.svg)\n[![codecov](https://codecov.io/gh/vega/ts-json-schema-generator/branch/master/graph/badge.svg)](https://codecov.io/gh/vega/ts-json-schema-generator)\n[![npm version](https://img.shields.io/npm/v/ts-json-schema-generator.svg)](https://www.npmjs.com/package/ts-json-schema-generator)\n\nExtended version of [https://github.com/xiag-ag/typescript-to-json-schema](https://github.com/xiag-ag/typescript-to-json-schema).\n\nInspired by [`YousefED/typescript-json-schema`](https://github.com/YousefED/typescript-json-schema). Here's the differences list:\n\n-   this implementation avoids the use of `typeChecker.getTypeAtLocation()` (so probably it keeps correct type aliases)\n-   processing AST and formatting JSON schema have been split into two independent steps\n-   not exported types, interfaces, enums are not exposed in the `definitions` section in the JSON schema\n\n## Contributors\n\nThis project is made possible by a [community of contributors](https://github.com/vega/ts-json-schema-generator/graphs/contributors). We welcome contributions of any kind (issues, code, documentation, examples, tests,...). Please read our [code of conduct](https://github.com/vega/vega/blob/master/CODE_OF_CONDUCT.md).\n\n## CLI Usage\n\n```bash\nnpm install --save ts-json-schema-generator\n./node_modules/.bin/ts-json-schema-generator --path 'my/project/**/*.ts' --type 'My.Type.Name'\n```\n\nNote that different platforms (e.g. Windows) may use different path separators so you may have to adjust the command above.\n\n## Programmatic Usage\n\n```js\n// main.js\n\nconst tsj = require(\"ts-json-schema-generator\");\nconst fs = require(\"fs\");\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst output_path = \"path/to/output/file\";\n\nconst schema = tsj.createGenerator(config).createSchema(config.type);\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\nRun the schema generator via `node main.js`.\n\n### Custom formatting\n\nExtending the built-in formatting is possible by creating a custom formatter and adding it to the main formatter:\n\n1. First we create a formatter, in this case for formatting function types:\n\n```ts\n// my-function-formatter.ts\nimport { BaseType, Definition, FunctionType, SubTypeFormatter } from \"ts-json-schema-generator\";\nimport ts from \"typescript\";\n\nexport class MyFunctionTypeFormatter implements SubTypeFormatter {\n    // You can skip this line if you don't need childTypeFormatter\n    public constructor(private childTypeFormatter: TypeFormatter) {}\n\n    public supportsType(type: FunctionType): boolean {\n        return type instanceof FunctionType;\n    }\n\n    public getDefinition(type: FunctionType): Definition {\n        // Return a custom schema for the function property.\n        return {\n            type: \"object\",\n            properties: {\n                isFunction: {\n                    type: \"boolean\",\n                    const: true,\n                },\n            },\n        };\n    }\n\n    // If this type does NOT HAVE children, generally all you need is:\n    public getChildren(type: FunctionType): BaseType[] {\n        return [];\n    }\n\n    // However, if children ARE supported, you'll need something similar to\n    // this (see src/TypeFormatter/{Array,Definition,etc}.ts for some examples):\n    public getChildren(type: FunctionType): BaseType[] {\n        return this.childTypeFormatter.getChildren(type.getType());\n    }\n}\n```\n\n2. Then we add the formatter as a child to the core formatter using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyFunctionTypeFormatter } from \"./my-function-formatter.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\n// We configure the formatter an add our custom formatter to it.\nconst formatter = createFormatter(config, (fmt, circularReferenceTypeFormatter) => {\n    // If your formatter DOES NOT support children, e.g. getChildren() { return [] }:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter());\n    // If your formatter DOES support children, you'll need this reference too:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter(circularReferenceTypeFormatter));\n});\n\nconst program = createProgram(config);\nconst parser = createParser(program, config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n### Custom parsing\n\nSimilar to custom formatting, extending the built-in parsing works practically the same way:\n\n1. First we create a parser, in this case for parsing construct types:\n\n```ts\n// my-constructor-parser.ts\nimport { Context, StringType, ReferenceType, BaseType, SubNodeParser } from \"ts-json-schema-generator\";\nimport ts from \"typescript\";\n\nexport class MyConstructorParser implements SubNodeParser {\n    supportsNode(node: ts.Node): boolean {\n        return node.kind === ts.SyntaxKind.ConstructorType;\n    }\n    createType(node: ts.Node, context: Context, reference?: ReferenceType): BaseType | undefined {\n        return new StringType(); // Treat constructors as strings in this example\n    }\n}\n```\n\n2. Then we add the parser as a child to the core parser using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyConstructorParser } from \"./my-constructor-parser.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst program = createProgram(config);\n\n// We configure the parser an add our custom parser to it.\nconst parser = createParser(program, config, (prs) => {\n    prs.addNodeParser(new MyConstructorParser());\n});\n\nconst formatter = createFormatter(config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n## Options\n\n```\n-p, --path 'index.ts'\n    The path to the TypeScript source file. If this is not provided, the type will be searched in the project specified in the `.tsconfig`.\n\n-t, --type 'My.Type.Name'\n    The type the generated schema will represent. If omitted, the generated schema will contain all\n    types found in the files matching path. The same is true if '*' is specified.\n\n-i, --id 'generatedSchemaId'\n    The `$id` of the generated schema. If omitted, there will be no `$id`.\n\n-e, --expose <all|none|export>\n    all: Create shared $ref definitions for all types.\n    none: Do not create shared $ref definitions.\n    export (default): Create shared $ref definitions only for exported types (not tagged as `@internal`).\n\n-f, --tsconfig 'my/project/tsconfig.json'\n    Use a custom tsconfig file for processing typescript (see https://www.typescriptlang.org/docs/handbook/tsconfig-json.html) instead of the default:\n    {\n        \"compilerOptions\": {\n            \"noEmit\": true,\n            \"emitDecoratorMetadata\": true,\n            \"experimentalDecorators\": true,\n            \"target\": \"ES5\",\n            \"module\": \"CommonJS\",\n            \"strictNullChecks\": false,\n        }\n    }\n\n-j, --jsDoc <extended|none|basic>\n    none: Do not use JsDoc annotations.\n    basic: Read JsDoc annotations to provide schema properties.\n    extended (default): Also read @nullable, and @asType annotations.\n\n--unstable\n    Do not sort properties.\n\n--strict-tuples\n    Do not allow additional items on tuples.\n\n--no-top-ref\n    Do not create a top-level $ref definition.\n\n--no-type-check\n    Skip type checks for better performance.\n\n--no-ref-encode\n    Do not encode references. According to the standard, references must be valid URIs but some tools do not support encoded references.\n\n--validation-keywords\n    Provide additional validation keywords to include.\n\n-o, --out\n    Specify the output file path. Without this option, the generator logs the response in the console.\n\n--additional-properties <true|false>\n    Controls whether or not to allow additional properties for objects that have no index signature.\n\n    true: Additional properties are allowed\n    false (default): Additional properties are not allowed\n```\n\n## Current state\n\n-   `interface` types\n-   `enum` types\n-   `union`, `tuple`, `type[]` types\n-   `Date`, `RegExp` types\n-   `string`, `boolean`, `number` types\n-   `\"value\"`, `123`, `true`, `false`, `null`, `undefined` literals\n-   type aliases\n-   generics\n-   `typeof`\n-   `keyof`\n-   conditional types\n\n## Run locally\n\n`yarn --silent run run --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\n## Debug\n\n`yarn --silent run debug --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\nAnd connect via the debugger protocol.\n\n[AST Explorer](https://astexplorer.net/) is amazing for developers of this tool!\n\n## Publish\n\nPublishing is handled by a 2-branch [pre-release process](https://intuit.github.io/auto/docs/generated/shipit#next-branch-default), configured in `publish-auto.yml`. All changes should be based off the default `next` branch, and are published automatically.\n\n-   PRs made into the default branch are auto-deployed to the `next` pre-release tag on NPM. The result can be installed with `npm install ts-json-schema-generator@next`\n    -   When merging into `next`, please use the `squash and merge` strategy.\n-   To release a new stable version, open a PR from `next` into `stable` using this [compare link](https://github.com/vega/ts-json-schema-generator/compare/stable...next).\n    -   When merging from `next` into `stable`, please use the `create a merge commit` strategy.\n",
      "readmeFilename": "README.md",
      "gitHead": "51a876b737c66a5f980bab3e0cff71462f59bc2b",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.96.1--canary.979.51a876b.0",
      "_nodeVersion": "14.18.0",
      "_npmVersion": "6.14.15",
      "dist": {
        "integrity": "sha512-qJ5N4phmmfS0DnJ6kX78goIYUiX7aJiIF1KqatgwsS1MQYHKS88v8vTKXS0sQ9TBqTbmesmYIaqkeyVR/dklUw==",
        "shasum": "c1435164859a0d98c5095cc3629dc60a1a7d0bed",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.96.1--canary.979.51a876b.0.tgz",
        "fileCount": 610,
        "unpackedSize": 626009,
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIE2+dt7XheVEDCUdA+HJ1+PTP1JzlQjV1zLbWEouRQXvAiEAir5eXkvrnOep3fV5+7uhxVCOH19UjA2O38hhzibgJ50="
          }
        ]
      },
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "maintainers": [
        {
          "name": "jheer",
          "email": "jeffrey.heer@gmail.com"
        },
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "kanitw",
          "email": "kanitw@gmail.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.96.1--canary.979.51a876b.0_1633574991202_0.6579312547245426"
      },
      "_hasShrinkwrap": false
    },
    "0.96.1--canary.979.fe4869a.0": {
      "name": "ts-json-schema-generator",
      "version": "0.96.1--canary.979.fe4869a.0",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "MooYeol Prescott Lee",
          "email": "mooyoul@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=10.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.9",
        "commander": "^8.2.0",
        "fast-json-stable-stringify": "^2.1.0",
        "glob": "^7.2.0",
        "json-stable-stringify": "^1.0.1",
        "json5": "^2.2.0",
        "typescript": "~4.4.3"
      },
      "devDependencies": {
        "@auto-it/conventional-commits": "^10.32.1",
        "@auto-it/first-time-contributor": "^10.32.1",
        "@babel/core": "^7.15.8",
        "@babel/preset-env": "^7.15.8",
        "@babel/preset-typescript": "^7.15.0",
        "@types/glob": "^7.1.4",
        "@types/jest": "^27.0.2",
        "@types/json-stable-stringify": "^1.0.33",
        "@types/node": "^16.10.3",
        "@typescript-eslint/eslint-plugin": "^4.33.0",
        "@typescript-eslint/parser": "^4.33.0",
        "ajv": "^8.6.3",
        "ajv-formats": "^2.1.1",
        "auto": "^10.32.1",
        "chai": "^4.3.4",
        "cross-env": "^7.0.3",
        "eslint": "^7.32.0",
        "eslint-config-prettier": "^8.3.0",
        "eslint-plugin-prettier": "^4.0.0",
        "jest": "^27.2.4",
        "jest-junit": "^13.0.0",
        "prettier": "^2.4.1",
        "ts-node": "^10.2.1",
        "vega": "^5.21.0",
        "vega-lite": "^5.1.1"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint \"{src,test,factory}/**/*.ts\"",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "cross-env FAST_TEST=1 jest test/ --verbose",
        "test:coverage": "yarn jest test/ --collectCoverage=true",
        "test:update": "cross-env UPDATE_SCHEMA=true yarn test:fast",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts",
        "release": "yarn build && auto shipit"
      },
      "readme": "# ts-json-schema-generator\n\n![Test](https://github.com/vega/ts-json-schema-generator/workflows/Test/badge.svg)\n[![codecov](https://codecov.io/gh/vega/ts-json-schema-generator/branch/master/graph/badge.svg)](https://codecov.io/gh/vega/ts-json-schema-generator)\n[![npm version](https://img.shields.io/npm/v/ts-json-schema-generator.svg)](https://www.npmjs.com/package/ts-json-schema-generator)\n\nExtended version of [https://github.com/xiag-ag/typescript-to-json-schema](https://github.com/xiag-ag/typescript-to-json-schema).\n\nInspired by [`YousefED/typescript-json-schema`](https://github.com/YousefED/typescript-json-schema). Here's the differences list:\n\n-   this implementation avoids the use of `typeChecker.getTypeAtLocation()` (so probably it keeps correct type aliases)\n-   processing AST and formatting JSON schema have been split into two independent steps\n-   not exported types, interfaces, enums are not exposed in the `definitions` section in the JSON schema\n\n## Contributors\n\nThis project is made possible by a [community of contributors](https://github.com/vega/ts-json-schema-generator/graphs/contributors). We welcome contributions of any kind (issues, code, documentation, examples, tests,...). Please read our [code of conduct](https://github.com/vega/vega/blob/master/CODE_OF_CONDUCT.md).\n\n## CLI Usage\n\n```bash\nnpm install --save ts-json-schema-generator\n./node_modules/.bin/ts-json-schema-generator --path 'my/project/**/*.ts' --type 'My.Type.Name'\n```\n\nNote that different platforms (e.g. Windows) may use different path separators so you may have to adjust the command above.\n\n## Programmatic Usage\n\n```js\n// main.js\n\nconst tsj = require(\"ts-json-schema-generator\");\nconst fs = require(\"fs\");\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst output_path = \"path/to/output/file\";\n\nconst schema = tsj.createGenerator(config).createSchema(config.type);\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\nRun the schema generator via `node main.js`.\n\n### Custom formatting\n\nExtending the built-in formatting is possible by creating a custom formatter and adding it to the main formatter:\n\n1. First we create a formatter, in this case for formatting function types:\n\n```ts\n// my-function-formatter.ts\nimport { BaseType, Definition, FunctionType, SubTypeFormatter } from \"ts-json-schema-generator\";\nimport ts from \"typescript\";\n\nexport class MyFunctionTypeFormatter implements SubTypeFormatter {\n    // You can skip this line if you don't need childTypeFormatter\n    public constructor(private childTypeFormatter: TypeFormatter) {}\n\n    public supportsType(type: FunctionType): boolean {\n        return type instanceof FunctionType;\n    }\n\n    public getDefinition(type: FunctionType): Definition {\n        // Return a custom schema for the function property.\n        return {\n            type: \"object\",\n            properties: {\n                isFunction: {\n                    type: \"boolean\",\n                    const: true,\n                },\n            },\n        };\n    }\n\n    // If this type does NOT HAVE children, generally all you need is:\n    public getChildren(type: FunctionType): BaseType[] {\n        return [];\n    }\n\n    // However, if children ARE supported, you'll need something similar to\n    // this (see src/TypeFormatter/{Array,Definition,etc}.ts for some examples):\n    public getChildren(type: FunctionType): BaseType[] {\n        return this.childTypeFormatter.getChildren(type.getType());\n    }\n}\n```\n\n2. Then we add the formatter as a child to the core formatter using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyFunctionTypeFormatter } from \"./my-function-formatter.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\n// We configure the formatter an add our custom formatter to it.\nconst formatter = createFormatter(config, (fmt, circularReferenceTypeFormatter) => {\n    // If your formatter DOES NOT support children, e.g. getChildren() { return [] }:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter());\n    // If your formatter DOES support children, you'll need this reference too:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter(circularReferenceTypeFormatter));\n});\n\nconst program = createProgram(config);\nconst parser = createParser(program, config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n### Custom parsing\n\nSimilar to custom formatting, extending the built-in parsing works practically the same way:\n\n1. First we create a parser, in this case for parsing construct types:\n\n```ts\n// my-constructor-parser.ts\nimport { Context, StringType, ReferenceType, BaseType, SubNodeParser } from \"ts-json-schema-generator\";\nimport ts from \"typescript\";\n\nexport class MyConstructorParser implements SubNodeParser {\n    supportsNode(node: ts.Node): boolean {\n        return node.kind === ts.SyntaxKind.ConstructorType;\n    }\n    createType(node: ts.Node, context: Context, reference?: ReferenceType): BaseType | undefined {\n        return new StringType(); // Treat constructors as strings in this example\n    }\n}\n```\n\n2. Then we add the parser as a child to the core parser using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyConstructorParser } from \"./my-constructor-parser.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst program = createProgram(config);\n\n// We configure the parser an add our custom parser to it.\nconst parser = createParser(program, config, (prs) => {\n    prs.addNodeParser(new MyConstructorParser());\n});\n\nconst formatter = createFormatter(config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n## Options\n\n```\n-p, --path 'index.ts'\n    The path to the TypeScript source file. If this is not provided, the type will be searched in the project specified in the `.tsconfig`.\n\n-t, --type 'My.Type.Name'\n    The type the generated schema will represent. If omitted, the generated schema will contain all\n    types found in the files matching path. The same is true if '*' is specified.\n\n-i, --id 'generatedSchemaId'\n    The `$id` of the generated schema. If omitted, there will be no `$id`.\n\n-e, --expose <all|none|export>\n    all: Create shared $ref definitions for all types.\n    none: Do not create shared $ref definitions.\n    export (default): Create shared $ref definitions only for exported types (not tagged as `@internal`).\n\n-f, --tsconfig 'my/project/tsconfig.json'\n    Use a custom tsconfig file for processing typescript (see https://www.typescriptlang.org/docs/handbook/tsconfig-json.html) instead of the default:\n    {\n        \"compilerOptions\": {\n            \"noEmit\": true,\n            \"emitDecoratorMetadata\": true,\n            \"experimentalDecorators\": true,\n            \"target\": \"ES5\",\n            \"module\": \"CommonJS\",\n            \"strictNullChecks\": false,\n        }\n    }\n\n-j, --jsDoc <extended|none|basic>\n    none: Do not use JsDoc annotations.\n    basic: Read JsDoc annotations to provide schema properties.\n    extended (default): Also read @nullable, and @asType annotations.\n\n--unstable\n    Do not sort properties.\n\n--strict-tuples\n    Do not allow additional items on tuples.\n\n--no-top-ref\n    Do not create a top-level $ref definition.\n\n--no-type-check\n    Skip type checks for better performance.\n\n--no-ref-encode\n    Do not encode references. According to the standard, references must be valid URIs but some tools do not support encoded references.\n\n--validation-keywords\n    Provide additional validation keywords to include.\n\n-o, --out\n    Specify the output file path. Without this option, the generator logs the response in the console.\n\n--additional-properties <true|false>\n    Controls whether or not to allow additional properties for objects that have no index signature.\n\n    true: Additional properties are allowed\n    false (default): Additional properties are not allowed\n```\n\n## Current state\n\n-   `interface` types\n-   `enum` types\n-   `union`, `tuple`, `type[]` types\n-   `Date`, `RegExp` types\n-   `string`, `boolean`, `number` types\n-   `\"value\"`, `123`, `true`, `false`, `null`, `undefined` literals\n-   type aliases\n-   generics\n-   `typeof`\n-   `keyof`\n-   conditional types\n\n## Run locally\n\n`yarn --silent run run --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\n## Debug\n\n`yarn --silent run debug --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\nAnd connect via the debugger protocol.\n\n[AST Explorer](https://astexplorer.net/) is amazing for developers of this tool!\n\n## Publish\n\nPublishing is handled by a 2-branch [pre-release process](https://intuit.github.io/auto/docs/generated/shipit#next-branch-default), configured in `publish-auto.yml`. All changes should be based off the default `next` branch, and are published automatically.\n\n-   PRs made into the default branch are auto-deployed to the `next` pre-release tag on NPM. The result can be installed with `npm install ts-json-schema-generator@next`\n    -   When merging into `next`, please use the `squash and merge` strategy.\n-   To release a new stable version, open a PR from `next` into `stable` using this [compare link](https://github.com/vega/ts-json-schema-generator/compare/stable...next).\n    -   When merging from `next` into `stable`, please use the `create a merge commit` strategy.\n",
      "readmeFilename": "README.md",
      "gitHead": "fe4869a124c61c5398ed3565b501035a8a28cf3b",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.96.1--canary.979.fe4869a.0",
      "_nodeVersion": "14.18.0",
      "_npmVersion": "6.14.15",
      "dist": {
        "integrity": "sha512-0iKFBOz7cquM52JRP6Erq0jwKrXPo3YC1THY8cpZqJ4TeQPH6XSIYaEbkRB/4VCxbkakZhdK1IcW8k3WWr2JiQ==",
        "shasum": "6a5d8d66b325fc8e401e7f115ea597c1429ca131",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.96.1--canary.979.fe4869a.0.tgz",
        "fileCount": 610,
        "unpackedSize": 626009,
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIQCwgnPM169G2e78sf1qg+LQ0PXHo6c09GJNoC4yOsyMjAIgfbabZJz7AP53+5fsPLCxKD6NG6x0Br0CPl/0ggS4BaU="
          }
        ]
      },
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "maintainers": [
        {
          "name": "jheer",
          "email": "jeffrey.heer@gmail.com"
        },
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "kanitw",
          "email": "kanitw@gmail.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.96.1--canary.979.fe4869a.0_1633608622124_0.8550585138144"
      },
      "_hasShrinkwrap": false
    },
    "0.96.1--canary.982.c7861b4.0": {
      "name": "ts-json-schema-generator",
      "version": "0.96.1--canary.982.c7861b4.0",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "MooYeol Prescott Lee",
          "email": "mooyoul@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=10.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.9",
        "commander": "^8.2.0",
        "fast-json-stable-stringify": "^2.1.0",
        "glob": "^7.2.0",
        "json-stable-stringify": "^1.0.1",
        "json5": "^2.2.0",
        "typescript": "~4.4.3"
      },
      "devDependencies": {
        "@auto-it/conventional-commits": "^10.32.1",
        "@auto-it/first-time-contributor": "^10.32.1",
        "@babel/core": "^7.15.8",
        "@babel/preset-env": "^7.15.8",
        "@babel/preset-typescript": "^7.15.0",
        "@types/glob": "^7.1.4",
        "@types/jest": "^27.0.2",
        "@types/json-stable-stringify": "^1.0.33",
        "@types/node": "^16.10.3",
        "@typescript-eslint/eslint-plugin": "^4.33.0",
        "@typescript-eslint/parser": "^4.33.0",
        "ajv": "^8.6.3",
        "ajv-formats": "^2.1.1",
        "auto": "^10.32.1",
        "chai": "^4.3.4",
        "cross-env": "^7.0.3",
        "eslint": "^7.32.0",
        "eslint-config-prettier": "^8.3.0",
        "eslint-plugin-prettier": "^4.0.0",
        "jest": "^27.2.4",
        "jest-junit": "^13.0.0",
        "prettier": "^2.4.1",
        "ts-node": "^10.2.1",
        "vega": "^5.21.0",
        "vega-lite": "^5.1.1"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint \"{src,test,factory}/**/*.ts\"",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "cross-env FAST_TEST=1 jest test/ --verbose",
        "test:coverage": "yarn jest test/ --collectCoverage=true",
        "test:update": "cross-env UPDATE_SCHEMA=true yarn test:fast",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts",
        "release": "yarn build && auto shipit"
      },
      "readme": "# ts-json-schema-generator\n\n![Test](https://github.com/vega/ts-json-schema-generator/workflows/Test/badge.svg)\n[![codecov](https://codecov.io/gh/vega/ts-json-schema-generator/branch/master/graph/badge.svg)](https://codecov.io/gh/vega/ts-json-schema-generator)\n[![npm version](https://img.shields.io/npm/v/ts-json-schema-generator.svg)](https://www.npmjs.com/package/ts-json-schema-generator)\n\nExtended version of [https://github.com/xiag-ag/typescript-to-json-schema](https://github.com/xiag-ag/typescript-to-json-schema).\n\nInspired by [`YousefED/typescript-json-schema`](https://github.com/YousefED/typescript-json-schema). Here's the differences list:\n\n-   this implementation avoids the use of `typeChecker.getTypeAtLocation()` (so probably it keeps correct type aliases)\n-   processing AST and formatting JSON schema have been split into two independent steps\n-   not exported types, interfaces, enums are not exposed in the `definitions` section in the JSON schema\n\n## Contributors\n\nThis project is made possible by a [community of contributors](https://github.com/vega/ts-json-schema-generator/graphs/contributors). We welcome contributions of any kind (issues, code, documentation, examples, tests,...). Please read our [code of conduct](https://github.com/vega/vega/blob/master/CODE_OF_CONDUCT.md).\n\n## CLI Usage\n\n```bash\nnpm install --save ts-json-schema-generator\n./node_modules/.bin/ts-json-schema-generator --path 'my/project/**/*.ts' --type 'My.Type.Name'\n```\n\nNote that different platforms (e.g. Windows) may use different path separators so you may have to adjust the command above.\n\n## Programmatic Usage\n\n```js\n// main.js\n\nconst tsj = require(\"ts-json-schema-generator\");\nconst fs = require(\"fs\");\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst output_path = \"path/to/output/file\";\n\nconst schema = tsj.createGenerator(config).createSchema(config.type);\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\nRun the schema generator via `node main.js`.\n\n### Custom formatting\n\nExtending the built-in formatting is possible by creating a custom formatter and adding it to the main formatter:\n\n1. First we create a formatter, in this case for formatting function types:\n\n```ts\n// my-function-formatter.ts\nimport { BaseType, Definition, FunctionType, SubTypeFormatter } from \"ts-json-schema-generator\";\nimport ts from \"typescript\";\n\nexport class MyFunctionTypeFormatter implements SubTypeFormatter {\n    // You can skip this line if you don't need childTypeFormatter\n    public constructor(private childTypeFormatter: TypeFormatter) {}\n\n    public supportsType(type: FunctionType): boolean {\n        return type instanceof FunctionType;\n    }\n\n    public getDefinition(type: FunctionType): Definition {\n        // Return a custom schema for the function property.\n        return {\n            type: \"object\",\n            properties: {\n                isFunction: {\n                    type: \"boolean\",\n                    const: true,\n                },\n            },\n        };\n    }\n\n    // If this type does NOT HAVE children, generally all you need is:\n    public getChildren(type: FunctionType): BaseType[] {\n        return [];\n    }\n\n    // However, if children ARE supported, you'll need something similar to\n    // this (see src/TypeFormatter/{Array,Definition,etc}.ts for some examples):\n    public getChildren(type: FunctionType): BaseType[] {\n        return this.childTypeFormatter.getChildren(type.getType());\n    }\n}\n```\n\n2. Then we add the formatter as a child to the core formatter using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyFunctionTypeFormatter } from \"./my-function-formatter.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\n// We configure the formatter an add our custom formatter to it.\nconst formatter = createFormatter(config, (fmt, circularReferenceTypeFormatter) => {\n    // If your formatter DOES NOT support children, e.g. getChildren() { return [] }:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter());\n    // If your formatter DOES support children, you'll need this reference too:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter(circularReferenceTypeFormatter));\n});\n\nconst program = createProgram(config);\nconst parser = createParser(program, config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n### Custom parsing\n\nSimilar to custom formatting, extending the built-in parsing works practically the same way:\n\n1. First we create a parser, in this case for parsing construct types:\n\n```ts\n// my-constructor-parser.ts\nimport { Context, StringType, ReferenceType, BaseType, SubNodeParser } from \"ts-json-schema-generator\";\nimport ts from \"typescript\";\n\nexport class MyConstructorParser implements SubNodeParser {\n    supportsNode(node: ts.Node): boolean {\n        return node.kind === ts.SyntaxKind.ConstructorType;\n    }\n    createType(node: ts.Node, context: Context, reference?: ReferenceType): BaseType | undefined {\n        return new StringType(); // Treat constructors as strings in this example\n    }\n}\n```\n\n2. Then we add the parser as a child to the core parser using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyConstructorParser } from \"./my-constructor-parser.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst program = createProgram(config);\n\n// We configure the parser an add our custom parser to it.\nconst parser = createParser(program, config, (prs) => {\n    prs.addNodeParser(new MyConstructorParser());\n});\n\nconst formatter = createFormatter(config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n## Options\n\n```\n-p, --path 'index.ts'\n    The path to the TypeScript source file. If this is not provided, the type will be searched in the project specified in the `.tsconfig`.\n\n-t, --type 'My.Type.Name'\n    The type the generated schema will represent. If omitted, the generated schema will contain all\n    types found in the files matching path. The same is true if '*' is specified.\n\n-i, --id 'generatedSchemaId'\n    The `$id` of the generated schema. If omitted, there will be no `$id`.\n\n-e, --expose <all|none|export>\n    all: Create shared $ref definitions for all types.\n    none: Do not create shared $ref definitions.\n    export (default): Create shared $ref definitions only for exported types (not tagged as `@internal`).\n\n-f, --tsconfig 'my/project/tsconfig.json'\n    Use a custom tsconfig file for processing typescript (see https://www.typescriptlang.org/docs/handbook/tsconfig-json.html) instead of the default:\n    {\n        \"compilerOptions\": {\n            \"noEmit\": true,\n            \"emitDecoratorMetadata\": true,\n            \"experimentalDecorators\": true,\n            \"target\": \"ES5\",\n            \"module\": \"CommonJS\",\n            \"strictNullChecks\": false,\n        }\n    }\n\n-j, --jsDoc <extended|none|basic>\n    none: Do not use JsDoc annotations.\n    basic: Read JsDoc annotations to provide schema properties.\n    extended (default): Also read @nullable, and @asType annotations.\n\n--unstable\n    Do not sort properties.\n\n--strict-tuples\n    Do not allow additional items on tuples.\n\n--no-top-ref\n    Do not create a top-level $ref definition.\n\n--no-type-check\n    Skip type checks for better performance.\n\n--no-ref-encode\n    Do not encode references. According to the standard, references must be valid URIs but some tools do not support encoded references.\n\n--validation-keywords\n    Provide additional validation keywords to include.\n\n-o, --out\n    Specify the output file path. Without this option, the generator logs the response in the console.\n\n--additional-properties <true|false>\n    Controls whether or not to allow additional properties for objects that have no index signature.\n\n    true: Additional properties are allowed\n    false (default): Additional properties are not allowed\n```\n\n## Current state\n\n-   `interface` types\n-   `enum` types\n-   `union`, `tuple`, `type[]` types\n-   `Date`, `RegExp` types\n-   `string`, `boolean`, `number` types\n-   `\"value\"`, `123`, `true`, `false`, `null`, `undefined` literals\n-   type aliases\n-   generics\n-   `typeof`\n-   `keyof`\n-   conditional types\n\n## Run locally\n\n`yarn --silent run run --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\n## Debug\n\n`yarn --silent run debug --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\nAnd connect via the debugger protocol.\n\n[AST Explorer](https://astexplorer.net/) is amazing for developers of this tool!\n\n## Publish\n\nPublishing is handled by a 2-branch [pre-release process](https://intuit.github.io/auto/docs/generated/shipit#next-branch-default), configured in `publish-auto.yml`. All changes should be based off the default `next` branch, and are published automatically.\n\n-   PRs made into the default branch are auto-deployed to the `next` pre-release tag on NPM. The result can be installed with `npm install ts-json-schema-generator@next`\n    -   When merging into `next`, please use the `squash and merge` strategy.\n-   To release a new stable version, open a PR from `next` into `stable` using this [compare link](https://github.com/vega/ts-json-schema-generator/compare/stable...next).\n    -   When merging from `next` into `stable`, please use the `create a merge commit` strategy.\n",
      "readmeFilename": "README.md",
      "gitHead": "c7861b462a28686514d4cbf8310d5508b0172c36",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.96.1--canary.982.c7861b4.0",
      "_nodeVersion": "14.18.0",
      "_npmVersion": "6.14.15",
      "dist": {
        "integrity": "sha512-8y/nMchbN1GcCrrbZb1/CGXyqW7fkAiHrk7J7HGMZORXuCrr2Dk+i9DsqkxENUe0fCJ37oKaBf7KxDYxiLbA6w==",
        "shasum": "9746ef050483b3781168fb552b47d9591a5fa2b4",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.96.1--canary.982.c7861b4.0.tgz",
        "fileCount": 610,
        "unpackedSize": 626112,
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEQCIEmupk8EYfmNGWkQSAC5MxKzGXjked3vxr0HNr7qUIRpAiBNJ1vBVECfFu2OqQH9jKiP9vteP1Q91NAqx1DxGDJQtw=="
          }
        ]
      },
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "maintainers": [
        {
          "name": "jheer",
          "email": "jeffrey.heer@gmail.com"
        },
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "kanitw",
          "email": "kanitw@gmail.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.96.1--canary.982.c7861b4.0_1633963179907_0.9936754519610531"
      },
      "_hasShrinkwrap": false
    },
    "0.97.0-next.0": {
      "name": "ts-json-schema-generator",
      "version": "0.97.0-next.0",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "MooYeol Prescott Lee",
          "email": "mooyoul@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=10.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.9",
        "commander": "^8.2.0",
        "fast-json-stable-stringify": "^2.1.0",
        "glob": "^7.2.0",
        "json-stable-stringify": "^1.0.1",
        "json5": "^2.2.0",
        "typescript": "~4.4.3"
      },
      "devDependencies": {
        "@auto-it/conventional-commits": "^10.32.1",
        "@auto-it/first-time-contributor": "^10.32.1",
        "@babel/core": "^7.15.8",
        "@babel/preset-env": "^7.15.8",
        "@babel/preset-typescript": "^7.15.0",
        "@types/glob": "^7.1.4",
        "@types/jest": "^27.0.2",
        "@types/json-stable-stringify": "^1.0.33",
        "@types/node": "^16.10.3",
        "@typescript-eslint/eslint-plugin": "^4.33.0",
        "@typescript-eslint/parser": "^4.33.0",
        "ajv": "^8.6.3",
        "ajv-formats": "^2.1.1",
        "auto": "^10.32.1",
        "chai": "^4.3.4",
        "cross-env": "^7.0.3",
        "eslint": "^7.32.0",
        "eslint-config-prettier": "^8.3.0",
        "eslint-plugin-prettier": "^4.0.0",
        "jest": "^27.2.4",
        "jest-junit": "^13.0.0",
        "prettier": "^2.4.1",
        "ts-node": "^10.2.1",
        "vega": "^5.21.0",
        "vega-lite": "^5.1.1"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint \"{src,test,factory}/**/*.ts\"",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "cross-env FAST_TEST=1 jest test/ --verbose",
        "test:coverage": "yarn jest test/ --collectCoverage=true",
        "test:update": "cross-env UPDATE_SCHEMA=true yarn test:fast",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts",
        "release": "yarn build && auto shipit"
      },
      "readme": "# ts-json-schema-generator\n\n![Test](https://github.com/vega/ts-json-schema-generator/workflows/Test/badge.svg)\n[![codecov](https://codecov.io/gh/vega/ts-json-schema-generator/branch/master/graph/badge.svg)](https://codecov.io/gh/vega/ts-json-schema-generator)\n[![npm version](https://img.shields.io/npm/v/ts-json-schema-generator.svg)](https://www.npmjs.com/package/ts-json-schema-generator)\n\nExtended version of [https://github.com/xiag-ag/typescript-to-json-schema](https://github.com/xiag-ag/typescript-to-json-schema).\n\nInspired by [`YousefED/typescript-json-schema`](https://github.com/YousefED/typescript-json-schema). Here's the differences list:\n\n-   this implementation avoids the use of `typeChecker.getTypeAtLocation()` (so probably it keeps correct type aliases)\n-   processing AST and formatting JSON schema have been split into two independent steps\n-   not exported types, interfaces, enums are not exposed in the `definitions` section in the JSON schema\n\n## Contributors\n\nThis project is made possible by a [community of contributors](https://github.com/vega/ts-json-schema-generator/graphs/contributors). We welcome contributions of any kind (issues, code, documentation, examples, tests,...). Please read our [code of conduct](https://github.com/vega/vega/blob/master/CODE_OF_CONDUCT.md).\n\n## CLI Usage\n\n```bash\nnpm install --save ts-json-schema-generator\n./node_modules/.bin/ts-json-schema-generator --path 'my/project/**/*.ts' --type 'My.Type.Name'\n```\n\nNote that different platforms (e.g. Windows) may use different path separators so you may have to adjust the command above.\n\n## Programmatic Usage\n\n```js\n// main.js\n\nconst tsj = require(\"ts-json-schema-generator\");\nconst fs = require(\"fs\");\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst output_path = \"path/to/output/file\";\n\nconst schema = tsj.createGenerator(config).createSchema(config.type);\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\nRun the schema generator via `node main.js`.\n\n### Custom formatting\n\nExtending the built-in formatting is possible by creating a custom formatter and adding it to the main formatter:\n\n1. First we create a formatter, in this case for formatting function types:\n\n```ts\n// my-function-formatter.ts\nimport { BaseType, Definition, FunctionType, SubTypeFormatter } from \"ts-json-schema-generator\";\nimport ts from \"typescript\";\n\nexport class MyFunctionTypeFormatter implements SubTypeFormatter {\n    // You can skip this line if you don't need childTypeFormatter\n    public constructor(private childTypeFormatter: TypeFormatter) {}\n\n    public supportsType(type: FunctionType): boolean {\n        return type instanceof FunctionType;\n    }\n\n    public getDefinition(type: FunctionType): Definition {\n        // Return a custom schema for the function property.\n        return {\n            type: \"object\",\n            properties: {\n                isFunction: {\n                    type: \"boolean\",\n                    const: true,\n                },\n            },\n        };\n    }\n\n    // If this type does NOT HAVE children, generally all you need is:\n    public getChildren(type: FunctionType): BaseType[] {\n        return [];\n    }\n\n    // However, if children ARE supported, you'll need something similar to\n    // this (see src/TypeFormatter/{Array,Definition,etc}.ts for some examples):\n    public getChildren(type: FunctionType): BaseType[] {\n        return this.childTypeFormatter.getChildren(type.getType());\n    }\n}\n```\n\n2. Then we add the formatter as a child to the core formatter using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyFunctionTypeFormatter } from \"./my-function-formatter.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\n// We configure the formatter an add our custom formatter to it.\nconst formatter = createFormatter(config, (fmt, circularReferenceTypeFormatter) => {\n    // If your formatter DOES NOT support children, e.g. getChildren() { return [] }:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter());\n    // If your formatter DOES support children, you'll need this reference too:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter(circularReferenceTypeFormatter));\n});\n\nconst program = createProgram(config);\nconst parser = createParser(program, config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n### Custom parsing\n\nSimilar to custom formatting, extending the built-in parsing works practically the same way:\n\n1. First we create a parser, in this case for parsing construct types:\n\n```ts\n// my-constructor-parser.ts\nimport { Context, StringType, ReferenceType, BaseType, SubNodeParser } from \"ts-json-schema-generator\";\nimport ts from \"typescript\";\n\nexport class MyConstructorParser implements SubNodeParser {\n    supportsNode(node: ts.Node): boolean {\n        return node.kind === ts.SyntaxKind.ConstructorType;\n    }\n    createType(node: ts.Node, context: Context, reference?: ReferenceType): BaseType | undefined {\n        return new StringType(); // Treat constructors as strings in this example\n    }\n}\n```\n\n2. Then we add the parser as a child to the core parser using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyConstructorParser } from \"./my-constructor-parser.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst program = createProgram(config);\n\n// We configure the parser an add our custom parser to it.\nconst parser = createParser(program, config, (prs) => {\n    prs.addNodeParser(new MyConstructorParser());\n});\n\nconst formatter = createFormatter(config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n## Options\n\n```\n-p, --path 'index.ts'\n    The path to the TypeScript source file. If this is not provided, the type will be searched in the project specified in the `.tsconfig`.\n\n-t, --type 'My.Type.Name'\n    The type the generated schema will represent. If omitted, the generated schema will contain all\n    types found in the files matching path. The same is true if '*' is specified.\n\n-i, --id 'generatedSchemaId'\n    The `$id` of the generated schema. If omitted, there will be no `$id`.\n\n-e, --expose <all|none|export>\n    all: Create shared $ref definitions for all types.\n    none: Do not create shared $ref definitions.\n    export (default): Create shared $ref definitions only for exported types (not tagged as `@internal`).\n\n-f, --tsconfig 'my/project/tsconfig.json'\n    Use a custom tsconfig file for processing typescript (see https://www.typescriptlang.org/docs/handbook/tsconfig-json.html) instead of the default:\n    {\n        \"compilerOptions\": {\n            \"noEmit\": true,\n            \"emitDecoratorMetadata\": true,\n            \"experimentalDecorators\": true,\n            \"target\": \"ES5\",\n            \"module\": \"CommonJS\",\n            \"strictNullChecks\": false,\n        }\n    }\n\n-j, --jsDoc <extended|none|basic>\n    none: Do not use JsDoc annotations.\n    basic: Read JsDoc annotations to provide schema properties.\n    extended (default): Also read @nullable, and @asType annotations.\n\n--unstable\n    Do not sort properties.\n\n--strict-tuples\n    Do not allow additional items on tuples.\n\n--no-top-ref\n    Do not create a top-level $ref definition.\n\n--no-type-check\n    Skip type checks for better performance.\n\n--no-ref-encode\n    Do not encode references. According to the standard, references must be valid URIs but some tools do not support encoded references.\n\n--validation-keywords\n    Provide additional validation keywords to include.\n\n-o, --out\n    Specify the output file path. Without this option, the generator logs the response in the console.\n\n--additional-properties <true|false>\n    Controls whether or not to allow additional properties for objects that have no index signature.\n\n    true: Additional properties are allowed\n    false (default): Additional properties are not allowed\n```\n\n## Current state\n\n-   `interface` types\n-   `enum` types\n-   `union`, `tuple`, `type[]` types\n-   `Date`, `RegExp` types\n-   `string`, `boolean`, `number` types\n-   `\"value\"`, `123`, `true`, `false`, `null`, `undefined` literals\n-   type aliases\n-   generics\n-   `typeof`\n-   `keyof`\n-   conditional types\n\n## Run locally\n\n`yarn --silent run run --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\n## Debug\n\n`yarn --silent run debug --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\nAnd connect via the debugger protocol.\n\n[AST Explorer](https://astexplorer.net/) is amazing for developers of this tool!\n\n## Publish\n\nPublishing is handled by a 2-branch [pre-release process](https://intuit.github.io/auto/docs/generated/shipit#next-branch-default), configured in `publish-auto.yml`. All changes should be based off the default `next` branch, and are published automatically.\n\n-   PRs made into the default branch are auto-deployed to the `next` pre-release tag on NPM. The result can be installed with `npm install ts-json-schema-generator@next`\n    -   When merging into `next`, please use the `squash and merge` strategy.\n-   To release a new stable version, open a PR from `next` into `stable` using this [compare link](https://github.com/vega/ts-json-schema-generator/compare/stable...next).\n    -   When merging from `next` into `stable`, please use the `create a merge commit` strategy.\n",
      "readmeFilename": "README.md",
      "gitHead": "3dc6a8623f38b79ec98207bf7223c9b6eb177a41",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.97.0-next.0",
      "_nodeVersion": "14.18.0",
      "_npmVersion": "6.14.15",
      "dist": {
        "integrity": "sha512-CeEPIqa3NvFkgEWRFjuPVc18m+oFSglZmF6QYV12Iny2lyFLgVHDhaFNRTM3tcDlzgN9bR2xLEsVlypQKn5quA==",
        "shasum": "48eae795649cb1a34af62c5526d7a4797a997001",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.97.0-next.0.tgz",
        "fileCount": 610,
        "unpackedSize": 626765,
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIQDE92AzDQG+/6Uma9kOujnXkW2f6Ju0pEPGM+bcEMYOXQIgUNsSocfG8u63xORwKE0LAEoU7rxKQcPyW7vv6EOJJrg="
          }
        ]
      },
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "maintainers": [
        {
          "name": "jheer",
          "email": "jeffrey.heer@gmail.com"
        },
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "kanitw",
          "email": "kanitw@gmail.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.97.0-next.0_1634056569392_0.0686181414133713"
      },
      "_hasShrinkwrap": false
    },
    "0.97.0-next.1": {
      "name": "ts-json-schema-generator",
      "version": "0.97.0-next.1",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "MooYeol Prescott Lee",
          "email": "mooyoul@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=10.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.9",
        "commander": "^8.2.0",
        "fast-json-stable-stringify": "^2.1.0",
        "glob": "^7.2.0",
        "json-stable-stringify": "^1.0.1",
        "json5": "^2.2.0",
        "typescript": "~4.4.3"
      },
      "devDependencies": {
        "@auto-it/conventional-commits": "^10.32.1",
        "@auto-it/first-time-contributor": "^10.32.1",
        "@babel/core": "^7.15.8",
        "@babel/preset-env": "^7.15.8",
        "@babel/preset-typescript": "^7.15.0",
        "@types/glob": "^7.1.4",
        "@types/jest": "^27.0.2",
        "@types/json-stable-stringify": "^1.0.33",
        "@types/node": "^16.10.3",
        "@typescript-eslint/eslint-plugin": "^4.33.0",
        "@typescript-eslint/parser": "^4.33.0",
        "ajv": "^8.6.3",
        "ajv-formats": "^2.1.1",
        "auto": "^10.32.1",
        "chai": "^4.3.4",
        "cross-env": "^7.0.3",
        "eslint": "^7.32.0",
        "eslint-config-prettier": "^8.3.0",
        "eslint-plugin-prettier": "^4.0.0",
        "jest": "^27.2.4",
        "jest-junit": "^13.0.0",
        "prettier": "^2.4.1",
        "ts-node": "^10.2.1",
        "vega": "^5.21.0",
        "vega-lite": "^5.1.1"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint \"{src,test,factory}/**/*.ts\"",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "cross-env FAST_TEST=1 jest test/ --verbose",
        "test:coverage": "yarn jest test/ --collectCoverage=true",
        "test:update": "cross-env UPDATE_SCHEMA=true yarn test:fast",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts",
        "release": "yarn build && auto shipit"
      },
      "readme": "# ts-json-schema-generator\n\n![Test](https://github.com/vega/ts-json-schema-generator/workflows/Test/badge.svg)\n[![codecov](https://codecov.io/gh/vega/ts-json-schema-generator/branch/master/graph/badge.svg)](https://codecov.io/gh/vega/ts-json-schema-generator)\n[![npm version](https://img.shields.io/npm/v/ts-json-schema-generator.svg)](https://www.npmjs.com/package/ts-json-schema-generator)\n\nExtended version of [https://github.com/xiag-ag/typescript-to-json-schema](https://github.com/xiag-ag/typescript-to-json-schema).\n\nInspired by [`YousefED/typescript-json-schema`](https://github.com/YousefED/typescript-json-schema). Here's the differences list:\n\n-   this implementation avoids the use of `typeChecker.getTypeAtLocation()` (so probably it keeps correct type aliases)\n-   processing AST and formatting JSON schema have been split into two independent steps\n-   not exported types, interfaces, enums are not exposed in the `definitions` section in the JSON schema\n\n## Contributors\n\nThis project is made possible by a [community of contributors](https://github.com/vega/ts-json-schema-generator/graphs/contributors). We welcome contributions of any kind (issues, code, documentation, examples, tests,...). Please read our [code of conduct](https://github.com/vega/vega/blob/master/CODE_OF_CONDUCT.md).\n\n## CLI Usage\n\n```bash\nnpm install --save ts-json-schema-generator\n./node_modules/.bin/ts-json-schema-generator --path 'my/project/**/*.ts' --type 'My.Type.Name'\n```\n\nNote that different platforms (e.g. Windows) may use different path separators so you may have to adjust the command above.\n\n## Programmatic Usage\n\n```js\n// main.js\n\nconst tsj = require(\"ts-json-schema-generator\");\nconst fs = require(\"fs\");\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst output_path = \"path/to/output/file\";\n\nconst schema = tsj.createGenerator(config).createSchema(config.type);\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\nRun the schema generator via `node main.js`.\n\n### Custom formatting\n\nExtending the built-in formatting is possible by creating a custom formatter and adding it to the main formatter:\n\n1. First we create a formatter, in this case for formatting function types:\n\n```ts\n// my-function-formatter.ts\nimport { BaseType, Definition, FunctionType, SubTypeFormatter } from \"ts-json-schema-generator\";\nimport ts from \"typescript\";\n\nexport class MyFunctionTypeFormatter implements SubTypeFormatter {\n    // You can skip this line if you don't need childTypeFormatter\n    public constructor(private childTypeFormatter: TypeFormatter) {}\n\n    public supportsType(type: FunctionType): boolean {\n        return type instanceof FunctionType;\n    }\n\n    public getDefinition(type: FunctionType): Definition {\n        // Return a custom schema for the function property.\n        return {\n            type: \"object\",\n            properties: {\n                isFunction: {\n                    type: \"boolean\",\n                    const: true,\n                },\n            },\n        };\n    }\n\n    // If this type does NOT HAVE children, generally all you need is:\n    public getChildren(type: FunctionType): BaseType[] {\n        return [];\n    }\n\n    // However, if children ARE supported, you'll need something similar to\n    // this (see src/TypeFormatter/{Array,Definition,etc}.ts for some examples):\n    public getChildren(type: FunctionType): BaseType[] {\n        return this.childTypeFormatter.getChildren(type.getType());\n    }\n}\n```\n\n2. Then we add the formatter as a child to the core formatter using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyFunctionTypeFormatter } from \"./my-function-formatter.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\n// We configure the formatter an add our custom formatter to it.\nconst formatter = createFormatter(config, (fmt, circularReferenceTypeFormatter) => {\n    // If your formatter DOES NOT support children, e.g. getChildren() { return [] }:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter());\n    // If your formatter DOES support children, you'll need this reference too:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter(circularReferenceTypeFormatter));\n});\n\nconst program = createProgram(config);\nconst parser = createParser(program, config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n### Custom parsing\n\nSimilar to custom formatting, extending the built-in parsing works practically the same way:\n\n1. First we create a parser, in this case for parsing construct types:\n\n```ts\n// my-constructor-parser.ts\nimport { Context, StringType, ReferenceType, BaseType, SubNodeParser } from \"ts-json-schema-generator\";\nimport ts from \"typescript\";\n\nexport class MyConstructorParser implements SubNodeParser {\n    supportsNode(node: ts.Node): boolean {\n        return node.kind === ts.SyntaxKind.ConstructorType;\n    }\n    createType(node: ts.Node, context: Context, reference?: ReferenceType): BaseType | undefined {\n        return new StringType(); // Treat constructors as strings in this example\n    }\n}\n```\n\n2. Then we add the parser as a child to the core parser using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyConstructorParser } from \"./my-constructor-parser.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst program = createProgram(config);\n\n// We configure the parser an add our custom parser to it.\nconst parser = createParser(program, config, (prs) => {\n    prs.addNodeParser(new MyConstructorParser());\n});\n\nconst formatter = createFormatter(config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n## Options\n\n```\n-p, --path 'index.ts'\n    The path to the TypeScript source file. If this is not provided, the type will be searched in the project specified in the `.tsconfig`.\n\n-t, --type 'My.Type.Name'\n    The type the generated schema will represent. If omitted, the generated schema will contain all\n    types found in the files matching path. The same is true if '*' is specified.\n\n-i, --id 'generatedSchemaId'\n    The `$id` of the generated schema. If omitted, there will be no `$id`.\n\n-e, --expose <all|none|export>\n    all: Create shared $ref definitions for all types.\n    none: Do not create shared $ref definitions.\n    export (default): Create shared $ref definitions only for exported types (not tagged as `@internal`).\n\n-f, --tsconfig 'my/project/tsconfig.json'\n    Use a custom tsconfig file for processing typescript (see https://www.typescriptlang.org/docs/handbook/tsconfig-json.html) instead of the default:\n    {\n        \"compilerOptions\": {\n            \"noEmit\": true,\n            \"emitDecoratorMetadata\": true,\n            \"experimentalDecorators\": true,\n            \"target\": \"ES5\",\n            \"module\": \"CommonJS\",\n            \"strictNullChecks\": false,\n        }\n    }\n\n-j, --jsDoc <extended|none|basic>\n    none: Do not use JsDoc annotations.\n    basic: Read JsDoc annotations to provide schema properties.\n    extended (default): Also read @nullable, and @asType annotations.\n\n--unstable\n    Do not sort properties.\n\n--strict-tuples\n    Do not allow additional items on tuples.\n\n--no-top-ref\n    Do not create a top-level $ref definition.\n\n--no-type-check\n    Skip type checks for better performance.\n\n--no-ref-encode\n    Do not encode references. According to the standard, references must be valid URIs but some tools do not support encoded references.\n\n--validation-keywords\n    Provide additional validation keywords to include.\n\n-o, --out\n    Specify the output file path. Without this option, the generator logs the response in the console.\n\n--additional-properties <true|false>\n    Controls whether or not to allow additional properties for objects that have no index signature.\n\n    true: Additional properties are allowed\n    false (default): Additional properties are not allowed\n```\n\n## Current state\n\n-   `interface` types\n-   `enum` types\n-   `union`, `tuple`, `type[]` types\n-   `Date`, `RegExp` types\n-   `string`, `boolean`, `number` types\n-   `\"value\"`, `123`, `true`, `false`, `null`, `undefined` literals\n-   type aliases\n-   generics\n-   `typeof`\n-   `keyof`\n-   conditional types\n\n## Run locally\n\n`yarn --silent run run --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\n## Debug\n\n`yarn --silent run debug --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\nAnd connect via the debugger protocol.\n\n[AST Explorer](https://astexplorer.net/) is amazing for developers of this tool!\n\n## Publish\n\nPublishing is handled by a 2-branch [pre-release process](https://intuit.github.io/auto/docs/generated/shipit#next-branch-default), configured in `publish-auto.yml`. All changes should be based off the default `next` branch, and are published automatically.\n\n-   PRs made into the default branch are auto-deployed to the `next` pre-release tag on NPM. The result can be installed with `npm install ts-json-schema-generator@next`\n    -   When merging into `next`, please use the `squash and merge` strategy.\n-   To release a new stable version, open a PR from `next` into `stable` using this [compare link](https://github.com/vega/ts-json-schema-generator/compare/stable...next).\n    -   When merging from `next` into `stable`, please use the `create a merge commit` strategy.\n",
      "readmeFilename": "README.md",
      "gitHead": "653fa77da0ce844227aab6fd82302ba15feafe2d",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.97.0-next.1",
      "_nodeVersion": "14.18.0",
      "_npmVersion": "6.14.15",
      "dist": {
        "integrity": "sha512-C9sB1dlMRLtpAcqWQtUO8yCWJo5T2pOAaAqhIpwx+OUcyP7sdUP3zyjQoRLaQzCZL2RPIERJ5MLvxBdaRiS+Ow==",
        "shasum": "35b36fed7c6c81a7635be152996262cf62538d4e",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.97.0-next.1.tgz",
        "fileCount": 610,
        "unpackedSize": 627222,
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEQCICEtEsS4O3uG/brZRoU9UePcHNKdGmeE6PKuYSX4oy9OAiBl7ouml7bpm17a1pPCOhMGENmwKCs9+PU09y1vViF8nQ=="
          }
        ]
      },
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "maintainers": [
        {
          "name": "jheer",
          "email": "jeffrey.heer@gmail.com"
        },
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "kanitw",
          "email": "kanitw@gmail.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.97.0-next.1_1634218592913_0.7036796379242682"
      },
      "_hasShrinkwrap": false
    },
    "0.97.0-next.2": {
      "name": "ts-json-schema-generator",
      "version": "0.97.0-next.2",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "MooYeol Prescott Lee",
          "email": "mooyoul@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=10.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.9",
        "commander": "^8.2.0",
        "fast-json-stable-stringify": "^2.1.0",
        "glob": "^7.2.0",
        "json-stable-stringify": "^1.0.1",
        "json5": "^2.2.0",
        "typescript": "~4.4.3"
      },
      "devDependencies": {
        "@auto-it/conventional-commits": "^10.32.1",
        "@auto-it/first-time-contributor": "^10.32.1",
        "@babel/core": "^7.15.8",
        "@babel/preset-env": "^7.15.8",
        "@babel/preset-typescript": "^7.15.0",
        "@types/glob": "^7.1.4",
        "@types/jest": "^27.0.2",
        "@types/json-stable-stringify": "^1.0.33",
        "@types/node": "^16.10.3",
        "@typescript-eslint/eslint-plugin": "^4.33.0",
        "@typescript-eslint/parser": "^4.33.0",
        "ajv": "^8.6.3",
        "ajv-formats": "^2.1.1",
        "auto": "^10.32.1",
        "chai": "^4.3.4",
        "cross-env": "^7.0.3",
        "eslint": "^7.32.0",
        "eslint-config-prettier": "^8.3.0",
        "eslint-plugin-prettier": "^4.0.0",
        "jest": "^27.2.4",
        "jest-junit": "^13.0.0",
        "prettier": "^2.4.1",
        "ts-node": "^10.2.1",
        "vega": "^5.21.0",
        "vega-lite": "^5.1.1"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint \"{src,test,factory}/**/*.ts\"",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "cross-env FAST_TEST=1 jest test/ --verbose",
        "test:coverage": "yarn jest test/ --collectCoverage=true",
        "test:update": "cross-env UPDATE_SCHEMA=true yarn test:fast",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts",
        "release": "yarn build && auto shipit"
      },
      "readme": "# ts-json-schema-generator\n\n![Test](https://github.com/vega/ts-json-schema-generator/workflows/Test/badge.svg)\n[![codecov](https://codecov.io/gh/vega/ts-json-schema-generator/branch/master/graph/badge.svg)](https://codecov.io/gh/vega/ts-json-schema-generator)\n[![npm version](https://img.shields.io/npm/v/ts-json-schema-generator.svg)](https://www.npmjs.com/package/ts-json-schema-generator)\n\nExtended version of [https://github.com/xiag-ag/typescript-to-json-schema](https://github.com/xiag-ag/typescript-to-json-schema).\n\nInspired by [`YousefED/typescript-json-schema`](https://github.com/YousefED/typescript-json-schema). Here's the differences list:\n\n-   this implementation avoids the use of `typeChecker.getTypeAtLocation()` (so probably it keeps correct type aliases)\n-   processing AST and formatting JSON schema have been split into two independent steps\n-   not exported types, interfaces, enums are not exposed in the `definitions` section in the JSON schema\n\n## Contributors\n\nThis project is made possible by a [community of contributors](https://github.com/vega/ts-json-schema-generator/graphs/contributors). We welcome contributions of any kind (issues, code, documentation, examples, tests,...). Please read our [code of conduct](https://github.com/vega/vega/blob/master/CODE_OF_CONDUCT.md).\n\n## CLI Usage\n\n```bash\nnpm install --save ts-json-schema-generator\n./node_modules/.bin/ts-json-schema-generator --path 'my/project/**/*.ts' --type 'My.Type.Name'\n```\n\nNote that different platforms (e.g. Windows) may use different path separators so you may have to adjust the command above.\n\n## Programmatic Usage\n\n```js\n// main.js\n\nconst tsj = require(\"ts-json-schema-generator\");\nconst fs = require(\"fs\");\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst output_path = \"path/to/output/file\";\n\nconst schema = tsj.createGenerator(config).createSchema(config.type);\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\nRun the schema generator via `node main.js`.\n\n### Custom formatting\n\nExtending the built-in formatting is possible by creating a custom formatter and adding it to the main formatter:\n\n1. First we create a formatter, in this case for formatting function types:\n\n```ts\n// my-function-formatter.ts\nimport { BaseType, Definition, FunctionType, SubTypeFormatter } from \"ts-json-schema-generator\";\nimport ts from \"typescript\";\n\nexport class MyFunctionTypeFormatter implements SubTypeFormatter {\n    // You can skip this line if you don't need childTypeFormatter\n    public constructor(private childTypeFormatter: TypeFormatter) {}\n\n    public supportsType(type: FunctionType): boolean {\n        return type instanceof FunctionType;\n    }\n\n    public getDefinition(type: FunctionType): Definition {\n        // Return a custom schema for the function property.\n        return {\n            type: \"object\",\n            properties: {\n                isFunction: {\n                    type: \"boolean\",\n                    const: true,\n                },\n            },\n        };\n    }\n\n    // If this type does NOT HAVE children, generally all you need is:\n    public getChildren(type: FunctionType): BaseType[] {\n        return [];\n    }\n\n    // However, if children ARE supported, you'll need something similar to\n    // this (see src/TypeFormatter/{Array,Definition,etc}.ts for some examples):\n    public getChildren(type: FunctionType): BaseType[] {\n        return this.childTypeFormatter.getChildren(type.getType());\n    }\n}\n```\n\n2. Then we add the formatter as a child to the core formatter using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyFunctionTypeFormatter } from \"./my-function-formatter.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\n// We configure the formatter an add our custom formatter to it.\nconst formatter = createFormatter(config, (fmt, circularReferenceTypeFormatter) => {\n    // If your formatter DOES NOT support children, e.g. getChildren() { return [] }:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter());\n    // If your formatter DOES support children, you'll need this reference too:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter(circularReferenceTypeFormatter));\n});\n\nconst program = createProgram(config);\nconst parser = createParser(program, config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n### Custom parsing\n\nSimilar to custom formatting, extending the built-in parsing works practically the same way:\n\n1. First we create a parser, in this case for parsing construct types:\n\n```ts\n// my-constructor-parser.ts\nimport { Context, StringType, ReferenceType, BaseType, SubNodeParser } from \"ts-json-schema-generator\";\nimport ts from \"typescript\";\n\nexport class MyConstructorParser implements SubNodeParser {\n    supportsNode(node: ts.Node): boolean {\n        return node.kind === ts.SyntaxKind.ConstructorType;\n    }\n    createType(node: ts.Node, context: Context, reference?: ReferenceType): BaseType | undefined {\n        return new StringType(); // Treat constructors as strings in this example\n    }\n}\n```\n\n2. Then we add the parser as a child to the core parser using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyConstructorParser } from \"./my-constructor-parser.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst program = createProgram(config);\n\n// We configure the parser an add our custom parser to it.\nconst parser = createParser(program, config, (prs) => {\n    prs.addNodeParser(new MyConstructorParser());\n});\n\nconst formatter = createFormatter(config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n## Options\n\n```\n-p, --path 'index.ts'\n    The path to the TypeScript source file. If this is not provided, the type will be searched in the project specified in the `.tsconfig`.\n\n-t, --type 'My.Type.Name'\n    The type the generated schema will represent. If omitted, the generated schema will contain all\n    types found in the files matching path. The same is true if '*' is specified.\n\n-i, --id 'generatedSchemaId'\n    The `$id` of the generated schema. If omitted, there will be no `$id`.\n\n-e, --expose <all|none|export>\n    all: Create shared $ref definitions for all types.\n    none: Do not create shared $ref definitions.\n    export (default): Create shared $ref definitions only for exported types (not tagged as `@internal`).\n\n-f, --tsconfig 'my/project/tsconfig.json'\n    Use a custom tsconfig file for processing typescript (see https://www.typescriptlang.org/docs/handbook/tsconfig-json.html) instead of the default:\n    {\n        \"compilerOptions\": {\n            \"noEmit\": true,\n            \"emitDecoratorMetadata\": true,\n            \"experimentalDecorators\": true,\n            \"target\": \"ES5\",\n            \"module\": \"CommonJS\",\n            \"strictNullChecks\": false,\n        }\n    }\n\n-j, --jsDoc <extended|none|basic>\n    none: Do not use JsDoc annotations.\n    basic: Read JsDoc annotations to provide schema properties.\n    extended (default): Also read @nullable, and @asType annotations.\n\n--unstable\n    Do not sort properties.\n\n--strict-tuples\n    Do not allow additional items on tuples.\n\n--no-top-ref\n    Do not create a top-level $ref definition.\n\n--no-type-check\n    Skip type checks for better performance.\n\n--no-ref-encode\n    Do not encode references. According to the standard, references must be valid URIs but some tools do not support encoded references.\n\n--validation-keywords\n    Provide additional validation keywords to include.\n\n-o, --out\n    Specify the output file path. Without this option, the generator logs the response in the console.\n\n--additional-properties <true|false>\n    Controls whether or not to allow additional properties for objects that have no index signature.\n\n    true: Additional properties are allowed\n    false (default): Additional properties are not allowed\n```\n\n## Current state\n\n-   `interface` types\n-   `enum` types\n-   `union`, `tuple`, `type[]` types\n-   `Date`, `RegExp` types\n-   `string`, `boolean`, `number` types\n-   `\"value\"`, `123`, `true`, `false`, `null`, `undefined` literals\n-   type aliases\n-   generics\n-   `typeof`\n-   `keyof`\n-   conditional types\n\n## Run locally\n\n`yarn --silent run run --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\n## Debug\n\n`yarn --silent run debug --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\nAnd connect via the debugger protocol.\n\n[AST Explorer](https://astexplorer.net/) is amazing for developers of this tool!\n\n## Publish\n\nPublishing is handled by a 2-branch [pre-release process](https://intuit.github.io/auto/docs/generated/shipit#next-branch-default), configured in `publish-auto.yml`. All changes should be based off the default `next` branch, and are published automatically.\n\n-   PRs made into the default branch are auto-deployed to the `next` pre-release tag on NPM. The result can be installed with `npm install ts-json-schema-generator@next`\n    -   When merging into `next`, please use the `squash and merge` strategy.\n-   To release a new stable version, open a PR from `next` into `stable` using this [compare link](https://github.com/vega/ts-json-schema-generator/compare/stable...next).\n    -   When merging from `next` into `stable`, please use the `create a merge commit` strategy.\n",
      "readmeFilename": "README.md",
      "gitHead": "df88ff8f51fe59b2ecc7cf16157c06ebe61e2355",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.97.0-next.2",
      "_nodeVersion": "14.18.0",
      "_npmVersion": "6.14.15",
      "dist": {
        "integrity": "sha512-8PNqITQdpmeKowOkCBcJ5PWC3xNHgzF22hGl7ElUyDyvux3cVGBikAcroTtIg6ZdwU5Wa/I+n6xzFY+q1/mE+w==",
        "shasum": "a88d5c710497d40860ae5adedc9cf949883b11c8",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.97.0-next.2.tgz",
        "fileCount": 610,
        "unpackedSize": 627295,
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEQCIElX0XnSjN19G8ppPyTbOIZT9HiOEDdBVnog/LFMJjheAiBm0b53h3+SmZ8X4voJoGPVmusAeaf1M3+RvhGWoVkKWQ=="
          }
        ]
      },
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "maintainers": [
        {
          "name": "jheer",
          "email": "jeffrey.heer@gmail.com"
        },
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "kanitw",
          "email": "kanitw@gmail.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.97.0-next.2_1634218659056_0.31768029700910216"
      },
      "_hasShrinkwrap": false
    },
    "0.97.0-next.3": {
      "name": "ts-json-schema-generator",
      "version": "0.97.0-next.3",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "MooYeol Prescott Lee",
          "email": "mooyoul@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=10.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.9",
        "commander": "^8.2.0",
        "fast-json-stable-stringify": "^2.1.0",
        "glob": "^7.2.0",
        "json-stable-stringify": "^1.0.1",
        "json5": "^2.2.0",
        "typescript": "~4.4.3"
      },
      "devDependencies": {
        "@auto-it/conventional-commits": "^10.32.1",
        "@auto-it/first-time-contributor": "^10.32.1",
        "@babel/core": "^7.15.8",
        "@babel/preset-env": "^7.15.8",
        "@babel/preset-typescript": "^7.15.0",
        "@types/glob": "^7.1.4",
        "@types/jest": "^27.0.2",
        "@types/json-stable-stringify": "^1.0.33",
        "@types/node": "^16.10.3",
        "@typescript-eslint/eslint-plugin": "^4.33.0",
        "@typescript-eslint/parser": "^4.33.0",
        "ajv": "^8.6.3",
        "ajv-formats": "^2.1.1",
        "auto": "^10.32.1",
        "chai": "^4.3.4",
        "cross-env": "^7.0.3",
        "eslint": "^7.32.0",
        "eslint-config-prettier": "^8.3.0",
        "eslint-plugin-prettier": "^4.0.0",
        "jest": "^27.2.4",
        "jest-junit": "^13.0.0",
        "prettier": "^2.4.1",
        "ts-node": "^10.2.1",
        "vega": "^5.21.0",
        "vega-lite": "^5.1.1"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint \"{src,test,factory}/**/*.ts\"",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "cross-env FAST_TEST=1 jest test/ --verbose",
        "test:coverage": "yarn jest test/ --collectCoverage=true",
        "test:update": "cross-env UPDATE_SCHEMA=true yarn test:fast",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts",
        "release": "yarn build && auto shipit"
      },
      "readme": "# ts-json-schema-generator\n\n![Test](https://github.com/vega/ts-json-schema-generator/workflows/Test/badge.svg)\n[![codecov](https://codecov.io/gh/vega/ts-json-schema-generator/branch/master/graph/badge.svg)](https://codecov.io/gh/vega/ts-json-schema-generator)\n[![npm version](https://img.shields.io/npm/v/ts-json-schema-generator.svg)](https://www.npmjs.com/package/ts-json-schema-generator)\n\nExtended version of [https://github.com/xiag-ag/typescript-to-json-schema](https://github.com/xiag-ag/typescript-to-json-schema).\n\nInspired by [`YousefED/typescript-json-schema`](https://github.com/YousefED/typescript-json-schema). Here's the differences list:\n\n-   this implementation avoids the use of `typeChecker.getTypeAtLocation()` (so probably it keeps correct type aliases)\n-   processing AST and formatting JSON schema have been split into two independent steps\n-   not exported types, interfaces, enums are not exposed in the `definitions` section in the JSON schema\n\n## Contributors\n\nThis project is made possible by a [community of contributors](https://github.com/vega/ts-json-schema-generator/graphs/contributors). We welcome contributions of any kind (issues, code, documentation, examples, tests,...). Please read our [code of conduct](https://github.com/vega/vega/blob/master/CODE_OF_CONDUCT.md).\n\n## CLI Usage\n\n```bash\nnpm install --save ts-json-schema-generator\n./node_modules/.bin/ts-json-schema-generator --path 'my/project/**/*.ts' --type 'My.Type.Name'\n```\n\nNote that different platforms (e.g. Windows) may use different path separators so you may have to adjust the command above.\n\n## Programmatic Usage\n\n```js\n// main.js\n\nconst tsj = require(\"ts-json-schema-generator\");\nconst fs = require(\"fs\");\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst output_path = \"path/to/output/file\";\n\nconst schema = tsj.createGenerator(config).createSchema(config.type);\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\nRun the schema generator via `node main.js`.\n\n### Custom formatting\n\nExtending the built-in formatting is possible by creating a custom formatter and adding it to the main formatter:\n\n1. First we create a formatter, in this case for formatting function types:\n\n```ts\n// my-function-formatter.ts\nimport { BaseType, Definition, FunctionType, SubTypeFormatter } from \"ts-json-schema-generator\";\nimport ts from \"typescript\";\n\nexport class MyFunctionTypeFormatter implements SubTypeFormatter {\n    // You can skip this line if you don't need childTypeFormatter\n    public constructor(private childTypeFormatter: TypeFormatter) {}\n\n    public supportsType(type: FunctionType): boolean {\n        return type instanceof FunctionType;\n    }\n\n    public getDefinition(type: FunctionType): Definition {\n        // Return a custom schema for the function property.\n        return {\n            type: \"object\",\n            properties: {\n                isFunction: {\n                    type: \"boolean\",\n                    const: true,\n                },\n            },\n        };\n    }\n\n    // If this type does NOT HAVE children, generally all you need is:\n    public getChildren(type: FunctionType): BaseType[] {\n        return [];\n    }\n\n    // However, if children ARE supported, you'll need something similar to\n    // this (see src/TypeFormatter/{Array,Definition,etc}.ts for some examples):\n    public getChildren(type: FunctionType): BaseType[] {\n        return this.childTypeFormatter.getChildren(type.getType());\n    }\n}\n```\n\n2. Then we add the formatter as a child to the core formatter using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyFunctionTypeFormatter } from \"./my-function-formatter.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\n// We configure the formatter an add our custom formatter to it.\nconst formatter = createFormatter(config, (fmt, circularReferenceTypeFormatter) => {\n    // If your formatter DOES NOT support children, e.g. getChildren() { return [] }:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter());\n    // If your formatter DOES support children, you'll need this reference too:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter(circularReferenceTypeFormatter));\n});\n\nconst program = createProgram(config);\nconst parser = createParser(program, config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n### Custom parsing\n\nSimilar to custom formatting, extending the built-in parsing works practically the same way:\n\n1. First we create a parser, in this case for parsing construct types:\n\n```ts\n// my-constructor-parser.ts\nimport { Context, StringType, ReferenceType, BaseType, SubNodeParser } from \"ts-json-schema-generator\";\nimport ts from \"typescript\";\n\nexport class MyConstructorParser implements SubNodeParser {\n    supportsNode(node: ts.Node): boolean {\n        return node.kind === ts.SyntaxKind.ConstructorType;\n    }\n    createType(node: ts.Node, context: Context, reference?: ReferenceType): BaseType | undefined {\n        return new StringType(); // Treat constructors as strings in this example\n    }\n}\n```\n\n2. Then we add the parser as a child to the core parser using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyConstructorParser } from \"./my-constructor-parser.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst program = createProgram(config);\n\n// We configure the parser an add our custom parser to it.\nconst parser = createParser(program, config, (prs) => {\n    prs.addNodeParser(new MyConstructorParser());\n});\n\nconst formatter = createFormatter(config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n## Options\n\n```\n-p, --path 'index.ts'\n    The path to the TypeScript source file. If this is not provided, the type will be searched in the project specified in the `.tsconfig`.\n\n-t, --type 'My.Type.Name'\n    The type the generated schema will represent. If omitted, the generated schema will contain all\n    types found in the files matching path. The same is true if '*' is specified.\n\n-i, --id 'generatedSchemaId'\n    The `$id` of the generated schema. If omitted, there will be no `$id`.\n\n-e, --expose <all|none|export>\n    all: Create shared $ref definitions for all types.\n    none: Do not create shared $ref definitions.\n    export (default): Create shared $ref definitions only for exported types (not tagged as `@internal`).\n\n-f, --tsconfig 'my/project/tsconfig.json'\n    Use a custom tsconfig file for processing typescript (see https://www.typescriptlang.org/docs/handbook/tsconfig-json.html) instead of the default:\n    {\n        \"compilerOptions\": {\n            \"noEmit\": true,\n            \"emitDecoratorMetadata\": true,\n            \"experimentalDecorators\": true,\n            \"target\": \"ES5\",\n            \"module\": \"CommonJS\",\n            \"strictNullChecks\": false,\n        }\n    }\n\n-j, --jsDoc <extended|none|basic>\n    none: Do not use JsDoc annotations.\n    basic: Read JsDoc annotations to provide schema properties.\n    extended (default): Also read @nullable, and @asType annotations.\n\n--unstable\n    Do not sort properties.\n\n--strict-tuples\n    Do not allow additional items on tuples.\n\n--no-top-ref\n    Do not create a top-level $ref definition.\n\n--no-type-check\n    Skip type checks for better performance.\n\n--no-ref-encode\n    Do not encode references. According to the standard, references must be valid URIs but some tools do not support encoded references.\n\n--validation-keywords\n    Provide additional validation keywords to include.\n\n-o, --out\n    Specify the output file path. Without this option, the generator logs the response in the console.\n\n--additional-properties <true|false>\n    Controls whether or not to allow additional properties for objects that have no index signature.\n\n    true: Additional properties are allowed\n    false (default): Additional properties are not allowed\n```\n\n## Current state\n\n-   `interface` types\n-   `enum` types\n-   `union`, `tuple`, `type[]` types\n-   `Date`, `RegExp` types\n-   `string`, `boolean`, `number` types\n-   `\"value\"`, `123`, `true`, `false`, `null`, `undefined` literals\n-   type aliases\n-   generics\n-   `typeof`\n-   `keyof`\n-   conditional types\n\n## Run locally\n\n`yarn --silent run run --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\n## Debug\n\n`yarn --silent run debug --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\nAnd connect via the debugger protocol.\n\n[AST Explorer](https://astexplorer.net/) is amazing for developers of this tool!\n\n## Publish\n\nPublishing is handled by a 2-branch [pre-release process](https://intuit.github.io/auto/docs/generated/shipit#next-branch-default), configured in `publish-auto.yml`. All changes should be based off the default `next` branch, and are published automatically.\n\n-   PRs made into the default branch are auto-deployed to the `next` pre-release tag on NPM. The result can be installed with `npm install ts-json-schema-generator@next`\n    -   When merging into `next`, please use the `squash and merge` strategy.\n-   To release a new stable version, open a PR from `next` into `stable` using this [compare link](https://github.com/vega/ts-json-schema-generator/compare/stable...next).\n    -   When merging from `next` into `stable`, please use the `create a merge commit` strategy.\n",
      "readmeFilename": "README.md",
      "gitHead": "909d12b01e6982bb863718c6722e08aaaa50cc4f",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.97.0-next.3",
      "_nodeVersion": "14.18.0",
      "_npmVersion": "6.14.15",
      "dist": {
        "integrity": "sha512-quB1rrqvdas6adS4hOW2QPuID4JLfMXayeTprcuohF2ypVOgjzkqHqjXPEsJYrZjhT0kSGVbxqONMMFhziy9/A==",
        "shasum": "8163c11506f73732ed9269d5753b8c124d46615f",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.97.0-next.3.tgz",
        "fileCount": 610,
        "unpackedSize": 627836,
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIQD8tjyrGzhUkX88Qpx8HF0Turm3SKSaJsdfk2EdEGWy1QIgQS/DiBgwSs9+AndDXft7zYdxOhX7QNNJEUMlBifLmJM="
          }
        ]
      },
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "maintainers": [
        {
          "name": "jheer",
          "email": "jeffrey.heer@gmail.com"
        },
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "kanitw",
          "email": "kanitw@gmail.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.97.0-next.3_1634313871120_0.6856756834922468"
      },
      "_hasShrinkwrap": false
    },
    "0.97.0-next.4": {
      "name": "ts-json-schema-generator",
      "version": "0.97.0-next.4",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "MooYeol Prescott Lee",
          "email": "mooyoul@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=10.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.9",
        "commander": "^8.2.0",
        "fast-json-stable-stringify": "^2.1.0",
        "glob": "^7.2.0",
        "json-stable-stringify": "^1.0.1",
        "json5": "^2.2.0",
        "typescript": "~4.4.3"
      },
      "devDependencies": {
        "@auto-it/conventional-commits": "^10.32.1",
        "@auto-it/first-time-contributor": "^10.32.1",
        "@babel/core": "^7.15.8",
        "@babel/preset-env": "^7.15.8",
        "@babel/preset-typescript": "^7.15.0",
        "@types/glob": "^7.1.4",
        "@types/jest": "^27.0.2",
        "@types/json-stable-stringify": "^1.0.33",
        "@types/node": "^16.10.3",
        "@typescript-eslint/eslint-plugin": "^4.33.0",
        "@typescript-eslint/parser": "^4.33.0",
        "ajv": "^8.6.3",
        "ajv-formats": "^2.1.1",
        "auto": "^10.32.1",
        "chai": "^4.3.4",
        "cross-env": "^7.0.3",
        "eslint": "^7.32.0",
        "eslint-config-prettier": "^8.3.0",
        "eslint-plugin-prettier": "^4.0.0",
        "jest": "^27.2.4",
        "jest-junit": "^13.0.0",
        "prettier": "^2.4.1",
        "ts-node": "^10.2.1",
        "vega": "^5.21.0",
        "vega-lite": "^5.1.1"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint \"{src,test,factory}/**/*.ts\"",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "cross-env FAST_TEST=1 jest test/ --verbose",
        "test:coverage": "yarn jest test/ --collectCoverage=true",
        "test:update": "cross-env UPDATE_SCHEMA=true yarn test:fast",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts",
        "release": "yarn build && auto shipit"
      },
      "readme": "# ts-json-schema-generator\n\n![Test](https://github.com/vega/ts-json-schema-generator/workflows/Test/badge.svg)\n[![codecov](https://codecov.io/gh/vega/ts-json-schema-generator/branch/master/graph/badge.svg)](https://codecov.io/gh/vega/ts-json-schema-generator)\n[![npm version](https://img.shields.io/npm/v/ts-json-schema-generator.svg)](https://www.npmjs.com/package/ts-json-schema-generator)\n\nExtended version of [https://github.com/xiag-ag/typescript-to-json-schema](https://github.com/xiag-ag/typescript-to-json-schema).\n\nInspired by [`YousefED/typescript-json-schema`](https://github.com/YousefED/typescript-json-schema). Here's the differences list:\n\n-   this implementation avoids the use of `typeChecker.getTypeAtLocation()` (so probably it keeps correct type aliases)\n-   processing AST and formatting JSON schema have been split into two independent steps\n-   not exported types, interfaces, enums are not exposed in the `definitions` section in the JSON schema\n\n## Contributors\n\nThis project is made possible by a [community of contributors](https://github.com/vega/ts-json-schema-generator/graphs/contributors). We welcome contributions of any kind (issues, code, documentation, examples, tests,...). Please read our [code of conduct](https://github.com/vega/vega/blob/master/CODE_OF_CONDUCT.md).\n\n## CLI Usage\n\n```bash\nnpm install --save ts-json-schema-generator\n./node_modules/.bin/ts-json-schema-generator --path 'my/project/**/*.ts' --type 'My.Type.Name'\n```\n\nNote that different platforms (e.g. Windows) may use different path separators so you may have to adjust the command above.\n\n## Programmatic Usage\n\n```js\n// main.js\n\nconst tsj = require(\"ts-json-schema-generator\");\nconst fs = require(\"fs\");\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst output_path = \"path/to/output/file\";\n\nconst schema = tsj.createGenerator(config).createSchema(config.type);\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\nRun the schema generator via `node main.js`.\n\n### Custom formatting\n\nExtending the built-in formatting is possible by creating a custom formatter and adding it to the main formatter:\n\n1. First we create a formatter, in this case for formatting function types:\n\n```ts\n// my-function-formatter.ts\nimport { BaseType, Definition, FunctionType, SubTypeFormatter } from \"ts-json-schema-generator\";\nimport ts from \"typescript\";\n\nexport class MyFunctionTypeFormatter implements SubTypeFormatter {\n    // You can skip this line if you don't need childTypeFormatter\n    public constructor(private childTypeFormatter: TypeFormatter) {}\n\n    public supportsType(type: FunctionType): boolean {\n        return type instanceof FunctionType;\n    }\n\n    public getDefinition(type: FunctionType): Definition {\n        // Return a custom schema for the function property.\n        return {\n            type: \"object\",\n            properties: {\n                isFunction: {\n                    type: \"boolean\",\n                    const: true,\n                },\n            },\n        };\n    }\n\n    // If this type does NOT HAVE children, generally all you need is:\n    public getChildren(type: FunctionType): BaseType[] {\n        return [];\n    }\n\n    // However, if children ARE supported, you'll need something similar to\n    // this (see src/TypeFormatter/{Array,Definition,etc}.ts for some examples):\n    public getChildren(type: FunctionType): BaseType[] {\n        return this.childTypeFormatter.getChildren(type.getType());\n    }\n}\n```\n\n2. Then we add the formatter as a child to the core formatter using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyFunctionTypeFormatter } from \"./my-function-formatter.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\n// We configure the formatter an add our custom formatter to it.\nconst formatter = createFormatter(config, (fmt, circularReferenceTypeFormatter) => {\n    // If your formatter DOES NOT support children, e.g. getChildren() { return [] }:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter());\n    // If your formatter DOES support children, you'll need this reference too:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter(circularReferenceTypeFormatter));\n});\n\nconst program = createProgram(config);\nconst parser = createParser(program, config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n### Custom parsing\n\nSimilar to custom formatting, extending the built-in parsing works practically the same way:\n\n1. First we create a parser, in this case for parsing construct types:\n\n```ts\n// my-constructor-parser.ts\nimport { Context, StringType, ReferenceType, BaseType, SubNodeParser } from \"ts-json-schema-generator\";\nimport ts from \"typescript\";\n\nexport class MyConstructorParser implements SubNodeParser {\n    supportsNode(node: ts.Node): boolean {\n        return node.kind === ts.SyntaxKind.ConstructorType;\n    }\n    createType(node: ts.Node, context: Context, reference?: ReferenceType): BaseType | undefined {\n        return new StringType(); // Treat constructors as strings in this example\n    }\n}\n```\n\n2. Then we add the parser as a child to the core parser using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyConstructorParser } from \"./my-constructor-parser.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst program = createProgram(config);\n\n// We configure the parser an add our custom parser to it.\nconst parser = createParser(program, config, (prs) => {\n    prs.addNodeParser(new MyConstructorParser());\n});\n\nconst formatter = createFormatter(config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n## Options\n\n```\n-p, --path 'index.ts'\n    The path to the TypeScript source file. If this is not provided, the type will be searched in the project specified in the `.tsconfig`.\n\n-t, --type 'My.Type.Name'\n    The type the generated schema will represent. If omitted, the generated schema will contain all\n    types found in the files matching path. The same is true if '*' is specified.\n\n-i, --id 'generatedSchemaId'\n    The `$id` of the generated schema. If omitted, there will be no `$id`.\n\n-e, --expose <all|none|export>\n    all: Create shared $ref definitions for all types.\n    none: Do not create shared $ref definitions.\n    export (default): Create shared $ref definitions only for exported types (not tagged as `@internal`).\n\n-f, --tsconfig 'my/project/tsconfig.json'\n    Use a custom tsconfig file for processing typescript (see https://www.typescriptlang.org/docs/handbook/tsconfig-json.html) instead of the default:\n    {\n        \"compilerOptions\": {\n            \"noEmit\": true,\n            \"emitDecoratorMetadata\": true,\n            \"experimentalDecorators\": true,\n            \"target\": \"ES5\",\n            \"module\": \"CommonJS\",\n            \"strictNullChecks\": false,\n        }\n    }\n\n-j, --jsDoc <extended|none|basic>\n    none: Do not use JsDoc annotations.\n    basic: Read JsDoc annotations to provide schema properties.\n    extended (default): Also read @nullable, and @asType annotations.\n\n--unstable\n    Do not sort properties.\n\n--strict-tuples\n    Do not allow additional items on tuples.\n\n--no-top-ref\n    Do not create a top-level $ref definition.\n\n--no-type-check\n    Skip type checks for better performance.\n\n--no-ref-encode\n    Do not encode references. According to the standard, references must be valid URIs but some tools do not support encoded references.\n\n--validation-keywords\n    Provide additional validation keywords to include.\n\n-o, --out\n    Specify the output file path. Without this option, the generator logs the response in the console.\n\n--additional-properties <true|false>\n    Controls whether or not to allow additional properties for objects that have no index signature.\n\n    true: Additional properties are allowed\n    false (default): Additional properties are not allowed\n```\n\n## Current state\n\n-   `interface` types\n-   `enum` types\n-   `union`, `tuple`, `type[]` types\n-   `Date`, `RegExp` types\n-   `string`, `boolean`, `number` types\n-   `\"value\"`, `123`, `true`, `false`, `null`, `undefined` literals\n-   type aliases\n-   generics\n-   `typeof`\n-   `keyof`\n-   conditional types\n\n## Run locally\n\n`yarn --silent run run --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\n## Debug\n\n`yarn --silent run debug --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\nAnd connect via the debugger protocol.\n\n[AST Explorer](https://astexplorer.net/) is amazing for developers of this tool!\n\n## Publish\n\nPublishing is handled by a 2-branch [pre-release process](https://intuit.github.io/auto/docs/generated/shipit#next-branch-default), configured in `publish-auto.yml`. All changes should be based off the default `next` branch, and are published automatically.\n\n-   PRs made into the default branch are auto-deployed to the `next` pre-release tag on NPM. The result can be installed with `npm install ts-json-schema-generator@next`\n    -   When merging into `next`, please use the `squash and merge` strategy.\n-   To release a new stable version, open a PR from `next` into `stable` using this [compare link](https://github.com/vega/ts-json-schema-generator/compare/stable...next).\n    -   When merging from `next` into `stable`, please use the `create a merge commit` strategy.\n",
      "readmeFilename": "README.md",
      "gitHead": "cc04c5ec2ecba4861956ade7f9307246bd0e14f1",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.97.0-next.4",
      "_nodeVersion": "14.18.1",
      "_npmVersion": "6.14.15",
      "dist": {
        "integrity": "sha512-VwtV03kuwTUD1p46z9g/0mrOzlV9kgbJxk3w+mEaCJCq1YtaF3KBqg5ky2m8gHu96YTOMSWkKyducLDw5eWubQ==",
        "shasum": "6920fbcd36aed5ac0b9b605430d468461d8f1db8",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.97.0-next.4.tgz",
        "fileCount": 610,
        "unpackedSize": 628074,
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEMCIDIpO41fiEgKv+3IjclOUdMJqU6NgHdvhXPp6fq69YGYAh8AtJMd8lqyut/zIwkS9EUAogd9ZfhyyhUAZNLLPqC1"
          }
        ]
      },
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "maintainers": [
        {
          "name": "jheer",
          "email": "jeffrey.heer@gmail.com"
        },
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "kanitw",
          "email": "kanitw@gmail.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.97.0-next.4_1635102592262_0.244127336907078"
      },
      "_hasShrinkwrap": false
    },
    "0.97.0-next.5": {
      "name": "ts-json-schema-generator",
      "version": "0.97.0-next.5",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "MooYeol Prescott Lee",
          "email": "mooyoul@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=10.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.9",
        "commander": "^8.2.0",
        "fast-json-stable-stringify": "^2.1.0",
        "glob": "^7.2.0",
        "json-stable-stringify": "^1.0.1",
        "json5": "^2.2.0",
        "typescript": "~4.4.3"
      },
      "devDependencies": {
        "@auto-it/conventional-commits": "^10.32.1",
        "@auto-it/first-time-contributor": "^10.32.1",
        "@babel/core": "^7.15.8",
        "@babel/preset-env": "^7.15.8",
        "@babel/preset-typescript": "^7.15.0",
        "@types/glob": "^7.1.4",
        "@types/jest": "^27.0.2",
        "@types/json-stable-stringify": "^1.0.33",
        "@types/node": "^16.10.3",
        "@typescript-eslint/eslint-plugin": "^4.33.0",
        "@typescript-eslint/parser": "^4.33.0",
        "ajv": "^8.6.3",
        "ajv-formats": "^2.1.1",
        "auto": "^10.32.1",
        "chai": "^4.3.4",
        "cross-env": "^7.0.3",
        "eslint": "^7.32.0",
        "eslint-config-prettier": "^8.3.0",
        "eslint-plugin-prettier": "^4.0.0",
        "jest": "^27.2.4",
        "jest-junit": "^13.0.0",
        "prettier": "^2.4.1",
        "ts-node": "^10.2.1",
        "vega": "^5.21.0",
        "vega-lite": "^5.1.1"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint \"{src,test,factory}/**/*.ts\"",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "cross-env FAST_TEST=1 jest test/ --verbose",
        "test:coverage": "yarn jest test/ --collectCoverage=true",
        "test:update": "cross-env UPDATE_SCHEMA=true yarn test:fast",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts",
        "release": "yarn build && auto shipit"
      },
      "readme": "# ts-json-schema-generator\n\n![Test](https://github.com/vega/ts-json-schema-generator/workflows/Test/badge.svg)\n[![codecov](https://codecov.io/gh/vega/ts-json-schema-generator/branch/master/graph/badge.svg)](https://codecov.io/gh/vega/ts-json-schema-generator)\n[![npm version](https://img.shields.io/npm/v/ts-json-schema-generator.svg)](https://www.npmjs.com/package/ts-json-schema-generator)\n\nExtended version of [https://github.com/xiag-ag/typescript-to-json-schema](https://github.com/xiag-ag/typescript-to-json-schema).\n\nInspired by [`YousefED/typescript-json-schema`](https://github.com/YousefED/typescript-json-schema). Here's the differences list:\n\n-   this implementation avoids the use of `typeChecker.getTypeAtLocation()` (so probably it keeps correct type aliases)\n-   processing AST and formatting JSON schema have been split into two independent steps\n-   not exported types, interfaces, enums are not exposed in the `definitions` section in the JSON schema\n\n## Contributors\n\nThis project is made possible by a [community of contributors](https://github.com/vega/ts-json-schema-generator/graphs/contributors). We welcome contributions of any kind (issues, code, documentation, examples, tests,...). Please read our [code of conduct](https://github.com/vega/vega/blob/master/CODE_OF_CONDUCT.md).\n\n## CLI Usage\n\n```bash\nnpm install --save ts-json-schema-generator\n./node_modules/.bin/ts-json-schema-generator --path 'my/project/**/*.ts' --type 'My.Type.Name'\n```\n\nNote that different platforms (e.g. Windows) may use different path separators so you may have to adjust the command above.\n\n## Programmatic Usage\n\n```js\n// main.js\n\nconst tsj = require(\"ts-json-schema-generator\");\nconst fs = require(\"fs\");\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst output_path = \"path/to/output/file\";\n\nconst schema = tsj.createGenerator(config).createSchema(config.type);\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\nRun the schema generator via `node main.js`.\n\n### Custom formatting\n\nExtending the built-in formatting is possible by creating a custom formatter and adding it to the main formatter:\n\n1. First we create a formatter, in this case for formatting function types:\n\n```ts\n// my-function-formatter.ts\nimport { BaseType, Definition, FunctionType, SubTypeFormatter } from \"ts-json-schema-generator\";\nimport ts from \"typescript\";\n\nexport class MyFunctionTypeFormatter implements SubTypeFormatter {\n    // You can skip this line if you don't need childTypeFormatter\n    public constructor(private childTypeFormatter: TypeFormatter) {}\n\n    public supportsType(type: FunctionType): boolean {\n        return type instanceof FunctionType;\n    }\n\n    public getDefinition(type: FunctionType): Definition {\n        // Return a custom schema for the function property.\n        return {\n            type: \"object\",\n            properties: {\n                isFunction: {\n                    type: \"boolean\",\n                    const: true,\n                },\n            },\n        };\n    }\n\n    // If this type does NOT HAVE children, generally all you need is:\n    public getChildren(type: FunctionType): BaseType[] {\n        return [];\n    }\n\n    // However, if children ARE supported, you'll need something similar to\n    // this (see src/TypeFormatter/{Array,Definition,etc}.ts for some examples):\n    public getChildren(type: FunctionType): BaseType[] {\n        return this.childTypeFormatter.getChildren(type.getType());\n    }\n}\n```\n\n2. Then we add the formatter as a child to the core formatter using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyFunctionTypeFormatter } from \"./my-function-formatter.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\n// We configure the formatter an add our custom formatter to it.\nconst formatter = createFormatter(config, (fmt, circularReferenceTypeFormatter) => {\n    // If your formatter DOES NOT support children, e.g. getChildren() { return [] }:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter());\n    // If your formatter DOES support children, you'll need this reference too:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter(circularReferenceTypeFormatter));\n});\n\nconst program = createProgram(config);\nconst parser = createParser(program, config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n### Custom parsing\n\nSimilar to custom formatting, extending the built-in parsing works practically the same way:\n\n1. First we create a parser, in this case for parsing construct types:\n\n```ts\n// my-constructor-parser.ts\nimport { Context, StringType, ReferenceType, BaseType, SubNodeParser } from \"ts-json-schema-generator\";\nimport ts from \"typescript\";\n\nexport class MyConstructorParser implements SubNodeParser {\n    supportsNode(node: ts.Node): boolean {\n        return node.kind === ts.SyntaxKind.ConstructorType;\n    }\n    createType(node: ts.Node, context: Context, reference?: ReferenceType): BaseType | undefined {\n        return new StringType(); // Treat constructors as strings in this example\n    }\n}\n```\n\n2. Then we add the parser as a child to the core parser using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyConstructorParser } from \"./my-constructor-parser.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst program = createProgram(config);\n\n// We configure the parser an add our custom parser to it.\nconst parser = createParser(program, config, (prs) => {\n    prs.addNodeParser(new MyConstructorParser());\n});\n\nconst formatter = createFormatter(config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n## Options\n\n```\n-p, --path 'index.ts'\n    The path to the TypeScript source file. If this is not provided, the type will be searched in the project specified in the `.tsconfig`.\n\n-t, --type 'My.Type.Name'\n    The type the generated schema will represent. If omitted, the generated schema will contain all\n    types found in the files matching path. The same is true if '*' is specified.\n\n-i, --id 'generatedSchemaId'\n    The `$id` of the generated schema. If omitted, there will be no `$id`.\n\n-e, --expose <all|none|export>\n    all: Create shared $ref definitions for all types.\n    none: Do not create shared $ref definitions.\n    export (default): Create shared $ref definitions only for exported types (not tagged as `@internal`).\n\n-f, --tsconfig 'my/project/tsconfig.json'\n    Use a custom tsconfig file for processing typescript (see https://www.typescriptlang.org/docs/handbook/tsconfig-json.html) instead of the default:\n    {\n        \"compilerOptions\": {\n            \"noEmit\": true,\n            \"emitDecoratorMetadata\": true,\n            \"experimentalDecorators\": true,\n            \"target\": \"ES5\",\n            \"module\": \"CommonJS\",\n            \"strictNullChecks\": false,\n        }\n    }\n\n-j, --jsDoc <extended|none|basic>\n    none: Do not use JsDoc annotations.\n    basic: Read JsDoc annotations to provide schema properties.\n    extended (default): Also read @nullable, and @asType annotations.\n\n--unstable\n    Do not sort properties.\n\n--strict-tuples\n    Do not allow additional items on tuples.\n\n--no-top-ref\n    Do not create a top-level $ref definition.\n\n--no-type-check\n    Skip type checks for better performance.\n\n--no-ref-encode\n    Do not encode references. According to the standard, references must be valid URIs but some tools do not support encoded references.\n\n--validation-keywords\n    Provide additional validation keywords to include.\n\n-o, --out\n    Specify the output file path. Without this option, the generator logs the response in the console.\n\n--additional-properties <true|false>\n    Controls whether or not to allow additional properties for objects that have no index signature.\n\n    true: Additional properties are allowed\n    false (default): Additional properties are not allowed\n```\n\n## Current state\n\n-   `interface` types\n-   `enum` types\n-   `union`, `tuple`, `type[]` types\n-   `Date`, `RegExp` types\n-   `string`, `boolean`, `number` types\n-   `\"value\"`, `123`, `true`, `false`, `null`, `undefined` literals\n-   type aliases\n-   generics\n-   `typeof`\n-   `keyof`\n-   conditional types\n\n## Run locally\n\n`yarn --silent run run --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\n## Debug\n\n`yarn --silent run debug --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\nAnd connect via the debugger protocol.\n\n[AST Explorer](https://astexplorer.net/) is amazing for developers of this tool!\n\n## Publish\n\nPublishing is handled by a 2-branch [pre-release process](https://intuit.github.io/auto/docs/generated/shipit#next-branch-default), configured in `publish-auto.yml`. All changes should be based off the default `next` branch, and are published automatically.\n\n-   PRs made into the default branch are auto-deployed to the `next` pre-release tag on NPM. The result can be installed with `npm install ts-json-schema-generator@next`\n    -   When merging into `next`, please use the `squash and merge` strategy.\n-   To release a new stable version, open a PR from `next` into `stable` using this [compare link](https://github.com/vega/ts-json-schema-generator/compare/stable...next).\n    -   When merging from `next` into `stable`, please use the `create a merge commit` strategy.\n",
      "readmeFilename": "README.md",
      "gitHead": "f0b7aab66b55d0aeae3db04681bca28ca8921f6a",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.97.0-next.5",
      "_nodeVersion": "14.18.1",
      "_npmVersion": "6.14.15",
      "dist": {
        "integrity": "sha512-LcAjwccTyg5HQyx0qLpA+eb5rFoGclG2e8tvQqPLDgTUIH+c/jN1d0uNGLY233g0DRFpG0lV7cNmvvzLOBsGJw==",
        "shasum": "58c9eff4881e16e99d710f17f93360febf8ff858",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.97.0-next.5.tgz",
        "fileCount": 610,
        "unpackedSize": 628127,
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEQCIFscfkFockAnvg84Ubk4qlkjZHyRWVu/6IMRTaxm2uQXAiBQ0olyXxDC4h+zxWkYt3Affi+eqeQTzlkNnS2I8oqS0A=="
          }
        ]
      },
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "maintainers": [
        {
          "name": "jheer",
          "email": "jeffrey.heer@gmail.com"
        },
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "kanitw",
          "email": "kanitw@gmail.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.97.0-next.5_1635772608163_0.8027403699530342"
      },
      "_hasShrinkwrap": false
    },
    "0.97.0": {
      "name": "ts-json-schema-generator",
      "version": "0.97.0",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "MooYeol Prescott Lee",
          "email": "mooyoul@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=10.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.9",
        "commander": "^8.2.0",
        "glob": "^7.2.0",
        "safe-stable-stringify": "^2.2.0",
        "json5": "^2.2.0",
        "typescript": "~4.4.3"
      },
      "devDependencies": {
        "@auto-it/conventional-commits": "^10.32.1",
        "@auto-it/first-time-contributor": "^10.32.1",
        "@babel/core": "^7.15.8",
        "@babel/preset-env": "^7.15.8",
        "@babel/preset-typescript": "^7.15.0",
        "@types/glob": "^7.1.4",
        "@types/jest": "^27.0.2",
        "@types/node": "^16.10.3",
        "@typescript-eslint/eslint-plugin": "^4.33.0",
        "@typescript-eslint/parser": "^4.33.0",
        "ajv": "^8.6.3",
        "ajv-formats": "^2.1.1",
        "auto": "^10.32.1",
        "chai": "^4.3.4",
        "cross-env": "^7.0.3",
        "eslint": "^7.32.0",
        "eslint-config-prettier": "^8.3.0",
        "eslint-plugin-prettier": "^4.0.0",
        "jest": "^27.2.4",
        "jest-junit": "^13.0.0",
        "prettier": "^2.4.1",
        "ts-node": "^10.2.1",
        "vega": "^5.21.0",
        "vega-lite": "^5.1.1"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint \"{src,test,factory}/**/*.ts\"",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "cross-env FAST_TEST=1 jest test/ --verbose",
        "test:coverage": "yarn jest test/ --collectCoverage=true",
        "test:update": "cross-env UPDATE_SCHEMA=true yarn test:fast",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts",
        "release": "yarn build && auto shipit"
      },
      "gitHead": "5e10013faace44a4306d1d5f43da5ca60ce2655e",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.97.0",
      "_nodeVersion": "14.18.1",
      "_npmVersion": "6.14.15",
      "dist": {
        "integrity": "sha512-kPDq4ut8Mu1ZgSN7OeTXz+ueb1juFt2eyGd23lMr3WoN5sq4Xa9m22kDI46OlwapE0aF8e1pUesOFgDcATHcuA==",
        "shasum": "ea4f2ddbcba1fb6c0a2f97d242783b7fdc8e203b",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.97.0.tgz",
        "fileCount": 610,
        "unpackedSize": 651090,
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIFkkB8iSwD/eBTue3I643ykkzmwS15iM68eonh5uNip1AiEA4TCDqdBeIt8ZKev9r+chGceCKVDJ3Yv/ns0/7PJASHE="
          }
        ]
      },
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "maintainers": [
        {
          "name": "jheer",
          "email": "jeffrey.heer@gmail.com"
        },
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "kanitw",
          "email": "kanitw@gmail.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.97.0_1636044591380_0.32645805819299256"
      },
      "_hasShrinkwrap": false
    },
    "0.97.1--canary.1017.09dac90.0": {
      "name": "ts-json-schema-generator",
      "version": "0.97.1--canary.1017.09dac90.0",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "MooYeol Prescott Lee",
          "email": "mooyoul@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=10.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.9",
        "commander": "^8.2.0",
        "glob": "^7.2.0",
        "safe-stable-stringify": "^2.2.0",
        "json5": "^2.2.0",
        "typescript": "~4.4.3"
      },
      "devDependencies": {
        "@auto-it/conventional-commits": "^10.32.1",
        "@auto-it/first-time-contributor": "^10.32.1",
        "@babel/core": "^7.15.8",
        "@babel/preset-env": "^7.15.8",
        "@babel/preset-typescript": "^7.15.0",
        "@types/glob": "^7.1.4",
        "@types/jest": "^27.0.2",
        "@types/node": "^16.10.3",
        "@typescript-eslint/eslint-plugin": "^4.33.0",
        "@typescript-eslint/parser": "^4.33.0",
        "ajv": "^8.6.3",
        "ajv-formats": "^2.1.1",
        "auto": "^10.32.1",
        "chai": "^4.3.4",
        "cross-env": "^7.0.3",
        "eslint": "^7.32.0",
        "eslint-config-prettier": "^8.3.0",
        "eslint-plugin-prettier": "^4.0.0",
        "jest": "^27.2.4",
        "jest-junit": "^13.0.0",
        "prettier": "^2.4.1",
        "ts-node": "^10.2.1",
        "vega": "^5.21.0",
        "vega-lite": "^5.1.1"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint \"{src,test,factory}/**/*.ts\"",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "cross-env FAST_TEST=1 jest test/ --verbose",
        "test:coverage": "yarn jest test/ --collectCoverage=true",
        "test:update": "cross-env UPDATE_SCHEMA=true yarn test:fast",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts",
        "release": "yarn build && auto shipit"
      },
      "readme": "# ts-json-schema-generator\n\n![Test](https://github.com/vega/ts-json-schema-generator/workflows/Test/badge.svg)\n[![codecov](https://codecov.io/gh/vega/ts-json-schema-generator/branch/master/graph/badge.svg)](https://codecov.io/gh/vega/ts-json-schema-generator)\n[![npm version](https://img.shields.io/npm/v/ts-json-schema-generator.svg)](https://www.npmjs.com/package/ts-json-schema-generator)\n\nExtended version of [https://github.com/xiag-ag/typescript-to-json-schema](https://github.com/xiag-ag/typescript-to-json-schema).\n\nInspired by [`YousefED/typescript-json-schema`](https://github.com/YousefED/typescript-json-schema). Here's the differences list:\n\n-   this implementation avoids the use of `typeChecker.getTypeAtLocation()` (so probably it keeps correct type aliases)\n-   processing AST and formatting JSON schema have been split into two independent steps\n-   not exported types, interfaces, enums are not exposed in the `definitions` section in the JSON schema\n\n## Contributors\n\nThis project is made possible by a [community of contributors](https://github.com/vega/ts-json-schema-generator/graphs/contributors). We welcome contributions of any kind (issues, code, documentation, examples, tests,...). Please read our [code of conduct](https://github.com/vega/vega/blob/master/CODE_OF_CONDUCT.md).\n\n## CLI Usage\n\n```bash\nnpm install --save ts-json-schema-generator\n./node_modules/.bin/ts-json-schema-generator --path 'my/project/**/*.ts' --type 'My.Type.Name'\n```\n\nNote that different platforms (e.g. Windows) may use different path separators so you may have to adjust the command above.\n\n## Programmatic Usage\n\n```js\n// main.js\n\nconst tsj = require(\"ts-json-schema-generator\");\nconst fs = require(\"fs\");\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst output_path = \"path/to/output/file\";\n\nconst schema = tsj.createGenerator(config).createSchema(config.type);\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\nRun the schema generator via `node main.js`.\n\n### Custom formatting\n\nExtending the built-in formatting is possible by creating a custom formatter and adding it to the main formatter:\n\n1. First we create a formatter, in this case for formatting function types:\n\n```ts\n// my-function-formatter.ts\nimport { BaseType, Definition, FunctionType, SubTypeFormatter } from \"ts-json-schema-generator\";\nimport ts from \"typescript\";\n\nexport class MyFunctionTypeFormatter implements SubTypeFormatter {\n    // You can skip this line if you don't need childTypeFormatter\n    public constructor(private childTypeFormatter: TypeFormatter) {}\n\n    public supportsType(type: FunctionType): boolean {\n        return type instanceof FunctionType;\n    }\n\n    public getDefinition(type: FunctionType): Definition {\n        // Return a custom schema for the function property.\n        return {\n            type: \"object\",\n            properties: {\n                isFunction: {\n                    type: \"boolean\",\n                    const: true,\n                },\n            },\n        };\n    }\n\n    // If this type does NOT HAVE children, generally all you need is:\n    public getChildren(type: FunctionType): BaseType[] {\n        return [];\n    }\n\n    // However, if children ARE supported, you'll need something similar to\n    // this (see src/TypeFormatter/{Array,Definition,etc}.ts for some examples):\n    public getChildren(type: FunctionType): BaseType[] {\n        return this.childTypeFormatter.getChildren(type.getType());\n    }\n}\n```\n\n2. Then we add the formatter as a child to the core formatter using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyFunctionTypeFormatter } from \"./my-function-formatter.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\n// We configure the formatter an add our custom formatter to it.\nconst formatter = createFormatter(config, (fmt, circularReferenceTypeFormatter) => {\n    // If your formatter DOES NOT support children, e.g. getChildren() { return [] }:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter());\n    // If your formatter DOES support children, you'll need this reference too:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter(circularReferenceTypeFormatter));\n});\n\nconst program = createProgram(config);\nconst parser = createParser(program, config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n### Custom parsing\n\nSimilar to custom formatting, extending the built-in parsing works practically the same way:\n\n1. First we create a parser, in this case for parsing construct types:\n\n```ts\n// my-constructor-parser.ts\nimport { Context, StringType, ReferenceType, BaseType, SubNodeParser } from \"ts-json-schema-generator\";\nimport ts from \"typescript\";\n\nexport class MyConstructorParser implements SubNodeParser {\n    supportsNode(node: ts.Node): boolean {\n        return node.kind === ts.SyntaxKind.ConstructorType;\n    }\n    createType(node: ts.Node, context: Context, reference?: ReferenceType): BaseType | undefined {\n        return new StringType(); // Treat constructors as strings in this example\n    }\n}\n```\n\n2. Then we add the parser as a child to the core parser using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyConstructorParser } from \"./my-constructor-parser.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst program = createProgram(config);\n\n// We configure the parser an add our custom parser to it.\nconst parser = createParser(program, config, (prs) => {\n    prs.addNodeParser(new MyConstructorParser());\n});\n\nconst formatter = createFormatter(config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n## Options\n\n```\n-p, --path 'index.ts'\n    The path to the TypeScript source file. If this is not provided, the type will be searched in the project specified in the `.tsconfig`.\n\n-t, --type 'My.Type.Name'\n    The type the generated schema will represent. If omitted, the generated schema will contain all\n    types found in the files matching path. The same is true if '*' is specified.\n\n-i, --id 'generatedSchemaId'\n    The `$id` of the generated schema. If omitted, there will be no `$id`.\n\n-e, --expose <all|none|export>\n    all: Create shared $ref definitions for all types.\n    none: Do not create shared $ref definitions.\n    export (default): Create shared $ref definitions only for exported types (not tagged as `@internal`).\n\n-f, --tsconfig 'my/project/tsconfig.json'\n    Use a custom tsconfig file for processing typescript (see https://www.typescriptlang.org/docs/handbook/tsconfig-json.html) instead of the default:\n    {\n        \"compilerOptions\": {\n            \"noEmit\": true,\n            \"emitDecoratorMetadata\": true,\n            \"experimentalDecorators\": true,\n            \"target\": \"ES5\",\n            \"module\": \"CommonJS\",\n            \"strictNullChecks\": false,\n        }\n    }\n\n-j, --jsDoc <extended|none|basic>\n    none: Do not use JsDoc annotations.\n    basic: Read JsDoc annotations to provide schema properties.\n    extended (default): Also read @nullable, and @asType annotations.\n\n--unstable\n    Do not sort properties.\n\n--strict-tuples\n    Do not allow additional items on tuples.\n\n--no-top-ref\n    Do not create a top-level $ref definition.\n\n--no-type-check\n    Skip type checks for better performance.\n\n--no-ref-encode\n    Do not encode references. According to the standard, references must be valid URIs but some tools do not support encoded references.\n\n--validation-keywords\n    Provide additional validation keywords to include.\n\n-o, --out\n    Specify the output file path. Without this option, the generator logs the response in the console.\n\n--additional-properties <true|false>\n    Controls whether or not to allow additional properties for objects that have no index signature.\n\n    true: Additional properties are allowed\n    false (default): Additional properties are not allowed\n```\n\n## Current state\n\n-   `interface` types\n-   `enum` types\n-   `union`, `tuple`, `type[]` types\n-   `Date`, `RegExp` types\n-   `string`, `boolean`, `number` types\n-   `\"value\"`, `123`, `true`, `false`, `null`, `undefined` literals\n-   type aliases\n-   generics\n-   `typeof`\n-   `keyof`\n-   conditional types\n\n## Run locally\n\n`yarn --silent run run --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\n## Debug\n\n`yarn --silent run debug --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\nAnd connect via the debugger protocol.\n\n[AST Explorer](https://astexplorer.net/) is amazing for developers of this tool!\n\n## Publish\n\nPublishing is handled by a 2-branch [pre-release process](https://intuit.github.io/auto/docs/generated/shipit#next-branch-default), configured in `publish-auto.yml`. All changes should be based off the default `next` branch, and are published automatically.\n\n-   PRs made into the default branch are auto-deployed to the `next` pre-release tag on NPM. The result can be installed with `npm install ts-json-schema-generator@next`\n    -   When merging into `next`, please use the `squash and merge` strategy.\n-   To release a new stable version, open a PR from `next` into `stable` using this [compare link](https://github.com/vega/ts-json-schema-generator/compare/stable...next).\n    -   When merging from `next` into `stable`, please use the `create a merge commit` strategy.\n",
      "readmeFilename": "README.md",
      "gitHead": "09dac908d7d2686fc20763c57bc94c388f720b27",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.97.1--canary.1017.09dac90.0",
      "_nodeVersion": "14.18.1",
      "_npmVersion": "6.14.15",
      "dist": {
        "integrity": "sha512-roRmtvZomQ0jRAsBj1dwAZYsRck03mNI1UWMbx5ZD/2UvgiLo0WltriDU0r8VSfH+qP/LKEiGQapr5ELrFjs+w==",
        "shasum": "63e70b376cbc10407583ee609e20946f3e1a5024",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.97.1--canary.1017.09dac90.0.tgz",
        "fileCount": 610,
        "unpackedSize": 627884,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJhlFV+CRA9TVsSAnZWagAAmsEP/itrAttFrHfYmodJD2N4\nVlLfkQMgd5lppNeDCKcMxPC791qDxZIEs7K4JAVPg7yF8UDR3YOmYE2iX1t1\nhnHwGCgnU0vyMp/SvijN9BAT7wlH1Cu0b2/BrMG9GgvwLnGNgXty84oeF4By\nSCg1KeAirpb6stn8RI7YrF+ILz7POM0aErh3ABH/HHzdB8ku10LzkcWRtdIT\npyprf7oXUi/qoq1dBPNE4RoW6FArfU44trNNVifZm2VIyFJRdQ+LMPfBu5nv\nlDNGDyxBC1BImkznfVFztuDxRfBKv9u7jBrsmyZyGB+Uc56FFApRUnZnPFQd\nL8zwq8N+ZYq9Bt8BN0C83SshlhGYHG/Ys5kJcEIIKqistelVO9OVVbBf1dGf\nbt8YHGNAl1myAvB/rZnWqY7cgjU6GLkfuKIJuAwCRH8TgsF8Obn4+IFh6CFx\n22Y9HwHs+yadjiirWCgb64Lm/ghHJW+gNkHTyZRUPXLnrUv4vanosTWj6QFT\n6ihad/hYZu5yVN1rSWrjEikPFFCz3paylddqhg2Xqw+Liq1QvgC/iD8foDIv\nJyU7hiPXdA/dHMxb8ZmRNfj/Ncw+qJyBAysoP1PbxWCVY2Ah+KesXro4SPj9\np/P+m7/ebzQJl1vzpZ1vyf4vwpuiHv9YLF9TfwoP2gmNi6aGoRFbMEY+I6NI\n2kTG\r\n=VAF9\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIQD6s4/KKm422XkXri5wP2uZ5CemyzEthFCpC2XIHr47BAIgIma0ku5PwDal7IoevWnIIF3caeU8DppBjG/iSv9kavI="
          }
        ]
      },
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "maintainers": [
        {
          "name": "jheer",
          "email": "jeffrey.heer@gmail.com"
        },
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "kanitw",
          "email": "kanitw@gmail.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.97.1--canary.1017.09dac90.0_1637111165792_0.6748140529837157"
      },
      "_hasShrinkwrap": false
    },
    "0.97.1--canary.1017.09dac90.1": {
      "name": "ts-json-schema-generator",
      "version": "0.97.1--canary.1017.09dac90.1",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "MooYeol Prescott Lee",
          "email": "mooyoul@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=10.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.9",
        "commander": "^8.2.0",
        "glob": "^7.2.0",
        "safe-stable-stringify": "^2.2.0",
        "json5": "^2.2.0",
        "typescript": "~4.4.3"
      },
      "devDependencies": {
        "@auto-it/conventional-commits": "^10.32.1",
        "@auto-it/first-time-contributor": "^10.32.1",
        "@babel/core": "^7.15.8",
        "@babel/preset-env": "^7.15.8",
        "@babel/preset-typescript": "^7.15.0",
        "@types/glob": "^7.1.4",
        "@types/jest": "^27.0.2",
        "@types/node": "^16.10.3",
        "@typescript-eslint/eslint-plugin": "^4.33.0",
        "@typescript-eslint/parser": "^4.33.0",
        "ajv": "^8.6.3",
        "ajv-formats": "^2.1.1",
        "auto": "^10.32.1",
        "chai": "^4.3.4",
        "cross-env": "^7.0.3",
        "eslint": "^7.32.0",
        "eslint-config-prettier": "^8.3.0",
        "eslint-plugin-prettier": "^4.0.0",
        "jest": "^27.2.4",
        "jest-junit": "^13.0.0",
        "prettier": "^2.4.1",
        "ts-node": "^10.2.1",
        "vega": "^5.21.0",
        "vega-lite": "^5.1.1"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint \"{src,test,factory}/**/*.ts\"",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "cross-env FAST_TEST=1 jest test/ --verbose",
        "test:coverage": "yarn jest test/ --collectCoverage=true",
        "test:update": "cross-env UPDATE_SCHEMA=true yarn test:fast",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts",
        "release": "yarn build && auto shipit"
      },
      "readme": "# ts-json-schema-generator\n\n![Test](https://github.com/vega/ts-json-schema-generator/workflows/Test/badge.svg)\n[![codecov](https://codecov.io/gh/vega/ts-json-schema-generator/branch/master/graph/badge.svg)](https://codecov.io/gh/vega/ts-json-schema-generator)\n[![npm version](https://img.shields.io/npm/v/ts-json-schema-generator.svg)](https://www.npmjs.com/package/ts-json-schema-generator)\n\nExtended version of [https://github.com/xiag-ag/typescript-to-json-schema](https://github.com/xiag-ag/typescript-to-json-schema).\n\nInspired by [`YousefED/typescript-json-schema`](https://github.com/YousefED/typescript-json-schema). Here's the differences list:\n\n-   this implementation avoids the use of `typeChecker.getTypeAtLocation()` (so probably it keeps correct type aliases)\n-   processing AST and formatting JSON schema have been split into two independent steps\n-   not exported types, interfaces, enums are not exposed in the `definitions` section in the JSON schema\n\n## Contributors\n\nThis project is made possible by a [community of contributors](https://github.com/vega/ts-json-schema-generator/graphs/contributors). We welcome contributions of any kind (issues, code, documentation, examples, tests,...). Please read our [code of conduct](https://github.com/vega/vega/blob/master/CODE_OF_CONDUCT.md).\n\n## CLI Usage\n\n```bash\nnpm install --save ts-json-schema-generator\n./node_modules/.bin/ts-json-schema-generator --path 'my/project/**/*.ts' --type 'My.Type.Name'\n```\n\nNote that different platforms (e.g. Windows) may use different path separators so you may have to adjust the command above.\n\n## Programmatic Usage\n\n```js\n// main.js\n\nconst tsj = require(\"ts-json-schema-generator\");\nconst fs = require(\"fs\");\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst output_path = \"path/to/output/file\";\n\nconst schema = tsj.createGenerator(config).createSchema(config.type);\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\nRun the schema generator via `node main.js`.\n\n### Custom formatting\n\nExtending the built-in formatting is possible by creating a custom formatter and adding it to the main formatter:\n\n1. First we create a formatter, in this case for formatting function types:\n\n```ts\n// my-function-formatter.ts\nimport { BaseType, Definition, FunctionType, SubTypeFormatter } from \"ts-json-schema-generator\";\nimport ts from \"typescript\";\n\nexport class MyFunctionTypeFormatter implements SubTypeFormatter {\n    // You can skip this line if you don't need childTypeFormatter\n    public constructor(private childTypeFormatter: TypeFormatter) {}\n\n    public supportsType(type: FunctionType): boolean {\n        return type instanceof FunctionType;\n    }\n\n    public getDefinition(type: FunctionType): Definition {\n        // Return a custom schema for the function property.\n        return {\n            type: \"object\",\n            properties: {\n                isFunction: {\n                    type: \"boolean\",\n                    const: true,\n                },\n            },\n        };\n    }\n\n    // If this type does NOT HAVE children, generally all you need is:\n    public getChildren(type: FunctionType): BaseType[] {\n        return [];\n    }\n\n    // However, if children ARE supported, you'll need something similar to\n    // this (see src/TypeFormatter/{Array,Definition,etc}.ts for some examples):\n    public getChildren(type: FunctionType): BaseType[] {\n        return this.childTypeFormatter.getChildren(type.getType());\n    }\n}\n```\n\n2. Then we add the formatter as a child to the core formatter using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyFunctionTypeFormatter } from \"./my-function-formatter.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\n// We configure the formatter an add our custom formatter to it.\nconst formatter = createFormatter(config, (fmt, circularReferenceTypeFormatter) => {\n    // If your formatter DOES NOT support children, e.g. getChildren() { return [] }:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter());\n    // If your formatter DOES support children, you'll need this reference too:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter(circularReferenceTypeFormatter));\n});\n\nconst program = createProgram(config);\nconst parser = createParser(program, config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n### Custom parsing\n\nSimilar to custom formatting, extending the built-in parsing works practically the same way:\n\n1. First we create a parser, in this case for parsing construct types:\n\n```ts\n// my-constructor-parser.ts\nimport { Context, StringType, ReferenceType, BaseType, SubNodeParser } from \"ts-json-schema-generator\";\nimport ts from \"typescript\";\n\nexport class MyConstructorParser implements SubNodeParser {\n    supportsNode(node: ts.Node): boolean {\n        return node.kind === ts.SyntaxKind.ConstructorType;\n    }\n    createType(node: ts.Node, context: Context, reference?: ReferenceType): BaseType | undefined {\n        return new StringType(); // Treat constructors as strings in this example\n    }\n}\n```\n\n2. Then we add the parser as a child to the core parser using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyConstructorParser } from \"./my-constructor-parser.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst program = createProgram(config);\n\n// We configure the parser an add our custom parser to it.\nconst parser = createParser(program, config, (prs) => {\n    prs.addNodeParser(new MyConstructorParser());\n});\n\nconst formatter = createFormatter(config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n## Options\n\n```\n-p, --path 'index.ts'\n    The path to the TypeScript source file. If this is not provided, the type will be searched in the project specified in the `.tsconfig`.\n\n-t, --type 'My.Type.Name'\n    The type the generated schema will represent. If omitted, the generated schema will contain all\n    types found in the files matching path. The same is true if '*' is specified.\n\n-i, --id 'generatedSchemaId'\n    The `$id` of the generated schema. If omitted, there will be no `$id`.\n\n-e, --expose <all|none|export>\n    all: Create shared $ref definitions for all types.\n    none: Do not create shared $ref definitions.\n    export (default): Create shared $ref definitions only for exported types (not tagged as `@internal`).\n\n-f, --tsconfig 'my/project/tsconfig.json'\n    Use a custom tsconfig file for processing typescript (see https://www.typescriptlang.org/docs/handbook/tsconfig-json.html) instead of the default:\n    {\n        \"compilerOptions\": {\n            \"noEmit\": true,\n            \"emitDecoratorMetadata\": true,\n            \"experimentalDecorators\": true,\n            \"target\": \"ES5\",\n            \"module\": \"CommonJS\",\n            \"strictNullChecks\": false,\n        }\n    }\n\n-j, --jsDoc <extended|none|basic>\n    none: Do not use JsDoc annotations.\n    basic: Read JsDoc annotations to provide schema properties.\n    extended (default): Also read @nullable, and @asType annotations.\n\n--unstable\n    Do not sort properties.\n\n--strict-tuples\n    Do not allow additional items on tuples.\n\n--no-top-ref\n    Do not create a top-level $ref definition.\n\n--no-type-check\n    Skip type checks for better performance.\n\n--no-ref-encode\n    Do not encode references. According to the standard, references must be valid URIs but some tools do not support encoded references.\n\n--validation-keywords\n    Provide additional validation keywords to include.\n\n-o, --out\n    Specify the output file path. Without this option, the generator logs the response in the console.\n\n--additional-properties <true|false>\n    Controls whether or not to allow additional properties for objects that have no index signature.\n\n    true: Additional properties are allowed\n    false (default): Additional properties are not allowed\n```\n\n## Current state\n\n-   `interface` types\n-   `enum` types\n-   `union`, `tuple`, `type[]` types\n-   `Date`, `RegExp` types\n-   `string`, `boolean`, `number` types\n-   `\"value\"`, `123`, `true`, `false`, `null`, `undefined` literals\n-   type aliases\n-   generics\n-   `typeof`\n-   `keyof`\n-   conditional types\n\n## Run locally\n\n`yarn --silent run run --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\n## Debug\n\n`yarn --silent run debug --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\nAnd connect via the debugger protocol.\n\n[AST Explorer](https://astexplorer.net/) is amazing for developers of this tool!\n\n## Publish\n\nPublishing is handled by a 2-branch [pre-release process](https://intuit.github.io/auto/docs/generated/shipit#next-branch-default), configured in `publish-auto.yml`. All changes should be based off the default `next` branch, and are published automatically.\n\n-   PRs made into the default branch are auto-deployed to the `next` pre-release tag on NPM. The result can be installed with `npm install ts-json-schema-generator@next`\n    -   When merging into `next`, please use the `squash and merge` strategy.\n-   To release a new stable version, open a PR from `next` into `stable` using this [compare link](https://github.com/vega/ts-json-schema-generator/compare/stable...next).\n    -   When merging from `next` into `stable`, please use the `create a merge commit` strategy.\n",
      "readmeFilename": "README.md",
      "gitHead": "09dac908d7d2686fc20763c57bc94c388f720b27",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.97.1--canary.1017.09dac90.1",
      "_nodeVersion": "14.18.1",
      "_npmVersion": "6.14.15",
      "dist": {
        "integrity": "sha512-t8YtUKhDnFLc86gLMjkLOTk4p+j0KN3e9l4TKhDoH5vJ+buZsL1uMOZ/0N7RS4xNAWn5bK2RkfOc3aFe75dNUA==",
        "shasum": "bfa17a771fa13cd1bbe68372be4d9e3d53dbec37",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.97.1--canary.1017.09dac90.1.tgz",
        "fileCount": 610,
        "unpackedSize": 627884,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJhlFnACRA9TVsSAnZWagAA8W4P/2xfG0anu9FRFFg8X0Ja\nVbbzQma1BFBWesgel63GWi+ShjIAr9ydw342smMvac9vAMgASAgJSIUyHbx/\nmHS7rLFjpFuXT/zYF+BMof4DiA6Yc72QEw63h7RSsdkcglEFWr4mLuneRuQc\nEF+VwyNcIrKR16J9BXqUMaiRVhEMMT40iRcY8VGpTaNZQeZrGMSse6oozufK\nO9IjzXdxUHqREd+LzITHSgX9i0Z/uM3WUcakZBeFb/Y1tP3DP9g+x+fu1aWB\nooJ7yhZKf+EckVcNprQSDzAkplAGB5MW0UPaqjlG/lqsOCiM9ESeAFa6rXKd\nlqAtP9NJ5crqTJkee91m/u4jbpbno8lUxLeWyAfqv/wb6n3B6S6a9cDiUu5s\nUG/TXkElG6koIPx1wJwrOOSOt95oOeMuOc8eeYfvonW5R1YDx29xS9YwVscl\n3ZV2DSpJ8BjCWz7S9OajUM3q+nBjfqplzF8ufcMV13iMZ3eWQDL3PsdomVfv\n5PTzkmrnPHEj5KHcSLco/ZpzeSdA5anQJLZH85vAy859PxO+iQkAMh+Cy6OB\nGzC4R2ieNVFVHK9HFNKptZDZ07oMX8sXKkGiCoW/qTo4qfbkaKhzSQukZfYD\nMZgi0s5ZCtJL0bcjOGXaAxQ8iKZa0vl6eRT08bQCALGuFatXeDc2sBqWXpAL\npV/M\r\n=tM33\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEQCIGEBMWqSeKeKiuxPbhyLGvH3tV7N2BiQS+xQdQHwsdO8AiB+cJ8E15rSRp16BzsZo5B0kwfGeEDeEzCo/Zr8wCqgcw=="
          }
        ]
      },
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "maintainers": [
        {
          "name": "jheer",
          "email": "jeffrey.heer@gmail.com"
        },
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "kanitw",
          "email": "kanitw@gmail.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.97.1--canary.1017.09dac90.1_1637112256328_0.6217347487345593"
      },
      "_hasShrinkwrap": false
    },
    "0.97.1--canary.1017.f5848fa.0": {
      "name": "ts-json-schema-generator",
      "version": "0.97.1--canary.1017.f5848fa.0",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "MooYeol Prescott Lee",
          "email": "mooyoul@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=10.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.9",
        "commander": "^8.2.0",
        "glob": "^7.2.0",
        "safe-stable-stringify": "^2.2.0",
        "json5": "^2.2.0",
        "typescript": "~4.4.3"
      },
      "devDependencies": {
        "@auto-it/conventional-commits": "^10.32.1",
        "@auto-it/first-time-contributor": "^10.32.1",
        "@babel/core": "^7.15.8",
        "@babel/preset-env": "^7.15.8",
        "@babel/preset-typescript": "^7.15.0",
        "@types/glob": "^7.1.4",
        "@types/jest": "^27.0.2",
        "@types/node": "^16.10.3",
        "@typescript-eslint/eslint-plugin": "^4.33.0",
        "@typescript-eslint/parser": "^4.33.0",
        "ajv": "^8.6.3",
        "ajv-formats": "^2.1.1",
        "auto": "^10.32.1",
        "chai": "^4.3.4",
        "cross-env": "^7.0.3",
        "eslint": "^7.32.0",
        "eslint-config-prettier": "^8.3.0",
        "eslint-plugin-prettier": "^4.0.0",
        "jest": "^27.2.4",
        "jest-junit": "^13.0.0",
        "prettier": "^2.4.1",
        "ts-node": "^10.2.1",
        "vega": "^5.21.0",
        "vega-lite": "^5.1.1"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint \"{src,test,factory}/**/*.ts\"",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "cross-env FAST_TEST=1 jest test/ --verbose",
        "test:coverage": "yarn jest test/ --collectCoverage=true",
        "test:update": "cross-env UPDATE_SCHEMA=true yarn test:fast",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts",
        "release": "yarn build && auto shipit"
      },
      "readme": "# ts-json-schema-generator\n\n![Test](https://github.com/vega/ts-json-schema-generator/workflows/Test/badge.svg)\n[![codecov](https://codecov.io/gh/vega/ts-json-schema-generator/branch/master/graph/badge.svg)](https://codecov.io/gh/vega/ts-json-schema-generator)\n[![npm version](https://img.shields.io/npm/v/ts-json-schema-generator.svg)](https://www.npmjs.com/package/ts-json-schema-generator)\n\nExtended version of [https://github.com/xiag-ag/typescript-to-json-schema](https://github.com/xiag-ag/typescript-to-json-schema).\n\nInspired by [`YousefED/typescript-json-schema`](https://github.com/YousefED/typescript-json-schema). Here's the differences list:\n\n-   this implementation avoids the use of `typeChecker.getTypeAtLocation()` (so probably it keeps correct type aliases)\n-   processing AST and formatting JSON schema have been split into two independent steps\n-   not exported types, interfaces, enums are not exposed in the `definitions` section in the JSON schema\n\n## Contributors\n\nThis project is made possible by a [community of contributors](https://github.com/vega/ts-json-schema-generator/graphs/contributors). We welcome contributions of any kind (issues, code, documentation, examples, tests,...). Please read our [code of conduct](https://github.com/vega/vega/blob/master/CODE_OF_CONDUCT.md).\n\n## CLI Usage\n\n```bash\nnpm install --save ts-json-schema-generator\n./node_modules/.bin/ts-json-schema-generator --path 'my/project/**/*.ts' --type 'My.Type.Name'\n```\n\nNote that different platforms (e.g. Windows) may use different path separators so you may have to adjust the command above.\n\n## Programmatic Usage\n\n```js\n// main.js\n\nconst tsj = require(\"ts-json-schema-generator\");\nconst fs = require(\"fs\");\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst output_path = \"path/to/output/file\";\n\nconst schema = tsj.createGenerator(config).createSchema(config.type);\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\nRun the schema generator via `node main.js`.\n\n### Custom formatting\n\nExtending the built-in formatting is possible by creating a custom formatter and adding it to the main formatter:\n\n1. First we create a formatter, in this case for formatting function types:\n\n```ts\n// my-function-formatter.ts\nimport { BaseType, Definition, FunctionType, SubTypeFormatter } from \"ts-json-schema-generator\";\nimport ts from \"typescript\";\n\nexport class MyFunctionTypeFormatter implements SubTypeFormatter {\n    // You can skip this line if you don't need childTypeFormatter\n    public constructor(private childTypeFormatter: TypeFormatter) {}\n\n    public supportsType(type: FunctionType): boolean {\n        return type instanceof FunctionType;\n    }\n\n    public getDefinition(type: FunctionType): Definition {\n        // Return a custom schema for the function property.\n        return {\n            type: \"object\",\n            properties: {\n                isFunction: {\n                    type: \"boolean\",\n                    const: true,\n                },\n            },\n        };\n    }\n\n    // If this type does NOT HAVE children, generally all you need is:\n    public getChildren(type: FunctionType): BaseType[] {\n        return [];\n    }\n\n    // However, if children ARE supported, you'll need something similar to\n    // this (see src/TypeFormatter/{Array,Definition,etc}.ts for some examples):\n    public getChildren(type: FunctionType): BaseType[] {\n        return this.childTypeFormatter.getChildren(type.getType());\n    }\n}\n```\n\n2. Then we add the formatter as a child to the core formatter using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyFunctionTypeFormatter } from \"./my-function-formatter.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\n// We configure the formatter an add our custom formatter to it.\nconst formatter = createFormatter(config, (fmt, circularReferenceTypeFormatter) => {\n    // If your formatter DOES NOT support children, e.g. getChildren() { return [] }:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter());\n    // If your formatter DOES support children, you'll need this reference too:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter(circularReferenceTypeFormatter));\n});\n\nconst program = createProgram(config);\nconst parser = createParser(program, config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n### Custom parsing\n\nSimilar to custom formatting, extending the built-in parsing works practically the same way:\n\n1. First we create a parser, in this case for parsing construct types:\n\n```ts\n// my-constructor-parser.ts\nimport { Context, StringType, ReferenceType, BaseType, SubNodeParser } from \"ts-json-schema-generator\";\nimport ts from \"typescript\";\n\nexport class MyConstructorParser implements SubNodeParser {\n    supportsNode(node: ts.Node): boolean {\n        return node.kind === ts.SyntaxKind.ConstructorType;\n    }\n    createType(node: ts.Node, context: Context, reference?: ReferenceType): BaseType | undefined {\n        return new StringType(); // Treat constructors as strings in this example\n    }\n}\n```\n\n2. Then we add the parser as a child to the core parser using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyConstructorParser } from \"./my-constructor-parser.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst program = createProgram(config);\n\n// We configure the parser an add our custom parser to it.\nconst parser = createParser(program, config, (prs) => {\n    prs.addNodeParser(new MyConstructorParser());\n});\n\nconst formatter = createFormatter(config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n## Options\n\n```\n-p, --path 'index.ts'\n    The path to the TypeScript source file. If this is not provided, the type will be searched in the project specified in the `.tsconfig`.\n\n-t, --type 'My.Type.Name'\n    The type the generated schema will represent. If omitted, the generated schema will contain all\n    types found in the files matching path. The same is true if '*' is specified.\n\n-i, --id 'generatedSchemaId'\n    The `$id` of the generated schema. If omitted, there will be no `$id`.\n\n-e, --expose <all|none|export>\n    all: Create shared $ref definitions for all types.\n    none: Do not create shared $ref definitions.\n    export (default): Create shared $ref definitions only for exported types (not tagged as `@internal`).\n\n-f, --tsconfig 'my/project/tsconfig.json'\n    Use a custom tsconfig file for processing typescript (see https://www.typescriptlang.org/docs/handbook/tsconfig-json.html) instead of the default:\n    {\n        \"compilerOptions\": {\n            \"noEmit\": true,\n            \"emitDecoratorMetadata\": true,\n            \"experimentalDecorators\": true,\n            \"target\": \"ES5\",\n            \"module\": \"CommonJS\",\n            \"strictNullChecks\": false,\n        }\n    }\n\n-j, --jsDoc <extended|none|basic>\n    none: Do not use JsDoc annotations.\n    basic: Read JsDoc annotations to provide schema properties.\n    extended (default): Also read @nullable, and @asType annotations.\n\n--unstable\n    Do not sort properties.\n\n--strict-tuples\n    Do not allow additional items on tuples.\n\n--no-top-ref\n    Do not create a top-level $ref definition.\n\n--no-type-check\n    Skip type checks for better performance.\n\n--no-ref-encode\n    Do not encode references. According to the standard, references must be valid URIs but some tools do not support encoded references.\n\n--validation-keywords\n    Provide additional validation keywords to include.\n\n-o, --out\n    Specify the output file path. Without this option, the generator logs the response in the console.\n\n--additional-properties <true|false>\n    Controls whether or not to allow additional properties for objects that have no index signature.\n\n    true: Additional properties are allowed\n    false (default): Additional properties are not allowed\n```\n\n## Current state\n\n-   `interface` types\n-   `enum` types\n-   `union`, `tuple`, `type[]` types\n-   `Date`, `RegExp` types\n-   `string`, `boolean`, `number` types\n-   `\"value\"`, `123`, `true`, `false`, `null`, `undefined` literals\n-   type aliases\n-   generics\n-   `typeof`\n-   `keyof`\n-   conditional types\n\n## Run locally\n\n`yarn --silent run run --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\n## Debug\n\n`yarn --silent run debug --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\nAnd connect via the debugger protocol.\n\n[AST Explorer](https://astexplorer.net/) is amazing for developers of this tool!\n\n## Publish\n\nPublishing is handled by a 2-branch [pre-release process](https://intuit.github.io/auto/docs/generated/shipit#next-branch-default), configured in `publish-auto.yml`. All changes should be based off the default `next` branch, and are published automatically.\n\n-   PRs made into the default branch are auto-deployed to the `next` pre-release tag on NPM. The result can be installed with `npm install ts-json-schema-generator@next`\n    -   When merging into `next`, please use the `squash and merge` strategy.\n-   To release a new stable version, open a PR from `next` into `stable` using this [compare link](https://github.com/vega/ts-json-schema-generator/compare/stable...next).\n    -   When merging from `next` into `stable`, please use the `create a merge commit` strategy.\n",
      "readmeFilename": "README.md",
      "gitHead": "f5848fa95efb624c89ec06ab2a207296e1bc211f",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.97.1--canary.1017.f5848fa.0",
      "_nodeVersion": "14.18.1",
      "_npmVersion": "6.14.15",
      "dist": {
        "integrity": "sha512-60KmuMRvVCpvTSqRPX2/aSK+i0LgVA8Vt30rt26g/76csumGKzkoG7dth5tUZIjvMN3AkLIbRhz4X3p6IaSzPA==",
        "shasum": "d10c9b4ba47cd51c0266e7016d01f0ec52994cf6",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.97.1--canary.1017.f5848fa.0.tgz",
        "fileCount": 610,
        "unpackedSize": 627884,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJhmBq8CRA9TVsSAnZWagAA6vIP/3nOpdH6zVHoYGM3MWNL\nkBhhyx1FFfWUKdvZMSuoiEZ3OdoQJNU831EA+7Lr1SxwFYSz9X1P9bEIvNSx\nxRkaN2bZ79HhvT7vPLCqaTaKvhSde7QbiUMkeWyLMXUM6qLDvRXgNuzFdXsN\n9YDfQX+WPdCRGaFtXonxGVtzFGVpULgXu1W/nwlMTmlvoZhz8DhHYu2XQNBw\nBObNadudxyhmnIhs/4+RankdfrmP3uIsz2oO82q8tbFtxP1YuYaqBU5XLU0p\nfAWq39d6oq9fw0FPpsDHyP+HrUdqPqWk2LoanC2JkOsCdqk2j37WeYYA4kZ8\nBidbBxjvj5sBiYFSIPKp4e5mBRDjDfxNesvFumSC0wWLytU6hcvK6Lx4smnt\nju40KzfUVL4tEhBHIHu0j5L8D0Nq+5X257kygPttMeu43cFeWIIGnT3EzpMo\nQeTv+yKYHGodaO1ljPplg8VXO8EMJGB+SB0zdMraJB1KxABG8luq/YZMLGHr\nfoTvRPJY88T4AsVzjGAnLRZ9KL8Fo0Dt+kdYndH02o1WzbmyFKgsIr9Dzbi2\nVEulmjEJuxLK43jl/7bDzP3Fg2023fz/f0O+okDZlnlbzchcnXLPGMxqRMu2\nELlCMuvDxVYDx588gY5m7nVb/0HxoUGwUQFMGJSYryV4b1Rvw0d551yCz/Ml\njm7M\r\n=au6R\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIGOJHfKzsvyFrB9IA+LGqJ5h9o2WV2tZLqZkoxDQsZuxAiEA0Ih8++P12umfrLQmyMqj3ilwyt1KPz3O7cuoYXos5Tg="
          }
        ]
      },
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "maintainers": [
        {
          "name": "jheer",
          "email": "jeffrey.heer@gmail.com"
        },
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "kanitw",
          "email": "kanitw@gmail.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.97.1--canary.1017.f5848fa.0_1637358268757_0.8329294970247718"
      },
      "_hasShrinkwrap": false
    },
    "0.97.1--canary.1017.f5848fa.1": {
      "name": "ts-json-schema-generator",
      "version": "0.97.1--canary.1017.f5848fa.1",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "MooYeol Prescott Lee",
          "email": "mooyoul@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=10.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.9",
        "commander": "^8.2.0",
        "glob": "^7.2.0",
        "safe-stable-stringify": "^2.2.0",
        "json5": "^2.2.0",
        "typescript": "~4.4.3"
      },
      "devDependencies": {
        "@auto-it/conventional-commits": "^10.32.1",
        "@auto-it/first-time-contributor": "^10.32.1",
        "@babel/core": "^7.15.8",
        "@babel/preset-env": "^7.15.8",
        "@babel/preset-typescript": "^7.15.0",
        "@types/glob": "^7.1.4",
        "@types/jest": "^27.0.2",
        "@types/node": "^16.10.3",
        "@typescript-eslint/eslint-plugin": "^4.33.0",
        "@typescript-eslint/parser": "^4.33.0",
        "ajv": "^8.6.3",
        "ajv-formats": "^2.1.1",
        "auto": "^10.32.1",
        "chai": "^4.3.4",
        "cross-env": "^7.0.3",
        "eslint": "^7.32.0",
        "eslint-config-prettier": "^8.3.0",
        "eslint-plugin-prettier": "^4.0.0",
        "jest": "^27.2.4",
        "jest-junit": "^13.0.0",
        "prettier": "^2.4.1",
        "ts-node": "^10.2.1",
        "vega": "^5.21.0",
        "vega-lite": "^5.1.1"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint \"{src,test,factory}/**/*.ts\"",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "cross-env FAST_TEST=1 jest test/ --verbose",
        "test:coverage": "yarn jest test/ --collectCoverage=true",
        "test:update": "cross-env UPDATE_SCHEMA=true yarn test:fast",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts",
        "release": "yarn build && auto shipit"
      },
      "readme": "# ts-json-schema-generator\n\n![Test](https://github.com/vega/ts-json-schema-generator/workflows/Test/badge.svg)\n[![codecov](https://codecov.io/gh/vega/ts-json-schema-generator/branch/master/graph/badge.svg)](https://codecov.io/gh/vega/ts-json-schema-generator)\n[![npm version](https://img.shields.io/npm/v/ts-json-schema-generator.svg)](https://www.npmjs.com/package/ts-json-schema-generator)\n\nExtended version of [https://github.com/xiag-ag/typescript-to-json-schema](https://github.com/xiag-ag/typescript-to-json-schema).\n\nInspired by [`YousefED/typescript-json-schema`](https://github.com/YousefED/typescript-json-schema). Here's the differences list:\n\n-   this implementation avoids the use of `typeChecker.getTypeAtLocation()` (so probably it keeps correct type aliases)\n-   processing AST and formatting JSON schema have been split into two independent steps\n-   not exported types, interfaces, enums are not exposed in the `definitions` section in the JSON schema\n\n## Contributors\n\nThis project is made possible by a [community of contributors](https://github.com/vega/ts-json-schema-generator/graphs/contributors). We welcome contributions of any kind (issues, code, documentation, examples, tests,...). Please read our [code of conduct](https://github.com/vega/vega/blob/master/CODE_OF_CONDUCT.md).\n\n## CLI Usage\n\n```bash\nnpm install --save ts-json-schema-generator\n./node_modules/.bin/ts-json-schema-generator --path 'my/project/**/*.ts' --type 'My.Type.Name'\n```\n\nNote that different platforms (e.g. Windows) may use different path separators so you may have to adjust the command above.\n\n## Programmatic Usage\n\n```js\n// main.js\n\nconst tsj = require(\"ts-json-schema-generator\");\nconst fs = require(\"fs\");\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst output_path = \"path/to/output/file\";\n\nconst schema = tsj.createGenerator(config).createSchema(config.type);\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\nRun the schema generator via `node main.js`.\n\n### Custom formatting\n\nExtending the built-in formatting is possible by creating a custom formatter and adding it to the main formatter:\n\n1. First we create a formatter, in this case for formatting function types:\n\n```ts\n// my-function-formatter.ts\nimport { BaseType, Definition, FunctionType, SubTypeFormatter } from \"ts-json-schema-generator\";\nimport ts from \"typescript\";\n\nexport class MyFunctionTypeFormatter implements SubTypeFormatter {\n    // You can skip this line if you don't need childTypeFormatter\n    public constructor(private childTypeFormatter: TypeFormatter) {}\n\n    public supportsType(type: FunctionType): boolean {\n        return type instanceof FunctionType;\n    }\n\n    public getDefinition(type: FunctionType): Definition {\n        // Return a custom schema for the function property.\n        return {\n            type: \"object\",\n            properties: {\n                isFunction: {\n                    type: \"boolean\",\n                    const: true,\n                },\n            },\n        };\n    }\n\n    // If this type does NOT HAVE children, generally all you need is:\n    public getChildren(type: FunctionType): BaseType[] {\n        return [];\n    }\n\n    // However, if children ARE supported, you'll need something similar to\n    // this (see src/TypeFormatter/{Array,Definition,etc}.ts for some examples):\n    public getChildren(type: FunctionType): BaseType[] {\n        return this.childTypeFormatter.getChildren(type.getType());\n    }\n}\n```\n\n2. Then we add the formatter as a child to the core formatter using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyFunctionTypeFormatter } from \"./my-function-formatter.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\n// We configure the formatter an add our custom formatter to it.\nconst formatter = createFormatter(config, (fmt, circularReferenceTypeFormatter) => {\n    // If your formatter DOES NOT support children, e.g. getChildren() { return [] }:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter());\n    // If your formatter DOES support children, you'll need this reference too:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter(circularReferenceTypeFormatter));\n});\n\nconst program = createProgram(config);\nconst parser = createParser(program, config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n### Custom parsing\n\nSimilar to custom formatting, extending the built-in parsing works practically the same way:\n\n1. First we create a parser, in this case for parsing construct types:\n\n```ts\n// my-constructor-parser.ts\nimport { Context, StringType, ReferenceType, BaseType, SubNodeParser } from \"ts-json-schema-generator\";\nimport ts from \"typescript\";\n\nexport class MyConstructorParser implements SubNodeParser {\n    supportsNode(node: ts.Node): boolean {\n        return node.kind === ts.SyntaxKind.ConstructorType;\n    }\n    createType(node: ts.Node, context: Context, reference?: ReferenceType): BaseType | undefined {\n        return new StringType(); // Treat constructors as strings in this example\n    }\n}\n```\n\n2. Then we add the parser as a child to the core parser using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyConstructorParser } from \"./my-constructor-parser.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst program = createProgram(config);\n\n// We configure the parser an add our custom parser to it.\nconst parser = createParser(program, config, (prs) => {\n    prs.addNodeParser(new MyConstructorParser());\n});\n\nconst formatter = createFormatter(config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n## Options\n\n```\n-p, --path 'index.ts'\n    The path to the TypeScript source file. If this is not provided, the type will be searched in the project specified in the `.tsconfig`.\n\n-t, --type 'My.Type.Name'\n    The type the generated schema will represent. If omitted, the generated schema will contain all\n    types found in the files matching path. The same is true if '*' is specified.\n\n-i, --id 'generatedSchemaId'\n    The `$id` of the generated schema. If omitted, there will be no `$id`.\n\n-e, --expose <all|none|export>\n    all: Create shared $ref definitions for all types.\n    none: Do not create shared $ref definitions.\n    export (default): Create shared $ref definitions only for exported types (not tagged as `@internal`).\n\n-f, --tsconfig 'my/project/tsconfig.json'\n    Use a custom tsconfig file for processing typescript (see https://www.typescriptlang.org/docs/handbook/tsconfig-json.html) instead of the default:\n    {\n        \"compilerOptions\": {\n            \"noEmit\": true,\n            \"emitDecoratorMetadata\": true,\n            \"experimentalDecorators\": true,\n            \"target\": \"ES5\",\n            \"module\": \"CommonJS\",\n            \"strictNullChecks\": false,\n        }\n    }\n\n-j, --jsDoc <extended|none|basic>\n    none: Do not use JsDoc annotations.\n    basic: Read JsDoc annotations to provide schema properties.\n    extended (default): Also read @nullable, and @asType annotations.\n\n--unstable\n    Do not sort properties.\n\n--strict-tuples\n    Do not allow additional items on tuples.\n\n--no-top-ref\n    Do not create a top-level $ref definition.\n\n--no-type-check\n    Skip type checks for better performance.\n\n--no-ref-encode\n    Do not encode references. According to the standard, references must be valid URIs but some tools do not support encoded references.\n\n--validation-keywords\n    Provide additional validation keywords to include.\n\n-o, --out\n    Specify the output file path. Without this option, the generator logs the response in the console.\n\n--additional-properties <true|false>\n    Controls whether or not to allow additional properties for objects that have no index signature.\n\n    true: Additional properties are allowed\n    false (default): Additional properties are not allowed\n```\n\n## Current state\n\n-   `interface` types\n-   `enum` types\n-   `union`, `tuple`, `type[]` types\n-   `Date`, `RegExp` types\n-   `string`, `boolean`, `number` types\n-   `\"value\"`, `123`, `true`, `false`, `null`, `undefined` literals\n-   type aliases\n-   generics\n-   `typeof`\n-   `keyof`\n-   conditional types\n\n## Run locally\n\n`yarn --silent run run --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\n## Debug\n\n`yarn --silent run debug --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\nAnd connect via the debugger protocol.\n\n[AST Explorer](https://astexplorer.net/) is amazing for developers of this tool!\n\n## Publish\n\nPublishing is handled by a 2-branch [pre-release process](https://intuit.github.io/auto/docs/generated/shipit#next-branch-default), configured in `publish-auto.yml`. All changes should be based off the default `next` branch, and are published automatically.\n\n-   PRs made into the default branch are auto-deployed to the `next` pre-release tag on NPM. The result can be installed with `npm install ts-json-schema-generator@next`\n    -   When merging into `next`, please use the `squash and merge` strategy.\n-   To release a new stable version, open a PR from `next` into `stable` using this [compare link](https://github.com/vega/ts-json-schema-generator/compare/stable...next).\n    -   When merging from `next` into `stable`, please use the `create a merge commit` strategy.\n",
      "readmeFilename": "README.md",
      "gitHead": "f5848fa95efb624c89ec06ab2a207296e1bc211f",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.97.1--canary.1017.f5848fa.1",
      "_nodeVersion": "14.18.1",
      "_npmVersion": "6.14.15",
      "dist": {
        "integrity": "sha512-NkVXFLY9C3zMKFYNe56ge/YTexk52d6xmS7JjxO6VN0+jbuITJxxLFIXarDU44ZZl6EmGdj77dbI9fcVN5w2gw==",
        "shasum": "f1e5155c839b68bc0703f075e4e1f2a2af7299c2",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.97.1--canary.1017.f5848fa.1.tgz",
        "fileCount": 610,
        "unpackedSize": 627884,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJhmBu7CRA9TVsSAnZWagAAXdUP+gKZU9/MbYSKsZTr8YZ6\nNQCp4imCLDMAKyEJPILQT/iwoAvEZ3KBcgiSig136qKEiAPwGQXPyyyDAvzw\n0OopfYtjLVHMHiwqnARv77K4BY5jxXlR/MKF+wv+NecFDh/ce2qwCZE6WY5t\neXn+oa3uxIwz7Qla9Qt+OZexzkXSJNRo7rXFgt86PEvOC5rtC/bOrf8KujVz\nQDzc2tZpaSepMLreLBIBX6URtecRzt/wahmJteAAPdMv2R91XZSBo/E3Xah4\nbU/hjOHJAVGc31s2HPGWf39bAJzgi6hRPLgLRxEZnn163YG6FUvZ+EA5z8tp\noZuRX1ZQzU1/iwm7jKiBYG5cMAevLIRHPQ+jU1SVqsZHXcsF55xVFjkYVKqA\nh3FSBBsR/2pjnvs2qxKTkW7FCUXCZhB0pL42d+6r/M2kb0Ai7JaMhpPbCpmi\nU3+NuDdQn5LEoqMCMI6zVBTED4BPQSufOLneWTR1BJ01pgv3V/mVLvnRaJ5v\nRFBwGkjF5mkke6yKykAj1upzSqZId6uRfYM6gaBurGQ+JE7y5bfRPMXDkzyt\n39dXmJWAXuMxsf6pwRNQxMbvwjmBJrFCOVVoruOok2mAzf5PemRTJMGUIUAh\nCGn3KLrPeKOyUb2ztMlYv7cIYkoaiVN1ts3NFy4PMP00pJ+UAzavY/NuoOWb\nCt4J\r\n=5mac\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEQCIF7VqNubagYBGZ7rr6zyei7Rds7ONHWGYlP+xgUIWuo9AiAeuGRocU1sjHYk9ODX3uANG8B1G7GL46Qv6lVYhMt3Gg=="
          }
        ]
      },
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "maintainers": [
        {
          "name": "jheer",
          "email": "jeffrey.heer@gmail.com"
        },
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "kanitw",
          "email": "kanitw@gmail.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.97.1--canary.1017.f5848fa.1_1637358523197_0.5615283872701351"
      },
      "_hasShrinkwrap": false
    },
    "0.97.1--canary.1017.a612074.0": {
      "name": "ts-json-schema-generator",
      "version": "0.97.1--canary.1017.a612074.0",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "MooYeol Prescott Lee",
          "email": "mooyoul@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=10.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.9",
        "commander": "^8.2.0",
        "glob": "^7.2.0",
        "safe-stable-stringify": "^2.2.0",
        "json5": "^2.2.0",
        "typescript": "~4.4.3"
      },
      "devDependencies": {
        "@auto-it/conventional-commits": "^10.32.1",
        "@auto-it/first-time-contributor": "^10.32.1",
        "@babel/core": "^7.15.8",
        "@babel/preset-env": "^7.15.8",
        "@babel/preset-typescript": "^7.15.0",
        "@types/glob": "^7.1.4",
        "@types/jest": "^27.0.2",
        "@types/node": "^16.10.3",
        "@typescript-eslint/eslint-plugin": "^4.33.0",
        "@typescript-eslint/parser": "^4.33.0",
        "ajv": "^8.6.3",
        "ajv-formats": "^2.1.1",
        "auto": "^10.32.1",
        "chai": "^4.3.4",
        "cross-env": "^7.0.3",
        "eslint": "^7.32.0",
        "eslint-config-prettier": "^8.3.0",
        "eslint-plugin-prettier": "^4.0.0",
        "jest": "^27.2.4",
        "jest-junit": "^13.0.0",
        "prettier": "^2.4.1",
        "ts-node": "^10.2.1",
        "vega": "^5.21.0",
        "vega-lite": "^5.1.1"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint \"{src,test,factory}/**/*.ts\"",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "cross-env FAST_TEST=1 jest test/ --verbose",
        "test:coverage": "yarn jest test/ --collectCoverage=true",
        "test:update": "cross-env UPDATE_SCHEMA=true yarn test:fast",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts",
        "release": "yarn build && auto shipit"
      },
      "readme": "# ts-json-schema-generator\n\n![Test](https://github.com/vega/ts-json-schema-generator/workflows/Test/badge.svg)\n[![codecov](https://codecov.io/gh/vega/ts-json-schema-generator/branch/master/graph/badge.svg)](https://codecov.io/gh/vega/ts-json-schema-generator)\n[![npm version](https://img.shields.io/npm/v/ts-json-schema-generator.svg)](https://www.npmjs.com/package/ts-json-schema-generator)\n\nExtended version of [https://github.com/xiag-ag/typescript-to-json-schema](https://github.com/xiag-ag/typescript-to-json-schema).\n\nInspired by [`YousefED/typescript-json-schema`](https://github.com/YousefED/typescript-json-schema). Here's the differences list:\n\n-   this implementation avoids the use of `typeChecker.getTypeAtLocation()` (so probably it keeps correct type aliases)\n-   processing AST and formatting JSON schema have been split into two independent steps\n-   not exported types, interfaces, enums are not exposed in the `definitions` section in the JSON schema\n\n## Contributors\n\nThis project is made possible by a [community of contributors](https://github.com/vega/ts-json-schema-generator/graphs/contributors). We welcome contributions of any kind (issues, code, documentation, examples, tests,...). Please read our [code of conduct](https://github.com/vega/vega/blob/master/CODE_OF_CONDUCT.md).\n\n## CLI Usage\n\n```bash\nnpm install --save ts-json-schema-generator\n./node_modules/.bin/ts-json-schema-generator --path 'my/project/**/*.ts' --type 'My.Type.Name'\n```\n\nNote that different platforms (e.g. Windows) may use different path separators so you may have to adjust the command above.\n\n## Programmatic Usage\n\n```js\n// main.js\n\nconst tsj = require(\"ts-json-schema-generator\");\nconst fs = require(\"fs\");\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst output_path = \"path/to/output/file\";\n\nconst schema = tsj.createGenerator(config).createSchema(config.type);\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\nRun the schema generator via `node main.js`.\n\n### Custom formatting\n\nExtending the built-in formatting is possible by creating a custom formatter and adding it to the main formatter:\n\n1. First we create a formatter, in this case for formatting function types:\n\n```ts\n// my-function-formatter.ts\nimport { BaseType, Definition, FunctionType, SubTypeFormatter } from \"ts-json-schema-generator\";\nimport ts from \"typescript\";\n\nexport class MyFunctionTypeFormatter implements SubTypeFormatter {\n    // You can skip this line if you don't need childTypeFormatter\n    public constructor(private childTypeFormatter: TypeFormatter) {}\n\n    public supportsType(type: FunctionType): boolean {\n        return type instanceof FunctionType;\n    }\n\n    public getDefinition(type: FunctionType): Definition {\n        // Return a custom schema for the function property.\n        return {\n            type: \"object\",\n            properties: {\n                isFunction: {\n                    type: \"boolean\",\n                    const: true,\n                },\n            },\n        };\n    }\n\n    // If this type does NOT HAVE children, generally all you need is:\n    public getChildren(type: FunctionType): BaseType[] {\n        return [];\n    }\n\n    // However, if children ARE supported, you'll need something similar to\n    // this (see src/TypeFormatter/{Array,Definition,etc}.ts for some examples):\n    public getChildren(type: FunctionType): BaseType[] {\n        return this.childTypeFormatter.getChildren(type.getType());\n    }\n}\n```\n\n2. Then we add the formatter as a child to the core formatter using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyFunctionTypeFormatter } from \"./my-function-formatter.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\n// We configure the formatter an add our custom formatter to it.\nconst formatter = createFormatter(config, (fmt, circularReferenceTypeFormatter) => {\n    // If your formatter DOES NOT support children, e.g. getChildren() { return [] }:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter());\n    // If your formatter DOES support children, you'll need this reference too:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter(circularReferenceTypeFormatter));\n});\n\nconst program = createProgram(config);\nconst parser = createParser(program, config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n### Custom parsing\n\nSimilar to custom formatting, extending the built-in parsing works practically the same way:\n\n1. First we create a parser, in this case for parsing construct types:\n\n```ts\n// my-constructor-parser.ts\nimport { Context, StringType, ReferenceType, BaseType, SubNodeParser } from \"ts-json-schema-generator\";\nimport ts from \"typescript\";\n\nexport class MyConstructorParser implements SubNodeParser {\n    supportsNode(node: ts.Node): boolean {\n        return node.kind === ts.SyntaxKind.ConstructorType;\n    }\n    createType(node: ts.Node, context: Context, reference?: ReferenceType): BaseType | undefined {\n        return new StringType(); // Treat constructors as strings in this example\n    }\n}\n```\n\n2. Then we add the parser as a child to the core parser using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyConstructorParser } from \"./my-constructor-parser.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst program = createProgram(config);\n\n// We configure the parser an add our custom parser to it.\nconst parser = createParser(program, config, (prs) => {\n    prs.addNodeParser(new MyConstructorParser());\n});\n\nconst formatter = createFormatter(config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n## Options\n\n```\n-p, --path 'index.ts'\n    The path to the TypeScript source file. If this is not provided, the type will be searched in the project specified in the `.tsconfig`.\n\n-t, --type 'My.Type.Name'\n    The type the generated schema will represent. If omitted, the generated schema will contain all\n    types found in the files matching path. The same is true if '*' is specified.\n\n-i, --id 'generatedSchemaId'\n    The `$id` of the generated schema. If omitted, there will be no `$id`.\n\n-e, --expose <all|none|export>\n    all: Create shared $ref definitions for all types.\n    none: Do not create shared $ref definitions.\n    export (default): Create shared $ref definitions only for exported types (not tagged as `@internal`).\n\n-f, --tsconfig 'my/project/tsconfig.json'\n    Use a custom tsconfig file for processing typescript (see https://www.typescriptlang.org/docs/handbook/tsconfig-json.html) instead of the default:\n    {\n        \"compilerOptions\": {\n            \"noEmit\": true,\n            \"emitDecoratorMetadata\": true,\n            \"experimentalDecorators\": true,\n            \"target\": \"ES5\",\n            \"module\": \"CommonJS\",\n            \"strictNullChecks\": false,\n        }\n    }\n\n-j, --jsDoc <extended|none|basic>\n    none: Do not use JsDoc annotations.\n    basic: Read JsDoc annotations to provide schema properties.\n    extended (default): Also read @nullable, and @asType annotations.\n\n--unstable\n    Do not sort properties.\n\n--strict-tuples\n    Do not allow additional items on tuples.\n\n--no-top-ref\n    Do not create a top-level $ref definition.\n\n--no-type-check\n    Skip type checks for better performance.\n\n--no-ref-encode\n    Do not encode references. According to the standard, references must be valid URIs but some tools do not support encoded references.\n\n--validation-keywords\n    Provide additional validation keywords to include.\n\n-o, --out\n    Specify the output file path. Without this option, the generator logs the response in the console.\n\n--additional-properties <true|false>\n    Controls whether or not to allow additional properties for objects that have no index signature.\n\n    true: Additional properties are allowed\n    false (default): Additional properties are not allowed\n```\n\n## Current state\n\n-   `interface` types\n-   `enum` types\n-   `union`, `tuple`, `type[]` types\n-   `Date`, `RegExp` types\n-   `string`, `boolean`, `number` types\n-   `\"value\"`, `123`, `true`, `false`, `null`, `undefined` literals\n-   type aliases\n-   generics\n-   `typeof`\n-   `keyof`\n-   conditional types\n\n## Run locally\n\n`yarn --silent run run --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\n## Debug\n\n`yarn --silent run debug --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\nAnd connect via the debugger protocol.\n\n[AST Explorer](https://astexplorer.net/) is amazing for developers of this tool!\n\n## Publish\n\nPublishing is handled by a 2-branch [pre-release process](https://intuit.github.io/auto/docs/generated/shipit#next-branch-default), configured in `publish-auto.yml`. All changes should be based off the default `next` branch, and are published automatically.\n\n-   PRs made into the default branch are auto-deployed to the `next` pre-release tag on NPM. The result can be installed with `npm install ts-json-schema-generator@next`\n    -   When merging into `next`, please use the `squash and merge` strategy.\n-   To release a new stable version, open a PR from `next` into `stable` using this [compare link](https://github.com/vega/ts-json-schema-generator/compare/stable...next).\n    -   When merging from `next` into `stable`, please use the `create a merge commit` strategy.\n",
      "readmeFilename": "README.md",
      "gitHead": "a61207409c41c7de3efc41f3d3deb55675223543",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.97.1--canary.1017.a612074.0",
      "_nodeVersion": "16.13.0",
      "_npmVersion": "8.1.0",
      "dist": {
        "integrity": "sha512-/pd76e/kfc32Fn6d1jjoJRVm0jSZ9FlNeO/swozTlRzX8UF7ZuHd9L23qiXkAmoZScUk7WOus/6WpPqLadk/kQ==",
        "shasum": "94c92755ad193147f63855a2d22649a68e0b0b40",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.97.1--canary.1017.a612074.0.tgz",
        "fileCount": 631,
        "unpackedSize": 735578,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJhmlmDCRA9TVsSAnZWagAApOUP+wYvdEu7jmfQhuvFyIgX\nu9/+iwjkm/p8TWHwK3nkxjtNlJQcyP6ORwFRIgsBKIVXxSBieBt/fbuOB17T\nCagAknPtLRNOeXZZjgcWAbGhmSB0wzQ27uayv6az8cbLX33dQcfC207QlkXj\nLzKCawrbSCjTZyKg3gLFPgNKMZUFYP65hztZBk7Yvd6UIAroHEDXyDfzcG72\n0HPH4inIKHsZX1XRJi/qA41Zs0XQgbLKKrPF7Uxhi447a4WnPH0GTBB6TVfh\ntc9vj5SHfoM7LCDBFgoVESydZ8v505XbPABREruF0FBiaQwJli6WxXm1KOi6\nRixzFf/ttfaegxSC/PWXwbNYXlKJFMpJQqghnHYW36OKc/6l8TENe07pgrt3\n3NAXfLi2LQN85RXRDnpSOTF0Yk0MxDQo/3f69HQxp80JpI6RO8MndkAKYHs+\ncfTZ7/IJ1QnxlnUJhz9DtnqaBmsV3S2ZAPM2cPLKTY5BAppPOU2EUrAIgLHW\n/VPI8XvEGkogK+ExaRz1XUwJwwh6XddV3HrrUbaS89lFNcsfkR4cNBnTJoNA\nsAAlpEwYqFRufRbIwVqV4q2+WjmdbPHgy/j5U12a+LiTn9ktcK7RzfitoRVV\n06W1Z9K9xubxWeAsA0G3OJD6wguBvO9tDf/hH0brarZ1wE+gsf6jh9B7cX12\nwk1Y\r\n=EqQ+\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIQCI7bGIQG2upJsSZw+8RpmujBqR0fcY/Ws9mFCacQ1twwIgGMjT0V4aixlks48h3pxViCSBKBsKxnDQBBdXp4+xqpU="
          }
        ]
      },
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "maintainers": [
        {
          "name": "jheer",
          "email": "jeffrey.heer@gmail.com"
        },
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "kanitw",
          "email": "kanitw@gmail.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.97.1--canary.1017.a612074.0_1637505410997_0.7842498295123228"
      },
      "_hasShrinkwrap": false
    },
    "0.98.0--canary.1027.7b60d67.0": {
      "name": "ts-json-schema-generator",
      "version": "0.98.0--canary.1027.7b60d67.0",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "MooYeol Prescott Lee",
          "email": "mooyoul@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=10.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.9",
        "commander": "^8.3.0",
        "glob": "^7.2.0",
        "safe-stable-stringify": "^2.2.0",
        "json5": "^2.2.0",
        "typescript": "~4.5.2"
      },
      "devDependencies": {
        "@auto-it/conventional-commits": "^10.32.2",
        "@auto-it/first-time-contributor": "^10.32.2",
        "@babel/core": "^7.16.0",
        "@babel/preset-env": "^7.16.4",
        "@babel/preset-typescript": "^7.16.0",
        "@types/glob": "^7.2.0",
        "@types/jest": "^27.0.3",
        "@types/node": "^16.11.9",
        "@typescript-eslint/eslint-plugin": "^5.4.0",
        "@typescript-eslint/parser": "^5.4.0",
        "ajv": "^8.8.1",
        "ajv-formats": "^2.1.1",
        "auto": "^10.32.2",
        "chai": "^4.3.4",
        "cross-env": "^7.0.3",
        "eslint": "^8.3.0",
        "eslint-config-prettier": "^8.3.0",
        "eslint-plugin-prettier": "^4.0.0",
        "jest": "^27.3.1",
        "jest-junit": "^13.0.0",
        "prettier": "^2.4.1",
        "ts-node": "^10.4.0",
        "vega": "^5.21.0",
        "vega-lite": "^5.1.1"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint \"{src,test,factory}/**/*.ts\"",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "cross-env FAST_TEST=1 jest test/ --verbose",
        "test:coverage": "yarn jest test/ --collectCoverage=true",
        "test:update": "cross-env UPDATE_SCHEMA=true yarn test:fast",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts",
        "release": "yarn build && auto shipit"
      },
      "readme": "# ts-json-schema-generator\n\n![Test](https://github.com/vega/ts-json-schema-generator/workflows/Test/badge.svg)\n[![codecov](https://codecov.io/gh/vega/ts-json-schema-generator/branch/master/graph/badge.svg)](https://codecov.io/gh/vega/ts-json-schema-generator)\n[![npm version](https://img.shields.io/npm/v/ts-json-schema-generator.svg)](https://www.npmjs.com/package/ts-json-schema-generator)\n\nExtended version of [https://github.com/xiag-ag/typescript-to-json-schema](https://github.com/xiag-ag/typescript-to-json-schema).\n\nInspired by [`YousefED/typescript-json-schema`](https://github.com/YousefED/typescript-json-schema). Here's the differences list:\n\n-   this implementation avoids the use of `typeChecker.getTypeAtLocation()` (so probably it keeps correct type aliases)\n-   processing AST and formatting JSON schema have been split into two independent steps\n-   not exported types, interfaces, enums are not exposed in the `definitions` section in the JSON schema\n\n## Contributors\n\nThis project is made possible by a [community of contributors](https://github.com/vega/ts-json-schema-generator/graphs/contributors). We welcome contributions of any kind (issues, code, documentation, examples, tests,...). Please read our [code of conduct](https://github.com/vega/vega/blob/master/CODE_OF_CONDUCT.md).\n\n## CLI Usage\n\n```bash\nnpm install --save ts-json-schema-generator\n./node_modules/.bin/ts-json-schema-generator --path 'my/project/**/*.ts' --type 'My.Type.Name'\n```\n\nNote that different platforms (e.g. Windows) may use different path separators so you may have to adjust the command above.\n\n## Programmatic Usage\n\n```js\n// main.js\n\nconst tsj = require(\"ts-json-schema-generator\");\nconst fs = require(\"fs\");\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst output_path = \"path/to/output/file\";\n\nconst schema = tsj.createGenerator(config).createSchema(config.type);\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\nRun the schema generator via `node main.js`.\n\n### Custom formatting\n\nExtending the built-in formatting is possible by creating a custom formatter and adding it to the main formatter:\n\n1. First we create a formatter, in this case for formatting function types:\n\n```ts\n// my-function-formatter.ts\nimport { BaseType, Definition, FunctionType, SubTypeFormatter } from \"ts-json-schema-generator\";\nimport ts from \"typescript\";\n\nexport class MyFunctionTypeFormatter implements SubTypeFormatter {\n    // You can skip this line if you don't need childTypeFormatter\n    public constructor(private childTypeFormatter: TypeFormatter) {}\n\n    public supportsType(type: FunctionType): boolean {\n        return type instanceof FunctionType;\n    }\n\n    public getDefinition(type: FunctionType): Definition {\n        // Return a custom schema for the function property.\n        return {\n            type: \"object\",\n            properties: {\n                isFunction: {\n                    type: \"boolean\",\n                    const: true,\n                },\n            },\n        };\n    }\n\n    // If this type does NOT HAVE children, generally all you need is:\n    public getChildren(type: FunctionType): BaseType[] {\n        return [];\n    }\n\n    // However, if children ARE supported, you'll need something similar to\n    // this (see src/TypeFormatter/{Array,Definition,etc}.ts for some examples):\n    public getChildren(type: FunctionType): BaseType[] {\n        return this.childTypeFormatter.getChildren(type.getType());\n    }\n}\n```\n\n2. Then we add the formatter as a child to the core formatter using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyFunctionTypeFormatter } from \"./my-function-formatter.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\n// We configure the formatter an add our custom formatter to it.\nconst formatter = createFormatter(config, (fmt, circularReferenceTypeFormatter) => {\n    // If your formatter DOES NOT support children, e.g. getChildren() { return [] }:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter());\n    // If your formatter DOES support children, you'll need this reference too:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter(circularReferenceTypeFormatter));\n});\n\nconst program = createProgram(config);\nconst parser = createParser(program, config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n### Custom parsing\n\nSimilar to custom formatting, extending the built-in parsing works practically the same way:\n\n1. First we create a parser, in this case for parsing construct types:\n\n```ts\n// my-constructor-parser.ts\nimport { Context, StringType, ReferenceType, BaseType, SubNodeParser } from \"ts-json-schema-generator\";\nimport ts from \"typescript\";\n\nexport class MyConstructorParser implements SubNodeParser {\n    supportsNode(node: ts.Node): boolean {\n        return node.kind === ts.SyntaxKind.ConstructorType;\n    }\n    createType(node: ts.Node, context: Context, reference?: ReferenceType): BaseType | undefined {\n        return new StringType(); // Treat constructors as strings in this example\n    }\n}\n```\n\n2. Then we add the parser as a child to the core parser using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyConstructorParser } from \"./my-constructor-parser.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst program = createProgram(config);\n\n// We configure the parser an add our custom parser to it.\nconst parser = createParser(program, config, (prs) => {\n    prs.addNodeParser(new MyConstructorParser());\n});\n\nconst formatter = createFormatter(config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n## Options\n\n```\n-p, --path 'index.ts'\n    The path to the TypeScript source file. If this is not provided, the type will be searched in the project specified in the `.tsconfig`.\n\n-t, --type 'My.Type.Name'\n    The type the generated schema will represent. If omitted, the generated schema will contain all\n    types found in the files matching path. The same is true if '*' is specified.\n\n-i, --id 'generatedSchemaId'\n    The `$id` of the generated schema. If omitted, there will be no `$id`.\n\n-e, --expose <all|none|export>\n    all: Create shared $ref definitions for all types.\n    none: Do not create shared $ref definitions.\n    export (default): Create shared $ref definitions only for exported types (not tagged as `@internal`).\n\n-f, --tsconfig 'my/project/tsconfig.json'\n    Use a custom tsconfig file for processing typescript (see https://www.typescriptlang.org/docs/handbook/tsconfig-json.html) instead of the default:\n    {\n        \"compilerOptions\": {\n            \"noEmit\": true,\n            \"emitDecoratorMetadata\": true,\n            \"experimentalDecorators\": true,\n            \"target\": \"ES5\",\n            \"module\": \"CommonJS\",\n            \"strictNullChecks\": false,\n        }\n    }\n\n-j, --jsDoc <extended|none|basic>\n    none: Do not use JsDoc annotations.\n    basic: Read JsDoc annotations to provide schema properties.\n    extended (default): Also read @nullable, and @asType annotations.\n\n--unstable\n    Do not sort properties.\n\n--strict-tuples\n    Do not allow additional items on tuples.\n\n--no-top-ref\n    Do not create a top-level $ref definition.\n\n--no-type-check\n    Skip type checks for better performance.\n\n--no-ref-encode\n    Do not encode references. According to the standard, references must be valid URIs but some tools do not support encoded references.\n\n--validation-keywords\n    Provide additional validation keywords to include.\n\n-o, --out\n    Specify the output file path. Without this option, the generator logs the response in the console.\n\n--additional-properties <true|false>\n    Controls whether or not to allow additional properties for objects that have no index signature.\n\n    true: Additional properties are allowed\n    false (default): Additional properties are not allowed\n```\n\n## Current state\n\n-   `interface` types\n-   `enum` types\n-   `union`, `tuple`, `type[]` types\n-   `Date`, `RegExp` types\n-   `string`, `boolean`, `number` types\n-   `\"value\"`, `123`, `true`, `false`, `null`, `undefined` literals\n-   type aliases\n-   generics\n-   `typeof`\n-   `keyof`\n-   conditional types\n\n## Run locally\n\n`yarn --silent run run --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\n## Debug\n\n`yarn --silent run debug --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\nAnd connect via the debugger protocol.\n\n[AST Explorer](https://astexplorer.net/) is amazing for developers of this tool!\n\n## Publish\n\nPublishing is handled by a 2-branch [pre-release process](https://intuit.github.io/auto/docs/generated/shipit#next-branch-default), configured in `publish-auto.yml`. All changes should be based off the default `next` branch, and are published automatically.\n\n-   PRs made into the default branch are auto-deployed to the `next` pre-release tag on NPM. The result can be installed with `npm install ts-json-schema-generator@next`\n    -   When merging into `next`, please use the `squash and merge` strategy.\n-   To release a new stable version, open a PR from `next` into `stable` using this [compare link](https://github.com/vega/ts-json-schema-generator/compare/stable...next).\n    -   When merging from `next` into `stable`, please use the `create a merge commit` strategy.\n",
      "readmeFilename": "README.md",
      "gitHead": "7b60d671d06a55fd91bea94fd75cfd613b6b0dcf",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.98.0--canary.1027.7b60d67.0",
      "_nodeVersion": "16.13.0",
      "_npmVersion": "8.1.0",
      "dist": {
        "integrity": "sha512-VVHMQ67VWW34z1x7zAqLDoD8Z6f8puB1OyXZQzaOhIg6JalXbY6gevimm6qlxD+mJiE+3Bf9XrJ1kKUPw9AKuQ==",
        "shasum": "3bcf1d379311669442fc92f94b3ae8fbe6ef6a9e",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.98.0--canary.1027.7b60d67.0.tgz",
        "fileCount": 631,
        "unpackedSize": 735397,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJhmloWCRA9TVsSAnZWagAAVHsP/jdgganNuk1ZLyCbi9fz\n1G1xxWv+5MzovhMqG+TuIg08r9Yz93mgZxPhn97uZ/if19vA5qNhaGjd9AYq\nZNHVtkwumjxqmZjoBlHV50ALY5V5zPUkrqDbSvrOddTumc65v/C6lhmcQHeg\nocsGxueNQ1hNzDq3J9PjbpkQ2bh/u6bbUweXuxgeEWEhrgRVTXm7OIqwXKK9\nzYUgw7uAPC48p2XEe76eOuELTzQ5lY5ExNLVXG1wWbDfFiQBFC0c5D+OIau+\nHuHlRpIAwsKM565F64GxAvCeMd9v1ap2f3sUrmJaJGpeZOfeGG8vz8EZzRfp\nd26bwF7jzRXElAK7AURi69nmOtLSQgim4z+2l0IpKuhT4cfZMbyh54HW0eix\nvOZ3Yyqhj/dYJRrASSyvcjCeH6oxxWeuB+wBlPCLDNIGHKHpZ1FC2n3+Xhyj\nxqAtyc8V4rQiNfr9PblUdWVKLFG/sKbXMfVK5frbwMJ9/gxJRnvHBLCQ4F2M\ng51g/0k+2/0NjZoEsEtQ1H5W5nevIpUnaNCoJU5/+8NDxAKmtyZp8a0o/Cgh\n+Jk/JwigKBBx444jC4Xeor6P3+S/g6Q8n5GbCZl9BNf/Ip0VTDVKCy9wZDZJ\ne0k7NeEL2usT2EysU6ZMuuoXFPRCB8Xkj/7nu65AP8jOPX6doPqQh5FBxQkD\nojy0\r\n=CCY+\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEQCIAYQ6Hy0grrRE+5bkPsOXzbUK43euKT47KFqTOKr5E5NAiBXkrnweQH83kIskNIvgD6U6R2X1dRIsefcoRwGP090rQ=="
          }
        ]
      },
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "maintainers": [
        {
          "name": "jheer",
          "email": "jeffrey.heer@gmail.com"
        },
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "kanitw",
          "email": "kanitw@gmail.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.98.0--canary.1027.7b60d67.0_1637505558005_0.83718754029381"
      },
      "_hasShrinkwrap": false
    },
    "0.97.1--canary.1037.b55fd54.0": {
      "name": "ts-json-schema-generator",
      "version": "0.97.1--canary.1037.b55fd54.0",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "MooYeol Prescott Lee",
          "email": "mooyoul@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=10.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.9",
        "commander": "^8.3.0",
        "glob": "^7.2.0",
        "safe-stable-stringify": "^2.2.0",
        "json5": "^2.2.0",
        "typescript": "~4.5.2"
      },
      "devDependencies": {
        "@auto-it/conventional-commits": "^10.32.3",
        "@auto-it/first-time-contributor": "^10.32.3",
        "@babel/core": "^7.16.0",
        "@babel/preset-env": "^7.16.4",
        "@babel/preset-typescript": "^7.16.0",
        "@types/glob": "^7.2.0",
        "@types/jest": "^27.0.3",
        "@types/node": "^16.11.10",
        "@typescript-eslint/eslint-plugin": "^5.4.0",
        "@typescript-eslint/parser": "^5.4.0",
        "ajv": "^8.8.2",
        "ajv-formats": "^2.1.1",
        "auto": "^10.32.3",
        "chai": "^4.3.4",
        "cross-env": "^7.0.3",
        "eslint": "^8.3.0",
        "eslint-config-prettier": "^8.3.0",
        "eslint-plugin-prettier": "^4.0.0",
        "jest": "^27.3.1",
        "jest-junit": "^13.0.0",
        "prettier": "^2.5.0",
        "ts-node": "^10.4.0",
        "vega": "^5.21.0",
        "vega-lite": "^5.2.0"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint \"{src,test,factory}/**/*.ts\"",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "cross-env FAST_TEST=1 jest test/ --verbose",
        "test:coverage": "yarn jest test/ --collectCoverage=true",
        "test:update": "cross-env UPDATE_SCHEMA=true yarn test:fast",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts",
        "release": "yarn build && auto shipit"
      },
      "readme": "# ts-json-schema-generator\n\n![Test](https://github.com/vega/ts-json-schema-generator/workflows/Test/badge.svg)\n[![codecov](https://codecov.io/gh/vega/ts-json-schema-generator/branch/master/graph/badge.svg)](https://codecov.io/gh/vega/ts-json-schema-generator)\n[![npm version](https://img.shields.io/npm/v/ts-json-schema-generator.svg)](https://www.npmjs.com/package/ts-json-schema-generator)\n\nExtended version of [https://github.com/xiag-ag/typescript-to-json-schema](https://github.com/xiag-ag/typescript-to-json-schema).\n\nInspired by [`YousefED/typescript-json-schema`](https://github.com/YousefED/typescript-json-schema). Here's the differences list:\n\n-   this implementation avoids the use of `typeChecker.getTypeAtLocation()` (so probably it keeps correct type aliases)\n-   processing AST and formatting JSON schema have been split into two independent steps\n-   not exported types, interfaces, enums are not exposed in the `definitions` section in the JSON schema\n\n## Contributors\n\nThis project is made possible by a [community of contributors](https://github.com/vega/ts-json-schema-generator/graphs/contributors). We welcome contributions of any kind (issues, code, documentation, examples, tests,...). Please read our [code of conduct](https://github.com/vega/vega/blob/master/CODE_OF_CONDUCT.md).\n\n## CLI Usage\n\n```bash\nnpm install --save ts-json-schema-generator\n./node_modules/.bin/ts-json-schema-generator --path 'my/project/**/*.ts' --type 'My.Type.Name'\n```\n\nNote that different platforms (e.g. Windows) may use different path separators so you may have to adjust the command above.\n\n## Programmatic Usage\n\n```js\n// main.js\n\nconst tsj = require(\"ts-json-schema-generator\");\nconst fs = require(\"fs\");\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst output_path = \"path/to/output/file\";\n\nconst schema = tsj.createGenerator(config).createSchema(config.type);\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\nRun the schema generator via `node main.js`.\n\n### Custom formatting\n\nExtending the built-in formatting is possible by creating a custom formatter and adding it to the main formatter:\n\n1. First we create a formatter, in this case for formatting function types:\n\n```ts\n// my-function-formatter.ts\nimport { BaseType, Definition, FunctionType, SubTypeFormatter } from \"ts-json-schema-generator\";\nimport ts from \"typescript\";\n\nexport class MyFunctionTypeFormatter implements SubTypeFormatter {\n    // You can skip this line if you don't need childTypeFormatter\n    public constructor(private childTypeFormatter: TypeFormatter) {}\n\n    public supportsType(type: FunctionType): boolean {\n        return type instanceof FunctionType;\n    }\n\n    public getDefinition(type: FunctionType): Definition {\n        // Return a custom schema for the function property.\n        return {\n            type: \"object\",\n            properties: {\n                isFunction: {\n                    type: \"boolean\",\n                    const: true,\n                },\n            },\n        };\n    }\n\n    // If this type does NOT HAVE children, generally all you need is:\n    public getChildren(type: FunctionType): BaseType[] {\n        return [];\n    }\n\n    // However, if children ARE supported, you'll need something similar to\n    // this (see src/TypeFormatter/{Array,Definition,etc}.ts for some examples):\n    public getChildren(type: FunctionType): BaseType[] {\n        return this.childTypeFormatter.getChildren(type.getType());\n    }\n}\n```\n\n2. Then we add the formatter as a child to the core formatter using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyFunctionTypeFormatter } from \"./my-function-formatter.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\n// We configure the formatter an add our custom formatter to it.\nconst formatter = createFormatter(config, (fmt, circularReferenceTypeFormatter) => {\n    // If your formatter DOES NOT support children, e.g. getChildren() { return [] }:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter());\n    // If your formatter DOES support children, you'll need this reference too:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter(circularReferenceTypeFormatter));\n});\n\nconst program = createProgram(config);\nconst parser = createParser(program, config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n### Custom parsing\n\nSimilar to custom formatting, extending the built-in parsing works practically the same way:\n\n1. First we create a parser, in this case for parsing construct types:\n\n```ts\n// my-constructor-parser.ts\nimport { Context, StringType, ReferenceType, BaseType, SubNodeParser } from \"ts-json-schema-generator\";\nimport ts from \"typescript\";\n\nexport class MyConstructorParser implements SubNodeParser {\n    supportsNode(node: ts.Node): boolean {\n        return node.kind === ts.SyntaxKind.ConstructorType;\n    }\n    createType(node: ts.Node, context: Context, reference?: ReferenceType): BaseType | undefined {\n        return new StringType(); // Treat constructors as strings in this example\n    }\n}\n```\n\n2. Then we add the parser as a child to the core parser using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyConstructorParser } from \"./my-constructor-parser.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst program = createProgram(config);\n\n// We configure the parser an add our custom parser to it.\nconst parser = createParser(program, config, (prs) => {\n    prs.addNodeParser(new MyConstructorParser());\n});\n\nconst formatter = createFormatter(config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n## Options\n\n```\n-p, --path 'index.ts'\n    The path to the TypeScript source file. If this is not provided, the type will be searched in the project specified in the `.tsconfig`.\n\n-t, --type 'My.Type.Name'\n    The type the generated schema will represent. If omitted, the generated schema will contain all\n    types found in the files matching path. The same is true if '*' is specified.\n\n-i, --id 'generatedSchemaId'\n    The `$id` of the generated schema. If omitted, there will be no `$id`.\n\n-e, --expose <all|none|export>\n    all: Create shared $ref definitions for all types.\n    none: Do not create shared $ref definitions.\n    export (default): Create shared $ref definitions only for exported types (not tagged as `@internal`).\n\n-f, --tsconfig 'my/project/tsconfig.json'\n    Use a custom tsconfig file for processing typescript (see https://www.typescriptlang.org/docs/handbook/tsconfig-json.html) instead of the default:\n    {\n        \"compilerOptions\": {\n            \"noEmit\": true,\n            \"emitDecoratorMetadata\": true,\n            \"experimentalDecorators\": true,\n            \"target\": \"ES5\",\n            \"module\": \"CommonJS\",\n            \"strictNullChecks\": false,\n        }\n    }\n\n-j, --jsDoc <extended|none|basic>\n    none: Do not use JsDoc annotations.\n    basic: Read JsDoc annotations to provide schema properties.\n    extended (default): Also read @nullable, and @asType annotations.\n\n--unstable\n    Do not sort properties.\n\n--strict-tuples\n    Do not allow additional items on tuples.\n\n--no-top-ref\n    Do not create a top-level $ref definition.\n\n--no-type-check\n    Skip type checks for better performance.\n\n--no-ref-encode\n    Do not encode references. According to the standard, references must be valid URIs but some tools do not support encoded references.\n\n--validation-keywords\n    Provide additional validation keywords to include.\n\n-o, --out\n    Specify the output file path. Without this option, the generator logs the response in the console.\n\n--additional-properties <true|false>\n    Controls whether or not to allow additional properties for objects that have no index signature.\n\n    true: Additional properties are allowed\n    false (default): Additional properties are not allowed\n```\n\n## Current state\n\n-   `interface` types\n-   `enum` types\n-   `union`, `tuple`, `type[]` types\n-   `Date`, `RegExp` types\n-   `string`, `boolean`, `number` types\n-   `\"value\"`, `123`, `true`, `false`, `null`, `undefined` literals\n-   type aliases\n-   generics\n-   `typeof`\n-   `keyof`\n-   conditional types\n\n## Run locally\n\n`yarn --silent run run --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\n## Debug\n\n`yarn --silent run debug --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\nAnd connect via the debugger protocol.\n\n[AST Explorer](https://astexplorer.net/) is amazing for developers of this tool!\n\n## Publish\n\nPublishing is handled by a 2-branch [pre-release process](https://intuit.github.io/auto/docs/generated/shipit#next-branch-default), configured in `publish-auto.yml`. All changes should be based off the default `next` branch, and are published automatically.\n\n-   PRs made into the default branch are auto-deployed to the `next` pre-release tag on NPM. The result can be installed with `npm install ts-json-schema-generator@next`\n    -   When merging into `next`, please use the `squash and merge` strategy.\n-   To release a new stable version, open a PR from `next` into `stable` using this [compare link](https://github.com/vega/ts-json-schema-generator/compare/stable...next).\n    -   When merging from `next` into `stable`, please use the `create a merge commit` strategy.\n",
      "readmeFilename": "README.md",
      "gitHead": "b55fd54c1df03910e62f806b0907af01ee7cdd9b",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.97.1--canary.1037.b55fd54.0",
      "_nodeVersion": "16.13.0",
      "_npmVersion": "8.1.0",
      "dist": {
        "integrity": "sha512-maJqn/GguXssAEXJBMEGQZyNinWqstuhZ5KQeIigNv+qPZtMtRsfbcW3MzTFSJUNaKmquAmpXRG00400tH4GgQ==",
        "shasum": "cde43aecea023a306fcdc443a8e9f35956ef5f79",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.97.1--canary.1037.b55fd54.0.tgz",
        "fileCount": 631,
        "unpackedSize": 735328,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJho+agCRA9TVsSAnZWagAAouEQAIUTpEVewauSusW6QnQd\nnJ4XgyIuBTGjgrfMeO0Gi3CW5nu/tO5SoScSA6+AUKz7f13Toc6BYdtyF2FY\ntXmE+cG+J1VCxOVtZIUDznjJ1yMKGjNBChD8236U+hHu6wnQybKggEgNmeCa\nlU3x0Jg8SKoi9QLYv2gC5Efc9DlNMlPTxCPnILWS1cRijQjVT8RXMgYvm7oJ\niy2VziSzMtTVO0rp8RQFdc9Kvjs+VD27aJD13nSYToAIIwHrj9A1gzOdXHKd\nZKrizWLCZTOMk0PYswXEZT8tgbLAAF8bkx8jW5ZdGNBcSG3EjHpb0Hxl9qsu\nuXgv+OnHIqDjVfuyWvxKZEOckaJOwG8/4SLxtIFY8BSWG2mMazjKuvF6lSeh\nDai9EMwDrMYNqsjRbHyuAUKxQaooXyip2uzVUwVGOVz+ARqbOqN872eCO0x+\n0dO1lsYlU993Hv4T0Y18Ss3gClNRw8l4yti7duSr8MbiblaRKLjpOy1rMOGI\nyH1KUaBM4HVHBnzmZzDR5Wfpk5aCwr5G2InojImXWUSW7vMVHF5i80n65H9k\nmDydtJ1WI2viEG49dbdO1L52wHJD3Mmv1ZZT2OgPT1XxopFc/m0h+oX3FNUG\n/Gi80/+Bt6j9LZzkK/uWcWPJ7OjePDnSLj0rd2IiRWnonv+NLKgx4u3IhpxV\nNES5\r\n=Rchh\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEQCIAoYcbJnVJVUwaihEXUR4SouO7TgfLpLddl00FpitTIQAiBo+eSW9cFPdkpnReRw+ChYqgN7eO3LPwaVH6Cd2EAcfA=="
          }
        ]
      },
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "maintainers": [
        {
          "name": "jheer",
          "email": "jeffrey.heer@gmail.com"
        },
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "kanitw",
          "email": "kanitw@gmail.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.97.1--canary.1037.b55fd54.0_1638131360049_0.18011312655038236"
      },
      "_hasShrinkwrap": false
    },
    "0.97.1--canary.b6f3ead.0": {
      "name": "ts-json-schema-generator",
      "version": "0.97.1--canary.b6f3ead.0",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "MooYeol Prescott Lee",
          "email": "mooyoul@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=10.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.9",
        "commander": "^8.3.0",
        "glob": "^7.2.0",
        "safe-stable-stringify": "^2.2.0",
        "json5": "^2.2.0",
        "typescript": "~4.5.2"
      },
      "devDependencies": {
        "@auto-it/conventional-commits": "^10.32.3",
        "@auto-it/first-time-contributor": "^10.32.3",
        "@babel/core": "^7.16.0",
        "@babel/preset-env": "^7.16.4",
        "@babel/preset-typescript": "^7.16.0",
        "@types/glob": "^7.2.0",
        "@types/jest": "^27.0.3",
        "@types/node": "^16.11.10",
        "@typescript-eslint/eslint-plugin": "^5.4.0",
        "@typescript-eslint/parser": "^5.4.0",
        "ajv": "^8.8.2",
        "ajv-formats": "^2.1.1",
        "auto": "^10.32.3",
        "chai": "^4.3.4",
        "cross-env": "^7.0.3",
        "eslint": "^8.3.0",
        "eslint-config-prettier": "^8.3.0",
        "eslint-plugin-prettier": "^4.0.0",
        "jest": "^27.3.1",
        "jest-junit": "^13.0.0",
        "prettier": "^2.5.0",
        "ts-node": "^10.4.0",
        "vega": "^5.21.0",
        "vega-lite": "^5.2.0"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint \"{src,test,factory}/**/*.ts\"",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "cross-env FAST_TEST=1 jest test/ --verbose",
        "test:coverage": "yarn jest test/ --collectCoverage=true",
        "test:update": "cross-env UPDATE_SCHEMA=true yarn test:fast",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts",
        "release": "yarn build && auto shipit"
      },
      "readme": "# ts-json-schema-generator\n\n![Test](https://github.com/vega/ts-json-schema-generator/workflows/Test/badge.svg)\n[![codecov](https://codecov.io/gh/vega/ts-json-schema-generator/branch/master/graph/badge.svg)](https://codecov.io/gh/vega/ts-json-schema-generator)\n[![npm version](https://img.shields.io/npm/v/ts-json-schema-generator.svg)](https://www.npmjs.com/package/ts-json-schema-generator)\n\nExtended version of [https://github.com/xiag-ag/typescript-to-json-schema](https://github.com/xiag-ag/typescript-to-json-schema).\n\nInspired by [`YousefED/typescript-json-schema`](https://github.com/YousefED/typescript-json-schema). Here's the differences list:\n\n-   this implementation avoids the use of `typeChecker.getTypeAtLocation()` (so probably it keeps correct type aliases)\n-   processing AST and formatting JSON schema have been split into two independent steps\n-   not exported types, interfaces, enums are not exposed in the `definitions` section in the JSON schema\n\n## Contributors\n\nThis project is made possible by a [community of contributors](https://github.com/vega/ts-json-schema-generator/graphs/contributors). We welcome contributions of any kind (issues, code, documentation, examples, tests,...). Please read our [code of conduct](https://github.com/vega/vega/blob/master/CODE_OF_CONDUCT.md).\n\n## CLI Usage\n\n```bash\nnpm install --save ts-json-schema-generator\n./node_modules/.bin/ts-json-schema-generator --path 'my/project/**/*.ts' --type 'My.Type.Name'\n```\n\nNote that different platforms (e.g. Windows) may use different path separators so you may have to adjust the command above.\n\n## Programmatic Usage\n\n```js\n// main.js\n\nconst tsj = require(\"ts-json-schema-generator\");\nconst fs = require(\"fs\");\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst output_path = \"path/to/output/file\";\n\nconst schema = tsj.createGenerator(config).createSchema(config.type);\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\nRun the schema generator via `node main.js`.\n\n### Custom formatting\n\nExtending the built-in formatting is possible by creating a custom formatter and adding it to the main formatter:\n\n1. First we create a formatter, in this case for formatting function types:\n\n```ts\n// my-function-formatter.ts\nimport { BaseType, Definition, FunctionType, SubTypeFormatter } from \"ts-json-schema-generator\";\nimport ts from \"typescript\";\n\nexport class MyFunctionTypeFormatter implements SubTypeFormatter {\n    // You can skip this line if you don't need childTypeFormatter\n    public constructor(private childTypeFormatter: TypeFormatter) {}\n\n    public supportsType(type: FunctionType): boolean {\n        return type instanceof FunctionType;\n    }\n\n    public getDefinition(type: FunctionType): Definition {\n        // Return a custom schema for the function property.\n        return {\n            type: \"object\",\n            properties: {\n                isFunction: {\n                    type: \"boolean\",\n                    const: true,\n                },\n            },\n        };\n    }\n\n    // If this type does NOT HAVE children, generally all you need is:\n    public getChildren(type: FunctionType): BaseType[] {\n        return [];\n    }\n\n    // However, if children ARE supported, you'll need something similar to\n    // this (see src/TypeFormatter/{Array,Definition,etc}.ts for some examples):\n    public getChildren(type: FunctionType): BaseType[] {\n        return this.childTypeFormatter.getChildren(type.getType());\n    }\n}\n```\n\n2. Then we add the formatter as a child to the core formatter using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyFunctionTypeFormatter } from \"./my-function-formatter.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\n// We configure the formatter an add our custom formatter to it.\nconst formatter = createFormatter(config, (fmt, circularReferenceTypeFormatter) => {\n    // If your formatter DOES NOT support children, e.g. getChildren() { return [] }:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter());\n    // If your formatter DOES support children, you'll need this reference too:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter(circularReferenceTypeFormatter));\n});\n\nconst program = createProgram(config);\nconst parser = createParser(program, config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n### Custom parsing\n\nSimilar to custom formatting, extending the built-in parsing works practically the same way:\n\n1. First we create a parser, in this case for parsing construct types:\n\n```ts\n// my-constructor-parser.ts\nimport { Context, StringType, ReferenceType, BaseType, SubNodeParser } from \"ts-json-schema-generator\";\nimport ts from \"typescript\";\n\nexport class MyConstructorParser implements SubNodeParser {\n    supportsNode(node: ts.Node): boolean {\n        return node.kind === ts.SyntaxKind.ConstructorType;\n    }\n    createType(node: ts.Node, context: Context, reference?: ReferenceType): BaseType | undefined {\n        return new StringType(); // Treat constructors as strings in this example\n    }\n}\n```\n\n2. Then we add the parser as a child to the core parser using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyConstructorParser } from \"./my-constructor-parser.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst program = createProgram(config);\n\n// We configure the parser an add our custom parser to it.\nconst parser = createParser(program, config, (prs) => {\n    prs.addNodeParser(new MyConstructorParser());\n});\n\nconst formatter = createFormatter(config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n## Options\n\n```\n-p, --path 'index.ts'\n    The path to the TypeScript source file. If this is not provided, the type will be searched in the project specified in the `.tsconfig`.\n\n-t, --type 'My.Type.Name'\n    The type the generated schema will represent. If omitted, the generated schema will contain all\n    types found in the files matching path. The same is true if '*' is specified.\n\n-i, --id 'generatedSchemaId'\n    The `$id` of the generated schema. If omitted, there will be no `$id`.\n\n-e, --expose <all|none|export>\n    all: Create shared $ref definitions for all types.\n    none: Do not create shared $ref definitions.\n    export (default): Create shared $ref definitions only for exported types (not tagged as `@internal`).\n\n-f, --tsconfig 'my/project/tsconfig.json'\n    Use a custom tsconfig file for processing typescript (see https://www.typescriptlang.org/docs/handbook/tsconfig-json.html) instead of the default:\n    {\n        \"compilerOptions\": {\n            \"noEmit\": true,\n            \"emitDecoratorMetadata\": true,\n            \"experimentalDecorators\": true,\n            \"target\": \"ES5\",\n            \"module\": \"CommonJS\",\n            \"strictNullChecks\": false,\n        }\n    }\n\n-j, --jsDoc <extended|none|basic>\n    none: Do not use JsDoc annotations.\n    basic: Read JsDoc annotations to provide schema properties.\n    extended (default): Also read @nullable, and @asType annotations.\n\n--unstable\n    Do not sort properties.\n\n--strict-tuples\n    Do not allow additional items on tuples.\n\n--no-top-ref\n    Do not create a top-level $ref definition.\n\n--no-type-check\n    Skip type checks for better performance.\n\n--no-ref-encode\n    Do not encode references. According to the standard, references must be valid URIs but some tools do not support encoded references.\n\n--validation-keywords\n    Provide additional validation keywords to include.\n\n-o, --out\n    Specify the output file path. Without this option, the generator logs the response in the console.\n\n--additional-properties <true|false>\n    Controls whether or not to allow additional properties for objects that have no index signature.\n\n    true: Additional properties are allowed\n    false (default): Additional properties are not allowed\n```\n\n## Current state\n\n-   `interface` types\n-   `enum` types\n-   `union`, `tuple`, `type[]` types\n-   `Date`, `RegExp` types\n-   `string`, `boolean`, `number` types\n-   `\"value\"`, `123`, `true`, `false`, `null`, `undefined` literals\n-   type aliases\n-   generics\n-   `typeof`\n-   `keyof`\n-   conditional types\n\n## Run locally\n\n`yarn --silent run run --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\n## Debug\n\n`yarn --silent run debug --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\nAnd connect via the debugger protocol.\n\n[AST Explorer](https://astexplorer.net/) is amazing for developers of this tool!\n\n## Publish\n\nPublishing is handled by a 2-branch [pre-release process](https://intuit.github.io/auto/docs/generated/shipit#next-branch-default), configured in `publish-auto.yml`. All changes should be based off the default `next` branch, and are published automatically.\n\n-   PRs made into the default branch are auto-deployed to the `next` pre-release tag on NPM. The result can be installed with `npm install ts-json-schema-generator@next`\n    -   When merging into `next`, please use the `squash and merge` strategy.\n-   To release a new stable version, open a PR from `next` into `stable` using this [compare link](https://github.com/vega/ts-json-schema-generator/compare/stable...next).\n    -   When merging from `next` into `stable`, please use the `create a merge commit` strategy.\n",
      "readmeFilename": "README.md",
      "gitHead": "b6f3ead166460cca607c8ca15d2ee8a3fdc6b7ca",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.97.1--canary.b6f3ead.0",
      "_nodeVersion": "16.13.0",
      "_npmVersion": "8.1.0",
      "dist": {
        "integrity": "sha512-RNV6Ke0pvCKaR7b8t9x5hU0UfAQikg7mI4LJT0W+YDzkntTNIQxznWmUmo+eynt3aClXftdJgOwhWkeCI+NyTg==",
        "shasum": "026247d6af49c268dc278c3e96526bd6493a375d",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.97.1--canary.b6f3ead.0.tgz",
        "fileCount": 631,
        "unpackedSize": 735318,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJhpWC7CRA9TVsSAnZWagAAtTAP+wWIBBpguzDyUKPEqPSZ\njlVPj5poaWg+AjfU3lbNxXBIl/q5Y5bJUcXQi1N5pNDUC1uALMNScp8UiFPd\nqpaIzPt1VqE0TSrM2EgCLZPtuDUU3yXJkKLtadrc1xldKTInL33wGIm0m6vk\nXH9GzhP5L+B9yN3hna0NMe+WNJx1RMzk/jBW9v0rDX8Ey/0INvxHzLP5sSHI\nFn7atsEuME7zsBIGzite7pr/fdcN4YH4LtVP6T1RUfa7Vz4bAkjlPj4/uD5a\nb5YX+pivpzFS1vWwKe3k326EChWa2KDm45oMeqBQEAp2N16EcjzmGDjsHeYG\nm5SbHFbuwzEQ2JFhR0MwprCIrjsmqRaY8goL95jVOIG57mVyIOYoVu+oN99T\nu3rRhrGvtqwyiMNBecyce+lw8pANp83YOV1LyWTHhwimqIvaNV6mG51r5LlL\nmV3SVJHHB1aEc2q+TnQ/MDKZ0qEualiqquUfwa9pceGUGYKUyiHWYZtfa4mM\ng+mAvXr2HN4lU5OnZ80VFJl4gWr1X+WYBjBDboLjdkS3Q3I/39m4xxRRzOcz\nbpdjBkWGEBrvheksT/u95yYG+9cvb2Dc3/nEC6hjTREszpGjcTuNTow6r44J\nOwuU2rvNUbNLGNImoxSV12O0Baxo7ug1FxG1knQ2a/V8FB7UCz6Dfu8K04b2\nJz2P\r\n=J+gM\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEYCIQCEbGyHI3vMYcs1YySW2Ho6SyePKbKVdLPJuABzDu2luQIhAKdmuKWMFoRDQ4eEJqDsWhRGtR/RLb+vzSmJas7REGsd"
          }
        ]
      },
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "maintainers": [
        {
          "name": "jheer",
          "email": "jeffrey.heer@gmail.com"
        },
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "kanitw",
          "email": "kanitw@gmail.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.97.1--canary.b6f3ead.0_1638228154872_0.2344748037879949"
      },
      "_hasShrinkwrap": false
    },
    "0.97.1--canary.1039.7266c79.0": {
      "name": "ts-json-schema-generator",
      "version": "0.97.1--canary.1039.7266c79.0",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "MooYeol Prescott Lee",
          "email": "mooyoul@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=10.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.9",
        "commander": "^8.3.0",
        "glob": "^7.2.0",
        "safe-stable-stringify": "^2.2.0",
        "json5": "^2.2.0",
        "typescript": "~4.5.2"
      },
      "devDependencies": {
        "@auto-it/conventional-commits": "^10.32.3",
        "@auto-it/first-time-contributor": "^10.32.3",
        "@babel/core": "^7.16.0",
        "@babel/preset-env": "^7.16.4",
        "@babel/preset-typescript": "^7.16.0",
        "@types/glob": "^7.2.0",
        "@types/jest": "^27.0.3",
        "@types/node": "^16.11.10",
        "@typescript-eslint/eslint-plugin": "^5.4.0",
        "@typescript-eslint/parser": "^5.4.0",
        "ajv": "^8.8.2",
        "ajv-formats": "^2.1.1",
        "auto": "^10.32.3",
        "chai": "^4.3.4",
        "cross-env": "^7.0.3",
        "eslint": "^8.3.0",
        "eslint-config-prettier": "^8.3.0",
        "eslint-plugin-prettier": "^4.0.0",
        "jest": "^27.3.1",
        "jest-junit": "^13.0.0",
        "prettier": "^2.5.0",
        "ts-node": "^10.4.0",
        "vega": "^5.21.0",
        "vega-lite": "^5.2.0"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint \"{src,test,factory}/**/*.ts\"",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "cross-env FAST_TEST=1 jest test/ --verbose",
        "test:coverage": "yarn jest test/ --collectCoverage=true",
        "test:update": "cross-env UPDATE_SCHEMA=true yarn test:fast",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts",
        "release": "yarn build && auto shipit"
      },
      "readme": "# ts-json-schema-generator\n\n![Test](https://github.com/vega/ts-json-schema-generator/workflows/Test/badge.svg)\n[![codecov](https://codecov.io/gh/vega/ts-json-schema-generator/branch/master/graph/badge.svg)](https://codecov.io/gh/vega/ts-json-schema-generator)\n[![npm version](https://img.shields.io/npm/v/ts-json-schema-generator.svg)](https://www.npmjs.com/package/ts-json-schema-generator)\n\nExtended version of [https://github.com/xiag-ag/typescript-to-json-schema](https://github.com/xiag-ag/typescript-to-json-schema).\n\nInspired by [`YousefED/typescript-json-schema`](https://github.com/YousefED/typescript-json-schema). Here's the differences list:\n\n-   this implementation avoids the use of `typeChecker.getTypeAtLocation()` (so probably it keeps correct type aliases)\n-   processing AST and formatting JSON schema have been split into two independent steps\n-   not exported types, interfaces, enums are not exposed in the `definitions` section in the JSON schema\n\n## Contributors\n\nThis project is made possible by a [community of contributors](https://github.com/vega/ts-json-schema-generator/graphs/contributors). We welcome contributions of any kind (issues, code, documentation, examples, tests,...). Please read our [code of conduct](https://github.com/vega/vega/blob/master/CODE_OF_CONDUCT.md).\n\n## CLI Usage\n\n```bash\nnpm install --save ts-json-schema-generator\n./node_modules/.bin/ts-json-schema-generator --path 'my/project/**/*.ts' --type 'My.Type.Name'\n```\n\nNote that different platforms (e.g. Windows) may use different path separators so you may have to adjust the command above.\n\n## Programmatic Usage\n\n```js\n// main.js\n\nconst tsj = require(\"ts-json-schema-generator\");\nconst fs = require(\"fs\");\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst output_path = \"path/to/output/file\";\n\nconst schema = tsj.createGenerator(config).createSchema(config.type);\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\nRun the schema generator via `node main.js`.\n\n### Custom formatting\n\nExtending the built-in formatting is possible by creating a custom formatter and adding it to the main formatter:\n\n1. First we create a formatter, in this case for formatting function types:\n\n```ts\n// my-function-formatter.ts\nimport { BaseType, Definition, FunctionType, SubTypeFormatter } from \"ts-json-schema-generator\";\nimport ts from \"typescript\";\n\nexport class MyFunctionTypeFormatter implements SubTypeFormatter {\n    // You can skip this line if you don't need childTypeFormatter\n    public constructor(private childTypeFormatter: TypeFormatter) {}\n\n    public supportsType(type: FunctionType): boolean {\n        return type instanceof FunctionType;\n    }\n\n    public getDefinition(type: FunctionType): Definition {\n        // Return a custom schema for the function property.\n        return {\n            type: \"object\",\n            properties: {\n                isFunction: {\n                    type: \"boolean\",\n                    const: true,\n                },\n            },\n        };\n    }\n\n    // If this type does NOT HAVE children, generally all you need is:\n    public getChildren(type: FunctionType): BaseType[] {\n        return [];\n    }\n\n    // However, if children ARE supported, you'll need something similar to\n    // this (see src/TypeFormatter/{Array,Definition,etc}.ts for some examples):\n    public getChildren(type: FunctionType): BaseType[] {\n        return this.childTypeFormatter.getChildren(type.getType());\n    }\n}\n```\n\n2. Then we add the formatter as a child to the core formatter using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyFunctionTypeFormatter } from \"./my-function-formatter.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\n// We configure the formatter an add our custom formatter to it.\nconst formatter = createFormatter(config, (fmt, circularReferenceTypeFormatter) => {\n    // If your formatter DOES NOT support children, e.g. getChildren() { return [] }:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter());\n    // If your formatter DOES support children, you'll need this reference too:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter(circularReferenceTypeFormatter));\n});\n\nconst program = createProgram(config);\nconst parser = createParser(program, config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n### Custom parsing\n\nSimilar to custom formatting, extending the built-in parsing works practically the same way:\n\n1. First we create a parser, in this case for parsing construct types:\n\n```ts\n// my-constructor-parser.ts\nimport { Context, StringType, ReferenceType, BaseType, SubNodeParser } from \"ts-json-schema-generator\";\nimport ts from \"typescript\";\n\nexport class MyConstructorParser implements SubNodeParser {\n    supportsNode(node: ts.Node): boolean {\n        return node.kind === ts.SyntaxKind.ConstructorType;\n    }\n    createType(node: ts.Node, context: Context, reference?: ReferenceType): BaseType | undefined {\n        return new StringType(); // Treat constructors as strings in this example\n    }\n}\n```\n\n2. Then we add the parser as a child to the core parser using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyConstructorParser } from \"./my-constructor-parser.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst program = createProgram(config);\n\n// We configure the parser an add our custom parser to it.\nconst parser = createParser(program, config, (prs) => {\n    prs.addNodeParser(new MyConstructorParser());\n});\n\nconst formatter = createFormatter(config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n## Options\n\n```\n-p, --path 'index.ts'\n    The path to the TypeScript source file. If this is not provided, the type will be searched in the project specified in the `.tsconfig`.\n\n-t, --type 'My.Type.Name'\n    The type the generated schema will represent. If omitted, the generated schema will contain all\n    types found in the files matching path. The same is true if '*' is specified.\n\n-i, --id 'generatedSchemaId'\n    The `$id` of the generated schema. If omitted, there will be no `$id`.\n\n-e, --expose <all|none|export>\n    all: Create shared $ref definitions for all types.\n    none: Do not create shared $ref definitions.\n    export (default): Create shared $ref definitions only for exported types (not tagged as `@internal`).\n\n-f, --tsconfig 'my/project/tsconfig.json'\n    Use a custom tsconfig file for processing typescript (see https://www.typescriptlang.org/docs/handbook/tsconfig-json.html) instead of the default:\n    {\n        \"compilerOptions\": {\n            \"noEmit\": true,\n            \"emitDecoratorMetadata\": true,\n            \"experimentalDecorators\": true,\n            \"target\": \"ES5\",\n            \"module\": \"CommonJS\",\n            \"strictNullChecks\": false,\n        }\n    }\n\n-j, --jsDoc <extended|none|basic>\n    none: Do not use JsDoc annotations.\n    basic: Read JsDoc annotations to provide schema properties.\n    extended (default): Also read @nullable, and @asType annotations.\n\n--unstable\n    Do not sort properties.\n\n--strict-tuples\n    Do not allow additional items on tuples.\n\n--no-top-ref\n    Do not create a top-level $ref definition.\n\n--no-type-check\n    Skip type checks for better performance.\n\n--no-ref-encode\n    Do not encode references. According to the standard, references must be valid URIs but some tools do not support encoded references.\n\n--validation-keywords\n    Provide additional validation keywords to include.\n\n-o, --out\n    Specify the output file path. Without this option, the generator logs the response in the console.\n\n--additional-properties <true|false>\n    Controls whether or not to allow additional properties for objects that have no index signature.\n\n    true: Additional properties are allowed\n    false (default): Additional properties are not allowed\n```\n\n## Current state\n\n-   `interface` types\n-   `enum` types\n-   `union`, `tuple`, `type[]` types\n-   `Date`, `RegExp` types\n-   `string`, `boolean`, `number` types\n-   `\"value\"`, `123`, `true`, `false`, `null`, `undefined` literals\n-   type aliases\n-   generics\n-   `typeof`\n-   `keyof`\n-   conditional types\n\n## Run locally\n\n`yarn --silent run run --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\n## Debug\n\n`yarn --silent run debug --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\nAnd connect via the debugger protocol.\n\n[AST Explorer](https://astexplorer.net/) is amazing for developers of this tool!\n\n## Publish\n\nPublishing is handled by a 2-branch [pre-release process](https://intuit.github.io/auto/docs/generated/shipit#next-branch-default), configured in `publish-auto.yml`. All changes should be based off the default `next` branch, and are published automatically.\n\n-   PRs made into the default branch are auto-deployed to the `next` pre-release tag on NPM. The result can be installed with `npm install ts-json-schema-generator@next`\n    -   When merging into `next`, please use the `squash and merge` strategy.\n-   To release a new stable version, open a PR from `next` into `stable` using this [compare link](https://github.com/vega/ts-json-schema-generator/compare/stable...next).\n    -   When merging from `next` into `stable`, please use the `create a merge commit` strategy.\n",
      "readmeFilename": "README.md",
      "gitHead": "7266c79e4907ca3a2d13c71afee10ad60aa6014a",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.97.1--canary.1039.7266c79.0",
      "_nodeVersion": "16.13.0",
      "_npmVersion": "8.1.0",
      "dist": {
        "integrity": "sha512-vgSnAAbJMLDio86DXb2mEDwdiyPx23ZfCMxUZsmAygqbprk2kiX7Yy7quiiI0ZTX4cThZG/XTboGvw4R+9iGdQ==",
        "shasum": "1311570e446971bf8b8e3140532d21ca67b44870",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.97.1--canary.1039.7266c79.0.tgz",
        "fileCount": 631,
        "unpackedSize": 735328,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJhpWHxCRA9TVsSAnZWagAAgIkP/RNug0lEuiPRgP6ASimz\nPnoe9xZr7aDv3mTqI2t3pctKtP0U4ayeCiMxXMB0YzaG4t9xFW0hPaJsj6s5\n4ufqEB4Zt2GwlG20RrQvTKofuQJsKWXuJeopxbhVjeFrrov+8Ca5Mq7Yn9mw\nz1e0N8VNKQryGmg+3RPe3Zw75nXF0AujLwcsCr75vZJ6utUdCT/ymwgRjt77\n2Kj8WH3PSocrB/uUP9XpzikLVch/n6cSAO9qeEW561VNbmuVZSYqRF4CfVvv\nRjBZDZfo5FhJ9yWR3D59nmnBKOmJrKJCfaz/sY5e02ty3S9jsGOZaC7VUVkY\nSzziS1+e4U7nh1FZpEB4GgSG/mN4Qm4JrJJzYwrLYiVP/jE5gGT2hvzlvWUp\nLYx/VZ+Ws7qj9z1JRbXM1V7pTLj0kzKUJqSR6u2uDDPH6jPekn7pnHq3NdUo\nwPNVEWSUTZb2lESy8Gu+EHdmdKgpNHXG6yDj3mjUIwl3iXg9LETsvVRCl8vD\nEuNosarFNL8r0QTe6JDdziF/0Qj5qjTuOzjXLz/yw+basbZKSSTfk9InQwVX\n5EBc3V6sbOtRaxXV8BUl+TxhPzG0xEoNFkcdTqBXFTHQKGhV2pvmLy03r2oT\nU6Vpd9laiOpvNRbrIJdp+w3Dwfwrpu1vQEZPjakkdxjF4VTg9d6gyRyaupoZ\nRKMJ\r\n=ij2N\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEQCIEoZ7GrcDIiuDgbNflZ/+/gShzWu5dkTlPKAGuDPHWteAiB2YcTckKfjan4xYfSl47kMzGBlaW4nHHkNRXeGzUxbHg=="
          }
        ]
      },
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "maintainers": [
        {
          "name": "jheer",
          "email": "jeffrey.heer@gmail.com"
        },
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "kanitw",
          "email": "kanitw@gmail.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.97.1--canary.1039.7266c79.0_1638228465623_0.7480248712067679"
      },
      "_hasShrinkwrap": false
    },
    "0.97.1--canary.1045.b192845.0": {
      "name": "ts-json-schema-generator",
      "version": "0.97.1--canary.1045.b192845.0",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "MooYeol Prescott Lee",
          "email": "mooyoul@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=10.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.9",
        "commander": "^8.3.0",
        "glob": "^7.2.0",
        "safe-stable-stringify": "^2.2.0",
        "json5": "^2.2.0",
        "typescript": "~4.5.2"
      },
      "devDependencies": {
        "@auto-it/conventional-commits": "^10.32.3",
        "@auto-it/first-time-contributor": "^10.32.3",
        "@babel/core": "^7.16.0",
        "@babel/preset-env": "^7.16.4",
        "@babel/preset-typescript": "^7.16.0",
        "@types/glob": "^7.2.0",
        "@types/jest": "^27.0.3",
        "@types/node": "^16.11.10",
        "@typescript-eslint/eslint-plugin": "^5.4.0",
        "@typescript-eslint/parser": "^5.4.0",
        "ajv": "^8.8.2",
        "ajv-formats": "^2.1.1",
        "auto": "^10.32.3",
        "chai": "^4.3.4",
        "cross-env": "^7.0.3",
        "eslint": "^8.3.0",
        "eslint-config-prettier": "^8.3.0",
        "eslint-plugin-prettier": "^4.0.0",
        "jest": "^27.3.1",
        "jest-junit": "^13.0.0",
        "prettier": "^2.5.0",
        "ts-node": "^10.4.0",
        "vega": "^5.21.0",
        "vega-lite": "^5.2.0"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint \"{src,test,factory}/**/*.ts\"",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "cross-env FAST_TEST=1 jest test/ --verbose",
        "test:coverage": "yarn jest test/ --collectCoverage=true",
        "test:update": "cross-env UPDATE_SCHEMA=true yarn test:fast",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts",
        "release": "yarn build && auto shipit"
      },
      "readme": "# ts-json-schema-generator\n\n![Test](https://github.com/vega/ts-json-schema-generator/workflows/Test/badge.svg)\n[![codecov](https://codecov.io/gh/vega/ts-json-schema-generator/branch/master/graph/badge.svg)](https://codecov.io/gh/vega/ts-json-schema-generator)\n[![npm version](https://img.shields.io/npm/v/ts-json-schema-generator.svg)](https://www.npmjs.com/package/ts-json-schema-generator)\n\nExtended version of [https://github.com/xiag-ag/typescript-to-json-schema](https://github.com/xiag-ag/typescript-to-json-schema).\n\nInspired by [`YousefED/typescript-json-schema`](https://github.com/YousefED/typescript-json-schema). Here's the differences list:\n\n-   this implementation avoids the use of `typeChecker.getTypeAtLocation()` (so probably it keeps correct type aliases)\n-   processing AST and formatting JSON schema have been split into two independent steps\n-   not exported types, interfaces, enums are not exposed in the `definitions` section in the JSON schema\n\n## Contributors\n\nThis project is made possible by a [community of contributors](https://github.com/vega/ts-json-schema-generator/graphs/contributors). We welcome contributions of any kind (issues, code, documentation, examples, tests,...). Please read our [code of conduct](https://github.com/vega/vega/blob/master/CODE_OF_CONDUCT.md).\n\n## CLI Usage\n\n```bash\nnpm install --save ts-json-schema-generator\n./node_modules/.bin/ts-json-schema-generator --path 'my/project/**/*.ts' --type 'My.Type.Name'\n```\n\nNote that different platforms (e.g. Windows) may use different path separators so you may have to adjust the command above.\n\n## Programmatic Usage\n\n```js\n// main.js\n\nconst tsj = require(\"ts-json-schema-generator\");\nconst fs = require(\"fs\");\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst output_path = \"path/to/output/file\";\n\nconst schema = tsj.createGenerator(config).createSchema(config.type);\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\nRun the schema generator via `node main.js`.\n\n### Custom formatting\n\nExtending the built-in formatting is possible by creating a custom formatter and adding it to the main formatter:\n\n1. First we create a formatter, in this case for formatting function types:\n\n```ts\n// my-function-formatter.ts\nimport { BaseType, Definition, FunctionType, SubTypeFormatter } from \"ts-json-schema-generator\";\nimport ts from \"typescript\";\n\nexport class MyFunctionTypeFormatter implements SubTypeFormatter {\n    // You can skip this line if you don't need childTypeFormatter\n    public constructor(private childTypeFormatter: TypeFormatter) {}\n\n    public supportsType(type: FunctionType): boolean {\n        return type instanceof FunctionType;\n    }\n\n    public getDefinition(type: FunctionType): Definition {\n        // Return a custom schema for the function property.\n        return {\n            type: \"object\",\n            properties: {\n                isFunction: {\n                    type: \"boolean\",\n                    const: true,\n                },\n            },\n        };\n    }\n\n    // If this type does NOT HAVE children, generally all you need is:\n    public getChildren(type: FunctionType): BaseType[] {\n        return [];\n    }\n\n    // However, if children ARE supported, you'll need something similar to\n    // this (see src/TypeFormatter/{Array,Definition,etc}.ts for some examples):\n    public getChildren(type: FunctionType): BaseType[] {\n        return this.childTypeFormatter.getChildren(type.getType());\n    }\n}\n```\n\n2. Then we add the formatter as a child to the core formatter using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyFunctionTypeFormatter } from \"./my-function-formatter.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\n// We configure the formatter an add our custom formatter to it.\nconst formatter = createFormatter(config, (fmt, circularReferenceTypeFormatter) => {\n    // If your formatter DOES NOT support children, e.g. getChildren() { return [] }:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter());\n    // If your formatter DOES support children, you'll need this reference too:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter(circularReferenceTypeFormatter));\n});\n\nconst program = createProgram(config);\nconst parser = createParser(program, config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n### Custom parsing\n\nSimilar to custom formatting, extending the built-in parsing works practically the same way:\n\n1. First we create a parser, in this case for parsing construct types:\n\n```ts\n// my-constructor-parser.ts\nimport { Context, StringType, ReferenceType, BaseType, SubNodeParser } from \"ts-json-schema-generator\";\nimport ts from \"typescript\";\n\nexport class MyConstructorParser implements SubNodeParser {\n    supportsNode(node: ts.Node): boolean {\n        return node.kind === ts.SyntaxKind.ConstructorType;\n    }\n    createType(node: ts.Node, context: Context, reference?: ReferenceType): BaseType | undefined {\n        return new StringType(); // Treat constructors as strings in this example\n    }\n}\n```\n\n2. Then we add the parser as a child to the core parser using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyConstructorParser } from \"./my-constructor-parser.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst program = createProgram(config);\n\n// We configure the parser an add our custom parser to it.\nconst parser = createParser(program, config, (prs) => {\n    prs.addNodeParser(new MyConstructorParser());\n});\n\nconst formatter = createFormatter(config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n## Options\n\n```\n-p, --path 'index.ts'\n    The path to the TypeScript source file. If this is not provided, the type will be searched in the project specified in the `.tsconfig`.\n\n-t, --type 'My.Type.Name'\n    The type the generated schema will represent. If omitted, the generated schema will contain all\n    types found in the files matching path. The same is true if '*' is specified.\n\n-i, --id 'generatedSchemaId'\n    The `$id` of the generated schema. If omitted, there will be no `$id`.\n\n-e, --expose <all|none|export>\n    all: Create shared $ref definitions for all types.\n    none: Do not create shared $ref definitions.\n    export (default): Create shared $ref definitions only for exported types (not tagged as `@internal`).\n\n-f, --tsconfig 'my/project/tsconfig.json'\n    Use a custom tsconfig file for processing typescript (see https://www.typescriptlang.org/docs/handbook/tsconfig-json.html) instead of the default:\n    {\n        \"compilerOptions\": {\n            \"noEmit\": true,\n            \"emitDecoratorMetadata\": true,\n            \"experimentalDecorators\": true,\n            \"target\": \"ES5\",\n            \"module\": \"CommonJS\",\n            \"strictNullChecks\": false,\n        }\n    }\n\n-j, --jsDoc <extended|none|basic>\n    none: Do not use JsDoc annotations.\n    basic: Read JsDoc annotations to provide schema properties.\n    extended (default): Also read @nullable, and @asType annotations.\n\n--unstable\n    Do not sort properties.\n\n--strict-tuples\n    Do not allow additional items on tuples.\n\n--no-top-ref\n    Do not create a top-level $ref definition.\n\n--no-type-check\n    Skip type checks for better performance.\n\n--no-ref-encode\n    Do not encode references. According to the standard, references must be valid URIs but some tools do not support encoded references.\n\n--validation-keywords\n    Provide additional validation keywords to include.\n\n-o, --out\n    Specify the output file path. Without this option, the generator logs the response in the console.\n\n--additional-properties <true|false>\n    Controls whether or not to allow additional properties for objects that have no index signature.\n\n    true: Additional properties are allowed\n    false (default): Additional properties are not allowed\n```\n\n## Current state\n\n-   `interface` types\n-   `enum` types\n-   `union`, `tuple`, `type[]` types\n-   `Date`, `RegExp` types\n-   `string`, `boolean`, `number` types\n-   `\"value\"`, `123`, `true`, `false`, `null`, `undefined` literals\n-   type aliases\n-   generics\n-   `typeof`\n-   `keyof`\n-   conditional types\n\n## Run locally\n\n`yarn --silent run run --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\n## Debug\n\n`yarn --silent run debug --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\nAnd connect via the debugger protocol.\n\n[AST Explorer](https://astexplorer.net/) is amazing for developers of this tool!\n\n## Publish\n\nPublishing is handled by a 2-branch [pre-release process](https://intuit.github.io/auto/docs/generated/shipit#next-branch-default), configured in `publish-auto.yml`. All changes should be based off the default `next` branch, and are published automatically.\n\n-   PRs made into the default branch are auto-deployed to the `next` pre-release tag on NPM. The result can be installed with `npm install ts-json-schema-generator@next`\n    -   When merging into `next`, please use the `squash and merge` strategy.\n-   To release a new stable version, open a PR from `next` into `stable` using this [compare link](https://github.com/vega/ts-json-schema-generator/compare/stable...next).\n    -   When merging from `next` into `stable`, please use the `create a merge commit` strategy.\n",
      "readmeFilename": "README.md",
      "gitHead": "b192845163021a7ce548ccaa008e5dc314b89154",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.97.1--canary.1045.b192845.0",
      "_nodeVersion": "16.13.0",
      "_npmVersion": "8.1.0",
      "dist": {
        "integrity": "sha512-8Q4V31kDCWTn3fQ04KO8cUiacetl2q0LUg8/qOByJ/fXdOUhEjMnzxAQbM9H4bnIMDmOP7fsL/hnim7+5ZMpeg==",
        "shasum": "f11b601769bae3f0c62c12be9299c199082aea10",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.97.1--canary.1045.b192845.0.tgz",
        "fileCount": 631,
        "unpackedSize": 734890,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJhprWyCRA9TVsSAnZWagAAIH4P+QH0luv0lLVytIR83nmn\nuATx0nbVC9KX81jpaZRNEqvhk00vi7wOwejmH9tlwXj4uXPWcUIrOzVBXUN4\nsmUIrs5bvZjlFP1uMNacG61SAPIfGQ3O6cb92VslnOYE4H9vu05/46pK4+LF\n1BH2TCPeuvzLa9j5hN0RoqYfj99jqB4XfSYIXAnW8+Xm/LBKty7tNy3OXVmm\nJhqERaCYf10H5GAG28N7ZH1qOIOZKo1z4OcsRtwBfntzq0o1ihG8DUsTeAC4\ncKzZ9RztbsfFWNMRIKL1aB96VgRs7/XgfZ+3042RVdtUPRGA6qyZuad8aG1y\nBBqiJJFgUylwUSkmJEA8jOTF9gxwNTLrOvnvlTv0dW8o62RpLjvAd8P7jNfI\nVjkn7YxnxQpPgqTI3N1+4NWyg5JY6ieWpBv0hBLdBwk4bizHWuLR3iaCztfo\nlnGzTA9Gl+EdLybLFI2+ADCz7aIl0rq6ipsmgOhocNrutfVUKmCA9ZkUjUNP\n6VQHMs64OjVgjbAZDxChyCOWoeskM7yiOD1DCHfDEHy2EYVj06slHt3jjCi9\n33B+FXVjoupHVBI/81G0K7GSMb0zYkkPGLZwYNjZJ3v0eyUMvBlkDBzcwfzB\nNftapM0gdy/7W0RzZJ1Qp0dDcjZvT4oOq4UUuJaDMEvkX0OUkOKo1pKO+rR9\nc0Wb\r\n=Drv3\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIDnPEatkzQCgb/HonDlQEIuvDX0CHHvY9pPn1JvihzFpAiEAsyZYh21o9gmsaWNYrBfshqzhabST5UTTIffOP5ES3K8="
          }
        ]
      },
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "maintainers": [
        {
          "name": "jheer",
          "email": "jeffrey.heer@gmail.com"
        },
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "kanitw",
          "email": "kanitw@gmail.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.97.1--canary.1045.b192845.0_1638315442029_0.30301634489972096"
      },
      "_hasShrinkwrap": false
    },
    "0.97.1--canary.1092.074aec1.0": {
      "name": "ts-json-schema-generator",
      "version": "0.97.1--canary.1092.074aec1.0",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "MooYeol Prescott Lee",
          "email": "mooyoul@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=10.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.9",
        "commander": "^8.3.0",
        "glob": "^7.2.0",
        "safe-stable-stringify": "^2.3.1",
        "json5": "^2.2.0",
        "typescript": "~4.5.4"
      },
      "devDependencies": {
        "@auto-it/conventional-commits": "^10.32.5",
        "@auto-it/first-time-contributor": "^10.32.5",
        "@babel/core": "^7.16.7",
        "@babel/preset-env": "^7.16.8",
        "@babel/preset-typescript": "^7.16.7",
        "@types/glob": "^7.2.0",
        "@types/jest": "^27.4.0",
        "@types/node": "^17.0.8",
        "@typescript-eslint/eslint-plugin": "^5.9.1",
        "@typescript-eslint/parser": "^5.9.1",
        "ajv": "^8.8.2",
        "ajv-formats": "^2.1.1",
        "auto": "^10.32.5",
        "chai": "^4.3.4",
        "cross-env": "^7.0.3",
        "eslint": "^8.6.0",
        "eslint-config-prettier": "^8.3.0",
        "eslint-plugin-prettier": "^4.0.0",
        "jest": "^27.4.7",
        "jest-junit": "^13.0.0",
        "prettier": "^2.5.1",
        "ts-node": "^10.4.0",
        "vega": "^5.21.0",
        "vega-lite": "^5.2.0"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint \"{src,test,factory}/**/*.ts\"",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "cross-env FAST_TEST=1 jest test/ --verbose",
        "test:coverage": "yarn jest test/ --collectCoverage=true",
        "test:update": "cross-env UPDATE_SCHEMA=true yarn test:fast",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node ts-json-schema-generator.ts",
        "release": "yarn build && auto shipit"
      },
      "readme": "# ts-json-schema-generator\n\n![Test](https://github.com/vega/ts-json-schema-generator/workflows/Test/badge.svg)\n[![codecov](https://codecov.io/gh/vega/ts-json-schema-generator/branch/master/graph/badge.svg)](https://codecov.io/gh/vega/ts-json-schema-generator)\n[![npm version](https://img.shields.io/npm/v/ts-json-schema-generator.svg)](https://www.npmjs.com/package/ts-json-schema-generator)\n\nExtended version of [https://github.com/xiag-ag/typescript-to-json-schema](https://github.com/xiag-ag/typescript-to-json-schema).\n\nInspired by [`YousefED/typescript-json-schema`](https://github.com/YousefED/typescript-json-schema). Here's the differences list:\n\n-   this implementation avoids the use of `typeChecker.getTypeAtLocation()` (so probably it keeps correct type aliases)\n-   processing AST and formatting JSON schema have been split into two independent steps\n-   not exported types, interfaces, enums are not exposed in the `definitions` section in the JSON schema\n\n## Contributors\n\nThis project is made possible by a [community of contributors](https://github.com/vega/ts-json-schema-generator/graphs/contributors). We welcome contributions of any kind (issues, code, documentation, examples, tests,...). Please read our [code of conduct](https://github.com/vega/vega/blob/master/CODE_OF_CONDUCT.md).\n\n## CLI Usage\n\n```bash\nnpm install --save ts-json-schema-generator\n./node_modules/.bin/ts-json-schema-generator --path 'my/project/**/*.ts' --type 'My.Type.Name'\n```\n\nNote that different platforms (e.g. Windows) may use different path separators so you may have to adjust the command above.\n\n## Programmatic Usage\n\n```js\n// main.js\n\nconst tsj = require(\"ts-json-schema-generator\");\nconst fs = require(\"fs\");\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst output_path = \"path/to/output/file\";\n\nconst schema = tsj.createGenerator(config).createSchema(config.type);\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\nRun the schema generator via `node main.js`.\n\n### Custom formatting\n\nExtending the built-in formatting is possible by creating a custom formatter and adding it to the main formatter:\n\n1. First we create a formatter, in this case for formatting function types:\n\n```ts\n// my-function-formatter.ts\nimport { BaseType, Definition, FunctionType, SubTypeFormatter } from \"ts-json-schema-generator\";\nimport ts from \"typescript\";\n\nexport class MyFunctionTypeFormatter implements SubTypeFormatter {\n    // You can skip this line if you don't need childTypeFormatter\n    public constructor(private childTypeFormatter: TypeFormatter) {}\n\n    public supportsType(type: FunctionType): boolean {\n        return type instanceof FunctionType;\n    }\n\n    public getDefinition(type: FunctionType): Definition {\n        // Return a custom schema for the function property.\n        return {\n            type: \"object\",\n            properties: {\n                isFunction: {\n                    type: \"boolean\",\n                    const: true,\n                },\n            },\n        };\n    }\n\n    // If this type does NOT HAVE children, generally all you need is:\n    public getChildren(type: FunctionType): BaseType[] {\n        return [];\n    }\n\n    // However, if children ARE supported, you'll need something similar to\n    // this (see src/TypeFormatter/{Array,Definition,etc}.ts for some examples):\n    public getChildren(type: FunctionType): BaseType[] {\n        return this.childTypeFormatter.getChildren(type.getType());\n    }\n}\n```\n\n2. Then we add the formatter as a child to the core formatter using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyFunctionTypeFormatter } from \"./my-function-formatter.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\n// We configure the formatter an add our custom formatter to it.\nconst formatter = createFormatter(config, (fmt, circularReferenceTypeFormatter) => {\n    // If your formatter DOES NOT support children, e.g. getChildren() { return [] }:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter());\n    // If your formatter DOES support children, you'll need this reference too:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter(circularReferenceTypeFormatter));\n});\n\nconst program = createProgram(config);\nconst parser = createParser(program, config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n### Custom parsing\n\nSimilar to custom formatting, extending the built-in parsing works practically the same way:\n\n1. First we create a parser, in this case for parsing construct types:\n\n```ts\n// my-constructor-parser.ts\nimport { Context, StringType, ReferenceType, BaseType, SubNodeParser } from \"ts-json-schema-generator\";\nimport ts from \"typescript\";\n\nexport class MyConstructorParser implements SubNodeParser {\n    supportsNode(node: ts.Node): boolean {\n        return node.kind === ts.SyntaxKind.ConstructorType;\n    }\n    createType(node: ts.Node, context: Context, reference?: ReferenceType): BaseType | undefined {\n        return new StringType(); // Treat constructors as strings in this example\n    }\n}\n```\n\n2. Then we add the parser as a child to the core parser using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyConstructorParser } from \"./my-constructor-parser.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst program = createProgram(config);\n\n// We configure the parser an add our custom parser to it.\nconst parser = createParser(program, config, (prs) => {\n    prs.addNodeParser(new MyConstructorParser());\n});\n\nconst formatter = createFormatter(config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n## Options\n\n```\n-p, --path 'index.ts'\n    The path to the TypeScript source file. If this is not provided, the type will be searched in the project specified in the `.tsconfig`.\n\n-t, --type 'My.Type.Name'\n    The type the generated schema will represent. If omitted, the generated schema will contain all\n    types found in the files matching path. The same is true if '*' is specified.\n\n-i, --id 'generatedSchemaId'\n    The `$id` of the generated schema. If omitted, there will be no `$id`.\n\n-e, --expose <all|none|export>\n    all: Create shared $ref definitions for all types.\n    none: Do not create shared $ref definitions.\n    export (default): Create shared $ref definitions only for exported types (not tagged as `@internal`).\n\n-f, --tsconfig 'my/project/tsconfig.json'\n    Use a custom tsconfig file for processing typescript (see https://www.typescriptlang.org/docs/handbook/tsconfig-json.html) instead of the default:\n    {\n        \"compilerOptions\": {\n            \"noEmit\": true,\n            \"emitDecoratorMetadata\": true,\n            \"experimentalDecorators\": true,\n            \"target\": \"ES5\",\n            \"module\": \"CommonJS\",\n            \"strictNullChecks\": false,\n        }\n    }\n\n-j, --jsDoc <extended|none|basic>\n    none: Do not use JsDoc annotations.\n    basic: Read JsDoc annotations to provide schema properties.\n    extended (default): Also read @nullable, and @asType annotations.\n\n--unstable\n    Do not sort properties.\n\n--strict-tuples\n    Do not allow additional items on tuples.\n\n--no-top-ref\n    Do not create a top-level $ref definition.\n\n--no-type-check\n    Skip type checks for better performance.\n\n--no-ref-encode\n    Do not encode references. According to the standard, references must be valid URIs but some tools do not support encoded references.\n\n--validation-keywords\n    Provide additional validation keywords to include.\n\n-o, --out\n    Specify the output file path. Without this option, the generator logs the response in the console.\n\n--additional-properties <true|false>\n    Controls whether or not to allow additional properties for objects that have no index signature.\n\n    true: Additional properties are allowed\n    false (default): Additional properties are not allowed\n```\n\n## Current state\n\n-   `interface` types\n-   `enum` types\n-   `union`, `tuple`, `type[]` types\n-   `Date`, `RegExp` types\n-   `string`, `boolean`, `number` types\n-   `\"value\"`, `123`, `true`, `false`, `null`, `undefined` literals\n-   type aliases\n-   generics\n-   `typeof`\n-   `keyof`\n-   conditional types\n\n## Run locally\n\n`yarn --silent run run --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\n## Debug\n\n`yarn --silent run debug --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\nAnd connect via the debugger protocol.\n\n[AST Explorer](https://astexplorer.net/) is amazing for developers of this tool!\n\n## Publish\n\nPublishing is handled by a 2-branch [pre-release process](https://intuit.github.io/auto/docs/generated/shipit#next-branch-default), configured in `publish-auto.yml`. All changes should be based off the default `next` branch, and are published automatically.\n\n-   PRs made into the default branch are auto-deployed to the `next` pre-release tag on NPM. The result can be installed with `npm install ts-json-schema-generator@next`\n    -   When merging into `next`, please use the `squash and merge` strategy.\n-   To release a new stable version, open a PR from `next` into `stable` using this [compare link](https://github.com/vega/ts-json-schema-generator/compare/stable...next).\n    -   When merging from `next` into `stable`, please use the `create a merge commit` strategy.\n",
      "readmeFilename": "README.md",
      "gitHead": "074aec1faeb45615d532eb9c0aae739c3d19f612",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.97.1--canary.1092.074aec1.0",
      "_nodeVersion": "16.13.1",
      "_npmVersion": "8.1.2",
      "dist": {
        "integrity": "sha512-W9rpFA9TiY6eXFFriTSaSWNyzpASP2Na/ZZCzNZvQiqdxFn0ddf+3bZ62VbSzB+1cKN9sA85z9yNaDxQXIhd8w==",
        "shasum": "e5fdfd20031758e2366b3f724de16bc86b1ed8a8",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.97.1--canary.1092.074aec1.0.tgz",
        "fileCount": 631,
        "unpackedSize": 735437,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJh311yCRA9TVsSAnZWagAA5MsP+wdGvk45X2nyVMhkKwpg\nMCqYKjA0CWSKbHmBX0Fn4LpH4+XAAWH/lVa5D9h/xA0YtiFR/+B/wJGACACd\nHjdr8e3RK/jRS5xlJNkSwew4Vu6Ea1Ap+yTNXF0aSue0P875HQFOFf9kDC87\nqYWXko28SBRZxNsjnNnFUHYMSL5gvt6RJ0HdvH/kfPfSPjxIfvdov+Dh7QF4\ni/t2sSB+F3pLMOL5ZL4G1uJ6phgZPE9mYIeRBBIaI87PfbaPDzeoPR362D33\nfAXGE7zMu+B4OarfTC/zLAgugFAMesYxl1WV9Jua4wO0g3RsatsqYuWpyWFj\nJEStbVOas5G3747CMkTYa/EFy6KuxSZsJAxslYE6i0yWxwzXNZGqf1NjERMF\n4ONTGMm0DpQMQCUuOtr2m+O5XkBZfA5i77wVKHQyYIJNi73Oq8cKCTSmBfeF\n6rCQETJe1Jol2XgA1NNaylUTdVgI71Q+4KZjFGyqZ9JzVERp+knfl/rkVlrI\n1SMO/emMFClmu1exaTu+UoJwgMpKk3XvFYh3js1YkvLFuA1hga7p++ykvafo\nQOgvJHO9sQZKcuhskXy5JZ2N/CDXnibljLYZYS+TRm18Oto6pnL3kEl4YY5T\nkqHBTZKmBR+v8T6J6ZK6LXggKghu9KSDr0TeAHiU7T63hJmtlN9TK5Fkm2XQ\nL6RY\r\n=r+c8\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIBAsefZ041G91JkPxU24niOCc6uwmQcVK6m4bjcR58dRAiEApUxfgF8sVrkNRns5YhyQnpEMLxnVYzWCpt8rSf26Ka0="
          }
        ]
      },
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "maintainers": [
        {
          "name": "jheer",
          "email": "jeffrey.heer@gmail.com"
        },
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "kanitw",
          "email": "kanitw@gmail.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.97.1--canary.1092.074aec1.0_1642028401797_0.8394469079064517"
      },
      "_hasShrinkwrap": false
    },
    "0.97.1--canary.1093.43d6c2f.0": {
      "name": "ts-json-schema-generator",
      "version": "0.97.1--canary.1093.43d6c2f.0",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "MooYeol Prescott Lee",
          "email": "mooyoul@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=10.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.9",
        "commander": "^8.3.0",
        "glob": "^7.2.0",
        "safe-stable-stringify": "^2.2.0",
        "json5": "^2.2.0",
        "typescript": "~4.5.2"
      },
      "devDependencies": {
        "@auto-it/conventional-commits": "^10.32.3",
        "@auto-it/first-time-contributor": "^10.32.3",
        "@babel/core": "^7.16.0",
        "@babel/preset-env": "^7.16.4",
        "@babel/preset-typescript": "^7.16.0",
        "@types/glob": "^7.2.0",
        "@types/jest": "^27.0.3",
        "@types/node": "^16.11.10",
        "@typescript-eslint/eslint-plugin": "^5.4.0",
        "@typescript-eslint/parser": "^5.4.0",
        "ajv": "^8.8.2",
        "ajv-formats": "^2.1.1",
        "auto": "^10.32.3",
        "chai": "^4.3.4",
        "cross-env": "^7.0.3",
        "eslint": "^8.3.0",
        "eslint-config-prettier": "^8.3.0",
        "eslint-plugin-prettier": "^4.0.0",
        "jest": "^27.3.1",
        "jest-junit": "^13.0.0",
        "prettier": "^2.5.0",
        "ts-node": "^10.4.0",
        "vega": "^5.21.0",
        "vega-lite": "^5.2.0"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint \"{src,test,factory}/**/*.ts\"",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "cross-env FAST_TEST=1 jest test/ --verbose",
        "test:coverage": "yarn jest test/ --collectCoverage=true",
        "test:update": "cross-env UPDATE_SCHEMA=true yarn test:fast",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node-transpile-only ts-json-schema-generator.ts",
        "release": "yarn build && auto shipit"
      },
      "readme": "# ts-json-schema-generator\n\n![Test](https://github.com/vega/ts-json-schema-generator/workflows/Test/badge.svg)\n[![codecov](https://codecov.io/gh/vega/ts-json-schema-generator/branch/master/graph/badge.svg)](https://codecov.io/gh/vega/ts-json-schema-generator)\n[![npm version](https://img.shields.io/npm/v/ts-json-schema-generator.svg)](https://www.npmjs.com/package/ts-json-schema-generator)\n\nExtended version of [https://github.com/xiag-ag/typescript-to-json-schema](https://github.com/xiag-ag/typescript-to-json-schema).\n\nInspired by [`YousefED/typescript-json-schema`](https://github.com/YousefED/typescript-json-schema). Here's the differences list:\n\n-   this implementation avoids the use of `typeChecker.getTypeAtLocation()` (so probably it keeps correct type aliases)\n-   processing AST and formatting JSON schema have been split into two independent steps\n-   not exported types, interfaces, enums are not exposed in the `definitions` section in the JSON schema\n\n## Contributors\n\nThis project is made possible by a [community of contributors](https://github.com/vega/ts-json-schema-generator/graphs/contributors). We welcome contributions of any kind (issues, code, documentation, examples, tests,...). Please read our [code of conduct](https://github.com/vega/vega/blob/master/CODE_OF_CONDUCT.md).\n\n## CLI Usage\n\n```bash\nnpm install --save ts-json-schema-generator\n./node_modules/.bin/ts-json-schema-generator --path 'my/project/**/*.ts' --type 'My.Type.Name'\n```\n\nNote that different platforms (e.g. Windows) may use different path separators so you may have to adjust the command above.\n\n## Programmatic Usage\n\n```js\n// main.js\n\nconst tsj = require(\"ts-json-schema-generator\");\nconst fs = require(\"fs\");\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst output_path = \"path/to/output/file\";\n\nconst schema = tsj.createGenerator(config).createSchema(config.type);\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\nRun the schema generator via `node main.js`.\n\n### Custom formatting\n\nExtending the built-in formatting is possible by creating a custom formatter and adding it to the main formatter:\n\n1. First we create a formatter, in this case for formatting function types:\n\n```ts\n// my-function-formatter.ts\nimport { BaseType, Definition, FunctionType, SubTypeFormatter } from \"ts-json-schema-generator\";\nimport ts from \"typescript\";\n\nexport class MyFunctionTypeFormatter implements SubTypeFormatter {\n    // You can skip this line if you don't need childTypeFormatter\n    public constructor(private childTypeFormatter: TypeFormatter) {}\n\n    public supportsType(type: FunctionType): boolean {\n        return type instanceof FunctionType;\n    }\n\n    public getDefinition(type: FunctionType): Definition {\n        // Return a custom schema for the function property.\n        return {\n            type: \"object\",\n            properties: {\n                isFunction: {\n                    type: \"boolean\",\n                    const: true,\n                },\n            },\n        };\n    }\n\n    // If this type does NOT HAVE children, generally all you need is:\n    public getChildren(type: FunctionType): BaseType[] {\n        return [];\n    }\n\n    // However, if children ARE supported, you'll need something similar to\n    // this (see src/TypeFormatter/{Array,Definition,etc}.ts for some examples):\n    public getChildren(type: FunctionType): BaseType[] {\n        return this.childTypeFormatter.getChildren(type.getType());\n    }\n}\n```\n\n2. Then we add the formatter as a child to the core formatter using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyFunctionTypeFormatter } from \"./my-function-formatter.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\n// We configure the formatter an add our custom formatter to it.\nconst formatter = createFormatter(config, (fmt, circularReferenceTypeFormatter) => {\n    // If your formatter DOES NOT support children, e.g. getChildren() { return [] }:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter());\n    // If your formatter DOES support children, you'll need this reference too:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter(circularReferenceTypeFormatter));\n});\n\nconst program = createProgram(config);\nconst parser = createParser(program, config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n### Custom parsing\n\nSimilar to custom formatting, extending the built-in parsing works practically the same way:\n\n1. First we create a parser, in this case for parsing construct types:\n\n```ts\n// my-constructor-parser.ts\nimport { Context, StringType, ReferenceType, BaseType, SubNodeParser } from \"ts-json-schema-generator\";\nimport ts from \"typescript\";\n\nexport class MyConstructorParser implements SubNodeParser {\n    supportsNode(node: ts.Node): boolean {\n        return node.kind === ts.SyntaxKind.ConstructorType;\n    }\n    createType(node: ts.Node, context: Context, reference?: ReferenceType): BaseType | undefined {\n        return new StringType(); // Treat constructors as strings in this example\n    }\n}\n```\n\n2. Then we add the parser as a child to the core parser using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyConstructorParser } from \"./my-constructor-parser.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst program = createProgram(config);\n\n// We configure the parser an add our custom parser to it.\nconst parser = createParser(program, config, (prs) => {\n    prs.addNodeParser(new MyConstructorParser());\n});\n\nconst formatter = createFormatter(config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n## Options\n\n```\n-p, --path 'index.ts'\n    The path to the TypeScript source file. If this is not provided, the type will be searched in the project specified in the `.tsconfig`.\n\n-t, --type 'My.Type.Name'\n    The type the generated schema will represent. If omitted, the generated schema will contain all\n    types found in the files matching path. The same is true if '*' is specified.\n\n-i, --id 'generatedSchemaId'\n    The `$id` of the generated schema. If omitted, there will be no `$id`.\n\n-e, --expose <all|none|export>\n    all: Create shared $ref definitions for all types.\n    none: Do not create shared $ref definitions.\n    export (default): Create shared $ref definitions only for exported types (not tagged as `@internal`).\n\n-f, --tsconfig 'my/project/tsconfig.json'\n    Use a custom tsconfig file for processing typescript (see https://www.typescriptlang.org/docs/handbook/tsconfig-json.html) instead of the default:\n    {\n        \"compilerOptions\": {\n            \"noEmit\": true,\n            \"emitDecoratorMetadata\": true,\n            \"experimentalDecorators\": true,\n            \"target\": \"ES5\",\n            \"module\": \"CommonJS\",\n            \"strictNullChecks\": false,\n        }\n    }\n\n-j, --jsDoc <extended|none|basic>\n    none: Do not use JsDoc annotations.\n    basic: Read JsDoc annotations to provide schema properties.\n    extended (default): Also read @nullable, and @asType annotations.\n\n--unstable\n    Do not sort properties.\n\n--strict-tuples\n    Do not allow additional items on tuples.\n\n--no-top-ref\n    Do not create a top-level $ref definition.\n\n--no-type-check\n    Skip type checks for better performance.\n\n--no-ref-encode\n    Do not encode references. According to the standard, references must be valid URIs but some tools do not support encoded references.\n\n--validation-keywords\n    Provide additional validation keywords to include.\n\n-o, --out\n    Specify the output file path. Without this option, the generator logs the response in the console.\n\n--additional-properties <true|false>\n    Controls whether or not to allow additional properties for objects that have no index signature.\n\n    true: Additional properties are allowed\n    false (default): Additional properties are not allowed\n```\n\n## Current state\n\n-   `interface` types\n-   `enum` types\n-   `union`, `tuple`, `type[]` types\n-   `Date`, `RegExp` types\n-   `string`, `boolean`, `number` types\n-   `\"value\"`, `123`, `true`, `false`, `null`, `undefined` literals\n-   type aliases\n-   generics\n-   `typeof`\n-   `keyof`\n-   conditional types\n\n## Run locally\n\n`yarn --silent run run --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\n## Debug\n\n`yarn --silent run debug --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\nAnd connect via the debugger protocol.\n\n[AST Explorer](https://astexplorer.net/) is amazing for developers of this tool!\n\n## Publish\n\nPublishing is handled by a 2-branch [pre-release process](https://intuit.github.io/auto/docs/generated/shipit#next-branch-default), configured in `publish-auto.yml`. All changes should be based off the default `next` branch, and are published automatically.\n\n-   PRs made into the default branch are auto-deployed to the `next` pre-release tag on NPM. The result can be installed with `npm install ts-json-schema-generator@next`\n    -   When merging into `next`, please use the `squash and merge` strategy.\n-   To release a new stable version, open a PR from `next` into `stable` using this [compare link](https://github.com/vega/ts-json-schema-generator/compare/stable...next).\n    -   When merging from `next` into `stable`, please use the `create a merge commit` strategy.\n",
      "readmeFilename": "README.md",
      "gitHead": "43d6c2fa9369d456766476dafb4a41851b201882",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.97.1--canary.1093.43d6c2f.0",
      "_nodeVersion": "16.13.2",
      "_npmVersion": "8.1.2",
      "dist": {
        "integrity": "sha512-4u1PyRs4CERY4Y7AexSJV0/E3PVAiBO05bdeZxU98Cf03l555sAytBKgtjY7uOsmYng9D1s8imIk6P9n7EqYPQ==",
        "shasum": "886b4895846c296bc3f6f334655093e558eb8152",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.97.1--canary.1093.43d6c2f.0.tgz",
        "fileCount": 631,
        "unpackedSize": 735818,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJh4MxMCRA9TVsSAnZWagAA3KIP+wfFEDucj7iRAVvSJGiv\n6UqN8+GzSWu28imbToraAJS0K43FuKoJdkpsy2HodJQNDOJfFKSyAwRQYrEJ\ncpWmnOnqCROLZulkfLeGEB0Wyc365uSH6P5OpdVlrGEqdmcmObpvj+P+CQuz\ndRYxl9EE/hdkL9lVwSVh9icRv6W/kGg2YQ8i6Qi8bmzVzXORmTERhxxvtElL\nSLuL7CyvTnXtJ7CAHEQLT8PgRsX2TgDcUH5xGleYzDcpYH/7BXQ+n57caVvc\nde6WKtIRszCgiwsDVMqLHzisi45Wz7iZCFJQ560X0N2d84sjC4qN5ewSuwHF\n9bqSdOW5nUlhhECkREjBWrUkteeM/+zuAhGZrAIJcLSZjfb/eRhyUBLCRFFs\nxhU/0oP4wQhYM+t8FIRxcKzi6BkHPhikExCRkoElwuUcaOBAzb0I/BuBLlRi\nh8Twpl86IH8pwoDsbItXs0NNKBLuSyVd6VJd56/dBOq0jmr1jKqUDCS2Iu14\nQDPE+HjXjMTOJWbHvub9bQ04iWT9l/r/Y1BPOvNbzpwbtkIDYCHXxMfVTJw2\nCS3PpTeaN30ksoMht1ZFx8VlVw+P5uDKBP3LA3LvBXAjyVosr8BHd+k86X/g\nlsFMYhAStrnHGAndbUaaZUy+pOLz/oxvq+ouQHFmg1KGrCZ0UKl/5E+0JsLo\n7PPD\r\n=V8DA\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEYCIQC4ydhc1aO0xiQk6U9FaaPQFTLM0LoE+AluVi9uGOG3IgIhAJkErHnkaSkuL2zAmR42NXQPa8q8bTNztRg7cutuirBe"
          }
        ]
      },
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "maintainers": [
        {
          "name": "jheer",
          "email": "jeffrey.heer@gmail.com"
        },
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "kanitw",
          "email": "kanitw@gmail.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.97.1--canary.1093.43d6c2f.0_1642122315879_0.4412992250772487"
      },
      "_hasShrinkwrap": false
    },
    "0.97.1-next.0": {
      "name": "ts-json-schema-generator",
      "version": "0.97.1-next.0",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "MooYeol Prescott Lee",
          "email": "mooyoul@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=10.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.9",
        "commander": "^8.3.0",
        "glob": "^7.2.0",
        "safe-stable-stringify": "^2.3.1",
        "json5": "^2.2.0",
        "typescript": "~4.5.4"
      },
      "devDependencies": {
        "@auto-it/conventional-commits": "^10.32.5",
        "@auto-it/first-time-contributor": "^10.32.5",
        "@babel/core": "^7.16.7",
        "@babel/preset-env": "^7.16.8",
        "@babel/preset-typescript": "^7.16.7",
        "@types/glob": "^7.2.0",
        "@types/jest": "^27.4.0",
        "@types/node": "^17.0.8",
        "@typescript-eslint/eslint-plugin": "^5.9.1",
        "@typescript-eslint/parser": "^5.9.1",
        "ajv": "^8.8.2",
        "ajv-formats": "^2.1.1",
        "auto": "^10.32.5",
        "chai": "^4.3.4",
        "cross-env": "^7.0.3",
        "eslint": "^8.6.0",
        "eslint-config-prettier": "^8.3.0",
        "eslint-plugin-prettier": "^4.0.0",
        "jest": "^27.4.7",
        "jest-junit": "^13.0.0",
        "prettier": "^2.5.1",
        "ts-node": "^10.4.0",
        "vega": "^5.21.0",
        "vega-lite": "^5.2.0"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint \"{src,test,factory}/**/*.ts\"",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "cross-env FAST_TEST=1 jest test/ --verbose",
        "test:coverage": "yarn jest test/ --collectCoverage=true",
        "test:update": "cross-env UPDATE_SCHEMA=true yarn test:fast",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node-transpile-only ts-json-schema-generator.ts",
        "release": "yarn build && auto shipit"
      },
      "readme": "# ts-json-schema-generator\n\n![Test](https://github.com/vega/ts-json-schema-generator/workflows/Test/badge.svg)\n[![codecov](https://codecov.io/gh/vega/ts-json-schema-generator/branch/master/graph/badge.svg)](https://codecov.io/gh/vega/ts-json-schema-generator)\n[![npm version](https://img.shields.io/npm/v/ts-json-schema-generator.svg)](https://www.npmjs.com/package/ts-json-schema-generator)\n\nExtended version of [https://github.com/xiag-ag/typescript-to-json-schema](https://github.com/xiag-ag/typescript-to-json-schema).\n\nInspired by [`YousefED/typescript-json-schema`](https://github.com/YousefED/typescript-json-schema). Here's the differences list:\n\n-   this implementation avoids the use of `typeChecker.getTypeAtLocation()` (so probably it keeps correct type aliases)\n-   processing AST and formatting JSON schema have been split into two independent steps\n-   not exported types, interfaces, enums are not exposed in the `definitions` section in the JSON schema\n\n## Contributors\n\nThis project is made possible by a [community of contributors](https://github.com/vega/ts-json-schema-generator/graphs/contributors). We welcome contributions of any kind (issues, code, documentation, examples, tests,...). Please read our [code of conduct](https://github.com/vega/vega/blob/master/CODE_OF_CONDUCT.md).\n\n## CLI Usage\n\n```bash\nnpm install --save ts-json-schema-generator\n./node_modules/.bin/ts-json-schema-generator --path 'my/project/**/*.ts' --type 'My.Type.Name'\n```\n\nNote that different platforms (e.g. Windows) may use different path separators so you may have to adjust the command above.\n\n## Programmatic Usage\n\n```js\n// main.js\n\nconst tsj = require(\"ts-json-schema-generator\");\nconst fs = require(\"fs\");\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst output_path = \"path/to/output/file\";\n\nconst schema = tsj.createGenerator(config).createSchema(config.type);\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\nRun the schema generator via `node main.js`.\n\n### Custom formatting\n\nExtending the built-in formatting is possible by creating a custom formatter and adding it to the main formatter:\n\n1. First we create a formatter, in this case for formatting function types:\n\n```ts\n// my-function-formatter.ts\nimport { BaseType, Definition, FunctionType, SubTypeFormatter } from \"ts-json-schema-generator\";\nimport ts from \"typescript\";\n\nexport class MyFunctionTypeFormatter implements SubTypeFormatter {\n    // You can skip this line if you don't need childTypeFormatter\n    public constructor(private childTypeFormatter: TypeFormatter) {}\n\n    public supportsType(type: FunctionType): boolean {\n        return type instanceof FunctionType;\n    }\n\n    public getDefinition(type: FunctionType): Definition {\n        // Return a custom schema for the function property.\n        return {\n            type: \"object\",\n            properties: {\n                isFunction: {\n                    type: \"boolean\",\n                    const: true,\n                },\n            },\n        };\n    }\n\n    // If this type does NOT HAVE children, generally all you need is:\n    public getChildren(type: FunctionType): BaseType[] {\n        return [];\n    }\n\n    // However, if children ARE supported, you'll need something similar to\n    // this (see src/TypeFormatter/{Array,Definition,etc}.ts for some examples):\n    public getChildren(type: FunctionType): BaseType[] {\n        return this.childTypeFormatter.getChildren(type.getType());\n    }\n}\n```\n\n2. Then we add the formatter as a child to the core formatter using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyFunctionTypeFormatter } from \"./my-function-formatter.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\n// We configure the formatter an add our custom formatter to it.\nconst formatter = createFormatter(config, (fmt, circularReferenceTypeFormatter) => {\n    // If your formatter DOES NOT support children, e.g. getChildren() { return [] }:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter());\n    // If your formatter DOES support children, you'll need this reference too:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter(circularReferenceTypeFormatter));\n});\n\nconst program = createProgram(config);\nconst parser = createParser(program, config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n### Custom parsing\n\nSimilar to custom formatting, extending the built-in parsing works practically the same way:\n\n1. First we create a parser, in this case for parsing construct types:\n\n```ts\n// my-constructor-parser.ts\nimport { Context, StringType, ReferenceType, BaseType, SubNodeParser } from \"ts-json-schema-generator\";\nimport ts from \"typescript\";\n\nexport class MyConstructorParser implements SubNodeParser {\n    supportsNode(node: ts.Node): boolean {\n        return node.kind === ts.SyntaxKind.ConstructorType;\n    }\n    createType(node: ts.Node, context: Context, reference?: ReferenceType): BaseType | undefined {\n        return new StringType(); // Treat constructors as strings in this example\n    }\n}\n```\n\n2. Then we add the parser as a child to the core parser using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyConstructorParser } from \"./my-constructor-parser.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst program = createProgram(config);\n\n// We configure the parser an add our custom parser to it.\nconst parser = createParser(program, config, (prs) => {\n    prs.addNodeParser(new MyConstructorParser());\n});\n\nconst formatter = createFormatter(config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n## Options\n\n```\n-p, --path 'index.ts'\n    The path to the TypeScript source file. If this is not provided, the type will be searched in the project specified in the `.tsconfig`.\n\n-t, --type 'My.Type.Name'\n    The type the generated schema will represent. If omitted, the generated schema will contain all\n    types found in the files matching path. The same is true if '*' is specified.\n\n-i, --id 'generatedSchemaId'\n    The `$id` of the generated schema. If omitted, there will be no `$id`.\n\n-e, --expose <all|none|export>\n    all: Create shared $ref definitions for all types.\n    none: Do not create shared $ref definitions.\n    export (default): Create shared $ref definitions only for exported types (not tagged as `@internal`).\n\n-f, --tsconfig 'my/project/tsconfig.json'\n    Use a custom tsconfig file for processing typescript (see https://www.typescriptlang.org/docs/handbook/tsconfig-json.html) instead of the default:\n    {\n        \"compilerOptions\": {\n            \"noEmit\": true,\n            \"emitDecoratorMetadata\": true,\n            \"experimentalDecorators\": true,\n            \"target\": \"ES5\",\n            \"module\": \"CommonJS\",\n            \"strictNullChecks\": false,\n        }\n    }\n\n-j, --jsDoc <extended|none|basic>\n    none: Do not use JsDoc annotations.\n    basic: Read JsDoc annotations to provide schema properties.\n    extended (default): Also read @nullable, and @asType annotations.\n\n--unstable\n    Do not sort properties.\n\n--strict-tuples\n    Do not allow additional items on tuples.\n\n--no-top-ref\n    Do not create a top-level $ref definition.\n\n--no-type-check\n    Skip type checks for better performance.\n\n--no-ref-encode\n    Do not encode references. According to the standard, references must be valid URIs but some tools do not support encoded references.\n\n--validation-keywords\n    Provide additional validation keywords to include.\n\n-o, --out\n    Specify the output file path. Without this option, the generator logs the response in the console.\n\n--additional-properties <true|false>\n    Controls whether or not to allow additional properties for objects that have no index signature.\n\n    true: Additional properties are allowed\n    false (default): Additional properties are not allowed\n```\n\n## Current state\n\n-   `interface` types\n-   `enum` types\n-   `union`, `tuple`, `type[]` types\n-   `Date`, `RegExp` types\n-   `string`, `boolean`, `number` types\n-   `\"value\"`, `123`, `true`, `false`, `null`, `undefined` literals\n-   type aliases\n-   generics\n-   `typeof`\n-   `keyof`\n-   conditional types\n\n## Run locally\n\n`yarn --silent run run --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\n## Debug\n\n`yarn --silent run debug --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\nAnd connect via the debugger protocol.\n\n[AST Explorer](https://astexplorer.net/) is amazing for developers of this tool!\n\n## Publish\n\nPublishing is handled by a 2-branch [pre-release process](https://intuit.github.io/auto/docs/generated/shipit#next-branch-default), configured in `publish-auto.yml`. All changes should be based off the default `next` branch, and are published automatically.\n\n-   PRs made into the default branch are auto-deployed to the `next` pre-release tag on NPM. The result can be installed with `npm install ts-json-schema-generator@next`\n    -   When merging into `next`, please use the `squash and merge` strategy.\n-   To release a new stable version, open a PR from `next` into `stable` using this [compare link](https://github.com/vega/ts-json-schema-generator/compare/stable...next).\n    -   When merging from `next` into `stable`, please use the `create a merge commit` strategy.\n",
      "readmeFilename": "README.md",
      "gitHead": "7d108c6498e22c2c22165aacab1e8a30902af91c",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.97.1-next.0",
      "_nodeVersion": "16.13.2",
      "_npmVersion": "8.1.2",
      "dist": {
        "integrity": "sha512-LTq3lFhwiayiORTM/1nXFifbvlUnz2A/0Vi0qs/+WlVMVVMU4cxmMRrwp7sMySsaUIhWfqP3i5dOikUK90rN9g==",
        "shasum": "29ef0de167b6b893142ccac46f4687897f403468",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.97.1-next.0.tgz",
        "fileCount": 631,
        "unpackedSize": 736333,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJh4M8gCRA9TVsSAnZWagAAXnQP/3ReDlJ4257l90mjA+nX\nzyrS+jdNVTxAjZlUFkfZR1Oh6c3TNU5nFSWQM1l0enM0CsqlLmLjP544KKS6\naNaUt0rMXAwE9TAEeTtqg01ZyoPTon/cuFZMw87VPGb+//VqZbr1BdHvSvmh\nSRk4qzVZsKICqE9AEEYwPQ8IU9/DLufTNR/8a2eh4/PqMI+0l86VR6hdWt2v\nlBiEIlf5j8muYm8eQtbt12MVndujMR4FRyQ0aLSomNKR/Ibfi6rkMp7Gn+So\nqPVWw7lap4LSGoTNKvDIuw1603ycrwZ+Rt3NExyHMuzJtlzwBjzknT6YEfmx\njHGFVNKRDZq0WxH0ggZmtVKRzWNARxMoW8XvIy/qxh3x1iMCMbqqjZLfBnAw\nURdwaPciQcmy74sq45kqS2TP/TGY+po/UE4j1AF5twcPd/uqx9ixwOtpBlFX\n6tRQSD/1OyUlIA23zwsoDi0Ugp9JJmTyZxvbECG88MR5l8J+9esg1onwKfxn\nbtKXSFkhDR9AQ1e/QoG76spAWZ1a2Bmfchf8WA3AHT2LPY+tEBJXnxA2diOb\n5ARnzxODRNmk9DlakDOE1JcHY+GwB79YjryphIBAzI07TffdXhfljem7Z5be\nam7uzdhu1hds5hlYNhDWRXfH0scAcR6yrRRZwjTvVAv0THsykxXUe5niKb7Z\nQlPz\r\n=6z+w\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEQCICkGasWyCEZKOiR360x/s+QB8SqwKhoJqeBof2P4NGy/AiApchwG4rzY2ahG5w3GVSLNBP/IJ82JHUtloiFq9ukukw=="
          }
        ]
      },
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "maintainers": [
        {
          "name": "jheer",
          "email": "jeffrey.heer@gmail.com"
        },
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "kanitw",
          "email": "kanitw@gmail.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.97.1-next.0_1642123040669_0.28315842879140707"
      },
      "_hasShrinkwrap": false
    },
    "0.97.1-next.1": {
      "name": "ts-json-schema-generator",
      "version": "0.97.1-next.1",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "MooYeol Prescott Lee",
          "email": "mooyoul@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=10.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.9",
        "commander": "^9.0.0",
        "glob": "^7.2.0",
        "safe-stable-stringify": "^2.3.1",
        "json5": "^2.2.0",
        "typescript": "~4.5.4"
      },
      "devDependencies": {
        "@auto-it/conventional-commits": "^10.32.5",
        "@auto-it/first-time-contributor": "^10.32.5",
        "@babel/core": "^7.16.7",
        "@babel/preset-env": "^7.16.8",
        "@babel/preset-typescript": "^7.16.7",
        "@types/glob": "^7.2.0",
        "@types/jest": "^27.4.0",
        "@types/node": "^17.0.8",
        "@typescript-eslint/eslint-plugin": "^5.9.1",
        "@typescript-eslint/parser": "^5.9.1",
        "ajv": "^8.8.2",
        "ajv-formats": "^2.1.1",
        "auto": "^10.32.5",
        "chai": "^4.3.4",
        "cross-env": "^7.0.3",
        "eslint": "^8.6.0",
        "eslint-config-prettier": "^8.3.0",
        "eslint-plugin-prettier": "^4.0.0",
        "jest": "^27.4.7",
        "jest-junit": "^13.0.0",
        "prettier": "^2.5.1",
        "ts-node": "^10.4.0",
        "vega": "^5.21.0",
        "vega-lite": "^5.2.0"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint \"{src,test,factory}/**/*.ts\"",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "cross-env FAST_TEST=1 jest test/ --verbose",
        "test:coverage": "yarn jest test/ --collectCoverage=true",
        "test:update": "cross-env UPDATE_SCHEMA=true yarn test:fast",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node-transpile-only ts-json-schema-generator.ts",
        "release": "yarn build && auto shipit"
      },
      "readme": "# ts-json-schema-generator\n\n![Test](https://github.com/vega/ts-json-schema-generator/workflows/Test/badge.svg)\n[![codecov](https://codecov.io/gh/vega/ts-json-schema-generator/branch/master/graph/badge.svg)](https://codecov.io/gh/vega/ts-json-schema-generator)\n[![npm version](https://img.shields.io/npm/v/ts-json-schema-generator.svg)](https://www.npmjs.com/package/ts-json-schema-generator)\n\nExtended version of [https://github.com/xiag-ag/typescript-to-json-schema](https://github.com/xiag-ag/typescript-to-json-schema).\n\nInspired by [`YousefED/typescript-json-schema`](https://github.com/YousefED/typescript-json-schema). Here's the differences list:\n\n-   this implementation avoids the use of `typeChecker.getTypeAtLocation()` (so probably it keeps correct type aliases)\n-   processing AST and formatting JSON schema have been split into two independent steps\n-   not exported types, interfaces, enums are not exposed in the `definitions` section in the JSON schema\n\n## Contributors\n\nThis project is made possible by a [community of contributors](https://github.com/vega/ts-json-schema-generator/graphs/contributors). We welcome contributions of any kind (issues, code, documentation, examples, tests,...). Please read our [code of conduct](https://github.com/vega/vega/blob/master/CODE_OF_CONDUCT.md).\n\n## CLI Usage\n\n```bash\nnpm install --save ts-json-schema-generator\n./node_modules/.bin/ts-json-schema-generator --path 'my/project/**/*.ts' --type 'My.Type.Name'\n```\n\nNote that different platforms (e.g. Windows) may use different path separators so you may have to adjust the command above.\n\n## Programmatic Usage\n\n```js\n// main.js\n\nconst tsj = require(\"ts-json-schema-generator\");\nconst fs = require(\"fs\");\n\n/** @type {import('ts-json-schema-generator/dist/src/Config').Config} */\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst output_path = \"path/to/output/file\";\n\nconst schema = tsj.createGenerator(config).createSchema(config.type);\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\nRun the schema generator via `node main.js`.\n\n### Custom formatting\n\nExtending the built-in formatting is possible by creating a custom formatter and adding it to the main formatter:\n\n1. First we create a formatter, in this case for formatting function types:\n\n```ts\n// my-function-formatter.ts\nimport { BaseType, Definition, FunctionType, SubTypeFormatter } from \"ts-json-schema-generator\";\nimport ts from \"typescript\";\n\nexport class MyFunctionTypeFormatter implements SubTypeFormatter {\n    // You can skip this line if you don't need childTypeFormatter\n    public constructor(private childTypeFormatter: TypeFormatter) {}\n\n    public supportsType(type: FunctionType): boolean {\n        return type instanceof FunctionType;\n    }\n\n    public getDefinition(type: FunctionType): Definition {\n        // Return a custom schema for the function property.\n        return {\n            type: \"object\",\n            properties: {\n                isFunction: {\n                    type: \"boolean\",\n                    const: true,\n                },\n            },\n        };\n    }\n\n    // If this type does NOT HAVE children, generally all you need is:\n    public getChildren(type: FunctionType): BaseType[] {\n        return [];\n    }\n\n    // However, if children ARE supported, you'll need something similar to\n    // this (see src/TypeFormatter/{Array,Definition,etc}.ts for some examples):\n    public getChildren(type: FunctionType): BaseType[] {\n        return this.childTypeFormatter.getChildren(type.getType());\n    }\n}\n```\n\n2. Then we add the formatter as a child to the core formatter using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyFunctionTypeFormatter } from \"./my-function-formatter.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\n// We configure the formatter an add our custom formatter to it.\nconst formatter = createFormatter(config, (fmt, circularReferenceTypeFormatter) => {\n    // If your formatter DOES NOT support children, e.g. getChildren() { return [] }:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter());\n    // If your formatter DOES support children, you'll need this reference too:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter(circularReferenceTypeFormatter));\n});\n\nconst program = createProgram(config);\nconst parser = createParser(program, config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n### Custom parsing\n\nSimilar to custom formatting, extending the built-in parsing works practically the same way:\n\n1. First we create a parser, in this case for parsing construct types:\n\n```ts\n// my-constructor-parser.ts\nimport { Context, StringType, ReferenceType, BaseType, SubNodeParser } from \"ts-json-schema-generator\";\nimport ts from \"typescript\";\n\nexport class MyConstructorParser implements SubNodeParser {\n    supportsNode(node: ts.Node): boolean {\n        return node.kind === ts.SyntaxKind.ConstructorType;\n    }\n    createType(node: ts.Node, context: Context, reference?: ReferenceType): BaseType | undefined {\n        return new StringType(); // Treat constructors as strings in this example\n    }\n}\n```\n\n2. Then we add the parser as a child to the core parser using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyConstructorParser } from \"./my-constructor-parser.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst program = createProgram(config);\n\n// We configure the parser an add our custom parser to it.\nconst parser = createParser(program, config, (prs) => {\n    prs.addNodeParser(new MyConstructorParser());\n});\n\nconst formatter = createFormatter(config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n## Options\n\n```\n-p, --path 'index.ts'\n    The path to the TypeScript source file. If this is not provided, the type will be searched in the project specified in the `.tsconfig`.\n\n-t, --type 'My.Type.Name'\n    The type the generated schema will represent. If omitted, the generated schema will contain all\n    types found in the files matching path. The same is true if '*' is specified.\n\n-i, --id 'generatedSchemaId'\n    The `$id` of the generated schema. If omitted, there will be no `$id`.\n\n-e, --expose <all|none|export>\n    all: Create shared $ref definitions for all types.\n    none: Do not create shared $ref definitions.\n    export (default): Create shared $ref definitions only for exported types (not tagged as `@internal`).\n\n-f, --tsconfig 'my/project/tsconfig.json'\n    Use a custom tsconfig file for processing typescript (see https://www.typescriptlang.org/docs/handbook/tsconfig-json.html) instead of the default:\n    {\n        \"compilerOptions\": {\n            \"noEmit\": true,\n            \"emitDecoratorMetadata\": true,\n            \"experimentalDecorators\": true,\n            \"target\": \"ES5\",\n            \"module\": \"CommonJS\",\n            \"strictNullChecks\": false,\n        }\n    }\n\n-j, --jsDoc <extended|none|basic>\n    none: Do not use JsDoc annotations.\n    basic: Read JsDoc annotations to provide schema properties.\n    extended (default): Also read @nullable, and @asType annotations.\n\n--unstable\n    Do not sort properties.\n\n--strict-tuples\n    Do not allow additional items on tuples.\n\n--no-top-ref\n    Do not create a top-level $ref definition.\n\n--no-type-check\n    Skip type checks for better performance.\n\n--no-ref-encode\n    Do not encode references. According to the standard, references must be valid URIs but some tools do not support encoded references.\n\n--validation-keywords\n    Provide additional validation keywords to include.\n\n-o, --out\n    Specify the output file path. Without this option, the generator logs the response in the console.\n\n--additional-properties <true|false>\n    Controls whether or not to allow additional properties for objects that have no index signature.\n\n    true: Additional properties are allowed\n    false (default): Additional properties are not allowed\n```\n\n## Current state\n\n-   `interface` types\n-   `enum` types\n-   `union`, `tuple`, `type[]` types\n-   `Date`, `RegExp` types\n-   `string`, `boolean`, `number` types\n-   `\"value\"`, `123`, `true`, `false`, `null`, `undefined` literals\n-   type aliases\n-   generics\n-   `typeof`\n-   `keyof`\n-   conditional types\n\n## Run locally\n\n`yarn --silent run run --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\n## Debug\n\n`yarn --silent run debug --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\nAnd connect via the debugger protocol.\n\n[AST Explorer](https://astexplorer.net/) is amazing for developers of this tool!\n\n## Publish\n\nPublishing is handled by a 2-branch [pre-release process](https://intuit.github.io/auto/docs/generated/shipit#next-branch-default), configured in `publish-auto.yml`. All changes should be based off the default `next` branch, and are published automatically.\n\n-   PRs made into the default branch are auto-deployed to the `next` pre-release tag on NPM. The result can be installed with `npm install ts-json-schema-generator@next`\n    -   When merging into `next`, please use the `squash and merge` strategy.\n-   To release a new stable version, open a PR from `next` into `stable` using this [compare link](https://github.com/vega/ts-json-schema-generator/compare/stable...next).\n    -   When merging from `next` into `stable`, please use the `create a merge commit` strategy.\n",
      "readmeFilename": "README.md",
      "gitHead": "dd1374753291b0aac8c570db6825f56bf0e811ca",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.97.1-next.1",
      "_nodeVersion": "16.13.2",
      "_npmVersion": "8.1.2",
      "dist": {
        "integrity": "sha512-vvYj/8j17XK0qAEE9naD09B/9iFImuEbh/C6Sxl6x66ArlRV/OeWKwf/78vyB5yqqbgwGp9j7fJ54KhVBNb0ag==",
        "shasum": "bf204b489ff6a39d8929f21bd0660ec8ef72cd6f",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.97.1-next.1.tgz",
        "fileCount": 631,
        "unpackedSize": 737030,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJiAq8lCRA9TVsSAnZWagAA5xIP/jq4EDjh+W1EeacCS7yG\n/0xhRGxanSC54IpdkdIxb24gJWAwf2RMUOjQ0gswPL1nXvuPgMIBbY8+9YMC\nFhBPU/v2Ju8PS2SAfPiWjWXeui21AJDSE5fcMyIC9qgcWgO4fWIiADX1w1Op\nte9niSrpEXnk+UOJtZBwB5Lq2NXwq71C+CPSrUdp+cAYKusEraUaeQanY42W\n1p3Or9bUaTeH30jGuQqeY/S+vC7ggQ6/f0rjaKMsnRwxxZI4AU0hWIseqKiG\nmyUJvAqqqex6OtszcLIrKUxI3DHzNxZ2b/Y/eGZxMVl7+44GQV0oHOA1OBip\n7hosCd64hd7sf2Xu6b5Pc25Ybir+GQvv2DvLiF0E3K+B4jg+9hVc85vBC8Q/\nfrMKMeLa237Sp91QKX19LnkJVQ/Hx2v9yY6K76DyLLaCB76kuZibkgByID+4\nkrbgj7i11bPN5dO78qVBylok4iW5dsfit5YuZjXj2f6i9hC8COPqJhrVbWwY\nXyQ9c6fVqO8UCCQzH/ckm747PMxuSilrbohmIHmqRW3U7FF9U4e3yhyxVPpl\n7LQcpC1mh5PreAvAFqRnW2drXdhlEtq2lDEZ/MzSE5fxnhYGetjUZuV7tcA2\nDiJpMmqUUvurjN+IlMokzBeVmNT1nmRbMVMGPd6zv5cQtje9o8uKbCAGWZas\n90Pn\r\n=7IZ9\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEYCIQC1JfLNE0bEHqnvROtt6kQjf4JhW0iRRkXJ2OY5Tu5zeAIhALh+8b9nR7hoNo0DHZjTogaFMfvJkgLBkgTtIyp8dKPL"
          }
        ]
      },
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "maintainers": [
        {
          "name": "jheer",
          "email": "jeffrey.heer@gmail.com"
        },
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "kanitw",
          "email": "kanitw@gmail.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.97.1-next.1_1644343076968_0.3875774491336368"
      },
      "_hasShrinkwrap": false
    },
    "0.98.0-next.0": {
      "name": "ts-json-schema-generator",
      "version": "0.98.0-next.0",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "MooYeol Prescott Lee",
          "email": "mooyoul@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=10.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.9",
        "commander": "^9.0.0",
        "glob": "^7.2.0",
        "safe-stable-stringify": "^2.3.1",
        "json5": "^2.2.0",
        "typescript": "~4.5.4"
      },
      "devDependencies": {
        "@auto-it/conventional-commits": "^10.32.5",
        "@auto-it/first-time-contributor": "^10.32.5",
        "@babel/core": "^7.16.7",
        "@babel/preset-env": "^7.16.8",
        "@babel/preset-typescript": "^7.16.7",
        "@types/glob": "^7.2.0",
        "@types/jest": "^27.4.0",
        "@types/node": "^17.0.8",
        "@typescript-eslint/eslint-plugin": "^5.9.1",
        "@typescript-eslint/parser": "^5.9.1",
        "ajv": "^8.8.2",
        "ajv-formats": "^2.1.1",
        "auto": "^10.32.5",
        "chai": "^4.3.4",
        "cross-env": "^7.0.3",
        "eslint": "^8.6.0",
        "eslint-config-prettier": "^8.3.0",
        "eslint-plugin-prettier": "^4.0.0",
        "jest": "^27.4.7",
        "jest-junit": "^13.0.0",
        "prettier": "^2.5.1",
        "ts-node": "^10.4.0",
        "vega": "^5.21.0",
        "vega-lite": "^5.2.0"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint \"{src,test,factory}/**/*.ts\"",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "cross-env FAST_TEST=1 jest test/ --verbose",
        "test:coverage": "yarn jest test/ --collectCoverage=true",
        "test:update": "cross-env UPDATE_SCHEMA=true yarn test:fast",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node-transpile-only ts-json-schema-generator.ts",
        "release": "yarn build && auto shipit"
      },
      "readme": "# ts-json-schema-generator\n\n![Test](https://github.com/vega/ts-json-schema-generator/workflows/Test/badge.svg)\n[![codecov](https://codecov.io/gh/vega/ts-json-schema-generator/branch/master/graph/badge.svg)](https://codecov.io/gh/vega/ts-json-schema-generator)\n[![npm version](https://img.shields.io/npm/v/ts-json-schema-generator.svg)](https://www.npmjs.com/package/ts-json-schema-generator)\n\nExtended version of [https://github.com/xiag-ag/typescript-to-json-schema](https://github.com/xiag-ag/typescript-to-json-schema).\n\nInspired by [`YousefED/typescript-json-schema`](https://github.com/YousefED/typescript-json-schema). Here's the differences list:\n\n-   this implementation avoids the use of `typeChecker.getTypeAtLocation()` (so probably it keeps correct type aliases)\n-   processing AST and formatting JSON schema have been split into two independent steps\n-   not exported types, interfaces, enums are not exposed in the `definitions` section in the JSON schema\n\n## Contributors\n\nThis project is made possible by a [community of contributors](https://github.com/vega/ts-json-schema-generator/graphs/contributors). We welcome contributions of any kind (issues, code, documentation, examples, tests,...). Please read our [code of conduct](https://github.com/vega/vega/blob/master/CODE_OF_CONDUCT.md).\n\n## CLI Usage\n\n```bash\nnpm install --save ts-json-schema-generator\n./node_modules/.bin/ts-json-schema-generator --path 'my/project/**/*.ts' --type 'My.Type.Name'\n```\n\nNote that different platforms (e.g. Windows) may use different path separators so you may have to adjust the command above.\n\n## Programmatic Usage\n\n```js\n// main.js\n\nconst tsj = require(\"ts-json-schema-generator\");\nconst fs = require(\"fs\");\n\n/** @type {import('ts-json-schema-generator/dist/src/Config').Config} */\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst output_path = \"path/to/output/file\";\n\nconst schema = tsj.createGenerator(config).createSchema(config.type);\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\nRun the schema generator via `node main.js`.\n\n### Custom formatting\n\nExtending the built-in formatting is possible by creating a custom formatter and adding it to the main formatter:\n\n1. First we create a formatter, in this case for formatting function types:\n\n```ts\n// my-function-formatter.ts\nimport { BaseType, Definition, FunctionType, SubTypeFormatter } from \"ts-json-schema-generator\";\nimport ts from \"typescript\";\n\nexport class MyFunctionTypeFormatter implements SubTypeFormatter {\n    // You can skip this line if you don't need childTypeFormatter\n    public constructor(private childTypeFormatter: TypeFormatter) {}\n\n    public supportsType(type: FunctionType): boolean {\n        return type instanceof FunctionType;\n    }\n\n    public getDefinition(type: FunctionType): Definition {\n        // Return a custom schema for the function property.\n        return {\n            type: \"object\",\n            properties: {\n                isFunction: {\n                    type: \"boolean\",\n                    const: true,\n                },\n            },\n        };\n    }\n\n    // If this type does NOT HAVE children, generally all you need is:\n    public getChildren(type: FunctionType): BaseType[] {\n        return [];\n    }\n\n    // However, if children ARE supported, you'll need something similar to\n    // this (see src/TypeFormatter/{Array,Definition,etc}.ts for some examples):\n    public getChildren(type: FunctionType): BaseType[] {\n        return this.childTypeFormatter.getChildren(type.getType());\n    }\n}\n```\n\n2. Then we add the formatter as a child to the core formatter using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyFunctionTypeFormatter } from \"./my-function-formatter.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\n// We configure the formatter an add our custom formatter to it.\nconst formatter = createFormatter(config, (fmt, circularReferenceTypeFormatter) => {\n    // If your formatter DOES NOT support children, e.g. getChildren() { return [] }:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter());\n    // If your formatter DOES support children, you'll need this reference too:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter(circularReferenceTypeFormatter));\n});\n\nconst program = createProgram(config);\nconst parser = createParser(program, config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n### Custom parsing\n\nSimilar to custom formatting, extending the built-in parsing works practically the same way:\n\n1. First we create a parser, in this case for parsing construct types:\n\n```ts\n// my-constructor-parser.ts\nimport { Context, StringType, ReferenceType, BaseType, SubNodeParser } from \"ts-json-schema-generator\";\nimport ts from \"typescript\";\n\nexport class MyConstructorParser implements SubNodeParser {\n    supportsNode(node: ts.Node): boolean {\n        return node.kind === ts.SyntaxKind.ConstructorType;\n    }\n    createType(node: ts.Node, context: Context, reference?: ReferenceType): BaseType | undefined {\n        return new StringType(); // Treat constructors as strings in this example\n    }\n}\n```\n\n2. Then we add the parser as a child to the core parser using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyConstructorParser } from \"./my-constructor-parser.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst program = createProgram(config);\n\n// We configure the parser an add our custom parser to it.\nconst parser = createParser(program, config, (prs) => {\n    prs.addNodeParser(new MyConstructorParser());\n});\n\nconst formatter = createFormatter(config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n## Options\n\n```\n-p, --path 'index.ts'\n    The path to the TypeScript source file. If this is not provided, the type will be searched in the project specified in the `.tsconfig`.\n\n-t, --type 'My.Type.Name'\n    The type the generated schema will represent. If omitted, the generated schema will contain all\n    types found in the files matching path. The same is true if '*' is specified.\n\n-i, --id 'generatedSchemaId'\n    The `$id` of the generated schema. If omitted, there will be no `$id`.\n\n-e, --expose <all|none|export>\n    all: Create shared $ref definitions for all types.\n    none: Do not create shared $ref definitions.\n    export (default): Create shared $ref definitions only for exported types (not tagged as `@internal`).\n\n-f, --tsconfig 'my/project/tsconfig.json'\n    Use a custom tsconfig file for processing typescript (see https://www.typescriptlang.org/docs/handbook/tsconfig-json.html) instead of the default:\n    {\n        \"compilerOptions\": {\n            \"noEmit\": true,\n            \"emitDecoratorMetadata\": true,\n            \"experimentalDecorators\": true,\n            \"target\": \"ES5\",\n            \"module\": \"CommonJS\",\n            \"strictNullChecks\": false,\n        }\n    }\n\n-j, --jsDoc <extended|none|basic>\n    none: Do not use JsDoc annotations.\n    basic: Read JsDoc annotations to provide schema properties.\n    extended (default): Also read @nullable, and @asType annotations.\n\n--unstable\n    Do not sort properties.\n\n--strict-tuples\n    Do not allow additional items on tuples.\n\n--no-top-ref\n    Do not create a top-level $ref definition.\n\n--no-type-check\n    Skip type checks for better performance.\n\n--no-ref-encode\n    Do not encode references. According to the standard, references must be valid URIs but some tools do not support encoded references.\n\n--validation-keywords\n    Provide additional validation keywords to include.\n\n-o, --out\n    Specify the output file path. Without this option, the generator logs the response in the console.\n\n--additional-properties <true|false>\n    Controls whether or not to allow additional properties for objects that have no index signature.\n\n    true: Additional properties are allowed\n    false (default): Additional properties are not allowed\n\n--minify\n    Minify generated schema (default: false)\n```\n\n## Current state\n\n-   `interface` types\n-   `enum` types\n-   `union`, `tuple`, `type[]` types\n-   `Date`, `RegExp` types\n-   `string`, `boolean`, `number` types\n-   `\"value\"`, `123`, `true`, `false`, `null`, `undefined` literals\n-   type aliases\n-   generics\n-   `typeof`\n-   `keyof`\n-   conditional types\n\n## Run locally\n\n`yarn --silent run run --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\n## Debug\n\n`yarn --silent run debug --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\nAnd connect via the debugger protocol.\n\n[AST Explorer](https://astexplorer.net/) is amazing for developers of this tool!\n\n## Publish\n\nPublishing is handled by a 2-branch [pre-release process](https://intuit.github.io/auto/docs/generated/shipit#next-branch-default), configured in `publish-auto.yml`. All changes should be based off the default `next` branch, and are published automatically.\n\n-   PRs made into the default branch are auto-deployed to the `next` pre-release tag on NPM. The result can be installed with `npm install ts-json-schema-generator@next`\n    -   When merging into `next`, please use the `squash and merge` strategy.\n-   To release a new stable version, open a PR from `next` into `stable` using this [compare link](https://github.com/vega/ts-json-schema-generator/compare/stable...next).\n    -   When merging from `next` into `stable`, please use the `create a merge commit` strategy.\n",
      "readmeFilename": "README.md",
      "gitHead": "d37fca82ff5fab655dfa80deb200eaea4f72fcc9",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.98.0-next.0",
      "_nodeVersion": "16.13.2",
      "_npmVersion": "8.1.2",
      "dist": {
        "integrity": "sha512-3kdpdPOJhaFpiK55XZe9pzTBELG8eStp7B7hl2rRh8BUu3170u2v/JqqGeB2pvY3ecH4eXq6fZZ6odQnO7J/pg==",
        "shasum": "731f088f3fbcb4de050bf1559f9c9fa256098a69",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.98.0-next.0.tgz",
        "fileCount": 631,
        "unpackedSize": 737600,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJiBqLxCRA9TVsSAnZWagAAAB0P/iibqeVxHbGieAxXKtYb\nT+v+ynfmCB2qV7d6RVmuS3uCK8rYf2DN0wy+8ZRo41pU0RPjklpSvQ9uN1kf\nhmURcrrRtfMJFs31OvqqZEI+61bUYs/6u9I1evV0xGpR4kRR8e9FrxbypocU\ncrWIPIgAj/AFu3aZi8h8VCJ+MdBjLscrIlNbzQLYjc9Lt/+WXTCcsZMQ/Xbu\nGm1ua5JzZHGeX8KiSxjFjK4+ya/f+Gl/HrngaNqgcCRLknamRxmNSO65Dq/A\nWqvsg54np7xd7EbNdiFwCDF4htQGJAuAil+a/FFwOzty88QT2/TV9FHI1anz\nAiQy7mWrUYy0opNeThMg8A1K90hNf6ip/sVvpol/Pq1rfFLuHaqDXlGq8FgC\nMtSNMeE7A+gG27Vevab+/LHbCUqCy5CMscKQhoCU/C+I4RKxItKcF8vYkFhB\nKpvihGU7xoUd2IkzSzCb8TtRgBfaThaxzp+CGS6XqP3fmkIp7lXjyOsNfTll\n2mhknKjr6OeNwLQwOKIFGfqMXNH8PBvUui4OgbD8/cIRXH9SBJgy2SSND/58\n/LqUBziVQYE4+5RnIFDFiMUz1D5sOt1sNqI7d8bphckmGmx8LsF/ff17ac1f\n+tomQ4MmY1lUifIaMUZYerVQH76/RnVaS8wkxfGzDzmELrVSEVqNHG/O8/bs\nGzZM\r\n=r4Rg\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEQCIFRgS8KH2cFo4BbrBvMJ1vE//Gvo1YTZRLaqrTY91JILAiAh7sSH04pNfl/LsRYCfJBB6ILJ/g/SAvSg6L5Ua44WSg=="
          }
        ]
      },
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "maintainers": [
        {
          "name": "jheer",
          "email": "jeffrey.heer@gmail.com"
        },
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "kanitw",
          "email": "kanitw@gmail.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.98.0-next.0_1644602097761_0.697852653193177"
      },
      "_hasShrinkwrap": false
    },
    "0.98.0-next.1": {
      "name": "ts-json-schema-generator",
      "version": "0.98.0-next.1",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "MooYeol Prescott Lee",
          "email": "mooyoul@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=10.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.9",
        "commander": "^9.0.0",
        "glob": "^7.2.0",
        "safe-stable-stringify": "^2.3.1",
        "json5": "^2.2.0",
        "typescript": "~4.5.4"
      },
      "devDependencies": {
        "@auto-it/conventional-commits": "^10.32.5",
        "@auto-it/first-time-contributor": "^10.32.5",
        "@babel/core": "^7.16.7",
        "@babel/preset-env": "^7.16.8",
        "@babel/preset-typescript": "^7.16.7",
        "@types/glob": "^7.2.0",
        "@types/jest": "^27.4.0",
        "@types/node": "^17.0.8",
        "@typescript-eslint/eslint-plugin": "^5.9.1",
        "@typescript-eslint/parser": "^5.9.1",
        "ajv": "^8.8.2",
        "ajv-formats": "^2.1.1",
        "auto": "^10.32.5",
        "chai": "^4.3.4",
        "cross-env": "^7.0.3",
        "eslint": "^8.6.0",
        "eslint-config-prettier": "^8.3.0",
        "eslint-plugin-prettier": "^4.0.0",
        "jest": "^27.4.7",
        "jest-junit": "^13.0.0",
        "prettier": "^2.5.1",
        "ts-node": "^10.4.0",
        "vega": "^5.21.0",
        "vega-lite": "^5.2.0"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint \"{src,test,factory}/**/*.ts\"",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "cross-env FAST_TEST=1 jest test/ --verbose",
        "test:coverage": "yarn jest test/ --collectCoverage=true",
        "test:update": "cross-env UPDATE_SCHEMA=true yarn test:fast",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node-transpile-only ts-json-schema-generator.ts",
        "release": "yarn build && auto shipit"
      },
      "readme": "# ts-json-schema-generator\n\n![Test](https://github.com/vega/ts-json-schema-generator/workflows/Test/badge.svg)\n[![codecov](https://codecov.io/gh/vega/ts-json-schema-generator/branch/master/graph/badge.svg)](https://codecov.io/gh/vega/ts-json-schema-generator)\n[![npm version](https://img.shields.io/npm/v/ts-json-schema-generator.svg)](https://www.npmjs.com/package/ts-json-schema-generator)\n\nExtended version of [https://github.com/xiag-ag/typescript-to-json-schema](https://github.com/xiag-ag/typescript-to-json-schema).\n\nInspired by [`YousefED/typescript-json-schema`](https://github.com/YousefED/typescript-json-schema). Here's the differences list:\n\n-   this implementation avoids the use of `typeChecker.getTypeAtLocation()` (so probably it keeps correct type aliases)\n-   processing AST and formatting JSON schema have been split into two independent steps\n-   not exported types, interfaces, enums are not exposed in the `definitions` section in the JSON schema\n\n## Contributors\n\nThis project is made possible by a [community of contributors](https://github.com/vega/ts-json-schema-generator/graphs/contributors). We welcome contributions of any kind (issues, code, documentation, examples, tests,...). Please read our [code of conduct](https://github.com/vega/vega/blob/master/CODE_OF_CONDUCT.md).\n\n## CLI Usage\n\n```bash\nnpm install --save ts-json-schema-generator\n./node_modules/.bin/ts-json-schema-generator --path 'my/project/**/*.ts' --type 'My.Type.Name'\n```\n\nNote that different platforms (e.g. Windows) may use different path separators so you may have to adjust the command above.\n\n## Programmatic Usage\n\n```js\n// main.js\n\nconst tsj = require(\"ts-json-schema-generator\");\nconst fs = require(\"fs\");\n\n/** @type {import('ts-json-schema-generator/dist/src/Config').Config} */\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst output_path = \"path/to/output/file\";\n\nconst schema = tsj.createGenerator(config).createSchema(config.type);\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\nRun the schema generator via `node main.js`.\n\n### Custom formatting\n\nExtending the built-in formatting is possible by creating a custom formatter and adding it to the main formatter:\n\n1. First we create a formatter, in this case for formatting function types:\n\n```ts\n// my-function-formatter.ts\nimport { BaseType, Definition, FunctionType, SubTypeFormatter } from \"ts-json-schema-generator\";\nimport ts from \"typescript\";\n\nexport class MyFunctionTypeFormatter implements SubTypeFormatter {\n    // You can skip this line if you don't need childTypeFormatter\n    public constructor(private childTypeFormatter: TypeFormatter) {}\n\n    public supportsType(type: FunctionType): boolean {\n        return type instanceof FunctionType;\n    }\n\n    public getDefinition(type: FunctionType): Definition {\n        // Return a custom schema for the function property.\n        return {\n            type: \"object\",\n            properties: {\n                isFunction: {\n                    type: \"boolean\",\n                    const: true,\n                },\n            },\n        };\n    }\n\n    // If this type does NOT HAVE children, generally all you need is:\n    public getChildren(type: FunctionType): BaseType[] {\n        return [];\n    }\n\n    // However, if children ARE supported, you'll need something similar to\n    // this (see src/TypeFormatter/{Array,Definition,etc}.ts for some examples):\n    public getChildren(type: FunctionType): BaseType[] {\n        return this.childTypeFormatter.getChildren(type.getType());\n    }\n}\n```\n\n2. Then we add the formatter as a child to the core formatter using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyFunctionTypeFormatter } from \"./my-function-formatter.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\n// We configure the formatter an add our custom formatter to it.\nconst formatter = createFormatter(config, (fmt, circularReferenceTypeFormatter) => {\n    // If your formatter DOES NOT support children, e.g. getChildren() { return [] }:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter());\n    // If your formatter DOES support children, you'll need this reference too:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter(circularReferenceTypeFormatter));\n});\n\nconst program = createProgram(config);\nconst parser = createParser(program, config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n### Custom parsing\n\nSimilar to custom formatting, extending the built-in parsing works practically the same way:\n\n1. First we create a parser, in this case for parsing construct types:\n\n```ts\n// my-constructor-parser.ts\nimport { Context, StringType, ReferenceType, BaseType, SubNodeParser } from \"ts-json-schema-generator\";\nimport ts from \"typescript\";\n\nexport class MyConstructorParser implements SubNodeParser {\n    supportsNode(node: ts.Node): boolean {\n        return node.kind === ts.SyntaxKind.ConstructorType;\n    }\n    createType(node: ts.Node, context: Context, reference?: ReferenceType): BaseType | undefined {\n        return new StringType(); // Treat constructors as strings in this example\n    }\n}\n```\n\n2. Then we add the parser as a child to the core parser using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyConstructorParser } from \"./my-constructor-parser.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst program = createProgram(config);\n\n// We configure the parser an add our custom parser to it.\nconst parser = createParser(program, config, (prs) => {\n    prs.addNodeParser(new MyConstructorParser());\n});\n\nconst formatter = createFormatter(config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n## Options\n\n```\n-p, --path 'index.ts'\n    The path to the TypeScript source file. If this is not provided, the type will be searched in the project specified in the `.tsconfig`.\n\n-t, --type 'My.Type.Name'\n    The type the generated schema will represent. If omitted, the generated schema will contain all\n    types found in the files matching path. The same is true if '*' is specified.\n\n-i, --id 'generatedSchemaId'\n    The `$id` of the generated schema. If omitted, there will be no `$id`.\n\n-e, --expose <all|none|export>\n    all: Create shared $ref definitions for all types.\n    none: Do not create shared $ref definitions.\n    export (default): Create shared $ref definitions only for exported types (not tagged as `@internal`).\n\n-f, --tsconfig 'my/project/tsconfig.json'\n    Use a custom tsconfig file for processing typescript (see https://www.typescriptlang.org/docs/handbook/tsconfig-json.html) instead of the default:\n    {\n        \"compilerOptions\": {\n            \"noEmit\": true,\n            \"emitDecoratorMetadata\": true,\n            \"experimentalDecorators\": true,\n            \"target\": \"ES5\",\n            \"module\": \"CommonJS\",\n            \"strictNullChecks\": false,\n        }\n    }\n\n-j, --jsDoc <extended|none|basic>\n    none: Do not use JsDoc annotations.\n    basic: Read JsDoc annotations to provide schema properties.\n    extended (default): Also read @nullable, and @asType annotations.\n\n--unstable\n    Do not sort properties.\n\n--strict-tuples\n    Do not allow additional items on tuples.\n\n--no-top-ref\n    Do not create a top-level $ref definition.\n\n--no-type-check\n    Skip type checks for better performance.\n\n--no-ref-encode\n    Do not encode references. According to the standard, references must be valid URIs but some tools do not support encoded references.\n\n--validation-keywords\n    Provide additional validation keywords to include.\n\n-o, --out\n    Specify the output file path. Without this option, the generator logs the response in the console.\n\n--additional-properties <true|false>\n    Controls whether or not to allow additional properties for objects that have no index signature.\n\n    true: Additional properties are allowed\n    false (default): Additional properties are not allowed\n\n--minify\n    Minify generated schema (default: false)\n```\n\n## Current state\n\n-   `interface` types\n-   `enum` types\n-   `union`, `tuple`, `type[]` types\n-   `Date`, `RegExp` types\n-   `string`, `boolean`, `number` types\n-   `\"value\"`, `123`, `true`, `false`, `null`, `undefined` literals\n-   type aliases\n-   generics\n-   `typeof`\n-   `keyof`\n-   conditional types\n\n## Run locally\n\n`yarn --silent run run --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\n## Debug\n\n`yarn --silent run debug --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\nAnd connect via the debugger protocol.\n\n[AST Explorer](https://astexplorer.net/) is amazing for developers of this tool!\n\n## Publish\n\nPublishing is handled by a 2-branch [pre-release process](https://intuit.github.io/auto/docs/generated/shipit#next-branch-default), configured in `publish-auto.yml`. All changes should be based off the default `next` branch, and are published automatically.\n\n-   PRs made into the default branch are auto-deployed to the `next` pre-release tag on NPM. The result can be installed with `npm install ts-json-schema-generator@next`\n    -   When merging into `next`, please use the `squash and merge` strategy.\n-   To release a new stable version, open a PR from `next` into `stable` using this [compare link](https://github.com/vega/ts-json-schema-generator/compare/stable...next).\n    -   When merging from `next` into `stable`, please use the `create a merge commit` strategy.\n",
      "readmeFilename": "README.md",
      "gitHead": "ac172d8aee45a4771a89fb1b33850493c6dab683",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.98.0-next.1",
      "_nodeVersion": "16.13.2",
      "_npmVersion": "8.1.2",
      "dist": {
        "integrity": "sha512-WayHk3XY/9MUCbAbo8OW78eHkYkZl+OUqHlkZtH4NiVcT+C+lWKko9wVsnR5EoOYPiY/w0+KSnyO4RuaqQ9Vng==",
        "shasum": "7106f2a3f3d4d9704240eb2d9922bf172043b5db",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.98.0-next.1.tgz",
        "fileCount": 658,
        "unpackedSize": 743936,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJiDGsWCRA9TVsSAnZWagAA1aAP/20qp3HLHfFTi7pz/B1k\nWR6MyKHW8CXlHFZQEn2oZaOFXkEog/kK70PA/QkMbpAfof4jg8xE+6dCxshw\nMboY4smj2QoEvzstKwjSK2d6e8qU9XsYvGyxbkOHiKbPIufLZe9s87QP74Vq\nFj1WTvg5FaLs938Xwd+k01imbfhyLJH7uN4rdXGe5dI6u2pgrPMRfqFueArt\nsxenexehFzqgSs4EIFpL7eV7NoYOYWh2vhWigP4AWV7A6D9WFcZLDRx6Mnqx\nlTl5jFWovXJku+9tFoTEv1zkYjDTcNTNyelckPMYSmdbPOtQZxArm8NJJxjl\nusMlfdLGVoFIhiGQBd5syiaqBeiO8r3F3kENzO7yWRyIk5THkf8HNRROqAKZ\nX75AsmswTrq5UlfwX2eZpS5NLrT692/2Vsh/8uP0qV/xv8gfCX7LgL8YK66r\nbA0NWTb0y7EADzNdcWSOu7DryQzuU6L+0Q3vk/EwUidLI8cEI5Xs7IuXsB9m\ndc7ORpdHLusV5ZVQ74u04siXp/Qg42lAH/QAm9NrLgIsQMPmZgPLIqjLo0p0\nU0VurFvJJxkQfgEj8yuyar4bNok+JqtSTb2OMYK2ifKfU/I5f0t+QBf/v28C\nryXR4RqhJIicwZrdvTcSqvgvk46xgqJR3SquzMGBMO04W4qgTMLb9YbXd1vh\nDSoK\r\n=HxNG\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIQDO6F69XarJ7UqSgYe0EEbDHVLJI/dCdVbrzq/8nrFQpgIgAVBXey/UrzEuSW7mrd2LloyzuFImq85LQUVEtYnYpEU="
          }
        ]
      },
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "maintainers": [
        {
          "name": "jheer",
          "email": "jeffrey.heer@gmail.com"
        },
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "kanitw",
          "email": "kanitw@gmail.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.98.0-next.1_1644981014506_0.4150298040701863"
      },
      "_hasShrinkwrap": false
    },
    "0.98.0": {
      "name": "ts-json-schema-generator",
      "version": "0.98.0",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "MooYeol Prescott Lee",
          "email": "mooyoul@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=10.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.9",
        "commander": "^9.0.0",
        "glob": "^7.2.0",
        "safe-stable-stringify": "^2.3.1",
        "json5": "^2.2.0",
        "typescript": "~4.5.4"
      },
      "devDependencies": {
        "@auto-it/conventional-commits": "^10.32.5",
        "@auto-it/first-time-contributor": "^10.32.5",
        "@babel/core": "^7.16.7",
        "@babel/preset-env": "^7.16.8",
        "@babel/preset-typescript": "^7.16.7",
        "@types/glob": "^7.2.0",
        "@types/jest": "^27.4.0",
        "@types/node": "^17.0.8",
        "@typescript-eslint/eslint-plugin": "^5.9.1",
        "@typescript-eslint/parser": "^5.9.1",
        "ajv": "^8.8.2",
        "ajv-formats": "^2.1.1",
        "auto": "^10.32.5",
        "chai": "^4.3.4",
        "cross-env": "^7.0.3",
        "eslint": "^8.6.0",
        "eslint-config-prettier": "^8.3.0",
        "eslint-plugin-prettier": "^4.0.0",
        "jest": "^27.4.7",
        "jest-junit": "^13.0.0",
        "prettier": "^2.5.1",
        "ts-node": "^10.4.0",
        "vega": "^5.21.0",
        "vega-lite": "^5.2.0"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint \"{src,test,factory}/**/*.ts\"",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "cross-env FAST_TEST=1 jest test/ --verbose",
        "test:coverage": "yarn jest test/ --collectCoverage=true",
        "test:update": "cross-env UPDATE_SCHEMA=true yarn test:fast",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node-transpile-only ts-json-schema-generator.ts",
        "release": "yarn build && auto shipit"
      },
      "gitHead": "63278ed96b02b1b5850f061affb13ce0ec17bb99",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.98.0",
      "_nodeVersion": "16.13.2",
      "_npmVersion": "8.1.2",
      "dist": {
        "integrity": "sha512-emurTxAKkhk9a/i0Rfg5WkT5Hbg7MaL9VlxQXsWScBun0aXVl99gr06sEcHm3EJ8As4Ji51J7VJGEg6wrER/Kg==",
        "shasum": "5aa957f45ba4b662a53ffafe86164e6e218942fa",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.98.0.tgz",
        "fileCount": 658,
        "unpackedSize": 743922,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJiDHKsCRA9TVsSAnZWagAA7r0QAKT38lEnKUMRYBw590IT\n/6pY0RcPLjoBRhbTZ/iBL9rcKkacxUqSeND8p9IDOcguSSWeBMci8MdFlAQ6\n+eGrT9rbDYuqW9XkU8ovL1XFgo52Gk+4JiMmREciHr/I0HshN06+GUoYZdV5\noG7Nv7PDpzWQ0s9+OSGBYlxhOhB2YwBGanMpjveB5CZanuIVJ+I28gXm24rA\nB6BqwzlMtfWf+d4KaYRtLUt6A3fNNGEOhBnPZNtp1R8CGARmiFnRDqu7cDBb\nuYYDOfK47Zoxtnrtn7n/JgIt2LzGTJCRhPLCgScPG9m1ohRs0pkg8oZVkOqc\nLx1UWG4pEQIUJG+sVvP81TefxOYIZK8TXjaJNYnAZLUVdErjpsita2Y/xrEJ\nwM5T+WTRRN0scecGH5u4gThT9NQk0AmQUnmhY0YzDfeNqg4q5csm4oyzuzXP\nht33TqwRBBd2vkBtGWkjJFGiEHGQh5hBv4+KlBtTym3xHxeVmZg9lCEpio1M\nB8pKk8BAQmE4MnSngRFLGEccK06LUPDfMAQhB5gUOMVqW+/JYXY2nL0SnxL+\nes/ctg19XYNtHhyl07Ui6mFGmka79HOk3XWZbt+d70WoGLi69PZnAAzvnEXk\nTPLeY1BM+eTY3FPXDrgcvMRlPToRCThGZfgIKyOmiPpaM5RowbZ6KV3iieYi\nCVn2\r\n=VFZI\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEYCIQDD8osx/ysq3DTJMOb4WJmyQsENJ/AEMr4sbtH/IvLy3gIhALY6TDaHOL0/Go4ASSVX1OdjI3wMRSiRaRtqfFt05bGj"
          }
        ]
      },
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "maintainers": [
        {
          "name": "jheer",
          "email": "jeffrey.heer@gmail.com"
        },
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "kanitw",
          "email": "kanitw@gmail.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.98.0_1644982956004_0.8318772456433339"
      },
      "_hasShrinkwrap": false
    },
    "0.98.1-next.0": {
      "name": "ts-json-schema-generator",
      "version": "0.98.1-next.0",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "MooYeol Prescott Lee",
          "email": "mooyoul@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=10.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.9",
        "commander": "^9.0.0",
        "glob": "^7.2.0",
        "safe-stable-stringify": "^2.3.1",
        "json5": "^2.2.0",
        "typescript": "~4.6.2"
      },
      "devDependencies": {
        "@auto-it/conventional-commits": "^10.32.5",
        "@auto-it/first-time-contributor": "^10.32.5",
        "@babel/core": "^7.16.7",
        "@babel/preset-env": "^7.16.8",
        "@babel/preset-typescript": "^7.16.7",
        "@types/glob": "^7.2.0",
        "@types/jest": "^27.4.0",
        "@types/node": "^17.0.8",
        "@typescript-eslint/eslint-plugin": "^5.9.1",
        "@typescript-eslint/parser": "^5.9.1",
        "ajv": "^8.8.2",
        "ajv-formats": "^2.1.1",
        "auto": "^10.32.5",
        "chai": "^4.3.4",
        "cross-env": "^7.0.3",
        "eslint": "^8.6.0",
        "eslint-config-prettier": "^8.3.0",
        "eslint-plugin-prettier": "^4.0.0",
        "jest": "^27.4.7",
        "jest-junit": "^13.0.0",
        "prettier": "^2.5.1",
        "ts-node": "^10.4.0",
        "vega": "^5.21.0",
        "vega-lite": "^5.2.0"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint \"{src,test,factory}/**/*.ts\"",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "cross-env FAST_TEST=1 jest test/ --verbose",
        "test:coverage": "yarn jest test/ --collectCoverage=true",
        "test:update": "cross-env UPDATE_SCHEMA=true yarn test:fast",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node-transpile-only ts-json-schema-generator.ts",
        "release": "yarn build && auto shipit"
      },
      "readme": "# ts-json-schema-generator\n\n![Test](https://github.com/vega/ts-json-schema-generator/workflows/Test/badge.svg)\n[![codecov](https://codecov.io/gh/vega/ts-json-schema-generator/branch/master/graph/badge.svg)](https://codecov.io/gh/vega/ts-json-schema-generator)\n[![npm version](https://img.shields.io/npm/v/ts-json-schema-generator.svg)](https://www.npmjs.com/package/ts-json-schema-generator)\n\nExtended version of [https://github.com/xiag-ag/typescript-to-json-schema](https://github.com/xiag-ag/typescript-to-json-schema).\n\nInspired by [`YousefED/typescript-json-schema`](https://github.com/YousefED/typescript-json-schema). Here's the differences list:\n\n-   this implementation avoids the use of `typeChecker.getTypeAtLocation()` (so probably it keeps correct type aliases)\n-   processing AST and formatting JSON schema have been split into two independent steps\n-   not exported types, interfaces, enums are not exposed in the `definitions` section in the JSON schema\n\n## Contributors\n\nThis project is made possible by a [community of contributors](https://github.com/vega/ts-json-schema-generator/graphs/contributors). We welcome contributions of any kind (issues, code, documentation, examples, tests,...). Please read our [code of conduct](https://github.com/vega/vega/blob/master/CODE_OF_CONDUCT.md).\n\n## CLI Usage\n\n```bash\nnpm install --save ts-json-schema-generator\n./node_modules/.bin/ts-json-schema-generator --path 'my/project/**/*.ts' --type 'My.Type.Name'\n```\n\nNote that different platforms (e.g. Windows) may use different path separators so you may have to adjust the command above.\n\n## Programmatic Usage\n\n```js\n// main.js\n\nconst tsj = require(\"ts-json-schema-generator\");\nconst fs = require(\"fs\");\n\n/** @type {import('ts-json-schema-generator/dist/src/Config').Config} */\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst output_path = \"path/to/output/file\";\n\nconst schema = tsj.createGenerator(config).createSchema(config.type);\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\nRun the schema generator via `node main.js`.\n\n### Custom formatting\n\nExtending the built-in formatting is possible by creating a custom formatter and adding it to the main formatter:\n\n1. First we create a formatter, in this case for formatting function types:\n\n```ts\n// my-function-formatter.ts\nimport { BaseType, Definition, FunctionType, SubTypeFormatter } from \"ts-json-schema-generator\";\nimport ts from \"typescript\";\n\nexport class MyFunctionTypeFormatter implements SubTypeFormatter {\n    // You can skip this line if you don't need childTypeFormatter\n    public constructor(private childTypeFormatter: TypeFormatter) {}\n\n    public supportsType(type: FunctionType): boolean {\n        return type instanceof FunctionType;\n    }\n\n    public getDefinition(type: FunctionType): Definition {\n        // Return a custom schema for the function property.\n        return {\n            type: \"object\",\n            properties: {\n                isFunction: {\n                    type: \"boolean\",\n                    const: true,\n                },\n            },\n        };\n    }\n\n    // If this type does NOT HAVE children, generally all you need is:\n    public getChildren(type: FunctionType): BaseType[] {\n        return [];\n    }\n\n    // However, if children ARE supported, you'll need something similar to\n    // this (see src/TypeFormatter/{Array,Definition,etc}.ts for some examples):\n    public getChildren(type: FunctionType): BaseType[] {\n        return this.childTypeFormatter.getChildren(type.getType());\n    }\n}\n```\n\n2. Then we add the formatter as a child to the core formatter using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyFunctionTypeFormatter } from \"./my-function-formatter.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\n// We configure the formatter an add our custom formatter to it.\nconst formatter = createFormatter(config, (fmt, circularReferenceTypeFormatter) => {\n    // If your formatter DOES NOT support children, e.g. getChildren() { return [] }:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter());\n    // If your formatter DOES support children, you'll need this reference too:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter(circularReferenceTypeFormatter));\n});\n\nconst program = createProgram(config);\nconst parser = createParser(program, config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n### Custom parsing\n\nSimilar to custom formatting, extending the built-in parsing works practically the same way:\n\n1. First we create a parser, in this case for parsing construct types:\n\n```ts\n// my-constructor-parser.ts\nimport { Context, StringType, ReferenceType, BaseType, SubNodeParser } from \"ts-json-schema-generator\";\nimport ts from \"typescript\";\n\nexport class MyConstructorParser implements SubNodeParser {\n    supportsNode(node: ts.Node): boolean {\n        return node.kind === ts.SyntaxKind.ConstructorType;\n    }\n    createType(node: ts.Node, context: Context, reference?: ReferenceType): BaseType | undefined {\n        return new StringType(); // Treat constructors as strings in this example\n    }\n}\n```\n\n2. Then we add the parser as a child to the core parser using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyConstructorParser } from \"./my-constructor-parser.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst program = createProgram(config);\n\n// We configure the parser an add our custom parser to it.\nconst parser = createParser(program, config, (prs) => {\n    prs.addNodeParser(new MyConstructorParser());\n});\n\nconst formatter = createFormatter(config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n## Options\n\n```\n-p, --path 'index.ts'\n    The path to the TypeScript source file. If this is not provided, the type will be searched in the project specified in the `.tsconfig`.\n\n-t, --type 'My.Type.Name'\n    The type the generated schema will represent. If omitted, the generated schema will contain all\n    types found in the files matching path. The same is true if '*' is specified.\n\n-i, --id 'generatedSchemaId'\n    The `$id` of the generated schema. If omitted, there will be no `$id`.\n\n-e, --expose <all|none|export>\n    all: Create shared $ref definitions for all types.\n    none: Do not create shared $ref definitions.\n    export (default): Create shared $ref definitions only for exported types (not tagged as `@internal`).\n\n-f, --tsconfig 'my/project/tsconfig.json'\n    Use a custom tsconfig file for processing typescript (see https://www.typescriptlang.org/docs/handbook/tsconfig-json.html) instead of the default:\n    {\n        \"compilerOptions\": {\n            \"noEmit\": true,\n            \"emitDecoratorMetadata\": true,\n            \"experimentalDecorators\": true,\n            \"target\": \"ES5\",\n            \"module\": \"CommonJS\",\n            \"strictNullChecks\": false,\n        }\n    }\n\n-j, --jsDoc <extended|none|basic>\n    none: Do not use JsDoc annotations.\n    basic: Read JsDoc annotations to provide schema properties.\n    extended (default): Also read @nullable, and @asType annotations.\n\n--unstable\n    Do not sort properties.\n\n--strict-tuples\n    Do not allow additional items on tuples.\n\n--no-top-ref\n    Do not create a top-level $ref definition.\n\n--no-type-check\n    Skip type checks for better performance.\n\n--no-ref-encode\n    Do not encode references. According to the standard, references must be valid URIs but some tools do not support encoded references.\n\n--validation-keywords\n    Provide additional validation keywords to include.\n\n-o, --out\n    Specify the output file path. Without this option, the generator logs the response in the console.\n\n--additional-properties <true|false>\n    Controls whether or not to allow additional properties for objects that have no index signature.\n\n    true: Additional properties are allowed\n    false (default): Additional properties are not allowed\n\n--minify\n    Minify generated schema (default: false)\n```\n\n## Current state\n\n-   `interface` types\n-   `enum` types\n-   `union`, `tuple`, `type[]` types\n-   `Date`, `RegExp` types\n-   `string`, `boolean`, `number` types\n-   `\"value\"`, `123`, `true`, `false`, `null`, `undefined` literals\n-   type aliases\n-   generics\n-   `typeof`\n-   `keyof`\n-   conditional types\n\n## Run locally\n\n`yarn --silent run run --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\n## Debug\n\n`yarn --silent run debug --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\nAnd connect via the debugger protocol.\n\n[AST Explorer](https://astexplorer.net/) is amazing for developers of this tool!\n\n## Publish\n\nPublishing is handled by a 2-branch [pre-release process](https://intuit.github.io/auto/docs/generated/shipit#next-branch-default), configured in `publish-auto.yml`. All changes should be based off the default `next` branch, and are published automatically.\n\n-   PRs made into the default branch are auto-deployed to the `next` pre-release tag on NPM. The result can be installed with `npm install ts-json-schema-generator@next`\n    -   When merging into `next`, please use the `squash and merge` strategy.\n-   To release a new stable version, open a PR from `next` into `stable` using this [compare link](https://github.com/vega/ts-json-schema-generator/compare/stable...next).\n    -   When merging from `next` into `stable`, please use the `create a merge commit` strategy.\n",
      "readmeFilename": "README.md",
      "gitHead": "e1f24491a4c601aa901df759d1603f8b72b2138f",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.98.1-next.0",
      "_nodeVersion": "16.14.0",
      "_npmVersion": "8.3.1",
      "dist": {
        "integrity": "sha512-IOHjWeb/WtnCzhV+E+O2vYByBIlu2D4kOWerdphzvL6KqlcUCCtROkkABU3736RBdVnIGb5d5zchjFmzYyoGVA==",
        "shasum": "4f20e351593823e534022cad195a439e6060a73b",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.98.1-next.0.tgz",
        "fileCount": 666,
        "unpackedSize": 748968,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJiK0Z+ACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2Vmqhrw//aUrWxsxp0aHu2D4YOnvd9NWzVG8bssfZ8g5sKheVfQsZh8RW\r\n9rIlFN7g7kQxKDBwRY6qFLvAdJnribPm+cSzcm3Ho/V07lTpN1Hsff9rJ25v\r\nwpGp1qtACsYD+bWOjEiLQtkBdNracsoKFazy7pNKqm7fEEMz/dbOk2x6Dk/f\r\nGNiUHsWk3jr7DwSdko8XIeWYkE/ZtljNgEyNzI3JQU/1r5zrLzTRjBUsyQ49\r\nbtMfKjTSvKmyMpsRXapVQf6dhKfhZAR0rbJSgKOImhQG+KtrcAE8tkpLB19K\r\n5pw6At5esmKORP7docOz5GwW5JLtja4xqnLi8zCg7jnXUrh9Jm2o+q53kwLz\r\nfA4dGC8Ubheju6Wb2rxwTWFIa+5AYK0Ov2P8dA/8V9Ywz2XR2ZBkaSyz9hhc\r\nmf2/7b/rfojOmFiaM5gTirFDwiLwzkZUPcsWPlLmdWzyMv4G3ybPxzp/Tjl0\r\nOf7a6S/ZeaH4bnfv46ISvSEZvg1fZ06f8GEctKFiMak/I8kFW4P++pnEcYbD\r\nf2sKDhm/BJb867deNaKykQQeq/ExDcKIebMcFA+lk0fdhb7G5JpoBR/QW9ed\r\nK66g7JrSIm1Q6PXFPuswD9riCdY5mS+8ZV831pNCSHPBRAlbghWBFSGmGpTG\r\nTTsgvDHHGBzOI9R9W3+m9Fz7pmM7jMwK294=\r\n=A6fB\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIQCSYURG4qsuGDfB4VBkddJcHZy61Ux4ZxSU5Y9y5jymigIgWeuH862642vXVq2q51rS/lw67nEPoQvpjfUXLpPfHLY="
          }
        ]
      },
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "maintainers": [
        {
          "name": "jheer",
          "email": "jeffrey.heer@gmail.com"
        },
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "kanitw",
          "email": "kanitw@gmail.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.98.1-next.0_1647003262186_0.4554915349024782"
      },
      "_hasShrinkwrap": false
    },
    "0.98.1-next.1": {
      "name": "ts-json-schema-generator",
      "version": "0.98.1-next.1",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "MooYeol Prescott Lee",
          "email": "mooyoul@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=10.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.9",
        "commander": "^9.0.0",
        "glob": "^7.2.0",
        "safe-stable-stringify": "^2.3.1",
        "json5": "^2.2.0",
        "typescript": "~4.6.2"
      },
      "devDependencies": {
        "@auto-it/conventional-commits": "^10.32.5",
        "@auto-it/first-time-contributor": "^10.32.5",
        "@babel/core": "^7.16.7",
        "@babel/preset-env": "^7.16.8",
        "@babel/preset-typescript": "^7.16.7",
        "@types/glob": "^7.2.0",
        "@types/jest": "^27.4.0",
        "@types/node": "^17.0.8",
        "@typescript-eslint/eslint-plugin": "^5.9.1",
        "@typescript-eslint/parser": "^5.9.1",
        "ajv": "^8.8.2",
        "ajv-formats": "^2.1.1",
        "auto": "^10.32.5",
        "chai": "^4.3.4",
        "cross-env": "^7.0.3",
        "eslint": "^8.6.0",
        "eslint-config-prettier": "^8.3.0",
        "eslint-plugin-prettier": "^4.0.0",
        "jest": "^27.4.7",
        "jest-junit": "^13.0.0",
        "prettier": "^2.5.1",
        "ts-node": "^10.4.0",
        "vega": "^5.21.0",
        "vega-lite": "^5.2.0"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint \"{src,test,factory}/**/*.ts\"",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "cross-env FAST_TEST=1 jest test/ --verbose",
        "test:coverage": "yarn jest test/ --collectCoverage=true",
        "test:update": "cross-env UPDATE_SCHEMA=true yarn test:fast",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node-transpile-only ts-json-schema-generator.ts",
        "release": "yarn build && auto shipit"
      },
      "readme": "# ts-json-schema-generator\n\n![Test](https://github.com/vega/ts-json-schema-generator/workflows/Test/badge.svg)\n[![codecov](https://codecov.io/gh/vega/ts-json-schema-generator/branch/master/graph/badge.svg)](https://codecov.io/gh/vega/ts-json-schema-generator)\n[![npm version](https://img.shields.io/npm/v/ts-json-schema-generator.svg)](https://www.npmjs.com/package/ts-json-schema-generator)\n\nExtended version of [https://github.com/xiag-ag/typescript-to-json-schema](https://github.com/xiag-ag/typescript-to-json-schema).\n\nInspired by [`YousefED/typescript-json-schema`](https://github.com/YousefED/typescript-json-schema). Here's the differences list:\n\n-   this implementation avoids the use of `typeChecker.getTypeAtLocation()` (so probably it keeps correct type aliases)\n-   processing AST and formatting JSON schema have been split into two independent steps\n-   not exported types, interfaces, enums are not exposed in the `definitions` section in the JSON schema\n\n## Contributors\n\nThis project is made possible by a [community of contributors](https://github.com/vega/ts-json-schema-generator/graphs/contributors). We welcome contributions of any kind (issues, code, documentation, examples, tests,...). Please read our [code of conduct](https://github.com/vega/vega/blob/master/CODE_OF_CONDUCT.md).\n\n## CLI Usage\n\n```bash\nnpm install --save ts-json-schema-generator\n./node_modules/.bin/ts-json-schema-generator --path 'my/project/**/*.ts' --type 'My.Type.Name'\n```\n\nNote that different platforms (e.g. Windows) may use different path separators so you may have to adjust the command above.\n\n## Programmatic Usage\n\n```js\n// main.js\n\nconst tsj = require(\"ts-json-schema-generator\");\nconst fs = require(\"fs\");\n\n/** @type {import('ts-json-schema-generator/dist/src/Config').Config} */\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst output_path = \"path/to/output/file\";\n\nconst schema = tsj.createGenerator(config).createSchema(config.type);\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\nRun the schema generator via `node main.js`.\n\n### Custom formatting\n\nExtending the built-in formatting is possible by creating a custom formatter and adding it to the main formatter:\n\n1. First we create a formatter, in this case for formatting function types:\n\n```ts\n// my-function-formatter.ts\nimport { BaseType, Definition, FunctionType, SubTypeFormatter } from \"ts-json-schema-generator\";\nimport ts from \"typescript\";\n\nexport class MyFunctionTypeFormatter implements SubTypeFormatter {\n    // You can skip this line if you don't need childTypeFormatter\n    public constructor(private childTypeFormatter: TypeFormatter) {}\n\n    public supportsType(type: FunctionType): boolean {\n        return type instanceof FunctionType;\n    }\n\n    public getDefinition(type: FunctionType): Definition {\n        // Return a custom schema for the function property.\n        return {\n            type: \"object\",\n            properties: {\n                isFunction: {\n                    type: \"boolean\",\n                    const: true,\n                },\n            },\n        };\n    }\n\n    // If this type does NOT HAVE children, generally all you need is:\n    public getChildren(type: FunctionType): BaseType[] {\n        return [];\n    }\n\n    // However, if children ARE supported, you'll need something similar to\n    // this (see src/TypeFormatter/{Array,Definition,etc}.ts for some examples):\n    public getChildren(type: FunctionType): BaseType[] {\n        return this.childTypeFormatter.getChildren(type.getType());\n    }\n}\n```\n\n2. Then we add the formatter as a child to the core formatter using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyFunctionTypeFormatter } from \"./my-function-formatter.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\n// We configure the formatter an add our custom formatter to it.\nconst formatter = createFormatter(config, (fmt, circularReferenceTypeFormatter) => {\n    // If your formatter DOES NOT support children, e.g. getChildren() { return [] }:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter());\n    // If your formatter DOES support children, you'll need this reference too:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter(circularReferenceTypeFormatter));\n});\n\nconst program = createProgram(config);\nconst parser = createParser(program, config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n### Custom parsing\n\nSimilar to custom formatting, extending the built-in parsing works practically the same way:\n\n1. First we create a parser, in this case for parsing construct types:\n\n```ts\n// my-constructor-parser.ts\nimport { Context, StringType, ReferenceType, BaseType, SubNodeParser } from \"ts-json-schema-generator\";\nimport ts from \"typescript\";\n\nexport class MyConstructorParser implements SubNodeParser {\n    supportsNode(node: ts.Node): boolean {\n        return node.kind === ts.SyntaxKind.ConstructorType;\n    }\n    createType(node: ts.Node, context: Context, reference?: ReferenceType): BaseType | undefined {\n        return new StringType(); // Treat constructors as strings in this example\n    }\n}\n```\n\n2. Then we add the parser as a child to the core parser using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyConstructorParser } from \"./my-constructor-parser.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst program = createProgram(config);\n\n// We configure the parser an add our custom parser to it.\nconst parser = createParser(program, config, (prs) => {\n    prs.addNodeParser(new MyConstructorParser());\n});\n\nconst formatter = createFormatter(config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n## Options\n\n```\n-p, --path 'index.ts'\n    The path to the TypeScript source file. If this is not provided, the type will be searched in the project specified in the `.tsconfig`.\n\n-t, --type 'My.Type.Name'\n    The type the generated schema will represent. If omitted, the generated schema will contain all\n    types found in the files matching path. The same is true if '*' is specified.\n\n-i, --id 'generatedSchemaId'\n    The `$id` of the generated schema. If omitted, there will be no `$id`.\n\n-e, --expose <all|none|export>\n    all: Create shared $ref definitions for all types.\n    none: Do not create shared $ref definitions.\n    export (default): Create shared $ref definitions only for exported types (not tagged as `@internal`).\n\n-f, --tsconfig 'my/project/tsconfig.json'\n    Use a custom tsconfig file for processing typescript (see https://www.typescriptlang.org/docs/handbook/tsconfig-json.html) instead of the default:\n    {\n        \"compilerOptions\": {\n            \"noEmit\": true,\n            \"emitDecoratorMetadata\": true,\n            \"experimentalDecorators\": true,\n            \"target\": \"ES5\",\n            \"module\": \"CommonJS\",\n            \"strictNullChecks\": false,\n        }\n    }\n\n-j, --jsDoc <extended|none|basic>\n    none: Do not use JsDoc annotations.\n    basic: Read JsDoc annotations to provide schema properties.\n    extended (default): Also read @nullable, and @asType annotations.\n\n--unstable\n    Do not sort properties.\n\n--strict-tuples\n    Do not allow additional items on tuples.\n\n--no-top-ref\n    Do not create a top-level $ref definition.\n\n--no-type-check\n    Skip type checks for better performance.\n\n--no-ref-encode\n    Do not encode references. According to the standard, references must be valid URIs but some tools do not support encoded references.\n\n--validation-keywords\n    Provide additional validation keywords to include.\n\n-o, --out\n    Specify the output file path. Without this option, the generator logs the response in the console.\n\n--additional-properties <true|false>\n    Controls whether or not to allow additional properties for objects that have no index signature.\n\n    true: Additional properties are allowed\n    false (default): Additional properties are not allowed\n\n--minify\n    Minify generated schema (default: false)\n```\n\n## Current state\n\n-   `interface` types\n-   `enum` types\n-   `union`, `tuple`, `type[]` types\n-   `Date`, `RegExp` types\n-   `string`, `boolean`, `number` types\n-   `\"value\"`, `123`, `true`, `false`, `null`, `undefined` literals\n-   type aliases\n-   generics\n-   `typeof`\n-   `keyof`\n-   conditional types\n\n## Run locally\n\n`yarn --silent run run --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\n## Debug\n\n`yarn --silent run debug --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\nAnd connect via the debugger protocol.\n\n[AST Explorer](https://astexplorer.net/) is amazing for developers of this tool!\n\n## Publish\n\nPublishing is handled by a 2-branch [pre-release process](https://intuit.github.io/auto/docs/generated/shipit#next-branch-default), configured in `publish-auto.yml`. All changes should be based off the default `next` branch, and are published automatically.\n\n-   PRs made into the default branch are auto-deployed to the `next` pre-release tag on NPM. The result can be installed with `npm install ts-json-schema-generator@next`\n    -   When merging into `next`, please use the `squash and merge` strategy.\n-   To release a new stable version, open a PR from `next` into `stable` using this [compare link](https://github.com/vega/ts-json-schema-generator/compare/stable...next).\n    -   When merging from `next` into `stable`, please use the `create a merge commit` strategy.\n",
      "readmeFilename": "README.md",
      "gitHead": "f4eb9e3fdd6026c675251e7b81c6309cfeaeb0e6",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.98.1-next.1",
      "_nodeVersion": "16.14.0",
      "_npmVersion": "8.3.1",
      "dist": {
        "integrity": "sha512-YhpzqoOXGkufo6EXfoIbrycmTKTgpuCuVV7LfAtvzq8lye+xtUQaR5nxyVgjuk0AvXqtHzEzJo/YW9LDUneGPw==",
        "shasum": "d9f75283e24abfaacd3d1640996dd27ac1a3dac3",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.98.1-next.1.tgz",
        "fileCount": 666,
        "unpackedSize": 753269,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJiMjqjACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2VmqGcw//YCtqR+aAov10rfZIIVhkIQpQUVUed1IgESKH8L9VfHDveBdB\r\nJjR/SLznnaNrdHk+LkERUbqiEk53m5osmjJ9xBeIJbxp/2S0zOkEboAiXlB5\r\nd2Sk9H2c1RbQgP2VfK0AfSzwQODhNO3r2CrtSPUv5C4iBFQYISCau8OsHvPP\r\nhOIavGDshlBimsyR+nQvr5/LJNZAQHhOzJfZNNzuaIM0peLPNP6IJGakfME3\r\ngOP3h2yTKjmRH4q9Qp+U3RUfOkyWhUMpiibHZAcBtfhgDvlSvzDWpn6iOM/G\r\n9L0UBXYAgbhqjvPSGO9BbK/P0kGqcSojMv2Ip3Z89ABiL4mjrSYD6IpxBARq\r\n2iQ5/ciCfqt/fR3E+ClQnA+L8Nf1w30ka/Upracolh3NghULTcfy6pS1tcEA\r\n+IVmU0NpUpGp/8FqPNp5+pt2sSmu4/y1qRVslSyjDgU2w0Ug5vcIKVnnyuUw\r\nkc4diHVITVdk7/L9mr0f+teqZaKfutJYl1MX438fPTr0D1i9/bq8ZR6cXmX2\r\nugwMKhvdpfpxsR8mXSDUa8YuABsHdD9tRcmsXIXY1+F3ohKMtOPXOyvpd20p\r\nmchriMdcd/bfr4RmYH0qvLmMkuzJrXvqLA6KhcDYfBvw63WXymYsbFDoR6FO\r\nNWR2523cvqZD1KxhG+yHvR5PdivTEfBh2pI=\r\n=W+wF\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIQDFat1pQ766PZo1LNUm+3S8NvVBFCyG00XDM/KiIZE3ZQIgXBFiN8dWgZV/U9VztFMYrebwgXeragvfXSyJTVWNlZQ="
          }
        ]
      },
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "maintainers": [
        {
          "name": "jheer",
          "email": "jeffrey.heer@gmail.com"
        },
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "kanitw",
          "email": "kanitw@gmail.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.98.1-next.1_1647458978933_0.01665943918816093"
      },
      "_hasShrinkwrap": false
    },
    "0.98.1-next.2": {
      "name": "ts-json-schema-generator",
      "version": "0.98.1-next.2",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "MooYeol Prescott Lee",
          "email": "mooyoul@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=10.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.9",
        "commander": "^9.0.0",
        "glob": "^7.2.0",
        "safe-stable-stringify": "^2.3.1",
        "json5": "^2.2.0",
        "typescript": "~4.6.2"
      },
      "devDependencies": {
        "@auto-it/conventional-commits": "^10.32.5",
        "@auto-it/first-time-contributor": "^10.32.5",
        "@babel/core": "^7.16.7",
        "@babel/preset-env": "^7.16.8",
        "@babel/preset-typescript": "^7.16.7",
        "@types/glob": "^7.2.0",
        "@types/jest": "^27.4.0",
        "@types/node": "^17.0.8",
        "@typescript-eslint/eslint-plugin": "^5.9.1",
        "@typescript-eslint/parser": "^5.9.1",
        "ajv": "^8.8.2",
        "ajv-formats": "^2.1.1",
        "auto": "^10.32.5",
        "chai": "^4.3.4",
        "cross-env": "^7.0.3",
        "eslint": "^8.6.0",
        "eslint-config-prettier": "^8.3.0",
        "eslint-plugin-prettier": "^4.0.0",
        "jest": "^27.4.7",
        "jest-junit": "^13.0.0",
        "prettier": "^2.5.1",
        "ts-node": "^10.4.0",
        "vega": "^5.21.0",
        "vega-lite": "^5.2.0"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint \"{src,test,factory}/**/*.ts\"",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "cross-env FAST_TEST=1 jest test/ --verbose",
        "test:coverage": "yarn jest test/ --collectCoverage=true",
        "test:update": "cross-env UPDATE_SCHEMA=true yarn test:fast",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node-transpile-only ts-json-schema-generator.ts",
        "release": "yarn build && auto shipit"
      },
      "readme": "# ts-json-schema-generator\n\n![Test](https://github.com/vega/ts-json-schema-generator/workflows/Test/badge.svg)\n[![codecov](https://codecov.io/gh/vega/ts-json-schema-generator/branch/master/graph/badge.svg)](https://codecov.io/gh/vega/ts-json-schema-generator)\n[![npm version](https://img.shields.io/npm/v/ts-json-schema-generator.svg)](https://www.npmjs.com/package/ts-json-schema-generator)\n\nExtended version of [https://github.com/xiag-ag/typescript-to-json-schema](https://github.com/xiag-ag/typescript-to-json-schema).\n\nInspired by [`YousefED/typescript-json-schema`](https://github.com/YousefED/typescript-json-schema). Here's the differences list:\n\n-   this implementation avoids the use of `typeChecker.getTypeAtLocation()` (so probably it keeps correct type aliases)\n-   processing AST and formatting JSON schema have been split into two independent steps\n-   not exported types, interfaces, enums are not exposed in the `definitions` section in the JSON schema\n\n## Contributors\n\nThis project is made possible by a [community of contributors](https://github.com/vega/ts-json-schema-generator/graphs/contributors). We welcome contributions of any kind (issues, code, documentation, examples, tests,...). Please read our [code of conduct](https://github.com/vega/vega/blob/master/CODE_OF_CONDUCT.md).\n\n## CLI Usage\n\n```bash\nnpm install --save ts-json-schema-generator\n./node_modules/.bin/ts-json-schema-generator --path 'my/project/**/*.ts' --type 'My.Type.Name'\n```\n\nNote that different platforms (e.g. Windows) may use different path separators so you may have to adjust the command above.\n\n## Programmatic Usage\n\n```js\n// main.js\n\nconst tsj = require(\"ts-json-schema-generator\");\nconst fs = require(\"fs\");\n\n/** @type {import('ts-json-schema-generator/dist/src/Config').Config} */\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst output_path = \"path/to/output/file\";\n\nconst schema = tsj.createGenerator(config).createSchema(config.type);\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\nRun the schema generator via `node main.js`.\n\n### Custom formatting\n\nExtending the built-in formatting is possible by creating a custom formatter and adding it to the main formatter:\n\n1. First we create a formatter, in this case for formatting function types:\n\n```ts\n// my-function-formatter.ts\nimport { BaseType, Definition, FunctionType, SubTypeFormatter } from \"ts-json-schema-generator\";\nimport ts from \"typescript\";\n\nexport class MyFunctionTypeFormatter implements SubTypeFormatter {\n    // You can skip this line if you don't need childTypeFormatter\n    public constructor(private childTypeFormatter: TypeFormatter) {}\n\n    public supportsType(type: FunctionType): boolean {\n        return type instanceof FunctionType;\n    }\n\n    public getDefinition(type: FunctionType): Definition {\n        // Return a custom schema for the function property.\n        return {\n            type: \"object\",\n            properties: {\n                isFunction: {\n                    type: \"boolean\",\n                    const: true,\n                },\n            },\n        };\n    }\n\n    // If this type does NOT HAVE children, generally all you need is:\n    public getChildren(type: FunctionType): BaseType[] {\n        return [];\n    }\n\n    // However, if children ARE supported, you'll need something similar to\n    // this (see src/TypeFormatter/{Array,Definition,etc}.ts for some examples):\n    public getChildren(type: FunctionType): BaseType[] {\n        return this.childTypeFormatter.getChildren(type.getType());\n    }\n}\n```\n\n2. Then we add the formatter as a child to the core formatter using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyFunctionTypeFormatter } from \"./my-function-formatter.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\n// We configure the formatter an add our custom formatter to it.\nconst formatter = createFormatter(config, (fmt, circularReferenceTypeFormatter) => {\n    // If your formatter DOES NOT support children, e.g. getChildren() { return [] }:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter());\n    // If your formatter DOES support children, you'll need this reference too:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter(circularReferenceTypeFormatter));\n});\n\nconst program = createProgram(config);\nconst parser = createParser(program, config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n### Custom parsing\n\nSimilar to custom formatting, extending the built-in parsing works practically the same way:\n\n1. First we create a parser, in this case for parsing construct types:\n\n```ts\n// my-constructor-parser.ts\nimport { Context, StringType, ReferenceType, BaseType, SubNodeParser } from \"ts-json-schema-generator\";\nimport ts from \"typescript\";\n\nexport class MyConstructorParser implements SubNodeParser {\n    supportsNode(node: ts.Node): boolean {\n        return node.kind === ts.SyntaxKind.ConstructorType;\n    }\n    createType(node: ts.Node, context: Context, reference?: ReferenceType): BaseType | undefined {\n        return new StringType(); // Treat constructors as strings in this example\n    }\n}\n```\n\n2. Then we add the parser as a child to the core parser using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyConstructorParser } from \"./my-constructor-parser.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst program = createProgram(config);\n\n// We configure the parser an add our custom parser to it.\nconst parser = createParser(program, config, (prs) => {\n    prs.addNodeParser(new MyConstructorParser());\n});\n\nconst formatter = createFormatter(config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n## Options\n\n```\n-p, --path 'index.ts'\n    The path to the TypeScript source file. If this is not provided, the type will be searched in the project specified in the `.tsconfig`.\n\n-t, --type 'My.Type.Name'\n    The type the generated schema will represent. If omitted, the generated schema will contain all\n    types found in the files matching path. The same is true if '*' is specified.\n\n-i, --id 'generatedSchemaId'\n    The `$id` of the generated schema. If omitted, there will be no `$id`.\n\n-e, --expose <all|none|export>\n    all: Create shared $ref definitions for all types.\n    none: Do not create shared $ref definitions.\n    export (default): Create shared $ref definitions only for exported types (not tagged as `@internal`).\n\n-f, --tsconfig 'my/project/tsconfig.json'\n    Use a custom tsconfig file for processing typescript (see https://www.typescriptlang.org/docs/handbook/tsconfig-json.html) instead of the default:\n    {\n        \"compilerOptions\": {\n            \"noEmit\": true,\n            \"emitDecoratorMetadata\": true,\n            \"experimentalDecorators\": true,\n            \"target\": \"ES5\",\n            \"module\": \"CommonJS\",\n            \"strictNullChecks\": false,\n        }\n    }\n\n-j, --jsDoc <extended|none|basic>\n    none: Do not use JsDoc annotations.\n    basic: Read JsDoc annotations to provide schema properties.\n    extended (default): Also read @nullable, and @asType annotations.\n\n--unstable\n    Do not sort properties.\n\n--strict-tuples\n    Do not allow additional items on tuples.\n\n--no-top-ref\n    Do not create a top-level $ref definition.\n\n--no-type-check\n    Skip type checks for better performance.\n\n--no-ref-encode\n    Do not encode references. According to the standard, references must be valid URIs but some tools do not support encoded references.\n\n--validation-keywords\n    Provide additional validation keywords to include.\n\n-o, --out\n    Specify the output file path. Without this option, the generator logs the response in the console.\n\n--additional-properties <true|false>\n    Controls whether or not to allow additional properties for objects that have no index signature.\n\n    true: Additional properties are allowed\n    false (default): Additional properties are not allowed\n\n--minify\n    Minify generated schema (default: false)\n```\n\n## Current state\n\n-   `interface` types\n-   `enum` types\n-   `union`, `tuple`, `type[]` types\n-   `Date`, `RegExp` types\n-   `string`, `boolean`, `number` types\n-   `\"value\"`, `123`, `true`, `false`, `null`, `undefined` literals\n-   type aliases\n-   generics\n-   `typeof`\n-   `keyof`\n-   conditional types\n\n## Run locally\n\n`yarn --silent run run --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\n## Debug\n\n`yarn --silent run debug --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\nAnd connect via the debugger protocol.\n\n[AST Explorer](https://astexplorer.net/) is amazing for developers of this tool!\n\n## Publish\n\nPublishing is handled by a 2-branch [pre-release process](https://intuit.github.io/auto/docs/generated/shipit#next-branch-default), configured in `publish-auto.yml`. All changes should be based off the default `next` branch, and are published automatically.\n\n-   PRs made into the default branch are auto-deployed to the `next` pre-release tag on NPM. The result can be installed with `npm install ts-json-schema-generator@next`\n    -   When merging into `next`, please use the `squash and merge` strategy.\n-   To release a new stable version, open a PR from `next` into `stable` using this [compare link](https://github.com/vega/ts-json-schema-generator/compare/stable...next).\n    -   When merging from `next` into `stable`, please use the `create a merge commit` strategy.\n",
      "readmeFilename": "README.md",
      "gitHead": "642022caad7dd60504408fade66d03425f82ab9a",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.98.1-next.2",
      "_nodeVersion": "16.14.0",
      "_npmVersion": "8.3.1",
      "dist": {
        "integrity": "sha512-pkScJVaFBus8beOXHxiUHe1Rpc/arEcBboB1/f1WmZK0kN89Ig7vMg0ikM1ybLuMLStpJ3oJu5icYvQw0jzn5A==",
        "shasum": "8e5fbf7b9daca45a4f96fa7408ac6999a2983bb8",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.98.1-next.2.tgz",
        "fileCount": 670,
        "unpackedSize": 762283,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJiN4vrACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2VmpiBA/8C1XY9wx9EDEHL3/3aOM0CvQ6PhD1Rr6/1QgLCPn9h8l0aWFy\r\nn4uxaDZ7i6GPJ5v+VZh05iEkJxskZdqjsMkAdFufA9Rw5/mlLEfBX8+MKTvN\r\nu3cgol5HA99usQZP2MNZWY9k1fs3P3TjEy8tR5ViOHu52BchFzA5hDKGKKJB\r\ndEhY1IPrr578qE6qIeS8yrvPBqbwMo+XQwuPZ7OCKNsHg33duwypNtxsyjlr\r\nBOuXx24vXBO4RivpudtLaeQv4vVtyrJEnbDjNLbAxUdh5EwTilPXdFskuQLT\r\nWOS/Wns3JH4644BWK/SrzMgZwDmX3RvGCwpOShQtQG7jXFckFUnAX+d4wIAE\r\nlItJtNwUiIVGTfg0Mr0CVYib+VAwkvRkm0doMgo4aoOcmsKIGPmZxOq350Fh\r\nsXaZdq5DsqIrhUu4suoBr3CSPVWmdQC0Cggr7tQaX/nsiK+0qbmRnk50aIc2\r\njiZ4BUdpw4GPjSxgZdNK+Vi6CInVco1JJGKarTya7o+sKBjQsF9exleCOq9u\r\nPNp6WuLTfgbXPIPMj5IYisu95hDnP+o/a/gkWUwwtMb+WhwF3dhTz1NhIhfX\r\n57HFOZK0oecLEBorA1Ls3QSaHymLIqHLtFoOj3C6rio/mj/6slyj5/8lYmdD\r\nVATzuqpWJ78g1MiJhoUFrgI7gKcrWVSRvwY=\r\n=5bve\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIQD5yBRWdl1U2J6Ff+MHmT8da98yK04iZEkzWDGALIrvRwIgBQPJyUHwtPqppuckxyoFZsaKGtSAXfG8H1sDg2YB8Yo="
          }
        ]
      },
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "maintainers": [
        {
          "name": "jheer",
          "email": "jeffrey.heer@gmail.com"
        },
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "kanitw",
          "email": "kanitw@gmail.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.98.1-next.2_1647807467392_0.2190756127507658"
      },
      "_hasShrinkwrap": false
    },
    "0.98.1-next.3": {
      "name": "ts-json-schema-generator",
      "version": "0.98.1-next.3",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "MooYeol Prescott Lee",
          "email": "mooyoul@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=10.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.9",
        "commander": "^9.0.0",
        "glob": "^7.2.0",
        "safe-stable-stringify": "^2.3.1",
        "json5": "^2.2.0",
        "typescript": "~4.6.2"
      },
      "devDependencies": {
        "@auto-it/conventional-commits": "^10.32.5",
        "@auto-it/first-time-contributor": "^10.32.5",
        "@babel/core": "^7.16.7",
        "@babel/preset-env": "^7.16.8",
        "@babel/preset-typescript": "^7.16.7",
        "@types/glob": "^7.2.0",
        "@types/jest": "^27.4.0",
        "@types/node": "^17.0.8",
        "@typescript-eslint/eslint-plugin": "^5.9.1",
        "@typescript-eslint/parser": "^5.9.1",
        "ajv": "^8.8.2",
        "ajv-formats": "^2.1.1",
        "auto": "^10.32.5",
        "chai": "^4.3.4",
        "cross-env": "^7.0.3",
        "eslint": "^8.6.0",
        "eslint-config-prettier": "^8.3.0",
        "eslint-plugin-prettier": "^4.0.0",
        "jest": "^27.4.7",
        "jest-junit": "^13.0.0",
        "prettier": "^2.5.1",
        "ts-node": "^10.4.0",
        "vega": "^5.21.0",
        "vega-lite": "^5.2.0"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint \"{src,test,factory}/**/*.ts\"",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "cross-env FAST_TEST=1 jest test/ --verbose",
        "test:coverage": "yarn jest test/ --collectCoverage=true",
        "test:update": "cross-env UPDATE_SCHEMA=true yarn test:fast",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node-transpile-only ts-json-schema-generator.ts",
        "release": "yarn build && auto shipit"
      },
      "readme": "# ts-json-schema-generator\n\n![Test](https://github.com/vega/ts-json-schema-generator/workflows/Test/badge.svg)\n[![codecov](https://codecov.io/gh/vega/ts-json-schema-generator/branch/master/graph/badge.svg)](https://codecov.io/gh/vega/ts-json-schema-generator)\n[![npm version](https://img.shields.io/npm/v/ts-json-schema-generator.svg)](https://www.npmjs.com/package/ts-json-schema-generator)\n\nExtended version of [https://github.com/xiag-ag/typescript-to-json-schema](https://github.com/xiag-ag/typescript-to-json-schema).\n\nInspired by [`YousefED/typescript-json-schema`](https://github.com/YousefED/typescript-json-schema). Here's the differences list:\n\n-   this implementation avoids the use of `typeChecker.getTypeAtLocation()` (so probably it keeps correct type aliases)\n-   processing AST and formatting JSON schema have been split into two independent steps\n-   not exported types, interfaces, enums are not exposed in the `definitions` section in the JSON schema\n\n## Contributors\n\nThis project is made possible by a [community of contributors](https://github.com/vega/ts-json-schema-generator/graphs/contributors). We welcome contributions of any kind (issues, code, documentation, examples, tests,...). Please read our [code of conduct](https://github.com/vega/vega/blob/master/CODE_OF_CONDUCT.md).\n\n## CLI Usage\n\n```bash\nnpm install --save ts-json-schema-generator\n./node_modules/.bin/ts-json-schema-generator --path 'my/project/**/*.ts' --type 'My.Type.Name'\n```\n\nNote that different platforms (e.g. Windows) may use different path separators so you may have to adjust the command above.\n\n## Programmatic Usage\n\n```js\n// main.js\n\nconst tsj = require(\"ts-json-schema-generator\");\nconst fs = require(\"fs\");\n\n/** @type {import('ts-json-schema-generator/dist/src/Config').Config} */\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst output_path = \"path/to/output/file\";\n\nconst schema = tsj.createGenerator(config).createSchema(config.type);\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\nRun the schema generator via `node main.js`.\n\n### Custom formatting\n\nExtending the built-in formatting is possible by creating a custom formatter and adding it to the main formatter:\n\n1. First we create a formatter, in this case for formatting function types:\n\n```ts\n// my-function-formatter.ts\nimport { BaseType, Definition, FunctionType, SubTypeFormatter } from \"ts-json-schema-generator\";\nimport ts from \"typescript\";\n\nexport class MyFunctionTypeFormatter implements SubTypeFormatter {\n    // You can skip this line if you don't need childTypeFormatter\n    public constructor(private childTypeFormatter: TypeFormatter) {}\n\n    public supportsType(type: FunctionType): boolean {\n        return type instanceof FunctionType;\n    }\n\n    public getDefinition(type: FunctionType): Definition {\n        // Return a custom schema for the function property.\n        return {\n            type: \"object\",\n            properties: {\n                isFunction: {\n                    type: \"boolean\",\n                    const: true,\n                },\n            },\n        };\n    }\n\n    // If this type does NOT HAVE children, generally all you need is:\n    public getChildren(type: FunctionType): BaseType[] {\n        return [];\n    }\n\n    // However, if children ARE supported, you'll need something similar to\n    // this (see src/TypeFormatter/{Array,Definition,etc}.ts for some examples):\n    public getChildren(type: FunctionType): BaseType[] {\n        return this.childTypeFormatter.getChildren(type.getType());\n    }\n}\n```\n\n2. Then we add the formatter as a child to the core formatter using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyFunctionTypeFormatter } from \"./my-function-formatter.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\n// We configure the formatter an add our custom formatter to it.\nconst formatter = createFormatter(config, (fmt, circularReferenceTypeFormatter) => {\n    // If your formatter DOES NOT support children, e.g. getChildren() { return [] }:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter());\n    // If your formatter DOES support children, you'll need this reference too:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter(circularReferenceTypeFormatter));\n});\n\nconst program = createProgram(config);\nconst parser = createParser(program, config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n### Custom parsing\n\nSimilar to custom formatting, extending the built-in parsing works practically the same way:\n\n1. First we create a parser, in this case for parsing construct types:\n\n```ts\n// my-constructor-parser.ts\nimport { Context, StringType, ReferenceType, BaseType, SubNodeParser } from \"ts-json-schema-generator\";\nimport ts from \"typescript\";\n\nexport class MyConstructorParser implements SubNodeParser {\n    supportsNode(node: ts.Node): boolean {\n        return node.kind === ts.SyntaxKind.ConstructorType;\n    }\n    createType(node: ts.Node, context: Context, reference?: ReferenceType): BaseType | undefined {\n        return new StringType(); // Treat constructors as strings in this example\n    }\n}\n```\n\n2. Then we add the parser as a child to the core parser using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyConstructorParser } from \"./my-constructor-parser.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst program = createProgram(config);\n\n// We configure the parser an add our custom parser to it.\nconst parser = createParser(program, config, (prs) => {\n    prs.addNodeParser(new MyConstructorParser());\n});\n\nconst formatter = createFormatter(config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n## Options\n\n```\n-p, --path 'index.ts'\n    The path to the TypeScript source file. If this is not provided, the type will be searched in the project specified in the `.tsconfig`.\n\n-t, --type 'My.Type.Name'\n    The type the generated schema will represent. If omitted, the generated schema will contain all\n    types found in the files matching path. The same is true if '*' is specified.\n\n-i, --id 'generatedSchemaId'\n    The `$id` of the generated schema. If omitted, there will be no `$id`.\n\n-e, --expose <all|none|export>\n    all: Create shared $ref definitions for all types.\n    none: Do not create shared $ref definitions.\n    export (default): Create shared $ref definitions only for exported types (not tagged as `@internal`).\n\n-f, --tsconfig 'my/project/tsconfig.json'\n    Use a custom tsconfig file for processing typescript (see https://www.typescriptlang.org/docs/handbook/tsconfig-json.html) instead of the default:\n    {\n        \"compilerOptions\": {\n            \"noEmit\": true,\n            \"emitDecoratorMetadata\": true,\n            \"experimentalDecorators\": true,\n            \"target\": \"ES5\",\n            \"module\": \"CommonJS\",\n            \"strictNullChecks\": false,\n        }\n    }\n\n-j, --jsDoc <extended|none|basic>\n    none: Do not use JsDoc annotations.\n    basic: Read JsDoc annotations to provide schema properties.\n    extended (default): Also read @nullable, and @asType annotations.\n\n--unstable\n    Do not sort properties.\n\n--strict-tuples\n    Do not allow additional items on tuples.\n\n--no-top-ref\n    Do not create a top-level $ref definition.\n\n--no-type-check\n    Skip type checks for better performance.\n\n--no-ref-encode\n    Do not encode references. According to the standard, references must be valid URIs but some tools do not support encoded references.\n\n--validation-keywords\n    Provide additional validation keywords to include.\n\n-o, --out\n    Specify the output file path. Without this option, the generator logs the response in the console.\n\n--additional-properties <true|false>\n    Controls whether or not to allow additional properties for objects that have no index signature.\n\n    true: Additional properties are allowed\n    false (default): Additional properties are not allowed\n\n--minify\n    Minify generated schema (default: false)\n```\n\n## Current state\n\n-   `interface` types\n-   `enum` types\n-   `union`, `tuple`, `type[]` types\n-   `Date`, `RegExp` types\n-   `string`, `boolean`, `number` types\n-   `\"value\"`, `123`, `true`, `false`, `null`, `undefined` literals\n-   type aliases\n-   generics\n-   `typeof`\n-   `keyof`\n-   conditional types\n\n## Run locally\n\n`yarn --silent run run --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\n## Debug\n\n`yarn --silent run debug --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\nAnd connect via the debugger protocol.\n\n[AST Explorer](https://astexplorer.net/) is amazing for developers of this tool!\n\n## Publish\n\nPublishing is handled by a 2-branch [pre-release process](https://intuit.github.io/auto/docs/generated/shipit#next-branch-default), configured in `publish-auto.yml`. All changes should be based off the default `next` branch, and are published automatically.\n\n-   PRs made into the default branch are auto-deployed to the `next` pre-release tag on NPM. The result can be installed with `npm install ts-json-schema-generator@next`\n    -   When merging into `next`, please use the `squash and merge` strategy.\n-   To release a new stable version, open a PR from `next` into `stable` using this [compare link](https://github.com/vega/ts-json-schema-generator/compare/stable...next).\n    -   When merging from `next` into `stable`, please use the `create a merge commit` strategy.\n",
      "readmeFilename": "README.md",
      "gitHead": "8f2dc153e03aea3680adfeafa720afdffbc59cc4",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.98.1-next.3",
      "_nodeVersion": "16.14.0",
      "_npmVersion": "8.3.1",
      "dist": {
        "integrity": "sha512-Y+Np2s16pRO1pO64bvpW0YIDQ2j+S05ldQkI8otVg/rwxM9yp5UFEixkQb0oH8C2iQ+HVxOGCh/Pbd1IXnEqhg==",
        "shasum": "dd8ef4405f9a36f21bff81dab6923fe2f3650315",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.98.1-next.3.tgz",
        "fileCount": 682,
        "unpackedSize": 770595,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJiOKC+ACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2VmoZhRAAnEIdnAEMm9/969uP8Vs+GI2UhVZwDmfb5oSvNVHXhAgWfUep\r\nCx/Lddk1vlfSozi7lF9mbrScWWWixMdxrm1JTxkvIrC5QytDU5k/fk/6H5AW\r\nWXtEdRedlmSgmAtygleUtj9J4xsPdX5UXo1zhKT8xBbimfICTr0GPBcdA/lb\r\nm6mpPD7uRKOZaAp3u/9cATnBPNNj0miKbds27i6n6Fj3SwJHFNIElAPESTaJ\r\nLncspXJprCk+O5bQKqMCURDI/uP9B1WvPMWHSuUH6giOF441uZOmcCQGpY8L\r\nwsnPMsfYOjqvoU6C30UZZmQLAo+GxGNY5XtP0fTqtk2jUEEGQSkOStnZ4sSY\r\nC4I6TaPll1OGEkDl6tjX2AbnKokW6zL3yHMuQBIiCQj03mBv/FbKiQyWg7hI\r\nOd0GmtVtSQ/JG5f6uHKQ/ah7RkRlKoRwOTCh4J6tuqylRgPE0aU7hfNRI7Ez\r\nYG1jYWVEHWl1ksIfktDDhoASfvchmmjNIY+1ge135kjX1KfG2hjTHLYt1/8S\r\nh1tOv5rntgq0AdvTrhRMr9AN2pzIulRXYM22F8yAVBXs2Q48bS4PTzCCAF7c\r\n/VpPCAKDk9tV/eR5v+1OdQ4SvyXTgl4YTZmAKDQeefYf+5/HQENA6XwF9w/F\r\nMwZjKMpvsAMNInRgeLfMiyDPYOxurMott8k=\r\n=doGz\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIDcPSwpKpIW01naILT3frXMXNoab/c73+XFfGF8j63OZAiEAr2iaXvzwJ7gntltFdxMDjYiha9bGDkithJa6GAoBBqM="
          }
        ]
      },
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "maintainers": [
        {
          "name": "jheer",
          "email": "jeffrey.heer@gmail.com"
        },
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "kanitw",
          "email": "kanitw@gmail.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.98.1-next.3_1647878334306_0.5356111165178952"
      },
      "_hasShrinkwrap": false
    },
    "0.98.1-next.4": {
      "name": "ts-json-schema-generator",
      "version": "0.98.1-next.4",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "MooYeol Prescott Lee",
          "email": "mooyoul@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=10.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.9",
        "commander": "^9.0.0",
        "glob": "^7.2.0",
        "safe-stable-stringify": "^2.3.1",
        "json5": "^2.2.0",
        "typescript": "~4.6.2"
      },
      "devDependencies": {
        "@auto-it/conventional-commits": "^10.32.5",
        "@auto-it/first-time-contributor": "^10.32.5",
        "@babel/core": "^7.16.7",
        "@babel/preset-env": "^7.16.8",
        "@babel/preset-typescript": "^7.16.7",
        "@types/glob": "^7.2.0",
        "@types/jest": "^27.4.0",
        "@types/node": "^17.0.8",
        "@typescript-eslint/eslint-plugin": "^5.9.1",
        "@typescript-eslint/parser": "^5.9.1",
        "ajv": "^8.8.2",
        "ajv-formats": "^2.1.1",
        "auto": "^10.32.5",
        "chai": "^4.3.4",
        "cross-env": "^7.0.3",
        "eslint": "^8.6.0",
        "eslint-config-prettier": "^8.3.0",
        "eslint-plugin-prettier": "^4.0.0",
        "jest": "^27.4.7",
        "jest-junit": "^13.0.0",
        "prettier": "^2.5.1",
        "ts-node": "^10.4.0",
        "vega": "^5.21.0",
        "vega-lite": "^5.2.0"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint \"{src,test,factory}/**/*.ts\"",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "cross-env FAST_TEST=1 jest test/ --verbose",
        "test:coverage": "yarn jest test/ --collectCoverage=true",
        "test:update": "cross-env UPDATE_SCHEMA=true yarn test:fast",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node-transpile-only ts-json-schema-generator.ts",
        "release": "yarn build && auto shipit"
      },
      "readme": "# ts-json-schema-generator\n\n![Test](https://github.com/vega/ts-json-schema-generator/workflows/Test/badge.svg)\n[![codecov](https://codecov.io/gh/vega/ts-json-schema-generator/branch/master/graph/badge.svg)](https://codecov.io/gh/vega/ts-json-schema-generator)\n[![npm version](https://img.shields.io/npm/v/ts-json-schema-generator.svg)](https://www.npmjs.com/package/ts-json-schema-generator)\n\nExtended version of [https://github.com/xiag-ag/typescript-to-json-schema](https://github.com/xiag-ag/typescript-to-json-schema).\n\nInspired by [`YousefED/typescript-json-schema`](https://github.com/YousefED/typescript-json-schema). Here's the differences list:\n\n-   this implementation avoids the use of `typeChecker.getTypeAtLocation()` (so probably it keeps correct type aliases)\n-   processing AST and formatting JSON schema have been split into two independent steps\n-   not exported types, interfaces, enums are not exposed in the `definitions` section in the JSON schema\n\n## Contributors\n\nThis project is made possible by a [community of contributors](https://github.com/vega/ts-json-schema-generator/graphs/contributors). We welcome contributions of any kind (issues, code, documentation, examples, tests,...). Please read our [code of conduct](https://github.com/vega/vega/blob/master/CODE_OF_CONDUCT.md).\n\n## CLI Usage\n\n```bash\nnpm install --save ts-json-schema-generator\n./node_modules/.bin/ts-json-schema-generator --path 'my/project/**/*.ts' --type 'My.Type.Name'\n```\n\nNote that different platforms (e.g. Windows) may use different path separators so you may have to adjust the command above.\n\n## Programmatic Usage\n\n```js\n// main.js\n\nconst tsj = require(\"ts-json-schema-generator\");\nconst fs = require(\"fs\");\n\n/** @type {import('ts-json-schema-generator/dist/src/Config').Config} */\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst output_path = \"path/to/output/file\";\n\nconst schema = tsj.createGenerator(config).createSchema(config.type);\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\nRun the schema generator via `node main.js`.\n\n### Custom formatting\n\nExtending the built-in formatting is possible by creating a custom formatter and adding it to the main formatter:\n\n1. First we create a formatter, in this case for formatting function types:\n\n```ts\n// my-function-formatter.ts\nimport { BaseType, Definition, FunctionType, SubTypeFormatter } from \"ts-json-schema-generator\";\nimport ts from \"typescript\";\n\nexport class MyFunctionTypeFormatter implements SubTypeFormatter {\n    // You can skip this line if you don't need childTypeFormatter\n    public constructor(private childTypeFormatter: TypeFormatter) {}\n\n    public supportsType(type: FunctionType): boolean {\n        return type instanceof FunctionType;\n    }\n\n    public getDefinition(type: FunctionType): Definition {\n        // Return a custom schema for the function property.\n        return {\n            type: \"object\",\n            properties: {\n                isFunction: {\n                    type: \"boolean\",\n                    const: true,\n                },\n            },\n        };\n    }\n\n    // If this type does NOT HAVE children, generally all you need is:\n    public getChildren(type: FunctionType): BaseType[] {\n        return [];\n    }\n\n    // However, if children ARE supported, you'll need something similar to\n    // this (see src/TypeFormatter/{Array,Definition,etc}.ts for some examples):\n    public getChildren(type: FunctionType): BaseType[] {\n        return this.childTypeFormatter.getChildren(type.getType());\n    }\n}\n```\n\n2. Then we add the formatter as a child to the core formatter using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyFunctionTypeFormatter } from \"./my-function-formatter.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\n// We configure the formatter an add our custom formatter to it.\nconst formatter = createFormatter(config, (fmt, circularReferenceTypeFormatter) => {\n    // If your formatter DOES NOT support children, e.g. getChildren() { return [] }:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter());\n    // If your formatter DOES support children, you'll need this reference too:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter(circularReferenceTypeFormatter));\n});\n\nconst program = createProgram(config);\nconst parser = createParser(program, config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n### Custom parsing\n\nSimilar to custom formatting, extending the built-in parsing works practically the same way:\n\n1. First we create a parser, in this case for parsing construct types:\n\n```ts\n// my-constructor-parser.ts\nimport { Context, StringType, ReferenceType, BaseType, SubNodeParser } from \"ts-json-schema-generator\";\nimport ts from \"typescript\";\n\nexport class MyConstructorParser implements SubNodeParser {\n    supportsNode(node: ts.Node): boolean {\n        return node.kind === ts.SyntaxKind.ConstructorType;\n    }\n    createType(node: ts.Node, context: Context, reference?: ReferenceType): BaseType | undefined {\n        return new StringType(); // Treat constructors as strings in this example\n    }\n}\n```\n\n2. Then we add the parser as a child to the core parser using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyConstructorParser } from \"./my-constructor-parser.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst program = createProgram(config);\n\n// We configure the parser an add our custom parser to it.\nconst parser = createParser(program, config, (prs) => {\n    prs.addNodeParser(new MyConstructorParser());\n});\n\nconst formatter = createFormatter(config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n## Options\n\n```\n-p, --path 'index.ts'\n    The path to the TypeScript source file. If this is not provided, the type will be searched in the project specified in the `.tsconfig`.\n\n-t, --type 'My.Type.Name'\n    The type the generated schema will represent. If omitted, the generated schema will contain all\n    types found in the files matching path. The same is true if '*' is specified.\n\n-i, --id 'generatedSchemaId'\n    The `$id` of the generated schema. If omitted, there will be no `$id`.\n\n-e, --expose <all|none|export>\n    all: Create shared $ref definitions for all types.\n    none: Do not create shared $ref definitions.\n    export (default): Create shared $ref definitions only for exported types (not tagged as `@internal`).\n\n-f, --tsconfig 'my/project/tsconfig.json'\n    Use a custom tsconfig file for processing typescript (see https://www.typescriptlang.org/docs/handbook/tsconfig-json.html) instead of the default:\n    {\n        \"compilerOptions\": {\n            \"noEmit\": true,\n            \"emitDecoratorMetadata\": true,\n            \"experimentalDecorators\": true,\n            \"target\": \"ES5\",\n            \"module\": \"CommonJS\",\n            \"strictNullChecks\": false,\n        }\n    }\n\n-j, --jsDoc <extended|none|basic>\n    none: Do not use JsDoc annotations.\n    basic: Read JsDoc annotations to provide schema properties.\n    extended (default): Also read @nullable, and @asType annotations.\n\n--unstable\n    Do not sort properties.\n\n--strict-tuples\n    Do not allow additional items on tuples.\n\n--no-top-ref\n    Do not create a top-level $ref definition.\n\n--no-type-check\n    Skip type checks for better performance.\n\n--no-ref-encode\n    Do not encode references. According to the standard, references must be valid URIs but some tools do not support encoded references.\n\n--validation-keywords\n    Provide additional validation keywords to include.\n\n-o, --out\n    Specify the output file path. Without this option, the generator logs the response in the console.\n\n--additional-properties <true|false>\n    Controls whether or not to allow additional properties for objects that have no index signature.\n\n    true: Additional properties are allowed\n    false (default): Additional properties are not allowed\n\n--minify\n    Minify generated schema (default: false)\n```\n\n## Current state\n\n-   `interface` types\n-   `enum` types\n-   `union`, `tuple`, `type[]` types\n-   `Date`, `RegExp` types\n-   `string`, `boolean`, `number` types\n-   `\"value\"`, `123`, `true`, `false`, `null`, `undefined` literals\n-   type aliases\n-   generics\n-   `typeof`\n-   `keyof`\n-   conditional types\n\n## Run locally\n\n`yarn --silent run run --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\n## Debug\n\n`yarn --silent run debug --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\nAnd connect via the debugger protocol.\n\n[AST Explorer](https://astexplorer.net/) is amazing for developers of this tool!\n\n## Publish\n\nPublishing is handled by a 2-branch [pre-release process](https://intuit.github.io/auto/docs/generated/shipit#next-branch-default), configured in `publish-auto.yml`. All changes should be based off the default `next` branch, and are published automatically.\n\n-   PRs made into the default branch are auto-deployed to the `next` pre-release tag on NPM. The result can be installed with `npm install ts-json-schema-generator@next`\n    -   When merging into `next`, please use the `squash and merge` strategy.\n-   To release a new stable version, open a PR from `next` into `stable` using this [compare link](https://github.com/vega/ts-json-schema-generator/compare/stable...next).\n    -   When merging from `next` into `stable`, please use the `create a merge commit` strategy.\n",
      "readmeFilename": "README.md",
      "gitHead": "d867c803033f75857c4c380f2225cf1b39779ab4",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@0.98.1-next.4",
      "_nodeVersion": "16.14.0",
      "_npmVersion": "8.3.1",
      "dist": {
        "integrity": "sha512-EN5AhI+E3HBojJLTKuMjBB46ZwmvWlP9lzINATg4GduBWHnoKUK/emo0ltec/HOA1DG40tjDAzlvq2CbL/Y58Q==",
        "shasum": "c739917fff5e3f52aba5214475504607565df12d",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-0.98.1-next.4.tgz",
        "fileCount": 682,
        "unpackedSize": 773025,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJiOKEXACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2VmqQ6Q/8D1WWRjiufNYp/MiIXSBcVmFfvVIfTloffweykd/xPxoWIeQy\r\nl17hCjARSSoKLDv/pwPgMhCmdw85DT2lALlFSI0WtvDmrF8d5VQWb432t4SB\r\nzCYQfUEgiAbD5b9sKTid61dXxByrUNc1tOf3iBRQbgyWgEpRaOiB58SjWaiR\r\njixl5/Di19mNVLIa/wEZGoLLGSYWABNnDj5SEvN9zof+ETV73VkMkh4msZvO\r\nAWr4fgfSX28OyLLKUKsWsL5KHDFz+lKyCZAHHfhh8FPQGeybAbEUO28ISKGZ\r\n/vz1UqZSWovjO2ijt/+tENH1tqVZxSqhAYEHN46wEA+vQ+rLgE55nViS5YdJ\r\nJnrFCACfFXFFf9ZpehVTmyS6B7y1VR0Pg/ISrQXCTsZvbauhD+4lksvKEOqe\r\njSs3OAPoMLdpkZT4gS8zQLuJn48eyf7/hk1/v1LWJya83IfFl/kFBOx0gJhw\r\nEdLdlCzwQZOMMn0aFx+68oG8G3RBMcvzxNcyHTtZqkAvved26/r+pi951CDu\r\nnDcuFxbf0Qre8qtIxgUqd0a+gzMeTZ6ChoGXzP/8W5/gZIJo9LrJFFxbgWxh\r\nPcEQKmtXB0bQa75UzlWjhavoX0kxL0g8DhHhfc3y52swuPtDYLFge4qGRZJp\r\n6aHHFIqlk+3bQmLwu97XslkL/FYIkGMR5yE=\r\n=tEnY\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCICE1mDzdX5R1DV+WuqZArBhvBzGsOr8pzV5/AWChMZ5hAiEArjw/S+wjPSvMmerlDjHdmkG+Pdtdj0ZEVk9hLzxnK9Q="
          }
        ]
      },
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "maintainers": [
        {
          "name": "jheer",
          "email": "jeffrey.heer@gmail.com"
        },
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "kanitw",
          "email": "kanitw@gmail.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_0.98.1-next.4_1647878423124_0.30084138528320437"
      },
      "_hasShrinkwrap": false
    },
    "1.0.0": {
      "name": "ts-json-schema-generator",
      "version": "1.0.0",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "MooYeol Prescott Lee",
          "email": "mooyoul@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=10.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.9",
        "commander": "^9.0.0",
        "glob": "^7.2.0",
        "safe-stable-stringify": "^2.3.1",
        "json5": "^2.2.0",
        "typescript": "~4.6.2"
      },
      "devDependencies": {
        "@auto-it/conventional-commits": "^10.32.5",
        "@auto-it/first-time-contributor": "^10.32.5",
        "@babel/core": "^7.16.7",
        "@babel/preset-env": "^7.16.8",
        "@babel/preset-typescript": "^7.16.7",
        "@types/glob": "^7.2.0",
        "@types/jest": "^27.4.0",
        "@types/node": "^17.0.8",
        "@typescript-eslint/eslint-plugin": "^5.9.1",
        "@typescript-eslint/parser": "^5.9.1",
        "ajv": "^8.8.2",
        "ajv-formats": "^2.1.1",
        "auto": "^10.32.5",
        "chai": "^4.3.4",
        "cross-env": "^7.0.3",
        "eslint": "^8.6.0",
        "eslint-config-prettier": "^8.3.0",
        "eslint-plugin-prettier": "^4.0.0",
        "jest": "^27.4.7",
        "jest-junit": "^13.0.0",
        "prettier": "^2.5.1",
        "ts-node": "^10.4.0",
        "vega": "^5.21.0",
        "vega-lite": "^5.2.0"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint \"{src,test,factory}/**/*.ts\"",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "cross-env FAST_TEST=1 jest test/ --verbose",
        "test:coverage": "yarn jest test/ --collectCoverage=true",
        "test:update": "cross-env UPDATE_SCHEMA=true yarn test:fast",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node-transpile-only ts-json-schema-generator.ts",
        "release": "yarn build && auto shipit"
      },
      "gitHead": "2d38d0023ae604c16e613b1a2d58204afff0e865",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@1.0.0",
      "_nodeVersion": "16.14.0",
      "_npmVersion": "8.3.1",
      "dist": {
        "integrity": "sha512-F5VofsyMhNSXKII32NDS8/Ur8o2K3Sh5i/U2ke3UgCKf26ybgm2cZeT2x7VJPl1trML/9QLzz/82l0mvzmb3Vw==",
        "shasum": "33e4affd1665268899eb57afbad397bc6a58cc53",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-1.0.0.tgz",
        "fileCount": 682,
        "unpackedSize": 773009,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJiOKM9ACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2Vmo10Q/9HlkkzgeXSs69bmlxb3SaRoDfiwJpXfToBzFIkHmIypkgWrBP\r\n+yssHdD68lePovnH416ceSfK5y5olNGXzGnlXasrsTCxuGZbBKo9z9pnJ2IP\r\npnLe9xMHLjMCSBjxdnqiPg55+exxElKnyqdJPiARY8ajQediyP6E2JBFAnAj\r\n/NJK63o+cg6ggwM9APCIDpeatfNvB9oWfg0HUZ2xXEb1/jfCFT3/LaPcNsBt\r\nLl9ToSDMh8Ky+mz1gfLBYzLscL3vAn1bKsJoG/RXGOSoFm4xuo2PUVLfQtLC\r\nSPPc6i/dwQw4g3aYkCXd0xIsgNJ89rLeXbpyAf7axynlW6KS2KhzgwNTtscv\r\nkwPUdQRcUYXLlsCpZ4i87liAp93wn5MqjXmbV1SSSBHkHCo2vuz7A7PeBviW\r\nplRrs3eiGYta3A+34uPZTYz4u0qE9+mgxT7PZsSZTAtMwXlcES0IwfYQ/kKH\r\ndL/y/ps/LM0kOoWYVQfK2WKmyWxk0HvSSVqerbXbpPv6LzFnrZeM2eD6kKmt\r\neCglACqI/acJehdkE1Tp6/HGZa0LDKzs5wsuFh1j6w/TWwYqK1M3bG3b7Sh+\r\nI0NuTvWXqyxriX7iqy0ptovwLDWpwqoOi+nBPQZMjpaVgFYSDExdj8obAd9s\r\n4mqzbl58iMQWJGU7w+IpwBFNmdBzqVyZ5WE=\r\n=pM5d\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIDC0AGHFHbKXh2ZFBxE2byz8UmH9QYw8O2+/EgGI3yrKAiEA5BiA2vtVQgydETEBuv9cCydfSAzj4cLVRetSDy5mtCU="
          }
        ]
      },
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "maintainers": [
        {
          "name": "jheer",
          "email": "jeffrey.heer@gmail.com"
        },
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "kanitw",
          "email": "kanitw@gmail.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_1.0.0_1647878973107_0.2433103197701454"
      },
      "_hasShrinkwrap": false
    },
    "1.0.1-next.0": {
      "name": "ts-json-schema-generator",
      "version": "1.0.1-next.0",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "MooYeol Prescott Lee",
          "email": "mooyoul@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=10.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.9",
        "commander": "^9.0.0",
        "glob": "^7.2.0",
        "safe-stable-stringify": "^2.3.1",
        "json5": "^2.2.0",
        "typescript": "~4.6.2"
      },
      "devDependencies": {
        "@auto-it/conventional-commits": "^10.32.5",
        "@auto-it/first-time-contributor": "^10.32.5",
        "@babel/core": "^7.16.7",
        "@babel/preset-env": "^7.16.8",
        "@babel/preset-typescript": "^7.16.7",
        "@types/glob": "^7.2.0",
        "@types/jest": "^27.4.0",
        "@types/node": "^17.0.8",
        "@typescript-eslint/eslint-plugin": "^5.9.1",
        "@typescript-eslint/parser": "^5.9.1",
        "ajv": "^8.8.2",
        "ajv-formats": "^2.1.1",
        "auto": "^10.32.5",
        "chai": "^4.3.4",
        "cross-env": "^7.0.3",
        "eslint": "^8.6.0",
        "eslint-config-prettier": "^8.3.0",
        "eslint-plugin-prettier": "^4.0.0",
        "jest": "^27.4.7",
        "jest-junit": "^13.0.0",
        "prettier": "^2.5.1",
        "ts-node": "^10.4.0",
        "vega": "^5.21.0",
        "vega-lite": "^5.2.0"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint \"{src,test,factory}/**/*.ts\"",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "cross-env FAST_TEST=1 jest test/ --verbose",
        "test:coverage": "yarn jest test/ --collectCoverage=true",
        "test:update": "cross-env UPDATE_SCHEMA=true yarn test:fast",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node-transpile-only ts-json-schema-generator.ts",
        "release": "yarn build && auto shipit"
      },
      "readme": "# ts-json-schema-generator\n\n![Test](https://github.com/vega/ts-json-schema-generator/workflows/Test/badge.svg)\n[![codecov](https://codecov.io/gh/vega/ts-json-schema-generator/branch/master/graph/badge.svg)](https://codecov.io/gh/vega/ts-json-schema-generator)\n[![npm version](https://img.shields.io/npm/v/ts-json-schema-generator.svg)](https://www.npmjs.com/package/ts-json-schema-generator)\n\nExtended version of [https://github.com/xiag-ag/typescript-to-json-schema](https://github.com/xiag-ag/typescript-to-json-schema).\n\nInspired by [`YousefED/typescript-json-schema`](https://github.com/YousefED/typescript-json-schema). Here's the differences list:\n\n-   this implementation avoids the use of `typeChecker.getTypeAtLocation()` (so probably it keeps correct type aliases)\n-   processing AST and formatting JSON schema have been split into two independent steps\n-   not exported types, interfaces, enums are not exposed in the `definitions` section in the JSON schema\n\n## Contributors\n\nThis project is made possible by a [community of contributors](https://github.com/vega/ts-json-schema-generator/graphs/contributors). We welcome contributions of any kind (issues, code, documentation, examples, tests,...). Please read our [code of conduct](https://github.com/vega/vega/blob/master/CODE_OF_CONDUCT.md).\n\n## CLI Usage\n\n```bash\nnpm install --save ts-json-schema-generator\n./node_modules/.bin/ts-json-schema-generator --path 'my/project/**/*.ts' --type 'My.Type.Name'\n```\n\nNote that different platforms (e.g. Windows) may use different path separators so you may have to adjust the command above.\n\n## Programmatic Usage\n\n```js\n// main.js\n\nconst tsj = require(\"ts-json-schema-generator\");\nconst fs = require(\"fs\");\n\n/** @type {import('ts-json-schema-generator/dist/src/Config').Config} */\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst output_path = \"path/to/output/file\";\n\nconst schema = tsj.createGenerator(config).createSchema(config.type);\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\nRun the schema generator via `node main.js`.\n\n### Custom formatting\n\nExtending the built-in formatting is possible by creating a custom formatter and adding it to the main formatter:\n\n1. First we create a formatter, in this case for formatting function types:\n\n```ts\n// my-function-formatter.ts\nimport { BaseType, Definition, FunctionType, SubTypeFormatter } from \"ts-json-schema-generator\";\nimport ts from \"typescript\";\n\nexport class MyFunctionTypeFormatter implements SubTypeFormatter {\n    // You can skip this line if you don't need childTypeFormatter\n    public constructor(private childTypeFormatter: TypeFormatter) {}\n\n    public supportsType(type: FunctionType): boolean {\n        return type instanceof FunctionType;\n    }\n\n    public getDefinition(type: FunctionType): Definition {\n        // Return a custom schema for the function property.\n        return {\n            type: \"object\",\n            properties: {\n                isFunction: {\n                    type: \"boolean\",\n                    const: true,\n                },\n            },\n        };\n    }\n\n    // If this type does NOT HAVE children, generally all you need is:\n    public getChildren(type: FunctionType): BaseType[] {\n        return [];\n    }\n\n    // However, if children ARE supported, you'll need something similar to\n    // this (see src/TypeFormatter/{Array,Definition,etc}.ts for some examples):\n    public getChildren(type: FunctionType): BaseType[] {\n        return this.childTypeFormatter.getChildren(type.getType());\n    }\n}\n```\n\n2. Then we add the formatter as a child to the core formatter using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyFunctionTypeFormatter } from \"./my-function-formatter.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\n// We configure the formatter an add our custom formatter to it.\nconst formatter = createFormatter(config, (fmt, circularReferenceTypeFormatter) => {\n    // If your formatter DOES NOT support children, e.g. getChildren() { return [] }:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter());\n    // If your formatter DOES support children, you'll need this reference too:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter(circularReferenceTypeFormatter));\n});\n\nconst program = createProgram(config);\nconst parser = createParser(program, config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n### Custom parsing\n\nSimilar to custom formatting, extending the built-in parsing works practically the same way:\n\n1. First we create a parser, in this case for parsing construct types:\n\n```ts\n// my-constructor-parser.ts\nimport { Context, StringType, ReferenceType, BaseType, SubNodeParser } from \"ts-json-schema-generator\";\nimport ts from \"typescript\";\n\nexport class MyConstructorParser implements SubNodeParser {\n    supportsNode(node: ts.Node): boolean {\n        return node.kind === ts.SyntaxKind.ConstructorType;\n    }\n    createType(node: ts.Node, context: Context, reference?: ReferenceType): BaseType | undefined {\n        return new StringType(); // Treat constructors as strings in this example\n    }\n}\n```\n\n2. Then we add the parser as a child to the core parser using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyConstructorParser } from \"./my-constructor-parser.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst program = createProgram(config);\n\n// We configure the parser an add our custom parser to it.\nconst parser = createParser(program, config, (prs) => {\n    prs.addNodeParser(new MyConstructorParser());\n});\n\nconst formatter = createFormatter(config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n## Options\n\n```\n-p, --path 'index.ts'\n    The path to the TypeScript source file. If this is not provided, the type will be searched in the project specified in the `.tsconfig`.\n\n-t, --type 'My.Type.Name'\n    The type the generated schema will represent. If omitted, the generated schema will contain all\n    types found in the files matching path. The same is true if '*' is specified.\n\n-i, --id 'generatedSchemaId'\n    The `$id` of the generated schema. If omitted, there will be no `$id`.\n\n-e, --expose <all|none|export>\n    all: Create shared $ref definitions for all types.\n    none: Do not create shared $ref definitions.\n    export (default): Create shared $ref definitions only for exported types (not tagged as `@internal`).\n\n-f, --tsconfig 'my/project/tsconfig.json'\n    Use a custom tsconfig file for processing typescript (see https://www.typescriptlang.org/docs/handbook/tsconfig-json.html) instead of the default:\n    {\n        \"compilerOptions\": {\n            \"noEmit\": true,\n            \"emitDecoratorMetadata\": true,\n            \"experimentalDecorators\": true,\n            \"target\": \"ES5\",\n            \"module\": \"CommonJS\",\n            \"strictNullChecks\": false,\n        }\n    }\n\n-j, --jsDoc <extended|none|basic>\n    none: Do not use JsDoc annotations.\n    basic: Read JsDoc annotations to provide schema properties.\n    extended (default): Also read @nullable, and @asType annotations.\n\n--unstable\n    Do not sort properties.\n\n--strict-tuples\n    Do not allow additional items on tuples.\n\n--no-top-ref\n    Do not create a top-level $ref definition.\n\n--no-type-check\n    Skip type checks for better performance.\n\n--no-ref-encode\n    Do not encode references. According to the standard, references must be valid URIs but some tools do not support encoded references.\n\n--validation-keywords\n    Provide additional validation keywords to include.\n\n-o, --out\n    Specify the output file path. Without this option, the generator logs the response in the console.\n\n--additional-properties <true|false>\n    Controls whether or not to allow additional properties for objects that have no index signature.\n\n    true: Additional properties are allowed\n    false (default): Additional properties are not allowed\n\n--minify\n    Minify generated schema (default: false)\n```\n\n## Current state\n\n-   `interface` types\n-   `enum` types\n-   `union`, `tuple`, `type[]` types\n-   `Date`, `RegExp` types\n-   `string`, `boolean`, `number` types\n-   `\"value\"`, `123`, `true`, `false`, `null`, `undefined` literals\n-   type aliases\n-   generics\n-   `typeof`\n-   `keyof`\n-   conditional types\n\n## Run locally\n\n`yarn --silent run run --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\n## Debug\n\n`yarn --silent run debug --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\nAnd connect via the debugger protocol.\n\n[AST Explorer](https://astexplorer.net/) is amazing for developers of this tool!\n\n## Publish\n\nPublishing is handled by a 2-branch [pre-release process](https://intuit.github.io/auto/docs/generated/shipit#next-branch-default), configured in `publish-auto.yml`. All changes should be based off the default `next` branch, and are published automatically.\n\n-   PRs made into the default branch are auto-deployed to the `next` pre-release tag on NPM. The result can be installed with `npm install ts-json-schema-generator@next`\n    -   When merging into `next`, please use the `squash and merge` strategy.\n-   To release a new stable version, open a PR from `next` into `stable` using this [compare link](https://github.com/vega/ts-json-schema-generator/compare/stable...next).\n    -   When merging from `next` into `stable`, please use the `create a merge commit` strategy.\n",
      "readmeFilename": "README.md",
      "gitHead": "32e8948182bd7604c65bfc24b49ee6baa4ab050f",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@1.0.1-next.0",
      "_nodeVersion": "16.14.0",
      "_npmVersion": "8.3.1",
      "dist": {
        "integrity": "sha512-x36pVa4v1r3/sT5nkW2viAGU1sftGpewCJ48zhKMo0WJWITPwOi0kzFY3ySmIfD5HiadOHIlbTMci+p6ua5Teg==",
        "shasum": "c696a95401bd1090ad195314f339c01a5f203220",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-1.0.1-next.0.tgz",
        "fileCount": 682,
        "unpackedSize": 773592,
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJiOjQ+ACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2VmrmJw/8C6wsAlIF//vEGpIg2RW3xclaGUIGgLE2GRdTmawSth9CoWgg\r\nykczNIcS+U30A7A7jMH4kPZo3PXHLAkHE4+Y612P3NqIg33L8hAxaLYnYc3r\r\nT1+wKjwi6DO1+DbxBXXt11qLJzCbWDsOChhLbQX2w+Q3a3qzoQN29/1RRi6X\r\n2Fd4MhSNGm8l25ZR/pjlQxKswbUFdy94Xrd8NLWLScO2kY/uMX7wS1YM0JJm\r\nlqOL2mlAcMg6xCSw24i2Q+TqqHhI5kxfTF/AgT5j4/pFBzNbJKvREnGIyHka\r\neILzi9TY+KHxkoZVcmusPAoAlWBWTyb6Zq6ThoDGdlZjhhNGpp/GkMnkBl/M\r\nTpPnoYXBLrvCE61t0Ej5nnjVe/6nBDiMQot/82wjUSSXr3gaMpJr1890+XPy\r\npJ5890NetFx2pPrc5F1ykFhZVdbYA0R46RCWV6Fi1tRrOnekkuGIXd1Y+QeP\r\ngxxNY4xkLwlu7pqsdDYIOnpas8PeN2QL3dJCoVWJ5tHcpEkPJNOJl2OeysnU\r\n/8qqC39kUrIP+fKfp1cxkAoLVGdyKdX+B0tJj/f55SafbE4anUyJ8rFlWHle\r\njXSmxfbhgI6D2mLMeGIsG6Q1Uuso/EwyqmCzQttiAHE3BqUvvNd3U5bCs9Ml\r\nOtX1xM5Pxecbs+e+xIEF/fdXrrrzhcr7ekc=\r\n=lLH0\r\n-----END PGP SIGNATURE-----\r\n",
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIQCBjtahZux8vW+q9fMvghHZ3L2JCzztYGof6tg9AACBBAIgB0aViSxhrYdjK/DwXkVRz0xU1eXr7sRxdAN6i7Lemi8="
          }
        ]
      },
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "maintainers": [
        {
          "name": "jheer",
          "email": "jeffrey.heer@gmail.com"
        },
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "kanitw",
          "email": "kanitw@gmail.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_1.0.1-next.0_1647981630102_0.8538312780575465"
      },
      "_hasShrinkwrap": false
    },
    "1.0.1-next.1": {
      "name": "ts-json-schema-generator",
      "version": "1.0.1-next.1",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "MooYeol Prescott Lee",
          "email": "mooyoul@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=10.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.9",
        "commander": "^9.0.0",
        "glob": "^7.2.0",
        "safe-stable-stringify": "^2.3.1",
        "json5": "^2.2.0",
        "typescript": "~4.6.2"
      },
      "devDependencies": {
        "@auto-it/conventional-commits": "^10.32.5",
        "@auto-it/first-time-contributor": "^10.32.5",
        "@babel/core": "^7.16.7",
        "@babel/preset-env": "^7.16.8",
        "@babel/preset-typescript": "^7.16.7",
        "@types/glob": "^7.2.0",
        "@types/jest": "^27.4.0",
        "@types/node": "^17.0.8",
        "@typescript-eslint/eslint-plugin": "^5.9.1",
        "@typescript-eslint/parser": "^5.9.1",
        "ajv": "^8.8.2",
        "ajv-formats": "^2.1.1",
        "auto": "^10.32.5",
        "chai": "^4.3.4",
        "cross-env": "^7.0.3",
        "eslint": "^8.6.0",
        "eslint-config-prettier": "^8.3.0",
        "eslint-plugin-prettier": "^4.0.0",
        "jest": "^27.4.7",
        "jest-junit": "^13.0.0",
        "prettier": "^2.5.1",
        "ts-node": "^10.4.0",
        "vega": "^5.21.0",
        "vega-lite": "^5.2.0"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint \"{src,test,factory}/**/*.ts\"",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "cross-env FAST_TEST=1 jest test/ --verbose",
        "test:coverage": "yarn jest test/ --collectCoverage=true",
        "test:update": "cross-env UPDATE_SCHEMA=true yarn test:fast",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node-transpile-only ts-json-schema-generator.ts",
        "release": "yarn build && auto shipit"
      },
      "readme": "# ts-json-schema-generator\n\n![Test](https://github.com/vega/ts-json-schema-generator/workflows/Test/badge.svg)\n[![codecov](https://codecov.io/gh/vega/ts-json-schema-generator/branch/master/graph/badge.svg)](https://codecov.io/gh/vega/ts-json-schema-generator)\n[![npm version](https://img.shields.io/npm/v/ts-json-schema-generator.svg)](https://www.npmjs.com/package/ts-json-schema-generator)\n\nExtended version of [https://github.com/xiag-ag/typescript-to-json-schema](https://github.com/xiag-ag/typescript-to-json-schema).\n\nInspired by [`YousefED/typescript-json-schema`](https://github.com/YousefED/typescript-json-schema). Here's the differences list:\n\n-   this implementation avoids the use of `typeChecker.getTypeAtLocation()` (so probably it keeps correct type aliases)\n-   processing AST and formatting JSON schema have been split into two independent steps\n-   not exported types, interfaces, enums are not exposed in the `definitions` section in the JSON schema\n\n## Contributors\n\nThis project is made possible by a [community of contributors](https://github.com/vega/ts-json-schema-generator/graphs/contributors). We welcome contributions of any kind (issues, code, documentation, examples, tests,...). Please read our [code of conduct](https://github.com/vega/vega/blob/master/CODE_OF_CONDUCT.md).\n\n## CLI Usage\n\n```bash\nnpm install --save ts-json-schema-generator\n./node_modules/.bin/ts-json-schema-generator --path 'my/project/**/*.ts' --type 'My.Type.Name'\n```\n\nNote that different platforms (e.g. Windows) may use different path separators so you may have to adjust the command above.\n\n## Programmatic Usage\n\n```js\n// main.js\n\nconst tsj = require(\"ts-json-schema-generator\");\nconst fs = require(\"fs\");\n\n/** @type {import('ts-json-schema-generator/dist/src/Config').Config} */\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst output_path = \"path/to/output/file\";\n\nconst schema = tsj.createGenerator(config).createSchema(config.type);\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\nRun the schema generator via `node main.js`.\n\n### Custom formatting\n\nExtending the built-in formatting is possible by creating a custom formatter and adding it to the main formatter:\n\n1. First we create a formatter, in this case for formatting function types:\n\n```ts\n// my-function-formatter.ts\nimport { BaseType, Definition, FunctionType, SubTypeFormatter } from \"ts-json-schema-generator\";\nimport ts from \"typescript\";\n\nexport class MyFunctionTypeFormatter implements SubTypeFormatter {\n    // You can skip this line if you don't need childTypeFormatter\n    public constructor(private childTypeFormatter: TypeFormatter) {}\n\n    public supportsType(type: FunctionType): boolean {\n        return type instanceof FunctionType;\n    }\n\n    public getDefinition(type: FunctionType): Definition {\n        // Return a custom schema for the function property.\n        return {\n            type: \"object\",\n            properties: {\n                isFunction: {\n                    type: \"boolean\",\n                    const: true,\n                },\n            },\n        };\n    }\n\n    // If this type does NOT HAVE children, generally all you need is:\n    public getChildren(type: FunctionType): BaseType[] {\n        return [];\n    }\n\n    // However, if children ARE supported, you'll need something similar to\n    // this (see src/TypeFormatter/{Array,Definition,etc}.ts for some examples):\n    public getChildren(type: FunctionType): BaseType[] {\n        return this.childTypeFormatter.getChildren(type.getType());\n    }\n}\n```\n\n2. Then we add the formatter as a child to the core formatter using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyFunctionTypeFormatter } from \"./my-function-formatter.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\n// We configure the formatter an add our custom formatter to it.\nconst formatter = createFormatter(config, (fmt, circularReferenceTypeFormatter) => {\n    // If your formatter DOES NOT support children, e.g. getChildren() { return [] }:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter());\n    // If your formatter DOES support children, you'll need this reference too:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter(circularReferenceTypeFormatter));\n});\n\nconst program = createProgram(config);\nconst parser = createParser(program, config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n### Custom parsing\n\nSimilar to custom formatting, extending the built-in parsing works practically the same way:\n\n1. First we create a parser, in this case for parsing construct types:\n\n```ts\n// my-constructor-parser.ts\nimport { Context, StringType, ReferenceType, BaseType, SubNodeParser } from \"ts-json-schema-generator\";\nimport ts from \"typescript\";\n\nexport class MyConstructorParser implements SubNodeParser {\n    supportsNode(node: ts.Node): boolean {\n        return node.kind === ts.SyntaxKind.ConstructorType;\n    }\n    createType(node: ts.Node, context: Context, reference?: ReferenceType): BaseType | undefined {\n        return new StringType(); // Treat constructors as strings in this example\n    }\n}\n```\n\n2. Then we add the parser as a child to the core parser using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyConstructorParser } from \"./my-constructor-parser.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst program = createProgram(config);\n\n// We configure the parser an add our custom parser to it.\nconst parser = createParser(program, config, (prs) => {\n    prs.addNodeParser(new MyConstructorParser());\n});\n\nconst formatter = createFormatter(config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n## Options\n\n```\n-p, --path 'index.ts'\n    The path to the TypeScript source file. If this is not provided, the type will be searched in the project specified in the `.tsconfig`.\n\n-t, --type 'My.Type.Name'\n    The type the generated schema will represent. If omitted, the generated schema will contain all\n    types found in the files matching path. The same is true if '*' is specified.\n\n-i, --id 'generatedSchemaId'\n    The `$id` of the generated schema. If omitted, there will be no `$id`.\n\n-e, --expose <all|none|export>\n    all: Create shared $ref definitions for all types.\n    none: Do not create shared $ref definitions.\n    export (default): Create shared $ref definitions only for exported types (not tagged as `@internal`).\n\n-f, --tsconfig 'my/project/tsconfig.json'\n    Use a custom tsconfig file for processing typescript (see https://www.typescriptlang.org/docs/handbook/tsconfig-json.html) instead of the default:\n    {\n        \"compilerOptions\": {\n            \"noEmit\": true,\n            \"emitDecoratorMetadata\": true,\n            \"experimentalDecorators\": true,\n            \"target\": \"ES5\",\n            \"module\": \"CommonJS\",\n            \"strictNullChecks\": false,\n        }\n    }\n\n-j, --jsDoc <extended|none|basic>\n    none: Do not use JsDoc annotations.\n    basic: Read JsDoc annotations to provide schema properties.\n    extended (default): Also read @nullable, and @asType annotations.\n\n--unstable\n    Do not sort properties.\n\n--strict-tuples\n    Do not allow additional items on tuples.\n\n--no-top-ref\n    Do not create a top-level $ref definition.\n\n--no-type-check\n    Skip type checks for better performance.\n\n--no-ref-encode\n    Do not encode references. According to the standard, references must be valid URIs but some tools do not support encoded references.\n\n--validation-keywords\n    Provide additional validation keywords to include.\n\n-o, --out\n    Specify the output file path. Without this option, the generator logs the response in the console.\n\n--additional-properties <true|false>\n    Controls whether or not to allow additional properties for objects that have no index signature.\n\n    true: Additional properties are allowed\n    false (default): Additional properties are not allowed\n\n--minify\n    Minify generated schema (default: false)\n```\n\n## Current state\n\n-   `interface` types\n-   `enum` types\n-   `union`, `tuple`, `type[]` types\n-   `Date`, `RegExp` types\n-   `string`, `boolean`, `number` types\n-   `\"value\"`, `123`, `true`, `false`, `null`, `undefined` literals\n-   type aliases\n-   generics\n-   `typeof`\n-   `keyof`\n-   conditional types\n\n## Run locally\n\n`yarn --silent run run --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\n## Debug\n\n`yarn --silent run debug --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\nAnd connect via the debugger protocol.\n\n[AST Explorer](https://astexplorer.net/) is amazing for developers of this tool!\n\n## Publish\n\nPublishing is handled by a 2-branch [pre-release process](https://intuit.github.io/auto/docs/generated/shipit#next-branch-default), configured in `publish-auto.yml`. All changes should be based off the default `next` branch, and are published automatically.\n\n-   PRs made into the default branch are auto-deployed to the `next` pre-release tag on NPM. The result can be installed with `npm install ts-json-schema-generator@next`\n    -   When merging into `next`, please use the `squash and merge` strategy.\n-   To release a new stable version, open a PR from `next` into `stable` using this [compare link](https://github.com/vega/ts-json-schema-generator/compare/stable...next).\n    -   When merging from `next` into `stable`, please use the `create a merge commit` strategy.\n",
      "readmeFilename": "README.md",
      "gitHead": "fad197f4f32d070a9fb0e8228cbb98ee70d9f83c",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@1.0.1-next.1",
      "_nodeVersion": "16.14.0",
      "_npmVersion": "8.3.1",
      "dist": {
        "integrity": "sha512-yhNdMLdFu+XIs675Zwk4RHizTZXj7nc2QbqQcMlEt5B9o4S7tFo9C9lycVN9vtq0/sZSp9OPkqQQ95iDAyLEtw==",
        "shasum": "3ba3961f20981e12abf889473e47dc19c92d6c6f",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-1.0.1-next.1.tgz",
        "fileCount": 682,
        "unpackedSize": 776889,
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIQDsyzdNpADyOgGjWzv70YhntIG+HW5/PHA8LcIjqG9RJAIgBu47256fsipj1upeW8NczQ6CwXGVNr8dPAubT6HyxlI="
          }
        ],
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJiROREACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2Vmq++Q//VGM0kMYNgFAT7WyKXF6p3whwxNFvOFUiGUeR1MweBPOE3K95\r\ne2TB9zdCwtk3LVWew08rMSw2olnTDF8WanqdiFXmOYzHeBeBxAWZzX7GYPZN\r\nblDT5eSUHpO4CviBFiBh15m74GTL/fJmv9R4IBwpN97RbvGz6wFTqCXI1/aX\r\ngpLXSlkhupEGGvjd0CkyNZd7khMMCK5193PPQVKgXU3nbr+ZTnBqy0OdKJqp\r\nKlD1LCHMjZOb0hA6Apts3Hb/LOhhygaZ2M2m6lia6KvXjDJsAKtM0UJLzUJN\r\naMEbZUMnMWs95uD3+VLQfs79GUr11gNhncxCYJLaBcPNlV2nzC1TyIMpBZ6K\r\nWO0R876+3Kw8ks5EBzM73ScxZp7oDSdgM/spnza32lhPu1+GUFtJ71pSQmbQ\r\nDlHJkiYk8WTNGC1iJffYPek3fu2w6+j96RgX1VqeNjf0Op3oWpE8m+XY3Gjb\r\nSA0/VWof9t0eESaFBqsV7sWLwCskqBLAL0AtVlGP9M+OZPl3qiXfNcvmbRRZ\r\nGD1/lXpLPRJrwZ/w5fky2BZ5Rmau1vExfp5TBWsebqDyowWi0cfmrZUDtuMI\r\nlQoO0eNTN+FZGjJux+Gk3iQ1DI9cIIOeGGRhCmM6dsMjOG+WiK9WZ72UYJVq\r\n6R6nE2cpP5GeClg0dOccM6gB4lq0koGzfh4=\r\n=eFxe\r\n-----END PGP SIGNATURE-----\r\n"
      },
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "maintainers": [
        {
          "name": "jheer",
          "email": "jeffrey.heer@gmail.com"
        },
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "kanitw",
          "email": "kanitw@gmail.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_1.0.1-next.1_1648682051931_0.31695395001453397"
      },
      "_hasShrinkwrap": false
    },
    "1.0.1--canary.9aa9c56.0": {
      "name": "ts-json-schema-generator",
      "version": "1.0.1--canary.9aa9c56.0",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "MooYeol Prescott Lee",
          "email": "mooyoul@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=10.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.9",
        "commander": "^9.0.0",
        "glob": "^7.2.0",
        "safe-stable-stringify": "^2.3.1",
        "json5": "^2.2.0",
        "typescript": "~4.6.2"
      },
      "devDependencies": {
        "@auto-it/conventional-commits": "^10.32.5",
        "@auto-it/first-time-contributor": "^10.32.5",
        "@babel/core": "^7.16.7",
        "@babel/preset-env": "^7.16.8",
        "@babel/preset-typescript": "^7.16.7",
        "@types/glob": "^7.2.0",
        "@types/jest": "^27.4.0",
        "@types/node": "^17.0.8",
        "@typescript-eslint/eslint-plugin": "^5.9.1",
        "@typescript-eslint/parser": "^5.9.1",
        "ajv": "^8.8.2",
        "ajv-formats": "^2.1.1",
        "auto": "^10.32.5",
        "chai": "^4.3.4",
        "cross-env": "^7.0.3",
        "eslint": "^8.6.0",
        "eslint-config-prettier": "^8.3.0",
        "eslint-plugin-prettier": "^4.0.0",
        "jest": "^27.4.7",
        "jest-junit": "^13.0.0",
        "prettier": "^2.5.1",
        "ts-node": "^10.4.0",
        "vega": "^5.21.0",
        "vega-lite": "^5.2.0"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint \"{src,test,factory}/**/*.ts\"",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "cross-env FAST_TEST=1 jest test/ --verbose",
        "test:coverage": "yarn jest test/ --collectCoverage=true",
        "test:update": "cross-env UPDATE_SCHEMA=true yarn test:fast",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node-transpile-only ts-json-schema-generator.ts",
        "release": "yarn build && auto shipit"
      },
      "readme": "# ts-json-schema-generator\n\n![Test](https://github.com/vega/ts-json-schema-generator/workflows/Test/badge.svg)\n[![codecov](https://codecov.io/gh/vega/ts-json-schema-generator/branch/master/graph/badge.svg)](https://codecov.io/gh/vega/ts-json-schema-generator)\n[![npm version](https://img.shields.io/npm/v/ts-json-schema-generator.svg)](https://www.npmjs.com/package/ts-json-schema-generator)\n\nExtended version of [https://github.com/xiag-ag/typescript-to-json-schema](https://github.com/xiag-ag/typescript-to-json-schema).\n\nInspired by [`YousefED/typescript-json-schema`](https://github.com/YousefED/typescript-json-schema). Here's the differences list:\n\n-   this implementation avoids the use of `typeChecker.getTypeAtLocation()` (so probably it keeps correct type aliases)\n-   processing AST and formatting JSON schema have been split into two independent steps\n-   not exported types, interfaces, enums are not exposed in the `definitions` section in the JSON schema\n\n## Contributors\n\nThis project is made possible by a [community of contributors](https://github.com/vega/ts-json-schema-generator/graphs/contributors). We welcome contributions of any kind (issues, code, documentation, examples, tests,...). Please read our [code of conduct](https://github.com/vega/vega/blob/master/CODE_OF_CONDUCT.md).\n\n## CLI Usage\n\n```bash\nnpm install --save ts-json-schema-generator\n./node_modules/.bin/ts-json-schema-generator --path 'my/project/**/*.ts' --type 'My.Type.Name'\n```\n\nNote that different platforms (e.g. Windows) may use different path separators so you may have to adjust the command above.\n\n## Programmatic Usage\n\n```js\n// main.js\n\nconst tsj = require(\"ts-json-schema-generator\");\nconst fs = require(\"fs\");\n\n/** @type {import('ts-json-schema-generator/dist/src/Config').Config} */\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst output_path = \"path/to/output/file\";\n\nconst schema = tsj.createGenerator(config).createSchema(config.type);\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\nRun the schema generator via `node main.js`.\n\n### Custom formatting\n\nExtending the built-in formatting is possible by creating a custom formatter and adding it to the main formatter:\n\n1. First we create a formatter, in this case for formatting function types:\n\n```ts\n// my-function-formatter.ts\nimport { BaseType, Definition, FunctionType, SubTypeFormatter } from \"ts-json-schema-generator\";\nimport ts from \"typescript\";\n\nexport class MyFunctionTypeFormatter implements SubTypeFormatter {\n    // You can skip this line if you don't need childTypeFormatter\n    public constructor(private childTypeFormatter: TypeFormatter) {}\n\n    public supportsType(type: FunctionType): boolean {\n        return type instanceof FunctionType;\n    }\n\n    public getDefinition(type: FunctionType): Definition {\n        // Return a custom schema for the function property.\n        return {\n            type: \"object\",\n            properties: {\n                isFunction: {\n                    type: \"boolean\",\n                    const: true,\n                },\n            },\n        };\n    }\n\n    // If this type does NOT HAVE children, generally all you need is:\n    public getChildren(type: FunctionType): BaseType[] {\n        return [];\n    }\n\n    // However, if children ARE supported, you'll need something similar to\n    // this (see src/TypeFormatter/{Array,Definition,etc}.ts for some examples):\n    public getChildren(type: FunctionType): BaseType[] {\n        return this.childTypeFormatter.getChildren(type.getType());\n    }\n}\n```\n\n2. Then we add the formatter as a child to the core formatter using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyFunctionTypeFormatter } from \"./my-function-formatter.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\n// We configure the formatter an add our custom formatter to it.\nconst formatter = createFormatter(config, (fmt, circularReferenceTypeFormatter) => {\n    // If your formatter DOES NOT support children, e.g. getChildren() { return [] }:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter());\n    // If your formatter DOES support children, you'll need this reference too:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter(circularReferenceTypeFormatter));\n});\n\nconst program = createProgram(config);\nconst parser = createParser(program, config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n### Custom parsing\n\nSimilar to custom formatting, extending the built-in parsing works practically the same way:\n\n1. First we create a parser, in this case for parsing construct types:\n\n```ts\n// my-constructor-parser.ts\nimport { Context, StringType, ReferenceType, BaseType, SubNodeParser } from \"ts-json-schema-generator\";\nimport ts from \"typescript\";\n\nexport class MyConstructorParser implements SubNodeParser {\n    supportsNode(node: ts.Node): boolean {\n        return node.kind === ts.SyntaxKind.ConstructorType;\n    }\n    createType(node: ts.Node, context: Context, reference?: ReferenceType): BaseType | undefined {\n        return new StringType(); // Treat constructors as strings in this example\n    }\n}\n```\n\n2. Then we add the parser as a child to the core parser using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyConstructorParser } from \"./my-constructor-parser.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst program = createProgram(config);\n\n// We configure the parser an add our custom parser to it.\nconst parser = createParser(program, config, (prs) => {\n    prs.addNodeParser(new MyConstructorParser());\n});\n\nconst formatter = createFormatter(config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n## Options\n\n```\n-p, --path 'index.ts'\n    The path to the TypeScript source file. If this is not provided, the type will be searched in the project specified in the `.tsconfig`.\n\n-t, --type 'My.Type.Name'\n    The type the generated schema will represent. If omitted, the generated schema will contain all\n    types found in the files matching path. The same is true if '*' is specified.\n\n-i, --id 'generatedSchemaId'\n    The `$id` of the generated schema. If omitted, there will be no `$id`.\n\n-e, --expose <all|none|export>\n    all: Create shared $ref definitions for all types.\n    none: Do not create shared $ref definitions.\n    export (default): Create shared $ref definitions only for exported types (not tagged as `@internal`).\n\n-f, --tsconfig 'my/project/tsconfig.json'\n    Use a custom tsconfig file for processing typescript (see https://www.typescriptlang.org/docs/handbook/tsconfig-json.html) instead of the default:\n    {\n        \"compilerOptions\": {\n            \"noEmit\": true,\n            \"emitDecoratorMetadata\": true,\n            \"experimentalDecorators\": true,\n            \"target\": \"ES5\",\n            \"module\": \"CommonJS\",\n            \"strictNullChecks\": false,\n        }\n    }\n\n-j, --jsDoc <extended|none|basic>\n    none: Do not use JsDoc annotations.\n    basic: Read JsDoc annotations to provide schema properties.\n    extended (default): Also read @nullable, and @asType annotations.\n\n--unstable\n    Do not sort properties.\n\n--strict-tuples\n    Do not allow additional items on tuples.\n\n--no-top-ref\n    Do not create a top-level $ref definition.\n\n--no-type-check\n    Skip type checks for better performance.\n\n--no-ref-encode\n    Do not encode references. According to the standard, references must be valid URIs but some tools do not support encoded references.\n\n--validation-keywords\n    Provide additional validation keywords to include.\n\n-o, --out\n    Specify the output file path. Without this option, the generator logs the response in the console.\n\n--additional-properties <true|false>\n    Controls whether or not to allow additional properties for objects that have no index signature.\n\n    true: Additional properties are allowed\n    false (default): Additional properties are not allowed\n\n--minify\n    Minify generated schema (default: false)\n```\n\n## Current state\n\n-   `interface` types\n-   `enum` types\n-   `union`, `tuple`, `type[]` types\n-   `Date`, `RegExp` types\n-   `string`, `boolean`, `number` types\n-   `\"value\"`, `123`, `true`, `false`, `null`, `undefined` literals\n-   type aliases\n-   generics\n-   `typeof`\n-   `keyof`\n-   conditional types\n\n## Run locally\n\n`yarn --silent run run --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\n## Debug\n\n`yarn --silent run debug --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\nAnd connect via the debugger protocol.\n\n[AST Explorer](https://astexplorer.net/) is amazing for developers of this tool!\n\n## Publish\n\nPublishing is handled by a 2-branch [pre-release process](https://intuit.github.io/auto/docs/generated/shipit#next-branch-default), configured in `publish-auto.yml`. All changes should be based off the default `next` branch, and are published automatically.\n\n-   PRs made into the default branch are auto-deployed to the `next` pre-release tag on NPM. The result can be installed with `npm install ts-json-schema-generator@next`\n    -   When merging into `next`, please use the `squash and merge` strategy.\n-   To release a new stable version, open a PR from `next` into `stable` using this [compare link](https://github.com/vega/ts-json-schema-generator/compare/stable...next).\n    -   When merging from `next` into `stable`, please use the `create a merge commit` strategy.\n",
      "readmeFilename": "README.md",
      "gitHead": "9aa9c565986761bd404692dc3b1d914be2821e6b",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@1.0.1--canary.9aa9c56.0",
      "_nodeVersion": "16.14.2",
      "_npmVersion": "8.5.0",
      "dist": {
        "integrity": "sha512-Ejut+dj6ofSphqccluM6y7pjM4Dfk0Ui7wWRXu1q3pZCRUyd300pm5PEGdZCafOdfCEImD6TA8s8Ntgi+NS4pQ==",
        "shasum": "49e6367498c97445d6792b0028c40dc9fecf65e1",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-1.0.1--canary.9aa9c56.0.tgz",
        "fileCount": 682,
        "unpackedSize": 776911,
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEQCIBkN+QLKdcyaD17+fn9xiVjzZWiNryRhsufbctAEpLyVAiAeNibL3HmBDE5guIvWGUYuV190Xf9Nr3VMJyNHtHgaig=="
          }
        ],
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJiTPSzACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2VmrrwA//RL2/uXUwi76TBKuD7rafmPlkolrkADOcVb+INV7+zsmp+loj\r\nGS+Q76rW+ClwO4GL6LE1ID5Kb3X6yCvWOSmUycLbtL6K4fgg+Sl4Cl52+mAY\r\n5TXm15YOXYTfk9TH6A/ub9olXn56+hDyGBEPp04gdoAzWKOWuKKITq1Te3lK\r\nfIH2PkMOXW5tbgKWOFCQORN5s5bIbcYurPTnA/TrCGTx7QR0Qful/qHe+VSH\r\nUJ56/5yVO6MEurGNT7hek8MWGwliRYMVgQWrLG6wCpTj9gRAqt/NW4EW7p3a\r\nWJuN4gimnxxZnW/E34HdDHl94g9oOpdxniuqxZdMEGO6ClxSRqE8vKHNvsfA\r\nTMAusqYnccqIt1dtsXjwdY14TxlU8eoHvGbXq084w0tKAteARlBsV6IIBlDF\r\njueD311QIJr9JJyCGALsfFz0FG/j1QVqlDSdVMcKuwnSrDygIpN0Em1OSULJ\r\nBviZeFjzVNDePws0s8UrT20aBu8cmSBhCvE/fjWOv6OkvR4sQrws8c6n673/\r\nDSd/UajZwpNacBd1COCVMuPkEe+IVcZ99w1CnVFmNPS4Dl5tUwBGgaZJRG5O\r\n3DYdxzDaBv3ULO+EyOLW+FthTQ06bn3zWbp+kZTynYwqrzBScaX0y6iSPHZ7\r\n76jeM8WR71MfS1q08vublYnhYrs44A+7Y8E=\r\n=dKLk\r\n-----END PGP SIGNATURE-----\r\n"
      },
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "maintainers": [
        {
          "name": "jheer",
          "email": "jeffrey.heer@gmail.com"
        },
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "kanitw",
          "email": "kanitw@gmail.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_1.0.1--canary.9aa9c56.0_1649210547257_0.45182816919428803"
      },
      "_hasShrinkwrap": false
    },
    "1.1.0-next.0": {
      "name": "ts-json-schema-generator",
      "version": "1.1.0-next.0",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "MooYeol Prescott Lee",
          "email": "mooyoul@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=10.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.9",
        "commander": "^9.0.0",
        "glob": "^7.2.0",
        "safe-stable-stringify": "^2.3.1",
        "json5": "^2.2.0",
        "typescript": "~4.6.2"
      },
      "devDependencies": {
        "@auto-it/conventional-commits": "^10.32.5",
        "@auto-it/first-time-contributor": "^10.32.5",
        "@babel/core": "^7.16.7",
        "@babel/preset-env": "^7.16.8",
        "@babel/preset-typescript": "^7.16.7",
        "@types/glob": "^7.2.0",
        "@types/jest": "^27.4.0",
        "@types/node": "^17.0.8",
        "@typescript-eslint/eslint-plugin": "^5.9.1",
        "@typescript-eslint/parser": "^5.9.1",
        "ajv": "^8.8.2",
        "ajv-formats": "^2.1.1",
        "auto": "^10.32.5",
        "chai": "^4.3.4",
        "cross-env": "^7.0.3",
        "eslint": "^8.6.0",
        "eslint-config-prettier": "^8.3.0",
        "eslint-plugin-prettier": "^4.0.0",
        "jest": "^27.4.7",
        "jest-junit": "^13.0.0",
        "prettier": "^2.5.1",
        "ts-node": "^10.4.0",
        "vega": "^5.21.0",
        "vega-lite": "^5.2.0"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint \"{src,test,factory}/**/*.ts\"",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "cross-env FAST_TEST=1 jest test/ --verbose",
        "test:coverage": "yarn jest test/ --collectCoverage=true",
        "test:update": "cross-env UPDATE_SCHEMA=true yarn test:fast",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node-transpile-only ts-json-schema-generator.ts",
        "release": "yarn build && auto shipit"
      },
      "readme": "# ts-json-schema-generator\n\n![Test](https://github.com/vega/ts-json-schema-generator/workflows/Test/badge.svg)\n[![codecov](https://codecov.io/gh/vega/ts-json-schema-generator/branch/master/graph/badge.svg)](https://codecov.io/gh/vega/ts-json-schema-generator)\n[![npm version](https://img.shields.io/npm/v/ts-json-schema-generator.svg)](https://www.npmjs.com/package/ts-json-schema-generator)\n\nExtended version of [https://github.com/xiag-ag/typescript-to-json-schema](https://github.com/xiag-ag/typescript-to-json-schema).\n\nInspired by [`YousefED/typescript-json-schema`](https://github.com/YousefED/typescript-json-schema). Here's the differences list:\n\n-   this implementation avoids the use of `typeChecker.getTypeAtLocation()` (so probably it keeps correct type aliases)\n-   processing AST and formatting JSON schema have been split into two independent steps\n-   not exported types, interfaces, enums are not exposed in the `definitions` section in the JSON schema\n\n## Contributors\n\nThis project is made possible by a [community of contributors](https://github.com/vega/ts-json-schema-generator/graphs/contributors). We welcome contributions of any kind (issues, code, documentation, examples, tests,...). Please read our [code of conduct](https://github.com/vega/vega/blob/master/CODE_OF_CONDUCT.md).\n\n## CLI Usage\n\n```bash\nnpm install --save ts-json-schema-generator\n./node_modules/.bin/ts-json-schema-generator --path 'my/project/**/*.ts' --type 'My.Type.Name'\n```\n\nNote that different platforms (e.g. Windows) may use different path separators so you may have to adjust the command above.\n\n## Programmatic Usage\n\n```js\n// main.js\n\nconst tsj = require(\"ts-json-schema-generator\");\nconst fs = require(\"fs\");\n\n/** @type {import('ts-json-schema-generator/dist/src/Config').Config} */\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst output_path = \"path/to/output/file\";\n\nconst schema = tsj.createGenerator(config).createSchema(config.type);\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\nRun the schema generator via `node main.js`.\n\n### Custom formatting\n\nExtending the built-in formatting is possible by creating a custom formatter and adding it to the main formatter:\n\n1. First we create a formatter, in this case for formatting function types:\n\n```ts\n// my-function-formatter.ts\nimport { BaseType, Definition, FunctionType, SubTypeFormatter } from \"ts-json-schema-generator\";\nimport ts from \"typescript\";\n\nexport class MyFunctionTypeFormatter implements SubTypeFormatter {\n    // You can skip this line if you don't need childTypeFormatter\n    public constructor(private childTypeFormatter: TypeFormatter) {}\n\n    public supportsType(type: FunctionType): boolean {\n        return type instanceof FunctionType;\n    }\n\n    public getDefinition(type: FunctionType): Definition {\n        // Return a custom schema for the function property.\n        return {\n            type: \"object\",\n            properties: {\n                isFunction: {\n                    type: \"boolean\",\n                    const: true,\n                },\n            },\n        };\n    }\n\n    // If this type does NOT HAVE children, generally all you need is:\n    public getChildren(type: FunctionType): BaseType[] {\n        return [];\n    }\n\n    // However, if children ARE supported, you'll need something similar to\n    // this (see src/TypeFormatter/{Array,Definition,etc}.ts for some examples):\n    public getChildren(type: FunctionType): BaseType[] {\n        return this.childTypeFormatter.getChildren(type.getType());\n    }\n}\n```\n\n2. Then we add the formatter as a child to the core formatter using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyFunctionTypeFormatter } from \"./my-function-formatter.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\n// We configure the formatter an add our custom formatter to it.\nconst formatter = createFormatter(config, (fmt, circularReferenceTypeFormatter) => {\n    // If your formatter DOES NOT support children, e.g. getChildren() { return [] }:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter());\n    // If your formatter DOES support children, you'll need this reference too:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter(circularReferenceTypeFormatter));\n});\n\nconst program = createProgram(config);\nconst parser = createParser(program, config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n### Custom parsing\n\nSimilar to custom formatting, extending the built-in parsing works practically the same way:\n\n1. First we create a parser, in this case for parsing construct types:\n\n```ts\n// my-constructor-parser.ts\nimport { Context, StringType, ReferenceType, BaseType, SubNodeParser } from \"ts-json-schema-generator\";\nimport ts from \"typescript\";\n\nexport class MyConstructorParser implements SubNodeParser {\n    supportsNode(node: ts.Node): boolean {\n        return node.kind === ts.SyntaxKind.ConstructorType;\n    }\n    createType(node: ts.Node, context: Context, reference?: ReferenceType): BaseType | undefined {\n        return new StringType(); // Treat constructors as strings in this example\n    }\n}\n```\n\n2. Then we add the parser as a child to the core parser using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyConstructorParser } from \"./my-constructor-parser.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst program = createProgram(config);\n\n// We configure the parser an add our custom parser to it.\nconst parser = createParser(program, config, (prs) => {\n    prs.addNodeParser(new MyConstructorParser());\n});\n\nconst formatter = createFormatter(config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n## Options\n\n```\n-p, --path 'index.ts'\n    The path to the TypeScript source file. If this is not provided, the type will be searched in the project specified in the `.tsconfig`.\n\n-t, --type 'My.Type.Name'\n    The type the generated schema will represent. If omitted, the generated schema will contain all\n    types found in the files matching path. The same is true if '*' is specified.\n\n-i, --id 'generatedSchemaId'\n    The `$id` of the generated schema. If omitted, there will be no `$id`.\n\n-e, --expose <all|none|export>\n    all: Create shared $ref definitions for all types.\n    none: Do not create shared $ref definitions.\n    export (default): Create shared $ref definitions only for exported types (not tagged as `@internal`).\n\n-f, --tsconfig 'my/project/tsconfig.json'\n    Use a custom tsconfig file for processing typescript (see https://www.typescriptlang.org/docs/handbook/tsconfig-json.html) instead of the default:\n    {\n        \"compilerOptions\": {\n            \"noEmit\": true,\n            \"emitDecoratorMetadata\": true,\n            \"experimentalDecorators\": true,\n            \"target\": \"ES5\",\n            \"module\": \"CommonJS\",\n            \"strictNullChecks\": false,\n        }\n    }\n\n-j, --jsDoc <extended|none|basic>\n    none: Do not use JsDoc annotations.\n    basic: Read JsDoc annotations to provide schema properties.\n    extended (default): Also read @nullable, and @asType annotations.\n\n--unstable\n    Do not sort properties.\n\n--strict-tuples\n    Do not allow additional items on tuples.\n\n--no-top-ref\n    Do not create a top-level $ref definition.\n\n--no-type-check\n    Skip type checks for better performance.\n\n--no-ref-encode\n    Do not encode references. According to the standard, references must be valid URIs but some tools do not support encoded references.\n\n--validation-keywords\n    Provide additional validation keywords to include.\n\n-o, --out\n    Specify the output file path. Without this option, the generator logs the response in the console.\n\n--additional-properties <true|false>\n    Controls whether or not to allow additional properties for objects that have no index signature.\n\n    true: Additional properties are allowed\n    false (default): Additional properties are not allowed\n\n--minify\n    Minify generated schema (default: false)\n```\n\n## Current state\n\n-   `interface` types\n-   `enum` types\n-   `union`, `tuple`, `type[]` types\n-   `Date`, `RegExp` types\n-   `string`, `boolean`, `number` types\n-   `\"value\"`, `123`, `true`, `false`, `null`, `undefined` literals\n-   type aliases\n-   generics\n-   `typeof`\n-   `keyof`\n-   conditional types\n\n## Run locally\n\n`yarn --silent run run --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\n## Debug\n\n`yarn --silent run debug --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\nAnd connect via the debugger protocol.\n\n[AST Explorer](https://astexplorer.net/) is amazing for developers of this tool!\n\n## Publish\n\nPublishing is handled by a 2-branch [pre-release process](https://intuit.github.io/auto/docs/generated/shipit#next-branch-default), configured in `publish-auto.yml`. All changes should be based off the default `next` branch, and are published automatically.\n\n-   PRs made into the default branch are auto-deployed to the `next` pre-release tag on NPM. The result can be installed with `npm install ts-json-schema-generator@next`\n    -   When merging into `next`, please use the `squash and merge` strategy.\n-   To release a new stable version, open a PR from `next` into `stable` using this [compare link](https://github.com/vega/ts-json-schema-generator/compare/stable...next).\n    -   When merging from `next` into `stable`, please use the `create a merge commit` strategy.\n",
      "readmeFilename": "README.md",
      "gitHead": "cdd587e5f8db4d68bd3eb74d0d805f1e2ac664e1",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@1.1.0-next.0",
      "_nodeVersion": "16.14.2",
      "_npmVersion": "8.5.0",
      "dist": {
        "integrity": "sha512-LL7DL6gkOKqum6AB3Y/5GnTwPX5axl6e6fZzKv6OX/8XiJmBSnWuURIm03UZJfRnUXrfGsoPwXa2S6QJwL2/Dg==",
        "shasum": "63defc60e50f76ef623584711ed002b010976f0d",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-1.1.0-next.0.tgz",
        "fileCount": 682,
        "unpackedSize": 778317,
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEQCIAddhBW3ZNNULHJh2PKwUuhD2jjlkdsW8zPC6jtuzL6iAiAJf29bzCv1bb0yoGelgEbds/7dhpTPzH1XFVDaF1GkOA=="
          }
        ],
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJiTtpWACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2VmpU7RAAnyUvU3419BYe0LiM3/Ti2cFu43D4dZNrFUi41riOTW22JVCA\r\nS7ikgoG4z4dHkph0HwPLxRy+Zq2nsolus/bV20gYY1qv/jGQICoBVHm4mEFk\r\nglg4pwzdsEutJVO3LDAuj9IXwibKXW99Ufyx2NVbMU/bvJ6DHnRXOkeGP9Z5\r\ndaPwctgRGxPEYf9Ru3+LiC/IjAyzH6peMoVDaxS6tUR1BGZik7t32FhmDjsW\r\nh/U+jvxf8w6JsgBEBdckNyw1vc0WR09PNsGVtDd+jePJjytzIXlSUaBvTJAS\r\nGTexkCHXkzGDgBGKPFhY1URfegBnlktRPgBAZKzun34z5fR7mjWBTcWKe6x7\r\nN5YxPRapNlA0SR+hqrvHvD91w2AUKtZUhj3PdFvqw+EsbZZyBSN5Vv/tRhNt\r\nBwUBasY0/RaCmxIeqCp7tobC0ayMybyDo7o6VTwiBsKmPqlSdT2X0e16Va15\r\nTxyq8dOvjcGIzMM4lr/aVkRZ/l7Nc8iFCUt3fD5WXLxT5RO7XudGFCPZf5+y\r\nGxRQDjz48aLlTK5hsupUpFUBayRlz6Xaa5lvtl3b5YZFDjmM+BC6CBcWDycD\r\nefvHJcrlXI9EptkEG+4VefMr5EBVvPw+hIgEJGQK3aTGGhK3AydfItcPTTO9\r\n/VDrR8iOIzK1HbdsoIsB/gv/KRUK535bFOk=\r\n=Wl8c\r\n-----END PGP SIGNATURE-----\r\n"
      },
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "maintainers": [
        {
          "name": "jheer",
          "email": "jeffrey.heer@gmail.com"
        },
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "kanitw",
          "email": "kanitw@gmail.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_1.1.0-next.0_1649334870331_0.1123465486179751"
      },
      "_hasShrinkwrap": false
    },
    "1.0.1--canary.1222.31471bc.0": {
      "name": "ts-json-schema-generator",
      "version": "1.0.1--canary.1222.31471bc.0",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "MooYeol Prescott Lee",
          "email": "mooyoul@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=10.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.9",
        "commander": "^9.0.0",
        "glob": "^7.2.0",
        "safe-stable-stringify": "^2.3.1",
        "json5": "^2.2.0",
        "typescript": "~4.6.2"
      },
      "devDependencies": {
        "@auto-it/conventional-commits": "^10.32.5",
        "@auto-it/first-time-contributor": "^10.32.5",
        "@babel/core": "^7.16.7",
        "@babel/preset-env": "^7.16.8",
        "@babel/preset-typescript": "^7.16.7",
        "@types/glob": "^7.2.0",
        "@types/jest": "^27.4.0",
        "@types/node": "^17.0.8",
        "@typescript-eslint/eslint-plugin": "^5.9.1",
        "@typescript-eslint/parser": "^5.9.1",
        "ajv": "^8.8.2",
        "ajv-formats": "^2.1.1",
        "auto": "^10.32.5",
        "chai": "^4.3.4",
        "cross-env": "^7.0.3",
        "eslint": "^8.6.0",
        "eslint-config-prettier": "^8.3.0",
        "eslint-plugin-prettier": "^4.0.0",
        "jest": "^27.4.7",
        "jest-junit": "^13.0.0",
        "prettier": "^2.5.1",
        "ts-node": "^10.4.0",
        "vega": "^5.21.0",
        "vega-lite": "^5.2.0"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint \"{src,test,factory}/**/*.ts\"",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "cross-env FAST_TEST=1 jest test/ --verbose",
        "test:coverage": "yarn jest test/ --collectCoverage=true",
        "test:update": "cross-env UPDATE_SCHEMA=true yarn test:fast",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node-transpile-only ts-json-schema-generator.ts",
        "release": "yarn build && auto shipit"
      },
      "readme": "# ts-json-schema-generator\n\n![Test](https://github.com/vega/ts-json-schema-generator/workflows/Test/badge.svg)\n[![codecov](https://codecov.io/gh/vega/ts-json-schema-generator/branch/master/graph/badge.svg)](https://codecov.io/gh/vega/ts-json-schema-generator)\n[![npm version](https://img.shields.io/npm/v/ts-json-schema-generator.svg)](https://www.npmjs.com/package/ts-json-schema-generator)\n\nExtended version of [https://github.com/xiag-ag/typescript-to-json-schema](https://github.com/xiag-ag/typescript-to-json-schema).\n\nInspired by [`YousefED/typescript-json-schema`](https://github.com/YousefED/typescript-json-schema). Here's the differences list:\n\n-   this implementation avoids the use of `typeChecker.getTypeAtLocation()` (so probably it keeps correct type aliases)\n-   processing AST and formatting JSON schema have been split into two independent steps\n-   not exported types, interfaces, enums are not exposed in the `definitions` section in the JSON schema\n\n## Contributors\n\nThis project is made possible by a [community of contributors](https://github.com/vega/ts-json-schema-generator/graphs/contributors). We welcome contributions of any kind (issues, code, documentation, examples, tests,...). Please read our [code of conduct](https://github.com/vega/vega/blob/master/CODE_OF_CONDUCT.md).\n\n## CLI Usage\n\n```bash\nnpm install --save ts-json-schema-generator\n./node_modules/.bin/ts-json-schema-generator --path 'my/project/**/*.ts' --type 'My.Type.Name'\n```\n\nNote that different platforms (e.g. Windows) may use different path separators so you may have to adjust the command above.\n\n## Programmatic Usage\n\n```js\n// main.js\n\nconst tsj = require(\"ts-json-schema-generator\");\nconst fs = require(\"fs\");\n\n/** @type {import('ts-json-schema-generator/dist/src/Config').Config} */\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst output_path = \"path/to/output/file\";\n\nconst schema = tsj.createGenerator(config).createSchema(config.type);\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\nRun the schema generator via `node main.js`.\n\n### Custom formatting\n\nExtending the built-in formatting is possible by creating a custom formatter and adding it to the main formatter:\n\n1. First we create a formatter, in this case for formatting function types:\n\n```ts\n// my-function-formatter.ts\nimport { BaseType, Definition, FunctionType, SubTypeFormatter } from \"ts-json-schema-generator\";\nimport ts from \"typescript\";\n\nexport class MyFunctionTypeFormatter implements SubTypeFormatter {\n    // You can skip this line if you don't need childTypeFormatter\n    public constructor(private childTypeFormatter: TypeFormatter) {}\n\n    public supportsType(type: FunctionType): boolean {\n        return type instanceof FunctionType;\n    }\n\n    public getDefinition(type: FunctionType): Definition {\n        // Return a custom schema for the function property.\n        return {\n            type: \"object\",\n            properties: {\n                isFunction: {\n                    type: \"boolean\",\n                    const: true,\n                },\n            },\n        };\n    }\n\n    // If this type does NOT HAVE children, generally all you need is:\n    public getChildren(type: FunctionType): BaseType[] {\n        return [];\n    }\n\n    // However, if children ARE supported, you'll need something similar to\n    // this (see src/TypeFormatter/{Array,Definition,etc}.ts for some examples):\n    public getChildren(type: FunctionType): BaseType[] {\n        return this.childTypeFormatter.getChildren(type.getType());\n    }\n}\n```\n\n2. Then we add the formatter as a child to the core formatter using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyFunctionTypeFormatter } from \"./my-function-formatter.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\n// We configure the formatter an add our custom formatter to it.\nconst formatter = createFormatter(config, (fmt, circularReferenceTypeFormatter) => {\n    // If your formatter DOES NOT support children, e.g. getChildren() { return [] }:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter());\n    // If your formatter DOES support children, you'll need this reference too:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter(circularReferenceTypeFormatter));\n});\n\nconst program = createProgram(config);\nconst parser = createParser(program, config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n### Custom parsing\n\nSimilar to custom formatting, extending the built-in parsing works practically the same way:\n\n1. First we create a parser, in this case for parsing construct types:\n\n```ts\n// my-constructor-parser.ts\nimport { Context, StringType, ReferenceType, BaseType, SubNodeParser } from \"ts-json-schema-generator\";\nimport ts from \"typescript\";\n\nexport class MyConstructorParser implements SubNodeParser {\n    supportsNode(node: ts.Node): boolean {\n        return node.kind === ts.SyntaxKind.ConstructorType;\n    }\n    createType(node: ts.Node, context: Context, reference?: ReferenceType): BaseType | undefined {\n        return new StringType(); // Treat constructors as strings in this example\n    }\n}\n```\n\n2. Then we add the parser as a child to the core parser using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyConstructorParser } from \"./my-constructor-parser.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst program = createProgram(config);\n\n// We configure the parser an add our custom parser to it.\nconst parser = createParser(program, config, (prs) => {\n    prs.addNodeParser(new MyConstructorParser());\n});\n\nconst formatter = createFormatter(config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n## Options\n\n```\n-p, --path 'index.ts'\n    The path to the TypeScript source file. If this is not provided, the type will be searched in the project specified in the `.tsconfig`.\n\n-t, --type 'My.Type.Name'\n    The type the generated schema will represent. If omitted, the generated schema will contain all\n    types found in the files matching path. The same is true if '*' is specified.\n\n-i, --id 'generatedSchemaId'\n    The `$id` of the generated schema. If omitted, there will be no `$id`.\n\n-e, --expose <all|none|export>\n    all: Create shared $ref definitions for all types.\n    none: Do not create shared $ref definitions.\n    export (default): Create shared $ref definitions only for exported types (not tagged as `@internal`).\n\n-f, --tsconfig 'my/project/tsconfig.json'\n    Use a custom tsconfig file for processing typescript (see https://www.typescriptlang.org/docs/handbook/tsconfig-json.html) instead of the default:\n    {\n        \"compilerOptions\": {\n            \"noEmit\": true,\n            \"emitDecoratorMetadata\": true,\n            \"experimentalDecorators\": true,\n            \"target\": \"ES5\",\n            \"module\": \"CommonJS\",\n            \"strictNullChecks\": false,\n        }\n    }\n\n-j, --jsDoc <extended|none|basic>\n    none: Do not use JsDoc annotations.\n    basic: Read JsDoc annotations to provide schema properties.\n    extended (default): Also read @nullable, and @asType annotations.\n\n--unstable\n    Do not sort properties.\n\n--strict-tuples\n    Do not allow additional items on tuples.\n\n--no-top-ref\n    Do not create a top-level $ref definition.\n\n--no-type-check\n    Skip type checks for better performance.\n\n--no-ref-encode\n    Do not encode references. According to the standard, references must be valid URIs but some tools do not support encoded references.\n\n--validation-keywords\n    Provide additional validation keywords to include.\n\n-o, --out\n    Specify the output file path. Without this option, the generator logs the response in the console.\n\n--additional-properties <true|false>\n    Controls whether or not to allow additional properties for objects that have no index signature.\n\n    true: Additional properties are allowed\n    false (default): Additional properties are not allowed\n\n--minify\n    Minify generated schema (default: false)\n```\n\n## Current state\n\n-   `interface` types\n-   `enum` types\n-   `union`, `tuple`, `type[]` types\n-   `Date`, `RegExp` types\n-   `string`, `boolean`, `number` types\n-   `\"value\"`, `123`, `true`, `false`, `null`, `undefined` literals\n-   type aliases\n-   generics\n-   `typeof`\n-   `keyof`\n-   conditional types\n\n## Run locally\n\n`yarn --silent run run --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\n## Debug\n\n`yarn --silent run debug --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\nAnd connect via the debugger protocol.\n\n[AST Explorer](https://astexplorer.net/) is amazing for developers of this tool!\n\n## Publish\n\nPublishing is handled by a 2-branch [pre-release process](https://intuit.github.io/auto/docs/generated/shipit#next-branch-default), configured in `publish-auto.yml`. All changes should be based off the default `next` branch, and are published automatically.\n\n-   PRs made into the default branch are auto-deployed to the `next` pre-release tag on NPM. The result can be installed with `npm install ts-json-schema-generator@next`\n    -   When merging into `next`, please use the `squash and merge` strategy.\n-   To release a new stable version, open a PR from `next` into `stable` using this [compare link](https://github.com/vega/ts-json-schema-generator/compare/stable...next).\n    -   When merging from `next` into `stable`, please use the `create a merge commit` strategy.\n",
      "readmeFilename": "README.md",
      "gitHead": "31471bc7d6416076aed0808b924a07d0e62bd13b",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@1.0.1--canary.1222.31471bc.0",
      "_nodeVersion": "16.14.2",
      "_npmVersion": "8.5.0",
      "dist": {
        "integrity": "sha512-VpvzWaKAl/GFPo7Ap0sPtFQmMnOf5thd+5H6Rlr2s/g8L8L0Yq4O0ubudYpE2hrOwbZGNqiNxVEJvMHiaiJNew==",
        "shasum": "7a8ec1f7ec6695ed4365973ea8524a5a6491f377",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-1.0.1--canary.1222.31471bc.0.tgz",
        "fileCount": 682,
        "unpackedSize": 778349,
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEQCIGcta4FTzv6SCtmy+ZM6lgR6Tb1QopUKHvG8vv7YDxf9AiBF/ZCl7x2LRdtsgCZ7tm5fVHCJwRosiHCkOSyECpTiLA=="
          }
        ],
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJiXBZwACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2VmqHoA//b9SqTpHjalrTrxPO5ym0PIqn1NEdL0q/ZX3NacOyuQmNjv5K\r\nliIqlLnviwmRqncKew7a5zJS/VTPuEZCSI4qWMg7NjTDf2AM+Dsz4tbnQpBz\r\nfhKzbhXAW+2nxvGPkRcXGOUM1qkdiIwxSSzPzelgNWfZjNkscf8BllGgb7jM\r\n/LSOmsmiHxdbO+CKFrqXd3FSf/Nnhde7u6Y1LixFszRwYiSN91ojCgaCW22s\r\nGZF0+YRD8rzK5v0ssFiNo9xODLTSPQi7HNsq4AYzvxZvVoFgOEYtCojcbzLD\r\nmurTeNos37vKMppqb0FizLsBZWh98lAeCQao9vL4OsbJGhtAL0xrpqtqNzP9\r\nujJb0ZcLKWj+i0VJHROznNTQVcsUiZnjxk0+ngAhhu+xbmNowempo7s5RLhK\r\nntjFkplz8rNorBKSlnYdmjq37v3F4v34n71KR7JR724McjYCfmkmVgSF6+Ge\r\nw5s+ytrSdWrf4i8k/xZCeio+aXsFRTc/WsFAStMuP7F4LU5706dSP3oxQ0dH\r\nHXiViRCAxnvjogmOIi4Tzb2z6HiAoNRGlCUDNPJlDd6xFEA1IiZ6Qi4btC36\r\n+rSTfmjPGrSRKCQRrI61TpEQLYrGWIb6Br+1qhTcq17AsnLEBnm3UN84r5Fo\r\nU0veZUO6coCsnCPuuWcOzWCwSNYfem5T6nY=\r\n=u90P\r\n-----END PGP SIGNATURE-----\r\n"
      },
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "maintainers": [
        {
          "name": "jheer",
          "email": "jeffrey.heer@gmail.com"
        },
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "kanitw",
          "email": "kanitw@gmail.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_1.0.1--canary.1222.31471bc.0_1650202224403_0.7648260383217649"
      },
      "_hasShrinkwrap": false
    },
    "1.1.0-next.1": {
      "name": "ts-json-schema-generator",
      "version": "1.1.0-next.1",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "MooYeol Prescott Lee",
          "email": "mooyoul@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=10.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.9",
        "commander": "^9.0.0",
        "glob": "^7.2.0",
        "safe-stable-stringify": "^2.3.1",
        "json5": "^2.2.0",
        "typescript": "~4.6.2"
      },
      "devDependencies": {
        "@auto-it/conventional-commits": "^10.32.5",
        "@auto-it/first-time-contributor": "^10.32.5",
        "@babel/core": "^7.16.7",
        "@babel/preset-env": "^7.16.8",
        "@babel/preset-typescript": "^7.16.7",
        "@types/glob": "^7.2.0",
        "@types/jest": "^27.4.0",
        "@types/node": "^17.0.8",
        "@typescript-eslint/eslint-plugin": "^5.9.1",
        "@typescript-eslint/parser": "^5.9.1",
        "ajv": "^8.8.2",
        "ajv-formats": "^2.1.1",
        "auto": "^10.32.5",
        "chai": "^4.3.4",
        "cross-env": "^7.0.3",
        "eslint": "^8.6.0",
        "eslint-config-prettier": "^8.3.0",
        "eslint-plugin-prettier": "^4.0.0",
        "jest": "^27.4.7",
        "jest-junit": "^13.0.0",
        "prettier": "^2.5.1",
        "ts-node": "^10.4.0",
        "vega": "^5.21.0",
        "vega-lite": "^5.2.0"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint \"{src,test,factory}/**/*.ts\"",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "cross-env FAST_TEST=1 jest test/ --verbose",
        "test:coverage": "yarn jest test/ --collectCoverage=true",
        "test:update": "cross-env UPDATE_SCHEMA=true yarn test:fast",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node-transpile-only ts-json-schema-generator.ts",
        "release": "yarn build && auto shipit"
      },
      "readme": "# ts-json-schema-generator\n\n![Test](https://github.com/vega/ts-json-schema-generator/workflows/Test/badge.svg)\n[![codecov](https://codecov.io/gh/vega/ts-json-schema-generator/branch/master/graph/badge.svg)](https://codecov.io/gh/vega/ts-json-schema-generator)\n[![npm version](https://img.shields.io/npm/v/ts-json-schema-generator.svg)](https://www.npmjs.com/package/ts-json-schema-generator)\n\nExtended version of [https://github.com/xiag-ag/typescript-to-json-schema](https://github.com/xiag-ag/typescript-to-json-schema).\n\nInspired by [`YousefED/typescript-json-schema`](https://github.com/YousefED/typescript-json-schema). Here's the differences list:\n\n-   this implementation avoids the use of `typeChecker.getTypeAtLocation()` (so probably it keeps correct type aliases)\n-   processing AST and formatting JSON schema have been split into two independent steps\n-   not exported types, interfaces, enums are not exposed in the `definitions` section in the JSON schema\n\n## Contributors\n\nThis project is made possible by a [community of contributors](https://github.com/vega/ts-json-schema-generator/graphs/contributors). We welcome contributions of any kind (issues, code, documentation, examples, tests,...). Please read our [code of conduct](https://github.com/vega/vega/blob/master/CODE_OF_CONDUCT.md).\n\n## CLI Usage\n\n```bash\nnpm install --save ts-json-schema-generator\n./node_modules/.bin/ts-json-schema-generator --path 'my/project/**/*.ts' --type 'My.Type.Name'\n```\n\nNote that different platforms (e.g. Windows) may use different path separators so you may have to adjust the command above.\n\n## Programmatic Usage\n\n```js\n// main.js\n\nconst tsj = require(\"ts-json-schema-generator\");\nconst fs = require(\"fs\");\n\n/** @type {import('ts-json-schema-generator/dist/src/Config').Config} */\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst output_path = \"path/to/output/file\";\n\nconst schema = tsj.createGenerator(config).createSchema(config.type);\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\nRun the schema generator via `node main.js`.\n\n### Custom formatting\n\nExtending the built-in formatting is possible by creating a custom formatter and adding it to the main formatter:\n\n1. First we create a formatter, in this case for formatting function types:\n\n```ts\n// my-function-formatter.ts\nimport { BaseType, Definition, FunctionType, SubTypeFormatter } from \"ts-json-schema-generator\";\nimport ts from \"typescript\";\n\nexport class MyFunctionTypeFormatter implements SubTypeFormatter {\n    // You can skip this line if you don't need childTypeFormatter\n    public constructor(private childTypeFormatter: TypeFormatter) {}\n\n    public supportsType(type: FunctionType): boolean {\n        return type instanceof FunctionType;\n    }\n\n    public getDefinition(type: FunctionType): Definition {\n        // Return a custom schema for the function property.\n        return {\n            type: \"object\",\n            properties: {\n                isFunction: {\n                    type: \"boolean\",\n                    const: true,\n                },\n            },\n        };\n    }\n\n    // If this type does NOT HAVE children, generally all you need is:\n    public getChildren(type: FunctionType): BaseType[] {\n        return [];\n    }\n\n    // However, if children ARE supported, you'll need something similar to\n    // this (see src/TypeFormatter/{Array,Definition,etc}.ts for some examples):\n    public getChildren(type: FunctionType): BaseType[] {\n        return this.childTypeFormatter.getChildren(type.getType());\n    }\n}\n```\n\n2. Then we add the formatter as a child to the core formatter using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyFunctionTypeFormatter } from \"./my-function-formatter.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\n// We configure the formatter an add our custom formatter to it.\nconst formatter = createFormatter(config, (fmt, circularReferenceTypeFormatter) => {\n    // If your formatter DOES NOT support children, e.g. getChildren() { return [] }:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter());\n    // If your formatter DOES support children, you'll need this reference too:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter(circularReferenceTypeFormatter));\n});\n\nconst program = createProgram(config);\nconst parser = createParser(program, config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n### Custom parsing\n\nSimilar to custom formatting, extending the built-in parsing works practically the same way:\n\n1. First we create a parser, in this case for parsing construct types:\n\n```ts\n// my-constructor-parser.ts\nimport { Context, StringType, ReferenceType, BaseType, SubNodeParser } from \"ts-json-schema-generator\";\nimport ts from \"typescript\";\n\nexport class MyConstructorParser implements SubNodeParser {\n    supportsNode(node: ts.Node): boolean {\n        return node.kind === ts.SyntaxKind.ConstructorType;\n    }\n    createType(node: ts.Node, context: Context, reference?: ReferenceType): BaseType | undefined {\n        return new StringType(); // Treat constructors as strings in this example\n    }\n}\n```\n\n2. Then we add the parser as a child to the core parser using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyConstructorParser } from \"./my-constructor-parser.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst program = createProgram(config);\n\n// We configure the parser an add our custom parser to it.\nconst parser = createParser(program, config, (prs) => {\n    prs.addNodeParser(new MyConstructorParser());\n});\n\nconst formatter = createFormatter(config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n## Options\n\n```\n-p, --path 'index.ts'\n    The path to the TypeScript source file. If this is not provided, the type will be searched in the project specified in the `.tsconfig`.\n\n-t, --type 'My.Type.Name'\n    The type the generated schema will represent. If omitted, the generated schema will contain all\n    types found in the files matching path. The same is true if '*' is specified.\n\n-i, --id 'generatedSchemaId'\n    The `$id` of the generated schema. If omitted, there will be no `$id`.\n\n-e, --expose <all|none|export>\n    all: Create shared $ref definitions for all types.\n    none: Do not create shared $ref definitions.\n    export (default): Create shared $ref definitions only for exported types (not tagged as `@internal`).\n\n-f, --tsconfig 'my/project/tsconfig.json'\n    Use a custom tsconfig file for processing typescript (see https://www.typescriptlang.org/docs/handbook/tsconfig-json.html) instead of the default:\n    {\n        \"compilerOptions\": {\n            \"noEmit\": true,\n            \"emitDecoratorMetadata\": true,\n            \"experimentalDecorators\": true,\n            \"target\": \"ES5\",\n            \"module\": \"CommonJS\",\n            \"strictNullChecks\": false,\n        }\n    }\n\n-j, --jsDoc <extended|none|basic>\n    none: Do not use JsDoc annotations.\n    basic: Read JsDoc annotations to provide schema properties.\n    extended (default): Also read @nullable, and @asType annotations.\n\n--unstable\n    Do not sort properties.\n\n--strict-tuples\n    Do not allow additional items on tuples.\n\n--no-top-ref\n    Do not create a top-level $ref definition.\n\n--no-type-check\n    Skip type checks for better performance.\n\n--no-ref-encode\n    Do not encode references. According to the standard, references must be valid URIs but some tools do not support encoded references.\n\n--validation-keywords\n    Provide additional validation keywords to include.\n\n-o, --out\n    Specify the output file path. Without this option, the generator logs the response in the console.\n\n--additional-properties <true|false>\n    Controls whether or not to allow additional properties for objects that have no index signature.\n\n    true: Additional properties are allowed\n    false (default): Additional properties are not allowed\n\n--minify\n    Minify generated schema (default: false)\n```\n\n## Current state\n\n-   `interface` types\n-   `enum` types\n-   `union`, `tuple`, `type[]` types\n-   `Date`, `RegExp` types\n-   `string`, `boolean`, `number` types\n-   `\"value\"`, `123`, `true`, `false`, `null`, `undefined` literals\n-   type aliases\n-   generics\n-   `typeof`\n-   `keyof`\n-   conditional types\n\n## Run locally\n\n`yarn --silent run run --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\n## Debug\n\n`yarn --silent run debug --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\nAnd connect via the debugger protocol.\n\n[AST Explorer](https://astexplorer.net/) is amazing for developers of this tool!\n\n## Publish\n\nPublishing is handled by a 2-branch [pre-release process](https://intuit.github.io/auto/docs/generated/shipit#next-branch-default), configured in `publish-auto.yml`. All changes should be based off the default `next` branch, and are published automatically.\n\n-   PRs made into the default branch are auto-deployed to the `next` pre-release tag on NPM. The result can be installed with `npm install ts-json-schema-generator@next`\n    -   When merging into `next`, please use the `squash and merge` strategy.\n-   To release a new stable version, open a PR from `next` into `stable` using this [compare link](https://github.com/vega/ts-json-schema-generator/compare/stable...next).\n    -   When merging from `next` into `stable`, please use the `create a merge commit` strategy.\n",
      "readmeFilename": "README.md",
      "gitHead": "5b176a0ad95616c7b37090ed98ef315898ea4993",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@1.1.0-next.1",
      "_nodeVersion": "16.14.2",
      "_npmVersion": "8.5.0",
      "dist": {
        "integrity": "sha512-cZz3BRGA1cRPN4fsaQTKhuhM3TfogF7A2rF6KwhjRFwVor2gUocOOHpKRORwpwFkGX/41kNTgC2xmczlz7mHWw==",
        "shasum": "91fb979a8b3cb5519883fcb15701ac86abf4d43f",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-1.1.0-next.1.tgz",
        "fileCount": 682,
        "unpackedSize": 787961,
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIQDCz2ANNb5MJg3xjrrqmKx+RkHTqDbEzsrMbyCrDXG/UAIgUENAXMXraZfNch/yFBT4JzX4EB7vmAe/EUQU+QAkL/0="
          }
        ],
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJiXBa/ACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2VmpXzA/8DeU4s49RxSNKIx6jEJNEX0GLrWBdibY2+G0BvktOvoOutSZQ\r\nXaOYYHlYlEz9HLpuys9TNtM171mvo1hkk3aDgGtdAQwgk1QS/aUBOwK/t0yC\r\nSbPIZEv3lpgnBrIcKKReDt55EWH4NzHQwwLI8upMhsDz/23ZMHsn4LHvnWUR\r\nuH+54/1JiTSyqWYVNR+TcBBA9J8GSPDkIQIvezv2yPi3ETEYEA/PlRgVtFLm\r\ncf/z6f5XC5qrcSam6nlGHhDxb1UTGmBMTYAXNXRNHt+AhxeThlkY1WuUXSAk\r\nmRcnRPdEMxl06GnlqL30vfjY2pSiGK3mC45hTJQ6lvoL0pAOagb/MOn916hA\r\nkUfD69fkIJxivV0CVgHr0VI5HrV/zAsVOJeMCJ+65vqUtWO7SVgG2zxPDnOl\r\nDzMOHTSs91gl40Kps7Olllsouhi6J0UZOJkFHSv/pc3UyZSFrRciG6+CUVx9\r\nigVZM1NPJImyOw23A3nHT0Vj+ofvCwWDx4mjCgsVAYJ0Zsadj6WLTQlNGHT6\r\nV9NY0/ELKAWt65i0xgER4wjOZKTxaE5XLZijZiswLLgmFlycvCFn4ZSBd+1u\r\n5UahSFtVV8E44Rg5MfJYmIXfAIzqO7O7bvVLhZS3c8zoEkzBjTUh4Jemrw6p\r\nJLW26GEhMOXeZRMXqcOoXJvL4oIyRJLmqGI=\r\n=mfP1\r\n-----END PGP SIGNATURE-----\r\n"
      },
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "maintainers": [
        {
          "name": "jheer",
          "email": "jeffrey.heer@gmail.com"
        },
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "kanitw",
          "email": "kanitw@gmail.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_1.1.0-next.1_1650202303417_0.4843069771820401"
      },
      "_hasShrinkwrap": false
    },
    "1.1.0-next.2": {
      "name": "ts-json-schema-generator",
      "version": "1.1.0-next.2",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "MooYeol Prescott Lee",
          "email": "mooyoul@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=10.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.9",
        "commander": "^9.0.0",
        "glob": "^8.0.1",
        "json5": "^2.2.0",
        "normalize-path": "^3.0.0",
        "safe-stable-stringify": "^2.3.1",
        "typescript": "~4.6.2"
      },
      "devDependencies": {
        "@auto-it/conventional-commits": "^10.32.5",
        "@auto-it/first-time-contributor": "^10.32.5",
        "@babel/core": "^7.16.7",
        "@babel/preset-env": "^7.16.8",
        "@babel/preset-typescript": "^7.16.7",
        "@types/glob": "^7.2.0",
        "@types/jest": "^27.4.0",
        "@types/node": "^17.0.8",
        "@types/normalize-path": "^3.0.0",
        "@typescript-eslint/eslint-plugin": "^5.9.1",
        "@typescript-eslint/parser": "^5.9.1",
        "ajv": "^8.8.2",
        "ajv-formats": "^2.1.1",
        "auto": "^10.32.5",
        "chai": "^4.3.4",
        "cross-env": "^7.0.3",
        "eslint": "^8.6.0",
        "eslint-config-prettier": "^8.3.0",
        "eslint-plugin-prettier": "^4.0.0",
        "jest": "^28.0.3",
        "jest-junit": "^13.0.0",
        "prettier": "^2.5.1",
        "ts-node": "^10.4.0",
        "vega": "^5.21.0",
        "vega-lite": "^5.2.0"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint \"{src,test,factory}/**/*.ts\"",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "cross-env FAST_TEST=1 jest test/ --verbose",
        "test:coverage": "yarn jest test/ --collectCoverage=true",
        "test:update": "cross-env UPDATE_SCHEMA=true yarn test:fast",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node-transpile-only ts-json-schema-generator.ts",
        "release": "yarn build && auto shipit"
      },
      "readme": "# ts-json-schema-generator\n\n![Test](https://github.com/vega/ts-json-schema-generator/workflows/Test/badge.svg)\n[![codecov](https://codecov.io/gh/vega/ts-json-schema-generator/branch/master/graph/badge.svg)](https://codecov.io/gh/vega/ts-json-schema-generator)\n[![npm version](https://img.shields.io/npm/v/ts-json-schema-generator.svg)](https://www.npmjs.com/package/ts-json-schema-generator)\n\nExtended version of [https://github.com/xiag-ag/typescript-to-json-schema](https://github.com/xiag-ag/typescript-to-json-schema).\n\nInspired by [`YousefED/typescript-json-schema`](https://github.com/YousefED/typescript-json-schema). Here's the differences list:\n\n-   this implementation avoids the use of `typeChecker.getTypeAtLocation()` (so probably it keeps correct type aliases)\n-   processing AST and formatting JSON schema have been split into two independent steps\n-   not exported types, interfaces, enums are not exposed in the `definitions` section in the JSON schema\n\n## Contributors\n\nThis project is made possible by a [community of contributors](https://github.com/vega/ts-json-schema-generator/graphs/contributors). We welcome contributions of any kind (issues, code, documentation, examples, tests,...). Please read our [code of conduct](https://github.com/vega/vega/blob/master/CODE_OF_CONDUCT.md).\n\n## CLI Usage\n\n```bash\nnpm install --save ts-json-schema-generator\n./node_modules/.bin/ts-json-schema-generator --path 'my/project/**/*.ts' --type 'My.Type.Name'\n```\n\nNote that different platforms (e.g. Windows) may use different path separators so you may have to adjust the command above.\n\n## Programmatic Usage\n\n```js\n// main.js\n\nconst tsj = require(\"ts-json-schema-generator\");\nconst fs = require(\"fs\");\n\n/** @type {import('ts-json-schema-generator/dist/src/Config').Config} */\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst output_path = \"path/to/output/file\";\n\nconst schema = tsj.createGenerator(config).createSchema(config.type);\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\nRun the schema generator via `node main.js`.\n\n### Custom formatting\n\nExtending the built-in formatting is possible by creating a custom formatter and adding it to the main formatter:\n\n1. First we create a formatter, in this case for formatting function types:\n\n```ts\n// my-function-formatter.ts\nimport { BaseType, Definition, FunctionType, SubTypeFormatter } from \"ts-json-schema-generator\";\nimport ts from \"typescript\";\n\nexport class MyFunctionTypeFormatter implements SubTypeFormatter {\n    // You can skip this line if you don't need childTypeFormatter\n    public constructor(private childTypeFormatter: TypeFormatter) {}\n\n    public supportsType(type: FunctionType): boolean {\n        return type instanceof FunctionType;\n    }\n\n    public getDefinition(type: FunctionType): Definition {\n        // Return a custom schema for the function property.\n        return {\n            type: \"object\",\n            properties: {\n                isFunction: {\n                    type: \"boolean\",\n                    const: true,\n                },\n            },\n        };\n    }\n\n    // If this type does NOT HAVE children, generally all you need is:\n    public getChildren(type: FunctionType): BaseType[] {\n        return [];\n    }\n\n    // However, if children ARE supported, you'll need something similar to\n    // this (see src/TypeFormatter/{Array,Definition,etc}.ts for some examples):\n    public getChildren(type: FunctionType): BaseType[] {\n        return this.childTypeFormatter.getChildren(type.getType());\n    }\n}\n```\n\n2. Then we add the formatter as a child to the core formatter using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyFunctionTypeFormatter } from \"./my-function-formatter.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\n// We configure the formatter an add our custom formatter to it.\nconst formatter = createFormatter(config, (fmt, circularReferenceTypeFormatter) => {\n    // If your formatter DOES NOT support children, e.g. getChildren() { return [] }:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter());\n    // If your formatter DOES support children, you'll need this reference too:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter(circularReferenceTypeFormatter));\n});\n\nconst program = createProgram(config);\nconst parser = createParser(program, config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n### Custom parsing\n\nSimilar to custom formatting, extending the built-in parsing works practically the same way:\n\n1. First we create a parser, in this case for parsing construct types:\n\n```ts\n// my-constructor-parser.ts\nimport { Context, StringType, ReferenceType, BaseType, SubNodeParser } from \"ts-json-schema-generator\";\nimport ts from \"typescript\";\n\nexport class MyConstructorParser implements SubNodeParser {\n    supportsNode(node: ts.Node): boolean {\n        return node.kind === ts.SyntaxKind.ConstructorType;\n    }\n    createType(node: ts.Node, context: Context, reference?: ReferenceType): BaseType | undefined {\n        return new StringType(); // Treat constructors as strings in this example\n    }\n}\n```\n\n2. Then we add the parser as a child to the core parser using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyConstructorParser } from \"./my-constructor-parser.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst program = createProgram(config);\n\n// We configure the parser an add our custom parser to it.\nconst parser = createParser(program, config, (prs) => {\n    prs.addNodeParser(new MyConstructorParser());\n});\n\nconst formatter = createFormatter(config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n## Options\n\n```\n-p, --path 'index.ts'\n    The path to the TypeScript source file. If this is not provided, the type will be searched in the project specified in the `.tsconfig`.\n\n-t, --type 'My.Type.Name'\n    The type the generated schema will represent. If omitted, the generated schema will contain all\n    types found in the files matching path. The same is true if '*' is specified.\n\n-i, --id 'generatedSchemaId'\n    The `$id` of the generated schema. If omitted, there will be no `$id`.\n\n-e, --expose <all|none|export>\n    all: Create shared $ref definitions for all types.\n    none: Do not create shared $ref definitions.\n    export (default): Create shared $ref definitions only for exported types (not tagged as `@internal`).\n\n-f, --tsconfig 'my/project/tsconfig.json'\n    Use a custom tsconfig file for processing typescript (see https://www.typescriptlang.org/docs/handbook/tsconfig-json.html) instead of the default:\n    {\n        \"compilerOptions\": {\n            \"noEmit\": true,\n            \"emitDecoratorMetadata\": true,\n            \"experimentalDecorators\": true,\n            \"target\": \"ES5\",\n            \"module\": \"CommonJS\",\n            \"strictNullChecks\": false,\n        }\n    }\n\n-j, --jsDoc <extended|none|basic>\n    none: Do not use JsDoc annotations.\n    basic: Read JsDoc annotations to provide schema properties.\n    extended (default): Also read @nullable, and @asType annotations.\n\n--unstable\n    Do not sort properties.\n\n--strict-tuples\n    Do not allow additional items on tuples.\n\n--no-top-ref\n    Do not create a top-level $ref definition.\n\n--no-type-check\n    Skip type checks for better performance.\n\n--no-ref-encode\n    Do not encode references. According to the standard, references must be valid URIs but some tools do not support encoded references.\n\n--validation-keywords\n    Provide additional validation keywords to include.\n\n-o, --out\n    Specify the output file path. Without this option, the generator logs the response in the console.\n\n--additional-properties <true|false>\n    Controls whether or not to allow additional properties for objects that have no index signature.\n\n    true: Additional properties are allowed\n    false (default): Additional properties are not allowed\n\n--minify\n    Minify generated schema (default: false)\n```\n\n## Current state\n\n-   `interface` types\n-   `enum` types\n-   `union`, `tuple`, `type[]` types\n-   `Date`, `RegExp` types\n-   `string`, `boolean`, `number` types\n-   `\"value\"`, `123`, `true`, `false`, `null`, `undefined` literals\n-   type aliases\n-   generics\n-   `typeof`\n-   `keyof`\n-   conditional types\n\n## Run locally\n\n`yarn --silent run run --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\n## Debug\n\n`yarn --silent run debug --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\nAnd connect via the debugger protocol.\n\n[AST Explorer](https://astexplorer.net/) is amazing for developers of this tool!\n\n## Publish\n\nPublishing is handled by a 2-branch [pre-release process](https://intuit.github.io/auto/docs/generated/shipit#next-branch-default), configured in `publish-auto.yml`. All changes should be based off the default `next` branch, and are published automatically.\n\n-   PRs made into the default branch are auto-deployed to the `next` pre-release tag on NPM. The result can be installed with `npm install ts-json-schema-generator@next`\n    -   When merging into `next`, please use the `squash and merge` strategy.\n-   To release a new stable version, open a PR from `next` into `stable` using this [compare link](https://github.com/vega/ts-json-schema-generator/compare/stable...next).\n    -   When merging from `next` into `stable`, please use the `create a merge commit` strategy.\n",
      "readmeFilename": "README.md",
      "gitHead": "1d9605b304d9ed713db95f274f5ccd1e5315d824",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@1.1.0-next.2",
      "_nodeVersion": "16.15.0",
      "_npmVersion": "8.5.5",
      "dist": {
        "integrity": "sha512-3LLc/iiqQUpj5fWwtYjACXRYsx5hN1YSI9cnAtYpzQIJlh3q+E9BVNmIP7b3fIlWr6l1sgUdYGFlhhjZf2oV5w==",
        "shasum": "b2a423ad9369293a727ad897a4b8be00974fb1e9",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-1.1.0-next.2.tgz",
        "fileCount": 682,
        "unpackedSize": 788652,
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIQCkLqS0BUWkOZmDAHtrnG41NhYP/b+I1C1WY8PWib5L2AIgHROVgpNJgchq9GFvu1BMYoF3nb4UVFyLUuacRLZSVZs="
          }
        ],
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJidWULACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2VmqPQxAAhsx/Lrhca9aIEqP8WEMQ7O5hn9sPMexVeZwc5QPEIOGVw3sz\r\n1Mv6InQl4Xbc+B2Gkt9FrieyPZoOO2JWGG1j1SaEYXyk0UjB9tfQDsvDWTIt\r\nz4wQUz/wPYdf/QImU2kcqcTmRqLgQyUstCF1MhavnWyayr+msF6b5VJEo/h6\r\nWVOrZ3U6ybzYBN86Q0zn/ian+wRhNQ+Zc3j1wC7KEYqOfZ6b1AKONJE7UWBS\r\n7b5O0d/XxunooTaUFrJlTGQcUcEv11Olv15iKbQoQf61cfGWaWG2jF3HoAGk\r\nn7CTq5TA/VgffI2BQVYjY3EWpL40x8nfm9v1e5C5w6Zt7iscafAohV2oyFXu\r\nEhvrA8VItetkoBo853VPjSyhDtjXKaJapMVvFiL2qmy6QEXcXAKDOZSmTibD\r\n2BG3vJYLOPE2N39GgZeLr5a6sfBZsh+d9zghYLisz6p0RDZxzzTNzmq2X6x3\r\nnmqEZB8PU1b7CtjVFUupN2HKxd2szSCNheR33L+o6ttBpJRJkZ84PB3x0gHG\r\n+04VnTEOmLtS+rv+VVY63DyhZrX6zJASt3BaN7bJXAKK3GD1LpXik+MRcZ0m\r\nDrAiPE2gwcKnASWEbIkUdhwkP7wD7GT0U8L2DTwoewvQ8l+MIJ+vxraRbu3n\r\nWjxT74z5Ni+iX59cggz3PTGwBJchL09axSk=\r\n=cL/Q\r\n-----END PGP SIGNATURE-----\r\n"
      },
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "maintainers": [
        {
          "name": "jheer",
          "email": "jeffrey.heer@gmail.com"
        },
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "kanitw",
          "email": "kanitw@gmail.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_1.1.0-next.2_1651860746816_0.26666523169147327"
      },
      "_hasShrinkwrap": false
    },
    "1.1.0-next.3": {
      "name": "ts-json-schema-generator",
      "version": "1.1.0-next.3",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "MooYeol Prescott Lee",
          "email": "mooyoul@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=10.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.9",
        "commander": "^9.0.0",
        "glob": "^8.0.1",
        "json5": "^2.2.0",
        "normalize-path": "^3.0.0",
        "safe-stable-stringify": "^2.3.1",
        "typescript": "~4.6.2"
      },
      "devDependencies": {
        "@auto-it/conventional-commits": "^10.32.5",
        "@auto-it/first-time-contributor": "^10.32.5",
        "@babel/core": "^7.16.7",
        "@babel/preset-env": "^7.16.8",
        "@babel/preset-typescript": "^7.16.7",
        "@types/glob": "^7.2.0",
        "@types/jest": "^27.4.0",
        "@types/node": "^17.0.8",
        "@types/normalize-path": "^3.0.0",
        "@typescript-eslint/eslint-plugin": "^5.9.1",
        "@typescript-eslint/parser": "^5.9.1",
        "ajv": "^8.8.2",
        "ajv-formats": "^2.1.1",
        "auto": "^10.32.5",
        "chai": "^4.3.4",
        "cross-env": "^7.0.3",
        "eslint": "^8.6.0",
        "eslint-config-prettier": "^8.3.0",
        "eslint-plugin-prettier": "^4.0.0",
        "jest": "^28.0.3",
        "jest-junit": "^13.0.0",
        "prettier": "^2.5.1",
        "ts-node": "^10.4.0",
        "vega": "^5.21.0",
        "vega-lite": "^5.2.0"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint \"{src,test,factory}/**/*.ts\"",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "cross-env FAST_TEST=1 jest test/ --verbose",
        "test:coverage": "yarn jest test/ --collectCoverage=true",
        "test:update": "cross-env UPDATE_SCHEMA=true yarn test:fast",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node-transpile-only ts-json-schema-generator.ts",
        "release": "yarn build && auto shipit"
      },
      "readme": "# ts-json-schema-generator\n\n![Test](https://github.com/vega/ts-json-schema-generator/workflows/Test/badge.svg)\n[![codecov](https://codecov.io/gh/vega/ts-json-schema-generator/branch/master/graph/badge.svg)](https://codecov.io/gh/vega/ts-json-schema-generator)\n[![npm version](https://img.shields.io/npm/v/ts-json-schema-generator.svg)](https://www.npmjs.com/package/ts-json-schema-generator)\n\nExtended version of [https://github.com/xiag-ag/typescript-to-json-schema](https://github.com/xiag-ag/typescript-to-json-schema).\n\nInspired by [`YousefED/typescript-json-schema`](https://github.com/YousefED/typescript-json-schema). Here's the differences list:\n\n-   this implementation avoids the use of `typeChecker.getTypeAtLocation()` (so probably it keeps correct type aliases)\n-   processing AST and formatting JSON schema have been split into two independent steps\n-   not exported types, interfaces, enums are not exposed in the `definitions` section in the JSON schema\n\n## Contributors\n\nThis project is made possible by a [community of contributors](https://github.com/vega/ts-json-schema-generator/graphs/contributors). We welcome contributions of any kind (issues, code, documentation, examples, tests,...). Please read our [code of conduct](https://github.com/vega/vega/blob/master/CODE_OF_CONDUCT.md).\n\n## CLI Usage\n\n```bash\nnpm install --save ts-json-schema-generator\n./node_modules/.bin/ts-json-schema-generator --path 'my/project/**/*.ts' --type 'My.Type.Name'\n```\n\nNote that different platforms (e.g. Windows) may use different path separators so you may have to adjust the command above.\n\n## Programmatic Usage\n\n```js\n// main.js\n\nconst tsj = require(\"ts-json-schema-generator\");\nconst fs = require(\"fs\");\n\n/** @type {import('ts-json-schema-generator/dist/src/Config').Config} */\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst output_path = \"path/to/output/file\";\n\nconst schema = tsj.createGenerator(config).createSchema(config.type);\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\nRun the schema generator via `node main.js`.\n\n### Custom formatting\n\nExtending the built-in formatting is possible by creating a custom formatter and adding it to the main formatter:\n\n1. First we create a formatter, in this case for formatting function types:\n\n```ts\n// my-function-formatter.ts\nimport { BaseType, Definition, FunctionType, SubTypeFormatter } from \"ts-json-schema-generator\";\nimport ts from \"typescript\";\n\nexport class MyFunctionTypeFormatter implements SubTypeFormatter {\n    // You can skip this line if you don't need childTypeFormatter\n    public constructor(private childTypeFormatter: TypeFormatter) {}\n\n    public supportsType(type: FunctionType): boolean {\n        return type instanceof FunctionType;\n    }\n\n    public getDefinition(type: FunctionType): Definition {\n        // Return a custom schema for the function property.\n        return {\n            type: \"object\",\n            properties: {\n                isFunction: {\n                    type: \"boolean\",\n                    const: true,\n                },\n            },\n        };\n    }\n\n    // If this type does NOT HAVE children, generally all you need is:\n    public getChildren(type: FunctionType): BaseType[] {\n        return [];\n    }\n\n    // However, if children ARE supported, you'll need something similar to\n    // this (see src/TypeFormatter/{Array,Definition,etc}.ts for some examples):\n    public getChildren(type: FunctionType): BaseType[] {\n        return this.childTypeFormatter.getChildren(type.getType());\n    }\n}\n```\n\n2. Then we add the formatter as a child to the core formatter using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyFunctionTypeFormatter } from \"./my-function-formatter.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\n// We configure the formatter an add our custom formatter to it.\nconst formatter = createFormatter(config, (fmt, circularReferenceTypeFormatter) => {\n    // If your formatter DOES NOT support children, e.g. getChildren() { return [] }:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter());\n    // If your formatter DOES support children, you'll need this reference too:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter(circularReferenceTypeFormatter));\n});\n\nconst program = createProgram(config);\nconst parser = createParser(program, config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n### Custom parsing\n\nSimilar to custom formatting, extending the built-in parsing works practically the same way:\n\n1. First we create a parser, in this case for parsing construct types:\n\n```ts\n// my-constructor-parser.ts\nimport { Context, StringType, ReferenceType, BaseType, SubNodeParser } from \"ts-json-schema-generator\";\nimport ts from \"typescript\";\n\nexport class MyConstructorParser implements SubNodeParser {\n    supportsNode(node: ts.Node): boolean {\n        return node.kind === ts.SyntaxKind.ConstructorType;\n    }\n    createType(node: ts.Node, context: Context, reference?: ReferenceType): BaseType | undefined {\n        return new StringType(); // Treat constructors as strings in this example\n    }\n}\n```\n\n2. Then we add the parser as a child to the core parser using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyConstructorParser } from \"./my-constructor-parser.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst program = createProgram(config);\n\n// We configure the parser an add our custom parser to it.\nconst parser = createParser(program, config, (prs) => {\n    prs.addNodeParser(new MyConstructorParser());\n});\n\nconst formatter = createFormatter(config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n## Options\n\n```\n-p, --path 'index.ts'\n    The path to the TypeScript source file. If this is not provided, the type will be searched in the project specified in the `.tsconfig`.\n\n-t, --type 'My.Type.Name'\n    The type the generated schema will represent. If omitted, the generated schema will contain all\n    types found in the files matching path. The same is true if '*' is specified.\n\n-i, --id 'generatedSchemaId'\n    The `$id` of the generated schema. If omitted, there will be no `$id`.\n\n-e, --expose <all|none|export>\n    all: Create shared $ref definitions for all types.\n    none: Do not create shared $ref definitions.\n    export (default): Create shared $ref definitions only for exported types (not tagged as `@internal`).\n\n-f, --tsconfig 'my/project/tsconfig.json'\n    Use a custom tsconfig file for processing typescript (see https://www.typescriptlang.org/docs/handbook/tsconfig-json.html) instead of the default:\n    {\n        \"compilerOptions\": {\n            \"noEmit\": true,\n            \"emitDecoratorMetadata\": true,\n            \"experimentalDecorators\": true,\n            \"target\": \"ES5\",\n            \"module\": \"CommonJS\",\n            \"strictNullChecks\": false,\n        }\n    }\n\n-j, --jsDoc <extended|none|basic>\n    none: Do not use JsDoc annotations.\n    basic: Read JsDoc annotations to provide schema properties.\n    extended (default): Also read @nullable, and @asType annotations.\n\n--unstable\n    Do not sort properties.\n\n--strict-tuples\n    Do not allow additional items on tuples.\n\n--no-top-ref\n    Do not create a top-level $ref definition.\n\n--no-type-check\n    Skip type checks for better performance.\n\n--no-ref-encode\n    Do not encode references. According to the standard, references must be valid URIs but some tools do not support encoded references.\n\n--validation-keywords\n    Provide additional validation keywords to include.\n\n-o, --out\n    Specify the output file path. Without this option, the generator logs the response in the console.\n\n--additional-properties <true|false>\n    Controls whether or not to allow additional properties for objects that have no index signature.\n\n    true: Additional properties are allowed\n    false (default): Additional properties are not allowed\n\n--minify\n    Minify generated schema (default: false)\n```\n\n## Current state\n\n-   `interface` types\n-   `enum` types\n-   `union`, `tuple`, `type[]` types\n-   `Date`, `RegExp` types\n-   `string`, `boolean`, `number` types\n-   `\"value\"`, `123`, `true`, `false`, `null`, `undefined` literals\n-   type aliases\n-   generics\n-   `typeof`\n-   `keyof`\n-   conditional types\n\n## Run locally\n\n`yarn --silent run run --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\n## Debug\n\n`yarn --silent run debug --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\nAnd connect via the debugger protocol.\n\n[AST Explorer](https://astexplorer.net/) is amazing for developers of this tool!\n\n## Publish\n\nPublishing is handled by a 2-branch [pre-release process](https://intuit.github.io/auto/docs/generated/shipit#next-branch-default), configured in `publish-auto.yml`. All changes should be based off the default `next` branch, and are published automatically.\n\n-   PRs made into the default branch are auto-deployed to the `next` pre-release tag on NPM. The result can be installed with `npm install ts-json-schema-generator@next`\n    -   When merging into `next`, please use the `squash and merge` strategy.\n-   To release a new stable version, open a PR from `next` into `stable` using this [compare link](https://github.com/vega/ts-json-schema-generator/compare/stable...next).\n    -   When merging from `next` into `stable`, please use the `create a merge commit` strategy.\n",
      "readmeFilename": "README.md",
      "gitHead": "243ee05753de48af4dcf679b3d6f23d43748fd55",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@1.1.0-next.3",
      "_nodeVersion": "16.15.0",
      "_npmVersion": "8.5.5",
      "dist": {
        "integrity": "sha512-Uh+3lwpeFM8n3UmV5fyCTvTzIcR5nCQSKp7qaTIQDjUuN6SMSeSF5Lg0dbL9Lb6DBnKYi+39fpZNFiPah/k7dA==",
        "shasum": "8b0885ce83fa82d44d2585a2bc96c34e12425e6f",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-1.1.0-next.3.tgz",
        "fileCount": 682,
        "unpackedSize": 790423,
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEYCIQC8RyY2bRKjXATaBwUoHkQgjtcYE9F6kDh9ql5rWioQqwIhALv86gSX1gACa5GncaPSNECHp+DuOcINNqd3bm9NTPxR"
          }
        ],
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJidWVdACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2VmoHOw/8DNmg4P/kh/uLm04BUYP+8fCillcmHRHtJPAuQnWR0ckbDhKB\r\ninFkCCFCLZnN0jLRSyaRLuHDc9/bxceO5YavTt4Wj15hmnNzr0kK4/Rey+40\r\nBG/4aXcr3zDAiGilekWfAfXmPmQa1Orw7lzWEnmlSCkcf1NTmd8AwRXMRAmM\r\n2lO6Q/IhHDtdDveo8CjbxSp+386vQDUlZhyKvNQFSfDtF7UPzfk30Cv0v4NX\r\nrZNivLNRUROMMA/OGLQSKesQfTWw/N3Fo4+HFIbhkA+I0Wjvo3BxHkjcTTfW\r\n8roOSiZH5y1oQ4vh0guhtt/saHBdOQakQNpzxarFYVrMQLeitip4sjOXepL7\r\nMx7MGm9FE8GGf3wjXD1v/hxzpcZIvy64el3XiLJuelhTivqrVjfKUCYd6Zsv\r\nJ6kNO+TQSSndPWkNhaVMmAmxrdWkwUej7n/gl+TKuOeaNLsIi9o9puFCeBUh\r\n0P/+7o9yIUVYEU2pxgTlOzYh9gMMTtv5R8xFlVsBOune4oMsr8hlV9BEjlZw\r\nJbO40hcMCGofYQvD0tfHx4QT9MSGxydXbIk4iXEb6vbIqFV00/JsBnJ3sWS3\r\nVN7HubBnV5eIawNEn3R6WgP3sZ1dRC61cMAAWr2HZJHc9I4bI9tDg3qKT8Vs\r\nr+ApJ9HAyLVU2Tp6fAafc2J8LyPwSZtntRk=\r\n=U2xR\r\n-----END PGP SIGNATURE-----\r\n"
      },
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "maintainers": [
        {
          "name": "jheer",
          "email": "jeffrey.heer@gmail.com"
        },
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "kanitw",
          "email": "kanitw@gmail.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_1.1.0-next.3_1651860829190_0.8369656079452312"
      },
      "_hasShrinkwrap": false
    },
    "1.1.0-next.4": {
      "name": "ts-json-schema-generator",
      "version": "1.1.0-next.4",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "MooYeol Prescott Lee",
          "email": "mooyoul@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=10.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.9",
        "commander": "^9.0.0",
        "glob": "^8.0.1",
        "json5": "^2.2.0",
        "normalize-path": "^3.0.0",
        "safe-stable-stringify": "^2.3.1",
        "typescript": "~4.6.2"
      },
      "devDependencies": {
        "@auto-it/conventional-commits": "^10.32.5",
        "@auto-it/first-time-contributor": "^10.32.5",
        "@babel/core": "^7.16.7",
        "@babel/preset-env": "^7.16.8",
        "@babel/preset-typescript": "^7.16.7",
        "@types/glob": "^7.2.0",
        "@types/jest": "^27.4.0",
        "@types/node": "^17.0.8",
        "@types/normalize-path": "^3.0.0",
        "@typescript-eslint/eslint-plugin": "^5.9.1",
        "@typescript-eslint/parser": "^5.9.1",
        "ajv": "^8.8.2",
        "ajv-formats": "^2.1.1",
        "auto": "^10.32.5",
        "chai": "^4.3.4",
        "cross-env": "^7.0.3",
        "eslint": "^8.6.0",
        "eslint-config-prettier": "^8.3.0",
        "eslint-plugin-prettier": "^4.0.0",
        "jest": "^28.0.3",
        "jest-junit": "^13.0.0",
        "prettier": "^2.5.1",
        "ts-node": "^10.4.0",
        "vega": "^5.21.0",
        "vega-lite": "^5.2.0"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint \"{src,test,factory}/**/*.ts\"",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "cross-env FAST_TEST=1 jest test/ --verbose",
        "test:coverage": "yarn jest test/ --collectCoverage=true",
        "test:update": "cross-env UPDATE_SCHEMA=true yarn test:fast",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node-transpile-only ts-json-schema-generator.ts",
        "release": "yarn build && auto shipit"
      },
      "readme": "# ts-json-schema-generator\n\n![Test](https://github.com/vega/ts-json-schema-generator/workflows/Test/badge.svg)\n[![codecov](https://codecov.io/gh/vega/ts-json-schema-generator/branch/master/graph/badge.svg)](https://codecov.io/gh/vega/ts-json-schema-generator)\n[![npm version](https://img.shields.io/npm/v/ts-json-schema-generator.svg)](https://www.npmjs.com/package/ts-json-schema-generator)\n\nExtended version of [https://github.com/xiag-ag/typescript-to-json-schema](https://github.com/xiag-ag/typescript-to-json-schema).\n\nInspired by [`YousefED/typescript-json-schema`](https://github.com/YousefED/typescript-json-schema). Here's the differences list:\n\n-   this implementation avoids the use of `typeChecker.getTypeAtLocation()` (so probably it keeps correct type aliases)\n-   processing AST and formatting JSON schema have been split into two independent steps\n-   not exported types, interfaces, enums are not exposed in the `definitions` section in the JSON schema\n\n## Contributors\n\nThis project is made possible by a [community of contributors](https://github.com/vega/ts-json-schema-generator/graphs/contributors). We welcome contributions of any kind (issues, code, documentation, examples, tests,...). Please read our [code of conduct](https://vega.github.io/vega/about/code-of-conduct).\n\n## CLI Usage\n\n```bash\nnpm install --save ts-json-schema-generator\n./node_modules/.bin/ts-json-schema-generator --path 'my/project/**/*.ts' --type 'My.Type.Name'\n```\n\nNote that different platforms (e.g. Windows) may use different path separators so you may have to adjust the command above.\n\n## Programmatic Usage\n\n```js\n// main.js\n\nconst tsj = require(\"ts-json-schema-generator\");\nconst fs = require(\"fs\");\n\n/** @type {import('ts-json-schema-generator/dist/src/Config').Config} */\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst output_path = \"path/to/output/file\";\n\nconst schema = tsj.createGenerator(config).createSchema(config.type);\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\nRun the schema generator via `node main.js`.\n\n### Custom formatting\n\nExtending the built-in formatting is possible by creating a custom formatter and adding it to the main formatter:\n\n1. First we create a formatter, in this case for formatting function types:\n\n```ts\n// my-function-formatter.ts\nimport { BaseType, Definition, FunctionType, SubTypeFormatter } from \"ts-json-schema-generator\";\nimport ts from \"typescript\";\n\nexport class MyFunctionTypeFormatter implements SubTypeFormatter {\n    // You can skip this line if you don't need childTypeFormatter\n    public constructor(private childTypeFormatter: TypeFormatter) {}\n\n    public supportsType(type: FunctionType): boolean {\n        return type instanceof FunctionType;\n    }\n\n    public getDefinition(type: FunctionType): Definition {\n        // Return a custom schema for the function property.\n        return {\n            type: \"object\",\n            properties: {\n                isFunction: {\n                    type: \"boolean\",\n                    const: true,\n                },\n            },\n        };\n    }\n\n    // If this type does NOT HAVE children, generally all you need is:\n    public getChildren(type: FunctionType): BaseType[] {\n        return [];\n    }\n\n    // However, if children ARE supported, you'll need something similar to\n    // this (see src/TypeFormatter/{Array,Definition,etc}.ts for some examples):\n    public getChildren(type: FunctionType): BaseType[] {\n        return this.childTypeFormatter.getChildren(type.getType());\n    }\n}\n```\n\n2. Then we add the formatter as a child to the core formatter using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyFunctionTypeFormatter } from \"./my-function-formatter.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\n// We configure the formatter an add our custom formatter to it.\nconst formatter = createFormatter(config, (fmt, circularReferenceTypeFormatter) => {\n    // If your formatter DOES NOT support children, e.g. getChildren() { return [] }:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter());\n    // If your formatter DOES support children, you'll need this reference too:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter(circularReferenceTypeFormatter));\n});\n\nconst program = createProgram(config);\nconst parser = createParser(program, config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n### Custom parsing\n\nSimilar to custom formatting, extending the built-in parsing works practically the same way:\n\n1. First we create a parser, in this case for parsing construct types:\n\n```ts\n// my-constructor-parser.ts\nimport { Context, StringType, ReferenceType, BaseType, SubNodeParser } from \"ts-json-schema-generator\";\nimport ts from \"typescript\";\n\nexport class MyConstructorParser implements SubNodeParser {\n    supportsNode(node: ts.Node): boolean {\n        return node.kind === ts.SyntaxKind.ConstructorType;\n    }\n    createType(node: ts.Node, context: Context, reference?: ReferenceType): BaseType | undefined {\n        return new StringType(); // Treat constructors as strings in this example\n    }\n}\n```\n\n2. Then we add the parser as a child to the core parser using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyConstructorParser } from \"./my-constructor-parser.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst program = createProgram(config);\n\n// We configure the parser an add our custom parser to it.\nconst parser = createParser(program, config, (prs) => {\n    prs.addNodeParser(new MyConstructorParser());\n});\n\nconst formatter = createFormatter(config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n## Options\n\n```\n-p, --path 'index.ts'\n    The path to the TypeScript source file. If this is not provided, the type will be searched in the project specified in the `.tsconfig`.\n\n-t, --type 'My.Type.Name'\n    The type the generated schema will represent. If omitted, the generated schema will contain all\n    types found in the files matching path. The same is true if '*' is specified.\n\n-i, --id 'generatedSchemaId'\n    The `$id` of the generated schema. If omitted, there will be no `$id`.\n\n-e, --expose <all|none|export>\n    all: Create shared $ref definitions for all types.\n    none: Do not create shared $ref definitions.\n    export (default): Create shared $ref definitions only for exported types (not tagged as `@internal`).\n\n-f, --tsconfig 'my/project/tsconfig.json'\n    Use a custom tsconfig file for processing typescript (see https://www.typescriptlang.org/docs/handbook/tsconfig-json.html) instead of the default:\n    {\n        \"compilerOptions\": {\n            \"noEmit\": true,\n            \"emitDecoratorMetadata\": true,\n            \"experimentalDecorators\": true,\n            \"target\": \"ES5\",\n            \"module\": \"CommonJS\",\n            \"strictNullChecks\": false,\n        }\n    }\n\n-j, --jsDoc <extended|none|basic>\n    none: Do not use JsDoc annotations.\n    basic: Read JsDoc annotations to provide schema properties.\n    extended (default): Also read @nullable, and @asType annotations.\n\n--unstable\n    Do not sort properties.\n\n--strict-tuples\n    Do not allow additional items on tuples.\n\n--no-top-ref\n    Do not create a top-level $ref definition.\n\n--no-type-check\n    Skip type checks for better performance.\n\n--no-ref-encode\n    Do not encode references. According to the standard, references must be valid URIs but some tools do not support encoded references.\n\n--validation-keywords\n    Provide additional validation keywords to include.\n\n-o, --out\n    Specify the output file path. Without this option, the generator logs the response in the console.\n\n--additional-properties <true|false>\n    Controls whether or not to allow additional properties for objects that have no index signature.\n\n    true: Additional properties are allowed\n    false (default): Additional properties are not allowed\n\n--minify\n    Minify generated schema (default: false)\n```\n\n## Current state\n\n-   `interface` types\n-   `enum` types\n-   `union`, `tuple`, `type[]` types\n-   `Date`, `RegExp` types\n-   `string`, `boolean`, `number` types\n-   `\"value\"`, `123`, `true`, `false`, `null`, `undefined` literals\n-   type aliases\n-   generics\n-   `typeof`\n-   `keyof`\n-   conditional types\n\n## Run locally\n\n`yarn --silent run run --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\n## Debug\n\n`yarn --silent run debug --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\nAnd connect via the debugger protocol.\n\n[AST Explorer](https://astexplorer.net/) is amazing for developers of this tool!\n\n## Publish\n\nPublishing is handled by a 2-branch [pre-release process](https://intuit.github.io/auto/docs/generated/shipit#next-branch-default), configured in `publish-auto.yml`. All changes should be based off the default `next` branch, and are published automatically.\n\n-   PRs made into the default branch are auto-deployed to the `next` pre-release tag on NPM. The result can be installed with `npm install ts-json-schema-generator@next`\n    -   When merging into `next`, please use the `squash and merge` strategy.\n-   To release a new stable version, open a PR from `next` into `stable` using this [compare link](https://github.com/vega/ts-json-schema-generator/compare/stable...next).\n    -   When merging from `next` into `stable`, please use the `create a merge commit` strategy.\n",
      "readmeFilename": "README.md",
      "gitHead": "42ce3b68aa7111539cf4934b2d94b83f08b56ad0",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@1.1.0-next.4",
      "_nodeVersion": "16.15.0",
      "_npmVersion": "8.5.5",
      "dist": {
        "integrity": "sha512-mBRw/yg8zhWguYKdfZyDH1+GFo83HWTplTell1aI/MPVA9bXBmLgW1qqECIinNH0bMCG1koDtKqrQD1jvT8V/w==",
        "shasum": "119835cb34ce3ca75376d2ac80ba94c2a176cc0b",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-1.1.0-next.4.tgz",
        "fileCount": 686,
        "unpackedSize": 796232,
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIQDvmd8ZnAt0RDoUSt65tDy0gcB3EmsbUBjuYQGi35nZTQIgRHoInHoIzXlIUZsWjtx/W8C6KByx6z84oxccrdUrfHk="
          }
        ],
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJijpMhACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2Vmr6AQ//bmIDsbIDghpdd8Kw1Sp40PsY8KQCueTG0qnqA8yqmo3LrvMU\r\nzMWjciViq3RYo3+P89lwcaqOEKysLPrfZVgxcwwG/7Au1lPgIQhsqQoA4Ma2\r\ngz3KjNPbAsdRycvbhHHMFlKa7RK348p++AO02e2RgGaI6YX2S1OOZEJfkaCJ\r\nDmdnA+epEZ8Gq5DL0qYBOT9rVqFLB4KyPpNq6Mn0SVgdlxRQ81nzUC8vIGi0\r\ny9BzXydXfwkXfcy/KVP/oM3I2prDUJGZI+fhsRfiIfNtCoHpxxrh3J3tLyID\r\nP7mx9Qnmr8vprEGpi5NKx4JZPsdnC01GTN+mVn/MInTye7BewlK/F4dlTA5Y\r\nM4tZWleiP+jDXXPPN7lNaMOnVQuvFtHJaSb6iJQ8Drv0ZNGOWGKzHacf88i5\r\nV/gtFSuUZUplVzhGlttw8igGF4mC9+qIIdN07EHbF9VNnvPazpOJRymptW7N\r\nT4hdFX/erEzgI5jlp5sIdhufH1oBJKu11LIVVe0dP9TzuTdoQ1FV4NGrX2Z3\r\nRjP525nFEfT3CaWuBl6dvJ40O9v6hAiWaE6xf//M0wIDV40u++h5vsJx7EIV\r\nepy5Eyz6Y/A9lRYsgatQo48EvbI48WUfRGPz+xb48I2fzIfp/NIVdsvZf5bd\r\ntGFBUdewQ+98e4vkvT5hH2c1nbObq3fp6mQ=\r\n=s/Lb\r\n-----END PGP SIGNATURE-----\r\n"
      },
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "maintainers": [
        {
          "name": "jheer",
          "email": "jeffrey.heer@gmail.com"
        },
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "kanitw",
          "email": "kanitw@gmail.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_1.1.0-next.4_1653510944824_0.04115541540761969"
      },
      "_hasShrinkwrap": false
    },
    "1.1.0-next.5": {
      "name": "ts-json-schema-generator",
      "version": "1.1.0-next.5",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "MooYeol Prescott Lee",
          "email": "mooyoul@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=10.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.9",
        "commander": "^9.0.0",
        "glob": "^8.0.1",
        "json5": "^2.2.0",
        "normalize-path": "^3.0.0",
        "safe-stable-stringify": "^2.3.1",
        "typescript": "~4.6.2"
      },
      "devDependencies": {
        "@auto-it/conventional-commits": "^10.32.5",
        "@auto-it/first-time-contributor": "^10.32.5",
        "@babel/core": "^7.16.7",
        "@babel/preset-env": "^7.16.8",
        "@babel/preset-typescript": "^7.16.7",
        "@types/glob": "^7.2.0",
        "@types/jest": "^27.4.0",
        "@types/node": "^17.0.8",
        "@types/normalize-path": "^3.0.0",
        "@typescript-eslint/eslint-plugin": "^5.9.1",
        "@typescript-eslint/parser": "^5.9.1",
        "ajv": "^8.8.2",
        "ajv-formats": "^2.1.1",
        "auto": "^10.32.5",
        "chai": "^4.3.4",
        "cross-env": "^7.0.3",
        "eslint": "^8.6.0",
        "eslint-config-prettier": "^8.3.0",
        "eslint-plugin-prettier": "^4.0.0",
        "jest": "^28.0.3",
        "jest-junit": "^13.0.0",
        "prettier": "^2.5.1",
        "ts-node": "^10.4.0",
        "vega": "^5.21.0",
        "vega-lite": "^5.2.0"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint \"{src,test,factory}/**/*.ts\"",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "cross-env FAST_TEST=1 jest test/ --verbose",
        "test:coverage": "yarn jest test/ --collectCoverage=true",
        "test:update": "cross-env UPDATE_SCHEMA=true yarn test:fast",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node-transpile-only ts-json-schema-generator.ts",
        "release": "yarn build && auto shipit"
      },
      "readme": "# ts-json-schema-generator\n\n![Test](https://github.com/vega/ts-json-schema-generator/workflows/Test/badge.svg)\n[![codecov](https://codecov.io/gh/vega/ts-json-schema-generator/branch/master/graph/badge.svg)](https://codecov.io/gh/vega/ts-json-schema-generator)\n[![npm version](https://img.shields.io/npm/v/ts-json-schema-generator.svg)](https://www.npmjs.com/package/ts-json-schema-generator)\n\nExtended version of [https://github.com/xiag-ag/typescript-to-json-schema](https://github.com/xiag-ag/typescript-to-json-schema).\n\nInspired by [`YousefED/typescript-json-schema`](https://github.com/YousefED/typescript-json-schema). Here's the differences list:\n\n-   this implementation avoids the use of `typeChecker.getTypeAtLocation()` (so probably it keeps correct type aliases)\n-   processing AST and formatting JSON schema have been split into two independent steps\n-   not exported types, interfaces, enums are not exposed in the `definitions` section in the JSON schema\n\n## Contributors\n\nThis project is made possible by a [community of contributors](https://github.com/vega/ts-json-schema-generator/graphs/contributors). We welcome contributions of any kind (issues, code, documentation, examples, tests,...). Please read our [code of conduct](https://vega.github.io/vega/about/code-of-conduct).\n\n## CLI Usage\n\n```bash\nnpm install --save ts-json-schema-generator\n./node_modules/.bin/ts-json-schema-generator --path 'my/project/**/*.ts' --type 'My.Type.Name'\n```\n\nNote that different platforms (e.g. Windows) may use different path separators so you may have to adjust the command above.\n\n## Programmatic Usage\n\n```js\n// main.js\n\nconst tsj = require(\"ts-json-schema-generator\");\nconst fs = require(\"fs\");\n\n/** @type {import('ts-json-schema-generator/dist/src/Config').Config} */\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst output_path = \"path/to/output/file\";\n\nconst schema = tsj.createGenerator(config).createSchema(config.type);\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\nRun the schema generator via `node main.js`.\n\n### Custom formatting\n\nExtending the built-in formatting is possible by creating a custom formatter and adding it to the main formatter:\n\n1. First we create a formatter, in this case for formatting function types:\n\n```ts\n// my-function-formatter.ts\nimport { BaseType, Definition, FunctionType, SubTypeFormatter } from \"ts-json-schema-generator\";\nimport ts from \"typescript\";\n\nexport class MyFunctionTypeFormatter implements SubTypeFormatter {\n    // You can skip this line if you don't need childTypeFormatter\n    public constructor(private childTypeFormatter: TypeFormatter) {}\n\n    public supportsType(type: FunctionType): boolean {\n        return type instanceof FunctionType;\n    }\n\n    public getDefinition(type: FunctionType): Definition {\n        // Return a custom schema for the function property.\n        return {\n            type: \"object\",\n            properties: {\n                isFunction: {\n                    type: \"boolean\",\n                    const: true,\n                },\n            },\n        };\n    }\n\n    // If this type does NOT HAVE children, generally all you need is:\n    public getChildren(type: FunctionType): BaseType[] {\n        return [];\n    }\n\n    // However, if children ARE supported, you'll need something similar to\n    // this (see src/TypeFormatter/{Array,Definition,etc}.ts for some examples):\n    public getChildren(type: FunctionType): BaseType[] {\n        return this.childTypeFormatter.getChildren(type.getType());\n    }\n}\n```\n\n2. Then we add the formatter as a child to the core formatter using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyFunctionTypeFormatter } from \"./my-function-formatter.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\n// We configure the formatter an add our custom formatter to it.\nconst formatter = createFormatter(config, (fmt, circularReferenceTypeFormatter) => {\n    // If your formatter DOES NOT support children, e.g. getChildren() { return [] }:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter());\n    // If your formatter DOES support children, you'll need this reference too:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter(circularReferenceTypeFormatter));\n});\n\nconst program = createProgram(config);\nconst parser = createParser(program, config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n### Custom parsing\n\nSimilar to custom formatting, extending the built-in parsing works practically the same way:\n\n1. First we create a parser, in this case for parsing construct types:\n\n```ts\n// my-constructor-parser.ts\nimport { Context, StringType, ReferenceType, BaseType, SubNodeParser } from \"ts-json-schema-generator\";\nimport ts from \"typescript\";\n\nexport class MyConstructorParser implements SubNodeParser {\n    supportsNode(node: ts.Node): boolean {\n        return node.kind === ts.SyntaxKind.ConstructorType;\n    }\n    createType(node: ts.Node, context: Context, reference?: ReferenceType): BaseType | undefined {\n        return new StringType(); // Treat constructors as strings in this example\n    }\n}\n```\n\n2. Then we add the parser as a child to the core parser using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyConstructorParser } from \"./my-constructor-parser.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst program = createProgram(config);\n\n// We configure the parser an add our custom parser to it.\nconst parser = createParser(program, config, (prs) => {\n    prs.addNodeParser(new MyConstructorParser());\n});\n\nconst formatter = createFormatter(config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n## Options\n\n```\n-p, --path 'index.ts'\n    The path to the TypeScript source file. If this is not provided, the type will be searched in the project specified in the `.tsconfig`.\n\n-t, --type 'My.Type.Name'\n    The type the generated schema will represent. If omitted, the generated schema will contain all\n    types found in the files matching path. The same is true if '*' is specified.\n\n-i, --id 'generatedSchemaId'\n    The `$id` of the generated schema. If omitted, there will be no `$id`.\n\n-e, --expose <all|none|export>\n    all: Create shared $ref definitions for all types.\n    none: Do not create shared $ref definitions.\n    export (default): Create shared $ref definitions only for exported types (not tagged as `@internal`).\n\n-f, --tsconfig 'my/project/tsconfig.json'\n    Use a custom tsconfig file for processing typescript (see https://www.typescriptlang.org/docs/handbook/tsconfig-json.html) instead of the default:\n    {\n        \"compilerOptions\": {\n            \"noEmit\": true,\n            \"emitDecoratorMetadata\": true,\n            \"experimentalDecorators\": true,\n            \"target\": \"ES5\",\n            \"module\": \"CommonJS\",\n            \"strictNullChecks\": false,\n        }\n    }\n\n-j, --jsDoc <extended|none|basic>\n    none: Do not use JsDoc annotations.\n    basic: Read JsDoc annotations to provide schema properties.\n    extended (default): Also read @nullable, and @asType annotations.\n\n--unstable\n    Do not sort properties.\n\n--strict-tuples\n    Do not allow additional items on tuples.\n\n--no-top-ref\n    Do not create a top-level $ref definition.\n\n--no-type-check\n    Skip type checks for better performance.\n\n--no-ref-encode\n    Do not encode references. According to the standard, references must be valid URIs but some tools do not support encoded references.\n\n--validation-keywords\n    Provide additional validation keywords to include.\n\n-o, --out\n    Specify the output file path. Without this option, the generator logs the response in the console.\n\n--additional-properties <true|false>\n    Controls whether or not to allow additional properties for objects that have no index signature.\n\n    true: Additional properties are allowed\n    false (default): Additional properties are not allowed\n\n--minify\n    Minify generated schema (default: false)\n```\n\n## Current state\n\n-   `interface` types\n-   `enum` types\n-   `union`, `tuple`, `type[]` types\n-   `Date`, `RegExp` types\n-   `string`, `boolean`, `number` types\n-   `\"value\"`, `123`, `true`, `false`, `null`, `undefined` literals\n-   type aliases\n-   generics\n-   `typeof`\n-   `keyof`\n-   conditional types\n\n## Run locally\n\n`yarn --silent run run --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\n## Debug\n\n`yarn --silent run debug --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\nAnd connect via the debugger protocol.\n\n[AST Explorer](https://astexplorer.net/) is amazing for developers of this tool!\n\n## Publish\n\nPublishing is handled by a 2-branch [pre-release process](https://intuit.github.io/auto/docs/generated/shipit#next-branch-default), configured in `publish-auto.yml`. All changes should be based off the default `next` branch, and are published automatically.\n\n-   PRs made into the default branch are auto-deployed to the `next` pre-release tag on NPM. The result can be installed with `npm install ts-json-schema-generator@next`\n    -   When merging into `next`, please use the `squash and merge` strategy.\n-   To release a new stable version, open a PR from `next` into `stable` using this [compare link](https://github.com/vega/ts-json-schema-generator/compare/stable...next).\n    -   When merging from `next` into `stable`, please use the `create a merge commit` strategy.\n",
      "readmeFilename": "README.md",
      "gitHead": "0b04c7dccad565bdbd75524608798d03ceb21433",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@1.1.0-next.5",
      "_nodeVersion": "16.15.0",
      "_npmVersion": "8.5.5",
      "dist": {
        "integrity": "sha512-XXJ3/vznoxnLRh8+je8RyDSQZLHoqhbYm8au0LEQL0ieM1XrieGy8sTCbAyLSZp+S39L6CA3qr1zjd12kJkNrA==",
        "shasum": "25562adfd0d4b914fce978190f91ba55abba0d09",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-1.1.0-next.5.tgz",
        "fileCount": 686,
        "unpackedSize": 797397,
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIB/QUoeN0PNfbCWv+jVU/acv2c3I0rp2NmraJm1s4KZtAiEA2fUD3va2B79BkvmsxPBfRTAj54L/BvvKVSf4kIO+N2o="
          }
        ],
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJij4RzACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2Vmo4sw/7BAGREefo5Pq1eHmOQWh7KCJJZYArGBKYQT6dPvH1R/ZdmBOb\r\nn46JRVIsat4LPLfd3qE0JUIPUvEIflVSPMK7/GDfyZDXCfefzNmxAeJ5Noq0\r\njlD4PvzuHvgrrZbVMKTQDEQBpUbbYzhMwPL2ka9ZkpoqWzYm64ufy4F9Sgda\r\nb3L+mySG8IB1aNRilrAnhuwORUNvki+8bSaKW8PPJRAJ6gMCKOZJwpaMY421\r\nxUjhS7cNM3FAsRsDwe9pgB3PpzA46GqZKo/VEz+eWkNYx2C5cTMVD88ozdey\r\nukTBjJn5X19piYghawkJyE+SA/m3OBZoGPa/c/JXxneMF/s4fNJxvkgyIXZv\r\nYqmUf81wF9IE+Qc3sxrOgv4PJucRlomNXmJroAUovAZKm5IlYkJD9SL8BPfE\r\nNGbOekAvSdv0oeABd13agiTgFh/vdrx5y/x7Dq0qSOCOnPW4nCLHnZVaRjO4\r\nP75Ar2yg204UYN6lR/9DNrRkeONRZTU/uaEq8aR9TV/R+4JpopxVbmRhZ91g\r\n2EsI51GYDi2WNXyKHr9fg75NVX7SYm2kV9BJ0dNC+3G5tGIj2JxHr46ADzst\r\nr4onZVzHuy/Zlg5DGjZ9shNrFj5cRmH8IAI3IamIKXio95cvqqDetyNRcwB9\r\n8BxfF1IV+fi4I08MyFxq8sIHV7vo7cczxdY=\r\n=JhJy\r\n-----END PGP SIGNATURE-----\r\n"
      },
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "maintainers": [
        {
          "name": "jheer",
          "email": "jeffrey.heer@gmail.com"
        },
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "kanitw",
          "email": "kanitw@gmail.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_1.1.0-next.5_1653572722965_0.18949596432804694"
      },
      "_hasShrinkwrap": false
    },
    "1.0.1--canary.858e8cf.0": {
      "name": "ts-json-schema-generator",
      "version": "1.0.1--canary.858e8cf.0",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "MooYeol Prescott Lee",
          "email": "mooyoul@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=10.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.11",
        "commander": "^9.4.0",
        "glob": "^8.0.3",
        "json5": "^2.2.1",
        "normalize-path": "^3.0.0",
        "safe-stable-stringify": "^2.4.0",
        "typescript": "~4.8.3"
      },
      "devDependencies": {
        "@auto-it/conventional-commits": "^10.37.6",
        "@auto-it/first-time-contributor": "^10.37.6",
        "@babel/core": "^7.19.1",
        "@babel/preset-env": "^7.19.1",
        "@babel/preset-typescript": "^7.18.6",
        "@types/glob": "^8.0.0",
        "@types/jest": "^29.0.3",
        "@types/node": "^18.7.18",
        "@types/normalize-path": "^3.0.0",
        "@typescript-eslint/eslint-plugin": "^5.38.0",
        "@typescript-eslint/parser": "^5.38.0",
        "ajv": "^8.11.0",
        "ajv-formats": "^2.1.1",
        "auto": "^10.37.6",
        "chai": "^4.3.6",
        "cross-env": "^7.0.3",
        "eslint": "^8.23.1",
        "eslint-config-prettier": "^8.5.0",
        "eslint-plugin-prettier": "^4.2.1",
        "jest": "^29.0.3",
        "jest-junit": "^14.0.1",
        "prettier": "^2.7.1",
        "ts-node": "^10.9.1",
        "vega": "^5.22.1",
        "vega-lite": "^5.5.0"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint \"{src,test,factory}/**/*.ts\"",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "cross-env FAST_TEST=1 jest test/ --verbose",
        "test:coverage": "yarn jest test/ --collectCoverage=true",
        "test:update": "cross-env UPDATE_SCHEMA=true yarn test:fast",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node-transpile-only ts-json-schema-generator.ts",
        "release": "yarn build && auto shipit"
      },
      "readme": "# ts-json-schema-generator\n\n![Test](https://github.com/vega/ts-json-schema-generator/workflows/Test/badge.svg)\n[![codecov](https://codecov.io/gh/vega/ts-json-schema-generator/branch/master/graph/badge.svg)](https://codecov.io/gh/vega/ts-json-schema-generator)\n[![npm version](https://img.shields.io/npm/v/ts-json-schema-generator.svg)](https://www.npmjs.com/package/ts-json-schema-generator)\n\nExtended version of [https://github.com/xiag-ag/typescript-to-json-schema](https://github.com/xiag-ag/typescript-to-json-schema).\n\nInspired by [`YousefED/typescript-json-schema`](https://github.com/YousefED/typescript-json-schema). Here's the differences list:\n\n-   this implementation avoids the use of `typeChecker.getTypeAtLocation()` (so probably it keeps correct type aliases)\n-   processing AST and formatting JSON schema have been split into two independent steps\n-   not exported types, interfaces, enums are not exposed in the `definitions` section in the JSON schema\n\n## Contributors\n\nThis project is made possible by a [community of contributors](https://github.com/vega/ts-json-schema-generator/graphs/contributors). We welcome contributions of any kind (issues, code, documentation, examples, tests,...). Please read our [code of conduct](https://vega.github.io/vega/about/code-of-conduct).\n\n## CLI Usage\n\n```bash\nnpm install --save ts-json-schema-generator\n./node_modules/.bin/ts-json-schema-generator --path 'my/project/**/*.ts' --type 'My.Type.Name'\n```\n\nNote that different platforms (e.g. Windows) may use different path separators so you may have to adjust the command above.\n\n## Programmatic Usage\n\n```js\n// main.js\n\nconst tsj = require(\"ts-json-schema-generator\");\nconst fs = require(\"fs\");\n\n/** @type {import('ts-json-schema-generator/dist/src/Config').Config} */\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst output_path = \"path/to/output/file\";\n\nconst schema = tsj.createGenerator(config).createSchema(config.type);\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\nRun the schema generator via `node main.js`.\n\n### Custom formatting\n\nExtending the built-in formatting is possible by creating a custom formatter and adding it to the main formatter:\n\n1. First we create a formatter, in this case for formatting function types:\n\n```ts\n// my-function-formatter.ts\nimport { BaseType, Definition, FunctionType, SubTypeFormatter } from \"ts-json-schema-generator\";\nimport ts from \"typescript\";\n\nexport class MyFunctionTypeFormatter implements SubTypeFormatter {\n    // You can skip this line if you don't need childTypeFormatter\n    public constructor(private childTypeFormatter: TypeFormatter) {}\n\n    public supportsType(type: FunctionType): boolean {\n        return type instanceof FunctionType;\n    }\n\n    public getDefinition(type: FunctionType): Definition {\n        // Return a custom schema for the function property.\n        return {\n            type: \"object\",\n            properties: {\n                isFunction: {\n                    type: \"boolean\",\n                    const: true,\n                },\n            },\n        };\n    }\n\n    // If this type does NOT HAVE children, generally all you need is:\n    public getChildren(type: FunctionType): BaseType[] {\n        return [];\n    }\n\n    // However, if children ARE supported, you'll need something similar to\n    // this (see src/TypeFormatter/{Array,Definition,etc}.ts for some examples):\n    public getChildren(type: FunctionType): BaseType[] {\n        return this.childTypeFormatter.getChildren(type.getType());\n    }\n}\n```\n\n2. Then we add the formatter as a child to the core formatter using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyFunctionTypeFormatter } from \"./my-function-formatter.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\n// We configure the formatter an add our custom formatter to it.\nconst formatter = createFormatter(config, (fmt, circularReferenceTypeFormatter) => {\n    // If your formatter DOES NOT support children, e.g. getChildren() { return [] }:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter());\n    // If your formatter DOES support children, you'll need this reference too:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter(circularReferenceTypeFormatter));\n});\n\nconst program = createProgram(config);\nconst parser = createParser(program, config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n### Custom parsing\n\nSimilar to custom formatting, extending the built-in parsing works practically the same way:\n\n1. First we create a parser, in this case for parsing construct types:\n\n```ts\n// my-constructor-parser.ts\nimport { Context, StringType, ReferenceType, BaseType, SubNodeParser } from \"ts-json-schema-generator\";\n// use typescript exported by TJS to avoid version conflict\nimport ts from \"ts-json-schema-generator\";\n\nexport class MyConstructorParser implements SubNodeParser {\n    supportsNode(node: ts.Node): boolean {\n        return node.kind === ts.SyntaxKind.ConstructorType;\n    }\n    createType(node: ts.Node, context: Context, reference?: ReferenceType): BaseType | undefined {\n        return new StringType(); // Treat constructors as strings in this example\n    }\n}\n```\n\n2. Then we add the parser as a child to the core parser using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyConstructorParser } from \"./my-constructor-parser.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst program = createProgram(config);\n\n// We configure the parser an add our custom parser to it.\nconst parser = createParser(program, config, (prs) => {\n    prs.addNodeParser(new MyConstructorParser());\n});\n\nconst formatter = createFormatter(config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n## Options\n\n```\n-p, --path 'index.ts'\n    The path to the TypeScript source file. If this is not provided, the type will be searched in the project specified in the `.tsconfig`.\n\n-t, --type 'My.Type.Name'\n    The type the generated schema will represent. If omitted, the generated schema will contain all\n    types found in the files matching path. The same is true if '*' is specified.\n\n-i, --id 'generatedSchemaId'\n    The `$id` of the generated schema. If omitted, there will be no `$id`.\n\n-e, --expose <all|none|export>\n    all: Create shared $ref definitions for all types.\n    none: Do not create shared $ref definitions.\n    export (default): Create shared $ref definitions only for exported types (not tagged as `@internal`).\n\n-f, --tsconfig 'my/project/tsconfig.json'\n    Use a custom tsconfig file for processing typescript (see https://www.typescriptlang.org/docs/handbook/tsconfig-json.html) instead of the default:\n    {\n        \"compilerOptions\": {\n            \"noEmit\": true,\n            \"emitDecoratorMetadata\": true,\n            \"experimentalDecorators\": true,\n            \"target\": \"ES5\",\n            \"module\": \"CommonJS\",\n            \"strictNullChecks\": false,\n        }\n    }\n\n-j, --jsDoc <extended|none|basic>\n    none: Do not use JsDoc annotations.\n    basic: Read JsDoc annotations to provide schema properties.\n    extended (default): Also read @nullable, and @asType annotations.\n\n--unstable\n    Do not sort properties.\n\n--strict-tuples\n    Do not allow additional items on tuples.\n\n--no-top-ref\n    Do not create a top-level $ref definition.\n\n--no-type-check\n    Skip type checks for better performance.\n\n--no-ref-encode\n    Do not encode references. According to the standard, references must be valid URIs but some tools do not support encoded references.\n\n--validation-keywords\n    Provide additional validation keywords to include.\n\n-o, --out\n    Specify the output file path. Without this option, the generator logs the response in the console.\n\n--additional-properties <true|false>\n    Controls whether or not to allow additional properties for objects that have no index signature.\n\n    true: Additional properties are allowed\n    false (default): Additional properties are not allowed\n\n--minify\n    Minify generated schema (default: false)\n```\n\n## Current state\n\n-   `interface` types\n-   `enum` types\n-   `union`, `tuple`, `type[]` types\n-   `Date`, `RegExp` types\n-   `string`, `boolean`, `number` types\n-   `\"value\"`, `123`, `true`, `false`, `null`, `undefined` literals\n-   type aliases\n-   generics\n-   `typeof`\n-   `keyof`\n-   conditional types\n\n## Run locally\n\n`yarn --silent run run --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\n## Debug\n\n`yarn --silent run debug --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\nAnd connect via the debugger protocol.\n\n[AST Explorer](https://astexplorer.net/) is amazing for developers of this tool!\n\n## Publish\n\nPublishing is handled by a 2-branch [pre-release process](https://intuit.github.io/auto/docs/generated/shipit#next-branch-default), configured in `publish-auto.yml`. All changes should be based off the default `next` branch, and are published automatically.\n\n-   PRs made into the default branch are auto-deployed to the `next` pre-release tag on NPM. The result can be installed with `npm install ts-json-schema-generator@next`\n    -   When merging into `next`, please use the `squash and merge` strategy.\n-   To release a new stable version, open a PR from `next` into `stable` using this [compare link](https://github.com/vega/ts-json-schema-generator/compare/stable...next).\n    -   When merging from `next` into `stable`, please use the `create a merge commit` strategy.\n",
      "readmeFilename": "README.md",
      "gitHead": "858e8cf46b8ce24eb591c60087c205082370720d",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@1.0.1--canary.858e8cf.0",
      "_nodeVersion": "16.17.0",
      "_npmVersion": "8.15.0",
      "dist": {
        "integrity": "sha512-+ZbSVlwI7JyVQjtYZf8pioUL5klsWT1Oi5pUd9Pm+1t4n0lEDqGgRPAr+JTeuO0FTNeKIsCa+Ji3qf0MLNo7IQ==",
        "shasum": "72a89447199dea7d090678336b72db282b586c8f",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-1.0.1--canary.858e8cf.0.tgz",
        "fileCount": 700,
        "unpackedSize": 851497,
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEYCIQDSFy43jlKlSLuikhRjYA7IzerW26rxKBGbcIDa6uUz8wIhAMqOwSRQpAXL5cumMDuvmcC9baUwvz4SnkHGJuIs83IY"
          }
        ],
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJjKmwhACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2VmpGZA/9ENsGoepBtKdo5IsXriGST+tKBE9LakrxLxSkD05rLYbyti90\r\nXffxAYVVZ49JuuHOpmoXpa9qiNHson1xCh0EsepPiEAOTT5mUVVvTHknaTDd\r\nUXtJNGSbyklGNvYvFSBNS9oK3HvHYzOb3apoVeuS0HL3ltIf1M374FcZoRbo\r\nM3QPi9oQCPi24p7dzZVZbpQvClob1K1PryzAoXkZTo9sdkLDqdcVEUeUbMIA\r\nsWJDUp6AkxAguz+XjgxCvyk0D+32lKIOofZhNUXHTUiZK5SNhD+C3W+ANHeK\r\nk+AqzG+hRDEzgkRd8Wb+xnt00L38a2b9wEzGApxaWJE8V87kBfLsJ3wi0M7x\r\nZ72/Qi7zFJsL5MCCds3TW9uuOMzS2TBSqy1Hx4PAZ1PeYICh0srTYb9s1d84\r\n6KlIpJb35hZoZ55gfTilPuD0Rs6dAMAhBNEUAmwfwlm58FkSQLLcScQ2e7eu\r\ntQ2iEXCUsQIj6s6tvlyb1T60n86jBueriUZvoVk8z7Zg8X7rmWWjRj7Nuwni\r\n1bjAIti6jbGfhZJeOqYoGVyfAAzUgv7KSvJwPrRdmZSs46yTfXCInx6V/1OW\r\nhD2bUjiE8Ybe4NC8IwuIOG+o8E1pSi3Lku4CXZ1Crvlu5/tMe7EoCYQDZDbM\r\nYHAeoVVaOul0wJuKIrCWsSpZU9aR3mAZfJ8=\r\n=m7uS\r\n-----END PGP SIGNATURE-----\r\n"
      },
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "maintainers": [
        {
          "name": "jheer",
          "email": "jeffrey.heer@gmail.com"
        },
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "kanitw",
          "email": "kanitw@gmail.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_1.0.1--canary.858e8cf.0_1663724577037_0.29085912437088335"
      },
      "_hasShrinkwrap": false
    },
    "1.1.0-next.6": {
      "name": "ts-json-schema-generator",
      "version": "1.1.0-next.6",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "MooYeol Prescott Lee",
          "email": "mooyoul@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=10.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.11",
        "commander": "^9.4.0",
        "glob": "^8.0.3",
        "json5": "^2.2.1",
        "normalize-path": "^3.0.0",
        "safe-stable-stringify": "^2.4.0",
        "typescript": "~4.8.3"
      },
      "devDependencies": {
        "@auto-it/conventional-commits": "^10.37.6",
        "@auto-it/first-time-contributor": "^10.37.6",
        "@babel/core": "^7.19.1",
        "@babel/preset-env": "^7.19.1",
        "@babel/preset-typescript": "^7.18.6",
        "@types/glob": "^8.0.0",
        "@types/jest": "^29.0.3",
        "@types/node": "^18.7.18",
        "@types/normalize-path": "^3.0.0",
        "@typescript-eslint/eslint-plugin": "^5.38.0",
        "@typescript-eslint/parser": "^5.38.0",
        "ajv": "^8.11.0",
        "ajv-formats": "^2.1.1",
        "auto": "^10.37.6",
        "chai": "^4.3.6",
        "cross-env": "^7.0.3",
        "eslint": "^8.23.1",
        "eslint-config-prettier": "^8.5.0",
        "eslint-plugin-prettier": "^4.2.1",
        "jest": "^29.0.3",
        "jest-junit": "^14.0.1",
        "prettier": "^2.7.1",
        "ts-node": "^10.9.1",
        "vega": "^5.22.1",
        "vega-lite": "^5.5.0"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint \"{src,test,factory}/**/*.ts\"",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "cross-env FAST_TEST=1 jest test/ --verbose",
        "test:coverage": "yarn jest test/ --collectCoverage=true",
        "test:update": "cross-env UPDATE_SCHEMA=true yarn test:fast",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node-transpile-only ts-json-schema-generator.ts",
        "release": "yarn build && auto shipit"
      },
      "readme": "# ts-json-schema-generator\n\n![Test](https://github.com/vega/ts-json-schema-generator/workflows/Test/badge.svg)\n[![codecov](https://codecov.io/gh/vega/ts-json-schema-generator/branch/master/graph/badge.svg)](https://codecov.io/gh/vega/ts-json-schema-generator)\n[![npm version](https://img.shields.io/npm/v/ts-json-schema-generator.svg)](https://www.npmjs.com/package/ts-json-schema-generator)\n\nExtended version of [https://github.com/xiag-ag/typescript-to-json-schema](https://github.com/xiag-ag/typescript-to-json-schema).\n\nInspired by [`YousefED/typescript-json-schema`](https://github.com/YousefED/typescript-json-schema). Here's the differences list:\n\n-   this implementation avoids the use of `typeChecker.getTypeAtLocation()` (so probably it keeps correct type aliases)\n-   processing AST and formatting JSON schema have been split into two independent steps\n-   not exported types, interfaces, enums are not exposed in the `definitions` section in the JSON schema\n\n## Contributors\n\nThis project is made possible by a [community of contributors](https://github.com/vega/ts-json-schema-generator/graphs/contributors). We welcome contributions of any kind (issues, code, documentation, examples, tests,...). Please read our [code of conduct](https://vega.github.io/vega/about/code-of-conduct).\n\n## CLI Usage\n\n```bash\nnpm install --save ts-json-schema-generator\n./node_modules/.bin/ts-json-schema-generator --path 'my/project/**/*.ts' --type 'My.Type.Name'\n```\n\nNote that different platforms (e.g. Windows) may use different path separators so you may have to adjust the command above.\n\n## Programmatic Usage\n\n```js\n// main.js\n\nconst tsj = require(\"ts-json-schema-generator\");\nconst fs = require(\"fs\");\n\n/** @type {import('ts-json-schema-generator/dist/src/Config').Config} */\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst output_path = \"path/to/output/file\";\n\nconst schema = tsj.createGenerator(config).createSchema(config.type);\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\nRun the schema generator via `node main.js`.\n\n### Custom formatting\n\nExtending the built-in formatting is possible by creating a custom formatter and adding it to the main formatter:\n\n1. First we create a formatter, in this case for formatting function types:\n\n```ts\n// my-function-formatter.ts\nimport { BaseType, Definition, FunctionType, SubTypeFormatter } from \"ts-json-schema-generator\";\nimport ts from \"typescript\";\n\nexport class MyFunctionTypeFormatter implements SubTypeFormatter {\n    // You can skip this line if you don't need childTypeFormatter\n    public constructor(private childTypeFormatter: TypeFormatter) {}\n\n    public supportsType(type: FunctionType): boolean {\n        return type instanceof FunctionType;\n    }\n\n    public getDefinition(type: FunctionType): Definition {\n        // Return a custom schema for the function property.\n        return {\n            type: \"object\",\n            properties: {\n                isFunction: {\n                    type: \"boolean\",\n                    const: true,\n                },\n            },\n        };\n    }\n\n    // If this type does NOT HAVE children, generally all you need is:\n    public getChildren(type: FunctionType): BaseType[] {\n        return [];\n    }\n\n    // However, if children ARE supported, you'll need something similar to\n    // this (see src/TypeFormatter/{Array,Definition,etc}.ts for some examples):\n    public getChildren(type: FunctionType): BaseType[] {\n        return this.childTypeFormatter.getChildren(type.getType());\n    }\n}\n```\n\n2. Then we add the formatter as a child to the core formatter using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyFunctionTypeFormatter } from \"./my-function-formatter.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\n// We configure the formatter an add our custom formatter to it.\nconst formatter = createFormatter(config, (fmt, circularReferenceTypeFormatter) => {\n    // If your formatter DOES NOT support children, e.g. getChildren() { return [] }:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter());\n    // If your formatter DOES support children, you'll need this reference too:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter(circularReferenceTypeFormatter));\n});\n\nconst program = createProgram(config);\nconst parser = createParser(program, config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n### Custom parsing\n\nSimilar to custom formatting, extending the built-in parsing works practically the same way:\n\n1. First we create a parser, in this case for parsing construct types:\n\n```ts\n// my-constructor-parser.ts\nimport { Context, StringType, ReferenceType, BaseType, SubNodeParser } from \"ts-json-schema-generator\";\n// use typescript exported by TJS to avoid version conflict\nimport ts from \"ts-json-schema-generator\";\n\nexport class MyConstructorParser implements SubNodeParser {\n    supportsNode(node: ts.Node): boolean {\n        return node.kind === ts.SyntaxKind.ConstructorType;\n    }\n    createType(node: ts.Node, context: Context, reference?: ReferenceType): BaseType | undefined {\n        return new StringType(); // Treat constructors as strings in this example\n    }\n}\n```\n\n2. Then we add the parser as a child to the core parser using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyConstructorParser } from \"./my-constructor-parser.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst program = createProgram(config);\n\n// We configure the parser an add our custom parser to it.\nconst parser = createParser(program, config, (prs) => {\n    prs.addNodeParser(new MyConstructorParser());\n});\n\nconst formatter = createFormatter(config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n## Options\n\n```\n-p, --path 'index.ts'\n    The path to the TypeScript source file. If this is not provided, the type will be searched in the project specified in the `.tsconfig`.\n\n-t, --type 'My.Type.Name'\n    The type the generated schema will represent. If omitted, the generated schema will contain all\n    types found in the files matching path. The same is true if '*' is specified.\n\n-i, --id 'generatedSchemaId'\n    The `$id` of the generated schema. If omitted, there will be no `$id`.\n\n-e, --expose <all|none|export>\n    all: Create shared $ref definitions for all types.\n    none: Do not create shared $ref definitions.\n    export (default): Create shared $ref definitions only for exported types (not tagged as `@internal`).\n\n-f, --tsconfig 'my/project/tsconfig.json'\n    Use a custom tsconfig file for processing typescript (see https://www.typescriptlang.org/docs/handbook/tsconfig-json.html) instead of the default:\n    {\n        \"compilerOptions\": {\n            \"noEmit\": true,\n            \"emitDecoratorMetadata\": true,\n            \"experimentalDecorators\": true,\n            \"target\": \"ES5\",\n            \"module\": \"CommonJS\",\n            \"strictNullChecks\": false,\n        }\n    }\n\n-j, --jsDoc <extended|none|basic>\n    none: Do not use JsDoc annotations.\n    basic: Read JsDoc annotations to provide schema properties.\n    extended (default): Also read @nullable, and @asType annotations.\n\n--unstable\n    Do not sort properties.\n\n--strict-tuples\n    Do not allow additional items on tuples.\n\n--no-top-ref\n    Do not create a top-level $ref definition.\n\n--no-type-check\n    Skip type checks for better performance.\n\n--no-ref-encode\n    Do not encode references. According to the standard, references must be valid URIs but some tools do not support encoded references.\n\n--validation-keywords\n    Provide additional validation keywords to include.\n\n-o, --out\n    Specify the output file path. Without this option, the generator logs the response in the console.\n\n--additional-properties <true|false>\n    Controls whether or not to allow additional properties for objects that have no index signature.\n\n    true: Additional properties are allowed\n    false (default): Additional properties are not allowed\n\n--minify\n    Minify generated schema (default: false)\n```\n\n## Current state\n\n-   `interface` types\n-   `enum` types\n-   `union`, `tuple`, `type[]` types\n-   `Date`, `RegExp` types\n-   `string`, `boolean`, `number` types\n-   `\"value\"`, `123`, `true`, `false`, `null`, `undefined` literals\n-   type aliases\n-   generics\n-   `typeof`\n-   `keyof`\n-   conditional types\n\n## Run locally\n\n`yarn --silent run run --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\n## Debug\n\n`yarn --silent run debug --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\nAnd connect via the debugger protocol.\n\n[AST Explorer](https://astexplorer.net/) is amazing for developers of this tool!\n\n## Publish\n\nPublishing is handled by a 2-branch [pre-release process](https://intuit.github.io/auto/docs/generated/shipit#next-branch-default), configured in `publish-auto.yml`. All changes should be based off the default `next` branch, and are published automatically.\n\n-   PRs made into the default branch are auto-deployed to the `next` pre-release tag on NPM. The result can be installed with `npm install ts-json-schema-generator@next`\n    -   When merging into `next`, please use the `squash and merge` strategy.\n-   To release a new stable version, open a PR from `next` into `stable` using this [compare link](https://github.com/vega/ts-json-schema-generator/compare/stable...next).\n    -   When merging from `next` into `stable`, please use the `create a merge commit` strategy.\n",
      "readmeFilename": "README.md",
      "gitHead": "09324060d19da1cf8f8fb0f0d58f3bb8e61fa03e",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@1.1.0-next.6",
      "_nodeVersion": "16.17.0",
      "_npmVersion": "8.15.0",
      "dist": {
        "integrity": "sha512-JJOko9cEO/eQZ9O6aOA/mgzoImNNiMvQmzRy+d/ZWzQdlPIHJxhcFrF0J0ZYGOvCMVLupBcmyf8++SnwR1pC2Q==",
        "shasum": "16574033a3fff9c25f973462fd8fff1193af0d08",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-1.1.0-next.6.tgz",
        "fileCount": 700,
        "unpackedSize": 851475,
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIHNenLgBfQ2pH81HbArAZQiMK6hmJhNvNsfR6aTm1jzgAiEA/ZuLXcLuP0e2oKOzCNbiyjOVdgD9uiIpecCRCckxAqE="
          }
        ],
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJjKni4ACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2Vmqm9w//WVKw84DGDTCSKlAZx28uuevRzBy5GzWvkj9w2RIkf19Gsnai\r\nEGwVKS7sZXCDboeIWGiCRF53Jen6Lwm8a8iXTR51DjDd2sVU/fpOpFtcmBJC\r\nJV+BSEEovDROgGDmsRdrnNZ2dqwm8WBPqxx3kceMCIGEFbQtQ9jajBEMuJIy\r\nrPmdiwaYVKiJbGBvVomoy6d8AJGJLYK6f4TskiA5k5n6gduMsg5fwqXB8Ysy\r\nhxEdSsN4vyYpJ+/DnOhitevmtqpLR219sD+lfyIzkBz6Pz7xv16WTUr7nkyy\r\nVHRzEbBzLka+7VKY0kUXRpKpmV5yioqFEL9jfDyEd0ED5cc2AGcMmHN9+iPE\r\nEH4M1cWvv6Nna1XZ3yxGULrnQF5zSBqyj/5F4HwTtrzGtSZRT25ySA7kFUNu\r\nK3MPM0rogJUY21m3Uaf8VAOimgsorAcE5+G9Sfb9Sy3bxyNgE9qvCQAeg9mI\r\nNZ6WgJJOdOm/bLBxJISU2/TBKggsqlIGqUEZbd51sJdSWz0mgyn36Mu38Htt\r\nGF/P4Q7646XGFwSJhGmclK3ekNGgGa1jqCtWu1N+XW0VxbyGOa8CT5ythICA\r\n8TUbW2/7SM5+sk+zGpTXhp95FLBssJAgH+VWlf5lfPvOGP+vAh5EQ7xCpvIB\r\noIJZErkSnbUO45Y7wV3DhKqQsAy+FqjOjbQ=\r\n=fwTL\r\n-----END PGP SIGNATURE-----\r\n"
      },
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "maintainers": [
        {
          "name": "jheer",
          "email": "jeffrey.heer@gmail.com"
        },
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "kanitw",
          "email": "kanitw@gmail.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_1.1.0-next.6_1663727800584_0.8920557649745762"
      },
      "_hasShrinkwrap": false
    },
    "1.0.1--canary.1362.c55cbf2.0": {
      "name": "ts-json-schema-generator",
      "version": "1.0.1--canary.1362.c55cbf2.0",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "MooYeol Prescott Lee",
          "email": "mooyoul@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=10.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.11",
        "commander": "^9.4.0",
        "glob": "^8.0.3",
        "json5": "^2.2.1",
        "normalize-path": "^3.0.0",
        "safe-stable-stringify": "^2.4.0",
        "typescript": "~4.8.3"
      },
      "devDependencies": {
        "@auto-it/conventional-commits": "^10.37.6",
        "@auto-it/first-time-contributor": "^10.37.6",
        "@babel/core": "^7.19.1",
        "@babel/preset-env": "^7.19.1",
        "@babel/preset-typescript": "^7.18.6",
        "@types/glob": "^8.0.0",
        "@types/jest": "^29.0.3",
        "@types/node": "^18.7.18",
        "@types/normalize-path": "^3.0.0",
        "@typescript-eslint/eslint-plugin": "^5.38.0",
        "@typescript-eslint/parser": "^5.38.0",
        "ajv": "^8.11.0",
        "ajv-formats": "^2.1.1",
        "auto": "^10.37.6",
        "chai": "^4.3.6",
        "cross-env": "^7.0.3",
        "eslint": "^8.23.1",
        "eslint-config-prettier": "^8.5.0",
        "eslint-plugin-prettier": "^4.2.1",
        "jest": "^29.0.3",
        "jest-junit": "^14.0.1",
        "prettier": "^2.7.1",
        "ts-node": "^10.9.1",
        "vega": "^5.22.1",
        "vega-lite": "^5.5.0"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint \"{src,test,factory}/**/*.ts\"",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "cross-env FAST_TEST=1 jest test/ --verbose",
        "test:coverage": "yarn jest test/ --collectCoverage=true",
        "test:update": "cross-env UPDATE_SCHEMA=true yarn test:fast",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node-transpile-only ts-json-schema-generator.ts",
        "release": "yarn build && auto shipit"
      },
      "readme": "# ts-json-schema-generator\n\n![Test](https://github.com/vega/ts-json-schema-generator/workflows/Test/badge.svg)\n[![codecov](https://codecov.io/gh/vega/ts-json-schema-generator/branch/master/graph/badge.svg)](https://codecov.io/gh/vega/ts-json-schema-generator)\n[![npm version](https://img.shields.io/npm/v/ts-json-schema-generator.svg)](https://www.npmjs.com/package/ts-json-schema-generator)\n\nExtended version of [https://github.com/xiag-ag/typescript-to-json-schema](https://github.com/xiag-ag/typescript-to-json-schema).\n\nInspired by [`YousefED/typescript-json-schema`](https://github.com/YousefED/typescript-json-schema). Here's the differences list:\n\n-   this implementation avoids the use of `typeChecker.getTypeAtLocation()` (so probably it keeps correct type aliases)\n-   processing AST and formatting JSON schema have been split into two independent steps\n-   not exported types, interfaces, enums are not exposed in the `definitions` section in the JSON schema\n\n## Contributors\n\nThis project is made possible by a [community of contributors](https://github.com/vega/ts-json-schema-generator/graphs/contributors). We welcome contributions of any kind (issues, code, documentation, examples, tests,...). Please read our [code of conduct](https://vega.github.io/vega/about/code-of-conduct).\n\n## CLI Usage\n\n```bash\nnpm install --save ts-json-schema-generator\n./node_modules/.bin/ts-json-schema-generator --path 'my/project/**/*.ts' --type 'My.Type.Name'\n```\n\nNote that different platforms (e.g. Windows) may use different path separators so you may have to adjust the command above.\n\n## Programmatic Usage\n\n```js\n// main.js\n\nconst tsj = require(\"ts-json-schema-generator\");\nconst fs = require(\"fs\");\n\n/** @type {import('ts-json-schema-generator/dist/src/Config').Config} */\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst output_path = \"path/to/output/file\";\n\nconst schema = tsj.createGenerator(config).createSchema(config.type);\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\nRun the schema generator via `node main.js`.\n\n### Custom formatting\n\nExtending the built-in formatting is possible by creating a custom formatter and adding it to the main formatter:\n\n1. First we create a formatter, in this case for formatting function types:\n\n```ts\n// my-function-formatter.ts\nimport { BaseType, Definition, FunctionType, SubTypeFormatter } from \"ts-json-schema-generator\";\nimport ts from \"typescript\";\n\nexport class MyFunctionTypeFormatter implements SubTypeFormatter {\n    // You can skip this line if you don't need childTypeFormatter\n    public constructor(private childTypeFormatter: TypeFormatter) {}\n\n    public supportsType(type: FunctionType): boolean {\n        return type instanceof FunctionType;\n    }\n\n    public getDefinition(type: FunctionType): Definition {\n        // Return a custom schema for the function property.\n        return {\n            type: \"object\",\n            properties: {\n                isFunction: {\n                    type: \"boolean\",\n                    const: true,\n                },\n            },\n        };\n    }\n\n    // If this type does NOT HAVE children, generally all you need is:\n    public getChildren(type: FunctionType): BaseType[] {\n        return [];\n    }\n\n    // However, if children ARE supported, you'll need something similar to\n    // this (see src/TypeFormatter/{Array,Definition,etc}.ts for some examples):\n    public getChildren(type: FunctionType): BaseType[] {\n        return this.childTypeFormatter.getChildren(type.getType());\n    }\n}\n```\n\n2. Then we add the formatter as a child to the core formatter using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyFunctionTypeFormatter } from \"./my-function-formatter.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\n// We configure the formatter an add our custom formatter to it.\nconst formatter = createFormatter(config, (fmt, circularReferenceTypeFormatter) => {\n    // If your formatter DOES NOT support children, e.g. getChildren() { return [] }:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter());\n    // If your formatter DOES support children, you'll need this reference too:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter(circularReferenceTypeFormatter));\n});\n\nconst program = createProgram(config);\nconst parser = createParser(program, config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n### Custom parsing\n\nSimilar to custom formatting, extending the built-in parsing works practically the same way:\n\n1. First we create a parser, in this case for parsing construct types:\n\n```ts\n// my-constructor-parser.ts\nimport { Context, StringType, ReferenceType, BaseType, SubNodeParser } from \"ts-json-schema-generator\";\n// use typescript exported by TJS to avoid version conflict\nimport ts from \"ts-json-schema-generator\";\n\nexport class MyConstructorParser implements SubNodeParser {\n    supportsNode(node: ts.Node): boolean {\n        return node.kind === ts.SyntaxKind.ConstructorType;\n    }\n    createType(node: ts.Node, context: Context, reference?: ReferenceType): BaseType | undefined {\n        return new StringType(); // Treat constructors as strings in this example\n    }\n}\n```\n\n2. Then we add the parser as a child to the core parser using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyConstructorParser } from \"./my-constructor-parser.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst program = createProgram(config);\n\n// We configure the parser an add our custom parser to it.\nconst parser = createParser(program, config, (prs) => {\n    prs.addNodeParser(new MyConstructorParser());\n});\n\nconst formatter = createFormatter(config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n## Options\n\n```\n-p, --path 'index.ts'\n    The path to the TypeScript source file. If this is not provided, the type will be searched in the project specified in the `.tsconfig`.\n\n-t, --type 'My.Type.Name'\n    The type the generated schema will represent. If omitted, the generated schema will contain all\n    types found in the files matching path. The same is true if '*' is specified.\n\n-i, --id 'generatedSchemaId'\n    The `$id` of the generated schema. If omitted, there will be no `$id`.\n\n-e, --expose <all|none|export>\n    all: Create shared $ref definitions for all types.\n    none: Do not create shared $ref definitions.\n    export (default): Create shared $ref definitions only for exported types (not tagged as `@internal`).\n\n-f, --tsconfig 'my/project/tsconfig.json'\n    Use a custom tsconfig file for processing typescript (see https://www.typescriptlang.org/docs/handbook/tsconfig-json.html) instead of the default:\n    {\n        \"compilerOptions\": {\n            \"noEmit\": true,\n            \"emitDecoratorMetadata\": true,\n            \"experimentalDecorators\": true,\n            \"target\": \"ES5\",\n            \"module\": \"CommonJS\",\n            \"strictNullChecks\": false,\n        }\n    }\n\n-j, --jsDoc <extended|none|basic>\n    none: Do not use JsDoc annotations.\n    basic: Read JsDoc annotations to provide schema properties.\n    extended (default): Also read @nullable, and @asType annotations.\n\n--unstable\n    Do not sort properties.\n\n--strict-tuples\n    Do not allow additional items on tuples.\n\n--no-top-ref\n    Do not create a top-level $ref definition.\n\n--no-type-check\n    Skip type checks for better performance.\n\n--no-ref-encode\n    Do not encode references. According to the standard, references must be valid URIs but some tools do not support encoded references.\n\n--validation-keywords\n    Provide additional validation keywords to include.\n\n-o, --out\n    Specify the output file path. Without this option, the generator logs the response in the console.\n\n--additional-properties <true|false>\n    Controls whether or not to allow additional properties for objects that have no index signature.\n\n    true: Additional properties are allowed\n    false (default): Additional properties are not allowed\n\n--minify\n    Minify generated schema (default: false)\n```\n\n## Current state\n\n-   `interface` types\n-   `enum` types\n-   `union`, `tuple`, `type[]` types\n-   `Date`, `RegExp` types\n-   `string`, `boolean`, `number` types\n-   `\"value\"`, `123`, `true`, `false`, `null`, `undefined` literals\n-   type aliases\n-   generics\n-   `typeof`\n-   `keyof`\n-   conditional types\n\n## Run locally\n\n`yarn --silent run run --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\n## Debug\n\n`yarn --silent run debug --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\nAnd connect via the debugger protocol.\n\n[AST Explorer](https://astexplorer.net/) is amazing for developers of this tool!\n\n## Publish\n\nPublishing is handled by a 2-branch [pre-release process](https://intuit.github.io/auto/docs/generated/shipit#next-branch-default), configured in `publish-auto.yml`. All changes should be based off the default `next` branch, and are published automatically.\n\n-   PRs made into the default branch are auto-deployed to the `next` pre-release tag on NPM. The result can be installed with `npm install ts-json-schema-generator@next`\n    -   When merging into `next`, please use the `squash and merge` strategy.\n-   To release a new stable version, open a PR from `next` into `stable` using this [compare link](https://github.com/vega/ts-json-schema-generator/compare/stable...next).\n    -   When merging from `next` into `stable`, please use the `create a merge commit` strategy.\n",
      "readmeFilename": "README.md",
      "gitHead": "c55cbf2da419846edfd1d81ea99f0c2022dc9803",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@1.0.1--canary.1362.c55cbf2.0",
      "_nodeVersion": "16.17.0",
      "_npmVersion": "8.15.0",
      "dist": {
        "integrity": "sha512-qaJWoavo6EhKwjd38fs3wEFnIZkBBqVjYV6mUby5YU7dyE/k+W/M39rNH1ks5uZMY5mvQ+4JiZbK0Iy06Z/3EA==",
        "shasum": "364bfc38addab4580d7e18a5a78a0c2f870e8673",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-1.0.1--canary.1362.c55cbf2.0.tgz",
        "fileCount": 700,
        "unpackedSize": 851507,
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIGeO/EGlV6QeGrT3aLsZ+D4DEb5PXNhWMaAyQdRLlPKIAiEAtxjp+LSWm/wFRnGUXM48DhwMtAMowwFIe7Rj66/emMw="
          }
        ],
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJjKnx0ACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2VmpJzw/8DlPP62zvWVMQcnYN41dgeub2FwFviXmCKXW2otvQgX7Le6O8\r\nar0c0VbAPwPV+PVeu4VpB5MYkFc6QVuJ7T5ViEMFK1WTyZxFgR4RIIP6xPsA\r\nFfWic8S+iy8MOz4hnJo0tx14iPQv60NsW7yM1ShQX+GRFCKyk18Y3NIMxL47\r\nFUhFhBqnbNJanVBDlvi+/dihOvadAPDy6DUOuOqeGh895Z2Ax4/I9BL6CMDl\r\nWSPO5uVqkGT9EJCIHvfkE6IFijDd3L32zhsl9IwdIcnK5TddSV1id1RSyatI\r\n0doNFkqymvIH8p8Oz97Berog2gJvjue0QSGhC67R+VjzWaAmSLkP19Z8rIPh\r\nKxTbGpVzrjIN8mD61RU6XwyoacbS0am+NHgvMmuAtjLaUu2n607H7adsM6y6\r\nMwDm1/Bd5JaFNBY9pPsxPLY+W5lVdSl1MeuQlpzvneta9FycLulDzrr3mXK2\r\nYMXuQcjAE/s1/sPR8Q8GNZriUesIoKolICAvtmMBBydzWvs7uPs6k7oRVB41\r\nEOZVyBBupQnWpN3RYwmbv+YSMOtzrNGOmex7ABiUggkM3feWXjy+2rHv64b3\r\njtfgS/OiH6sgd6RyiW9VEz7lTpFOvhi2aEEEGp1dUWAQomnSVcwa07Cl23vZ\r\nni024FHgOa5KQ0D7eSNcg3p7vfj1xqP8tko=\r\n=rgv8\r\n-----END PGP SIGNATURE-----\r\n"
      },
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "maintainers": [
        {
          "name": "jheer",
          "email": "jeffrey.heer@gmail.com"
        },
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "kanitw",
          "email": "kanitw@gmail.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_1.0.1--canary.1362.c55cbf2.0_1663728756706_0.7783553469579236"
      },
      "_hasShrinkwrap": false
    },
    "1.1.0": {
      "name": "ts-json-schema-generator",
      "version": "1.1.0",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "MooYeol Prescott Lee",
          "email": "mooyoul@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=10.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.11",
        "commander": "^9.4.0",
        "glob": "^8.0.3",
        "json5": "^2.2.1",
        "normalize-path": "^3.0.0",
        "safe-stable-stringify": "^2.4.0",
        "typescript": "~4.8.3"
      },
      "devDependencies": {
        "@auto-it/conventional-commits": "^10.37.6",
        "@auto-it/first-time-contributor": "^10.37.6",
        "@babel/core": "^7.19.1",
        "@babel/preset-env": "^7.19.1",
        "@babel/preset-typescript": "^7.18.6",
        "@types/glob": "^8.0.0",
        "@types/jest": "^29.0.3",
        "@types/node": "^18.7.18",
        "@types/normalize-path": "^3.0.0",
        "@typescript-eslint/eslint-plugin": "^5.38.0",
        "@typescript-eslint/parser": "^5.38.0",
        "ajv": "^8.11.0",
        "ajv-formats": "^2.1.1",
        "auto": "^10.37.6",
        "chai": "^4.3.6",
        "cross-env": "^7.0.3",
        "eslint": "^8.23.1",
        "eslint-config-prettier": "^8.5.0",
        "eslint-plugin-prettier": "^4.2.1",
        "jest": "^29.0.3",
        "jest-junit": "^14.0.1",
        "prettier": "^2.7.1",
        "ts-node": "^10.9.1",
        "vega": "^5.22.1",
        "vega-lite": "^5.5.0"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint \"{src,test,factory}/**/*.ts\"",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "cross-env FAST_TEST=1 jest test/ --verbose",
        "test:coverage": "yarn jest test/ --collectCoverage=true",
        "test:update": "cross-env UPDATE_SCHEMA=true yarn test:fast",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node-transpile-only ts-json-schema-generator.ts",
        "release": "yarn build && auto shipit"
      },
      "gitHead": "ea05b174aa07f396f83f69f8ad5b99b89b5e6438",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@1.1.0",
      "_nodeVersion": "16.17.0",
      "_npmVersion": "8.15.0",
      "dist": {
        "integrity": "sha512-yQdIWXzVlmY/6ttgju8scfzKVUtQ1fv7rn0XOZyJyGAuF6juWnTL72+vkQiLEqMm5oyZ4IjQbxgvaFvymwI/5w==",
        "shasum": "72fc1e732f9bf09c4c63e0491f11e6bae6c67b92",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-1.1.0.tgz",
        "fileCount": 700,
        "unpackedSize": 851461,
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIQCwV30+NMV1fZyGfMrwOG5AZMKP0lSpWVem4XIhZowV5AIgHzXgM8NWZgHD0lqWl4tQX/1iaE3K5cpUWvbkmLCZi0Q="
          }
        ],
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJjKobEACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2VmrdpxAAnSLbWrz34nxF+KpmbMuH71GKRGlZ3lvaMfulUBfFm6m2WrCM\r\nHShgj9VpXz0jH7Uq+4E4X0efKAIueBafQplzV/waGmnGVqFO8zFmFBv6HEuu\r\nZYcu8FeJuC4RndzTjwE6CPByfVMQmhNygoVd1ASPNKpA+TPcNn4DnJSX7LVA\r\nfdEJJTghnNLz83lusDtVsgQ8LP6A9wT5lNSCnalkBV8wziGJM11gdBGwPbyq\r\nwnBuNRs2rHBPlTkdGCiuJHZZUVkTvsY5iPuxSf2IGzWQbBCBrZEfAZj6FdDP\r\n48Oz7wCXb8CUFV+8j8x4cN8TCSI5cwTxXNCAw+x+knbVDRN2WslzpXdYslll\r\ntfRVVP/Sjzz6SO6f028xn9XqpeBTUuwm4pvN9NLIKRkqLPfNOZlh6Pf0u3PO\r\nzFFY/O+dnwjkMs/Set5wsHbbcYkVQYvpDZd7oJ2xl4sxjrh+bt3W1Ip/Irxe\r\nQGeNkIk+k1mqy9ep+fR8vxjI/FKhD4UV4HaqaQb3+oq+svurkbzpd3W+nNov\r\nUgQWPBAd6Xyn7dOlC4O6VQttF8ioZyIicNRNsBTHEwDVUhj3unuE2xIeOab8\r\n7C1ksxmnKx4SbRFrvGVAKxnjkoxBppJ6UEsUth6g4dbFjtqGZzXBdK5vraen\r\neOPp7xg9fEjZMgU5WRk9kAWMATn0vHBRpqg=\r\n=adqu\r\n-----END PGP SIGNATURE-----\r\n"
      },
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "maintainers": [
        {
          "name": "jheer",
          "email": "jeffrey.heer@gmail.com"
        },
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "kanitw",
          "email": "kanitw@gmail.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_1.1.0_1663731396162_0.7346016260068264"
      },
      "_hasShrinkwrap": false
    },
    "2.0.0-next.0": {
      "name": "ts-json-schema-generator",
      "version": "2.0.0-next.0",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "MooYeol Prescott Lee",
          "email": "mooyoul@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=10.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.11",
        "commander": "^9.4.0",
        "glob": "^8.0.3",
        "json5": "^2.2.1",
        "normalize-path": "^3.0.0",
        "safe-stable-stringify": "^2.4.0",
        "typescript": "~4.8.3"
      },
      "devDependencies": {
        "@auto-it/conventional-commits": "^10.37.6",
        "@auto-it/first-time-contributor": "^10.37.6",
        "@babel/core": "^7.19.1",
        "@babel/preset-env": "^7.19.1",
        "@babel/preset-typescript": "^7.18.6",
        "@types/glob": "^8.0.0",
        "@types/jest": "^29.0.3",
        "@types/node": "^18.7.18",
        "@types/normalize-path": "^3.0.0",
        "@typescript-eslint/eslint-plugin": "^5.38.0",
        "@typescript-eslint/parser": "^5.38.0",
        "ajv": "^8.11.0",
        "ajv-formats": "^2.1.1",
        "auto": "^10.37.6",
        "chai": "^4.3.6",
        "cross-env": "^7.0.3",
        "eslint": "^8.23.1",
        "eslint-config-prettier": "^8.5.0",
        "eslint-plugin-prettier": "^4.2.1",
        "jest": "^29.0.3",
        "jest-junit": "^14.0.1",
        "prettier": "^2.7.1",
        "ts-node": "^10.9.1",
        "vega": "^5.22.1",
        "vega-lite": "^5.5.0"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint \"{src,test,factory}/**/*.ts\"",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "cross-env FAST_TEST=1 jest test/ --verbose",
        "test:coverage": "yarn jest test/ --collectCoverage=true",
        "test:update": "cross-env UPDATE_SCHEMA=true yarn test:fast",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node-transpile-only ts-json-schema-generator.ts",
        "release": "yarn build && auto shipit"
      },
      "readme": "# ts-json-schema-generator\n\n![Test](https://github.com/vega/ts-json-schema-generator/workflows/Test/badge.svg)\n[![codecov](https://codecov.io/gh/vega/ts-json-schema-generator/branch/master/graph/badge.svg)](https://codecov.io/gh/vega/ts-json-schema-generator)\n[![npm version](https://img.shields.io/npm/v/ts-json-schema-generator.svg)](https://www.npmjs.com/package/ts-json-schema-generator)\n\nExtended version of [https://github.com/xiag-ag/typescript-to-json-schema](https://github.com/xiag-ag/typescript-to-json-schema).\n\nInspired by [`YousefED/typescript-json-schema`](https://github.com/YousefED/typescript-json-schema). Here's the differences list:\n\n-   this implementation avoids the use of `typeChecker.getTypeAtLocation()` (so probably it keeps correct type aliases)\n-   processing AST and formatting JSON schema have been split into two independent steps\n-   not exported types, interfaces, enums are not exposed in the `definitions` section in the JSON schema\n\n## Contributors\n\nThis project is made possible by a [community of contributors](https://github.com/vega/ts-json-schema-generator/graphs/contributors). We welcome contributions of any kind (issues, code, documentation, examples, tests,...). Please read our [code of conduct](https://vega.github.io/vega/about/code-of-conduct).\n\n## CLI Usage\n\n```bash\nnpm install --save ts-json-schema-generator\n./node_modules/.bin/ts-json-schema-generator --path 'my/project/**/*.ts' --type 'My.Type.Name'\n```\n\nNote that different platforms (e.g. Windows) may use different path separators so you may have to adjust the command above.\n\n## Programmatic Usage\n\n```js\n// main.js\n\nconst tsj = require(\"ts-json-schema-generator\");\nconst fs = require(\"fs\");\n\n/** @type {import('ts-json-schema-generator/dist/src/Config').Config} */\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst output_path = \"path/to/output/file\";\n\nconst schema = tsj.createGenerator(config).createSchema(config.type);\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\nRun the schema generator via `node main.js`.\n\n### Custom formatting\n\nExtending the built-in formatting is possible by creating a custom formatter and adding it to the main formatter:\n\n1. First we create a formatter, in this case for formatting function types:\n\n```ts\n// my-function-formatter.ts\nimport { BaseType, Definition, FunctionType, SubTypeFormatter } from \"ts-json-schema-generator\";\nimport ts from \"typescript\";\n\nexport class MyFunctionTypeFormatter implements SubTypeFormatter {\n    // You can skip this line if you don't need childTypeFormatter\n    public constructor(private childTypeFormatter: TypeFormatter) {}\n\n    public supportsType(type: FunctionType): boolean {\n        return type instanceof FunctionType;\n    }\n\n    public getDefinition(type: FunctionType): Definition {\n        // Return a custom schema for the function property.\n        return {\n            type: \"object\",\n            properties: {\n                isFunction: {\n                    type: \"boolean\",\n                    const: true,\n                },\n            },\n        };\n    }\n\n    // If this type does NOT HAVE children, generally all you need is:\n    public getChildren(type: FunctionType): BaseType[] {\n        return [];\n    }\n\n    // However, if children ARE supported, you'll need something similar to\n    // this (see src/TypeFormatter/{Array,Definition,etc}.ts for some examples):\n    public getChildren(type: FunctionType): BaseType[] {\n        return this.childTypeFormatter.getChildren(type.getType());\n    }\n}\n```\n\n2. Then we add the formatter as a child to the core formatter using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyFunctionTypeFormatter } from \"./my-function-formatter.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\n// We configure the formatter an add our custom formatter to it.\nconst formatter = createFormatter(config, (fmt, circularReferenceTypeFormatter) => {\n    // If your formatter DOES NOT support children, e.g. getChildren() { return [] }:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter());\n    // If your formatter DOES support children, you'll need this reference too:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter(circularReferenceTypeFormatter));\n});\n\nconst program = createProgram(config);\nconst parser = createParser(program, config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n### Custom parsing\n\nSimilar to custom formatting, extending the built-in parsing works practically the same way:\n\n1. First we create a parser, in this case for parsing construct types:\n\n```ts\n// my-constructor-parser.ts\nimport { Context, StringType, ReferenceType, BaseType, SubNodeParser } from \"ts-json-schema-generator\";\n// use typescript exported by TJS to avoid version conflict\nimport ts from \"ts-json-schema-generator\";\n\nexport class MyConstructorParser implements SubNodeParser {\n    supportsNode(node: ts.Node): boolean {\n        return node.kind === ts.SyntaxKind.ConstructorType;\n    }\n    createType(node: ts.Node, context: Context, reference?: ReferenceType): BaseType | undefined {\n        return new StringType(); // Treat constructors as strings in this example\n    }\n}\n```\n\n2. Then we add the parser as a child to the core parser using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyConstructorParser } from \"./my-constructor-parser.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst program = createProgram(config);\n\n// We configure the parser an add our custom parser to it.\nconst parser = createParser(program, config, (prs) => {\n    prs.addNodeParser(new MyConstructorParser());\n});\n\nconst formatter = createFormatter(config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n## Options\n\n```\n-p, --path 'index.ts'\n    The path to the TypeScript source file. If this is not provided, the type will be searched in the project specified in the `.tsconfig`.\n\n-t, --type 'My.Type.Name'\n    The type the generated schema will represent. If omitted, the generated schema will contain all\n    types found in the files matching path. The same is true if '*' is specified.\n\n-i, --id 'generatedSchemaId'\n    The `$id` of the generated schema. If omitted, there will be no `$id`.\n\n-e, --expose <all|none|export>\n    all: Create shared $ref definitions for all types.\n    none: Do not create shared $ref definitions.\n    export (default): Create shared $ref definitions only for exported types (not tagged as `@internal`).\n\n-f, --tsconfig 'my/project/tsconfig.json'\n    Use a custom tsconfig file for processing typescript (see https://www.typescriptlang.org/docs/handbook/tsconfig-json.html) instead of the default:\n    {\n        \"compilerOptions\": {\n            \"noEmit\": true,\n            \"emitDecoratorMetadata\": true,\n            \"experimentalDecorators\": true,\n            \"target\": \"ES5\",\n            \"module\": \"CommonJS\",\n            \"strictNullChecks\": false,\n        }\n    }\n\n-j, --jsDoc <extended|none|basic>\n    none: Do not use JsDoc annotations.\n    basic: Read JsDoc annotations to provide schema properties.\n    extended (default): Also read @nullable, and @asType annotations.\n\n--unstable\n    Do not sort properties.\n\n--strict-tuples\n    Do not allow additional items on tuples.\n\n--no-top-ref\n    Do not create a top-level $ref definition.\n\n--no-type-check\n    Skip type checks for better performance.\n\n--no-ref-encode\n    Do not encode references. According to the standard, references must be valid URIs but some tools do not support encoded references.\n\n--validation-keywords\n    Provide additional validation keywords to include.\n\n-o, --out\n    Specify the output file path. Without this option, the generator logs the response in the console.\n\n--additional-properties <true|false>\n    Controls whether or not to allow additional properties for objects that have no index signature.\n\n    true: Additional properties are allowed\n    false (default): Additional properties are not allowed\n\n--minify\n    Minify generated schema (default: false)\n```\n\n## Current state\n\n-   `interface` types\n-   `enum` types\n-   `union`, `tuple`, `type[]` types\n-   `Date`, `RegExp` types\n-   `string`, `boolean`, `number` types\n-   `\"value\"`, `123`, `true`, `false`, `null`, `undefined` literals\n-   type aliases\n-   generics\n-   `typeof`\n-   `keyof`\n-   conditional types\n\n## Run locally\n\n`yarn --silent run run --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\n## Debug\n\n`yarn --silent run debug --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\nAnd connect via the debugger protocol.\n\n[AST Explorer](https://astexplorer.net/) is amazing for developers of this tool!\n\n## Publish\n\nPublishing is handled by a 2-branch [pre-release process](https://intuit.github.io/auto/docs/generated/shipit#next-branch-default), configured in `publish-auto.yml`. All changes should be based off the default `next` branch, and are published automatically.\n\n-   PRs made into the default branch are auto-deployed to the `next` pre-release tag on NPM. The result can be installed with `npm install ts-json-schema-generator@next`\n    -   When merging into `next`, please use the `squash and merge` strategy.\n-   To release a new stable version, open a PR from `next` into `stable` using this [compare link](https://github.com/vega/ts-json-schema-generator/compare/stable...next).\n    -   When merging from `next` into `stable`, please use the `create a merge commit` strategy.\n",
      "readmeFilename": "README.md",
      "gitHead": "065ac274946d33e153cff4eeecd52c889b45993b",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@2.0.0-next.0",
      "_nodeVersion": "16.17.0",
      "_npmVersion": "8.15.0",
      "dist": {
        "integrity": "sha512-YrUd2c3hsvUjBJUWRmsLm+YWdWcEVSE6HxJKVYAdFw6dkRg5mkslW76gocDt1qa2ECA/faOd6pLRxh6PN970Ow==",
        "shasum": "94b4976261b4dcdb3a0be2cad3a53412072e2d78",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-2.0.0-next.0.tgz",
        "fileCount": 700,
        "unpackedSize": 851475,
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEQCIB3a628xjntxTBDm3CMC82dHZne68coBetldPZMSpBiPAiBlsCMuvv/RHydD4cgY+9gUNjdheuN0cpPawqx3Uqcfew=="
          }
        ],
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJjKobSACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2Vmomjw//e0w4xGYxjSF1NQi4q9pYaFWedNbWoHFUZQpDK9aOigUBw6Zq\r\ncCuFza34/PDgx1wZcRSmKKR+UJy1+fbHi7ErgO9fC/1VaOhexRHa6pyUrawB\r\nU0wBrhFjZkx1Rgk1VpE+tQbTrfWrlQO1R4rbGRrgSYcxv92qwdrorFKt/HVB\r\nQwMzVjp749oIyGYB+75slJedHzpAfy7aCG2kjxBAxMAfOYLDH+vhnyiTJlm/\r\nXTrKWwy8O6QOXbIrQOECeSdqjAEeAN/bvFPSzCFIiOItaPPSiYGOjP+0Ab2A\r\nCkKKr+L3PE/yKL6HESC/i9UBlIIn/XiKBLaL3MPjN+DRymBsLOwKAmaeXd+S\r\nwuAmP/OmObAkQ+QuJkI/XGkx2VcDvUAO2gWFNXe3trLaSxVj0DBjE2+A8DCC\r\nmUPTG5bDPvOZXbJQCODyjpeACdLe9b2A7qIV1/PNkdapZyQpCbSjtwwOdD5Y\r\nG5D2ksKjd4AYypfYIcnZWwJwFMuIUdPxvw3ZHp5218ydHNzQWY5gw/UEB2HD\r\nJ9vlOGn4d7bJF08AxOim+esxm19EhpX2MA0U5JJhiUOJ6xgLobSD3u7WM64F\r\nyW4DpJl4kO+i6x/OZEJ5IdHArS3oWlP7AhgWpZT6ab+Qw5Cj3xewTXv4Mlvi\r\nch8s2K9d7Kt1Ya47aMthBl9vVuzfdyvw6+g=\r\n=9EJt\r\n-----END PGP SIGNATURE-----\r\n"
      },
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "maintainers": [
        {
          "name": "jheer",
          "email": "jeffrey.heer@gmail.com"
        },
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "kanitw",
          "email": "kanitw@gmail.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_2.0.0-next.0_1663731410457_0.8037203782474753"
      },
      "_hasShrinkwrap": false
    },
    "1.1.1-next.0": {
      "name": "ts-json-schema-generator",
      "version": "1.1.1-next.0",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "MooYeol Prescott Lee",
          "email": "mooyoul@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=10.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.11",
        "commander": "^9.4.0",
        "glob": "^8.0.3",
        "json5": "^2.2.1",
        "normalize-path": "^3.0.0",
        "safe-stable-stringify": "^2.4.0",
        "typescript": "~4.8.3"
      },
      "devDependencies": {
        "@auto-it/conventional-commits": "^10.37.6",
        "@auto-it/first-time-contributor": "^10.37.6",
        "@babel/core": "^7.19.1",
        "@babel/preset-env": "^7.19.1",
        "@babel/preset-typescript": "^7.18.6",
        "@types/glob": "^8.0.0",
        "@types/jest": "^29.0.3",
        "@types/node": "^18.7.18",
        "@types/normalize-path": "^3.0.0",
        "@typescript-eslint/eslint-plugin": "^5.38.0",
        "@typescript-eslint/parser": "^5.38.0",
        "ajv": "^8.11.0",
        "ajv-formats": "^2.1.1",
        "auto": "^10.37.6",
        "chai": "^4.3.6",
        "cross-env": "^7.0.3",
        "eslint": "^8.23.1",
        "eslint-config-prettier": "^8.5.0",
        "eslint-plugin-prettier": "^4.2.1",
        "jest": "^29.0.3",
        "jest-junit": "^14.0.1",
        "prettier": "^2.7.1",
        "ts-node": "^10.9.1",
        "vega": "^5.22.1",
        "vega-lite": "^5.5.0"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint \"{src,test,factory}/**/*.ts\"",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "cross-env FAST_TEST=1 jest test/ --verbose",
        "test:coverage": "yarn jest test/ --collectCoverage=true",
        "test:update": "cross-env UPDATE_SCHEMA=true yarn test:fast",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node-transpile-only ts-json-schema-generator.ts",
        "release": "yarn build && auto shipit"
      },
      "readme": "# ts-json-schema-generator\n\n![Test](https://github.com/vega/ts-json-schema-generator/workflows/Test/badge.svg)\n[![codecov](https://codecov.io/gh/vega/ts-json-schema-generator/branch/master/graph/badge.svg)](https://codecov.io/gh/vega/ts-json-schema-generator)\n[![npm version](https://img.shields.io/npm/v/ts-json-schema-generator.svg)](https://www.npmjs.com/package/ts-json-schema-generator)\n\nExtended version of [https://github.com/xiag-ag/typescript-to-json-schema](https://github.com/xiag-ag/typescript-to-json-schema).\n\nInspired by [`YousefED/typescript-json-schema`](https://github.com/YousefED/typescript-json-schema). Here's the differences list:\n\n-   this implementation avoids the use of `typeChecker.getTypeAtLocation()` (so probably it keeps correct type aliases)\n-   processing AST and formatting JSON schema have been split into two independent steps\n-   not exported types, interfaces, enums are not exposed in the `definitions` section in the JSON schema\n\n## Contributors\n\nThis project is made possible by a [community of contributors](https://github.com/vega/ts-json-schema-generator/graphs/contributors). We welcome contributions of any kind (issues, code, documentation, examples, tests,...). Please read our [code of conduct](https://vega.github.io/vega/about/code-of-conduct).\n\n## CLI Usage\n\n```bash\nnpm install --save ts-json-schema-generator\n./node_modules/.bin/ts-json-schema-generator --path 'my/project/**/*.ts' --type 'My.Type.Name'\n```\n\nNote that different platforms (e.g. Windows) may use different path separators so you may have to adjust the command above.\n\n## Programmatic Usage\n\n```js\n// main.js\n\nconst tsj = require(\"ts-json-schema-generator\");\nconst fs = require(\"fs\");\n\n/** @type {import('ts-json-schema-generator/dist/src/Config').Config} */\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst output_path = \"path/to/output/file\";\n\nconst schema = tsj.createGenerator(config).createSchema(config.type);\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\nRun the schema generator via `node main.js`.\n\n### Custom formatting\n\nExtending the built-in formatting is possible by creating a custom formatter and adding it to the main formatter:\n\n1. First we create a formatter, in this case for formatting function types:\n\n```ts\n// my-function-formatter.ts\nimport { BaseType, Definition, FunctionType, SubTypeFormatter } from \"ts-json-schema-generator\";\nimport ts from \"typescript\";\n\nexport class MyFunctionTypeFormatter implements SubTypeFormatter {\n    // You can skip this line if you don't need childTypeFormatter\n    public constructor(private childTypeFormatter: TypeFormatter) {}\n\n    public supportsType(type: FunctionType): boolean {\n        return type instanceof FunctionType;\n    }\n\n    public getDefinition(type: FunctionType): Definition {\n        // Return a custom schema for the function property.\n        return {\n            type: \"object\",\n            properties: {\n                isFunction: {\n                    type: \"boolean\",\n                    const: true,\n                },\n            },\n        };\n    }\n\n    // If this type does NOT HAVE children, generally all you need is:\n    public getChildren(type: FunctionType): BaseType[] {\n        return [];\n    }\n\n    // However, if children ARE supported, you'll need something similar to\n    // this (see src/TypeFormatter/{Array,Definition,etc}.ts for some examples):\n    public getChildren(type: FunctionType): BaseType[] {\n        return this.childTypeFormatter.getChildren(type.getType());\n    }\n}\n```\n\n2. Then we add the formatter as a child to the core formatter using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyFunctionTypeFormatter } from \"./my-function-formatter.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\n// We configure the formatter an add our custom formatter to it.\nconst formatter = createFormatter(config, (fmt, circularReferenceTypeFormatter) => {\n    // If your formatter DOES NOT support children, e.g. getChildren() { return [] }:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter());\n    // If your formatter DOES support children, you'll need this reference too:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter(circularReferenceTypeFormatter));\n});\n\nconst program = createProgram(config);\nconst parser = createParser(program, config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n### Custom parsing\n\nSimilar to custom formatting, extending the built-in parsing works practically the same way:\n\n1. First we create a parser, in this case for parsing construct types:\n\n```ts\n// my-constructor-parser.ts\nimport { Context, StringType, ReferenceType, BaseType, SubNodeParser } from \"ts-json-schema-generator\";\n// use typescript exported by TJS to avoid version conflict\nimport ts from \"ts-json-schema-generator\";\n\nexport class MyConstructorParser implements SubNodeParser {\n    supportsNode(node: ts.Node): boolean {\n        return node.kind === ts.SyntaxKind.ConstructorType;\n    }\n    createType(node: ts.Node, context: Context, reference?: ReferenceType): BaseType | undefined {\n        return new StringType(); // Treat constructors as strings in this example\n    }\n}\n```\n\n2. Then we add the parser as a child to the core parser using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyConstructorParser } from \"./my-constructor-parser.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst program = createProgram(config);\n\n// We configure the parser an add our custom parser to it.\nconst parser = createParser(program, config, (prs) => {\n    prs.addNodeParser(new MyConstructorParser());\n});\n\nconst formatter = createFormatter(config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n## Options\n\n```\n-p, --path 'index.ts'\n    The path to the TypeScript source file. If this is not provided, the type will be searched in the project specified in the `.tsconfig`.\n\n-t, --type 'My.Type.Name'\n    The type the generated schema will represent. If omitted, the generated schema will contain all\n    types found in the files matching path. The same is true if '*' is specified.\n\n-i, --id 'generatedSchemaId'\n    The `$id` of the generated schema. If omitted, there will be no `$id`.\n\n-e, --expose <all|none|export>\n    all: Create shared $ref definitions for all types.\n    none: Do not create shared $ref definitions.\n    export (default): Create shared $ref definitions only for exported types (not tagged as `@internal`).\n\n-f, --tsconfig 'my/project/tsconfig.json'\n    Use a custom tsconfig file for processing typescript (see https://www.typescriptlang.org/docs/handbook/tsconfig-json.html) instead of the default:\n    {\n        \"compilerOptions\": {\n            \"noEmit\": true,\n            \"emitDecoratorMetadata\": true,\n            \"experimentalDecorators\": true,\n            \"target\": \"ES5\",\n            \"module\": \"CommonJS\",\n            \"strictNullChecks\": false,\n        }\n    }\n\n-j, --jsDoc <extended|none|basic>\n    none: Do not use JsDoc annotations.\n    basic: Read JsDoc annotations to provide schema properties.\n    extended (default): Also read @nullable, and @asType annotations.\n\n--unstable\n    Do not sort properties.\n\n--strict-tuples\n    Do not allow additional items on tuples.\n\n--no-top-ref\n    Do not create a top-level $ref definition.\n\n--no-type-check\n    Skip type checks for better performance.\n\n--no-ref-encode\n    Do not encode references. According to the standard, references must be valid URIs but some tools do not support encoded references.\n\n--validation-keywords\n    Provide additional validation keywords to include.\n\n-o, --out\n    Specify the output file path. Without this option, the generator logs the response in the console.\n\n--additional-properties <true|false>\n    Controls whether or not to allow additional properties for objects that have no index signature.\n\n    true: Additional properties are allowed\n    false (default): Additional properties are not allowed\n\n--minify\n    Minify generated schema (default: false)\n```\n\n## Current state\n\n-   `interface` types\n-   `enum` types\n-   `union`, `tuple`, `type[]` types\n-   `Date`, `RegExp` types\n-   `string`, `boolean`, `number` types\n-   `\"value\"`, `123`, `true`, `false`, `null`, `undefined` literals\n-   type aliases\n-   generics\n-   `typeof`\n-   `keyof`\n-   conditional types\n\n## Run locally\n\n`yarn --silent run run --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\n## Debug\n\n`yarn --silent run debug --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\nAnd connect via the debugger protocol.\n\n[AST Explorer](https://astexplorer.net/) is amazing for developers of this tool!\n\n## Publish\n\nPublishing is handled by a 2-branch [pre-release process](https://intuit.github.io/auto/docs/generated/shipit#next-branch-default), configured in `publish-auto.yml`. All changes should be based off the default `next` branch, and are published automatically.\n\n-   PRs made into the default branch are auto-deployed to the `next` pre-release tag on NPM. The result can be installed with `npm install ts-json-schema-generator@next`\n    -   When merging into `next`, please use the `squash and merge` strategy.\n-   To release a new stable version, open a PR from `next` into `stable` using this [compare link](https://github.com/vega/ts-json-schema-generator/compare/stable...next).\n    -   When merging from `next` into `stable`, please use the `create a merge commit` strategy.\n",
      "readmeFilename": "README.md",
      "gitHead": "1a935d8dded024c06a0cb2a6a65ad34b5ec32096",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@1.1.1-next.0",
      "_nodeVersion": "16.17.0",
      "_npmVersion": "8.15.0",
      "dist": {
        "integrity": "sha512-2w/q5K9twWDROy65WtIpHj3Mf6+AaqKYFJ2Kw1IJgoYbKALxwz7gN0xhzQC4gQrIXrQcTV+N6zFoLEIaO8pSpQ==",
        "shasum": "3244edc159acd76c87904e43871da31db35d10f2",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-1.1.1-next.0.tgz",
        "fileCount": 708,
        "unpackedSize": 855361,
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEYCIQCMxOElYmE7npeI5NArQkh8OiA9Rr9m66Bjm8jf3W/legIhAMrMmSXzpYZrDgnENTTYdjzTso4VAoC3APo+A89S1Ax0"
          }
        ],
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJjK7XkACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2Vmrxww/9GPIOM2DhKHiA8E6Cz5LVqcL69MMeSJxYo2wkbjOWNg7iB90m\r\nu2Z/GsOeevRuhCx6anptbxdTdITRTb24SLcOvvsjIfdFb3J/GIMA1fGAQeOK\r\nzg0KduCtvKTD6mcdXmpovp1vmrm8jCSQjkI6plMF8s2jaQOlqtdsSfguB6uC\r\nhMvXVeMJq8bL+kxzSyST3sodplkFsaRNX2RuMUPuMpX1pi3CKhY1K1D4/bMB\r\nMPtnhZkjXIArLqyG9TOMTyt0vX8YHvblKzeYL2ff8KPee6NeNIocdN5Q5YH6\r\nGnbohCIL6VZRFEEu+QnhYXi2h3g+4ry2n7oHrGlL+pqBFJEDb6WhVIOjITZq\r\nbdEvoRvL3/U7wTwz+yEuAeuUxVVK2AUmRRYmvnwpiWMnEJTAemt80Edi0C4z\r\nm9jS16jeYnnhz2Uqwzf+w4FADS3NLi3Ogqq+KUts4Q5Xj8rALXxHELGJ10iZ\r\nVVsmbeCHBHaPV1PqyD76lPsmKLQv1jDksMNzqhBd50rcmGlzBFRJfUFuq7m9\r\nb+0P0x8CCeEQ/tRdScOCF367qb9EfaGHANTb+0dEr5VNAza57u2PL+3Eevwp\r\ntdBfWcwBVEz2F5sFnrphP9FsvVxVmoDsOy4UKr3g8WJ0f3EKp8NVXWn9C69B\r\nZkXdMtPbibNLLb5SaKMYoM3dm6Z9ZT0hq48=\r\n=b50b\r\n-----END PGP SIGNATURE-----\r\n"
      },
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "maintainers": [
        {
          "name": "jheer",
          "email": "jeffrey.heer@gmail.com"
        },
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "kanitw",
          "email": "kanitw@gmail.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_1.1.1-next.0_1663808996190_0.024866689064996894"
      },
      "_hasShrinkwrap": false
    },
    "1.1.1": {
      "name": "ts-json-schema-generator",
      "version": "1.1.1",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "MooYeol Prescott Lee",
          "email": "mooyoul@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=10.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.11",
        "commander": "^9.4.0",
        "glob": "^8.0.3",
        "json5": "^2.2.1",
        "normalize-path": "^3.0.0",
        "safe-stable-stringify": "^2.4.0",
        "typescript": "~4.8.3"
      },
      "devDependencies": {
        "@auto-it/conventional-commits": "^10.37.6",
        "@auto-it/first-time-contributor": "^10.37.6",
        "@babel/core": "^7.19.1",
        "@babel/preset-env": "^7.19.1",
        "@babel/preset-typescript": "^7.18.6",
        "@types/glob": "^8.0.0",
        "@types/jest": "^29.0.3",
        "@types/node": "^18.7.18",
        "@types/normalize-path": "^3.0.0",
        "@typescript-eslint/eslint-plugin": "^5.38.0",
        "@typescript-eslint/parser": "^5.38.0",
        "ajv": "^8.11.0",
        "ajv-formats": "^2.1.1",
        "auto": "^10.37.6",
        "chai": "^4.3.6",
        "cross-env": "^7.0.3",
        "eslint": "^8.23.1",
        "eslint-config-prettier": "^8.5.0",
        "eslint-plugin-prettier": "^4.2.1",
        "jest": "^29.0.3",
        "jest-junit": "^14.0.1",
        "prettier": "^2.7.1",
        "ts-node": "^10.9.1",
        "vega": "^5.22.1",
        "vega-lite": "^5.5.0"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint \"{src,test,factory}/**/*.ts\"",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "cross-env FAST_TEST=1 jest test/ --verbose",
        "test:coverage": "yarn jest test/ --collectCoverage=true",
        "test:update": "cross-env UPDATE_SCHEMA=true yarn test:fast",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node-transpile-only ts-json-schema-generator.ts",
        "release": "yarn build && auto shipit"
      },
      "gitHead": "088636094b5be3bcbad238dbf0cf38e21d4698ca",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@1.1.1",
      "_nodeVersion": "16.17.0",
      "_npmVersion": "8.15.0",
      "dist": {
        "integrity": "sha512-QflMS9rbsrR0CXzyuHEhppvmPODP1ETU/C+wdKN2QqDjyfgzsGxcczCYPJPwr1xn8nir9blV3+qRG74pzduv9g==",
        "shasum": "2234d0dc8ede0f5694ba7f0d2f473aae64829413",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-1.1.1.tgz",
        "fileCount": 708,
        "unpackedSize": 855347,
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEYCIQDOAICtuBh5PU5FYasFB+qfVxDLWX4ky+k6FcurG7y4jQIhAMEUFBoNx4l4Gk1nQJiarr3cCHhm5+CT9Xj1y8hFa1iA"
          }
        ],
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJjK7YWACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2VmqKug//fzP5+t/mtg1d7c9C0d3/Y4D89t4SNEg5Z/TNs/LuXjuQAbW6\r\nSSib0PGfC0DLWy3FuGVLHJUsC7x1PtpHLn+wMqvXTKSvi2HPKjbJSfSWp430\r\niM26tNrCKnmVOft81lFh/k/IIFIpGm8VoNWTandyBOc52b/6sR2QcXRbsHpd\r\nCQzJPNqdWCfNgsy/ReeumLUPtWMug12Ko2SBnszzsB36wcyAQrTmPIBdY1TX\r\nluKgLRjYXKAn4Is0R+jvC2f5SXZosmf6vy/F9mP5h76dobokhqOCKH5lVXUC\r\nczZFx1T+Di/Lu7pyD0X9N2h1u9KoI5kRL/E+x8NWKuNoVe+UpzneSAmRRCgG\r\nUXI1zZmzv+J3b6MyGHdx+a6Kwys39YAJaaFBgmfPIrKwn7Ff0wXFgWYpAWRa\r\nh43SbqhGbesWq/oo6zexsSM3hK6+8uQlI+OX21gxAwca/prhqlEcr4dGJ8AB\r\nKB/HP5HR56b/5yOiROTU2VNizhRoP+CH/6LheE4LrntAJrQMebJl3a9gN/Wy\r\nz5ncnYsDr/3zkNLEWgTHDInaqTYUADCSLBVmTmTJ24mmC1ddAY6gQqt0MR4F\r\nqMYg/Y9ItApn6/TF5lP+hee1qWbu5cZRfzlpw+SAU0y7JHVjU32/ncR6P8hc\r\nCiWhpnpdop74bAU+g9zqejMdu+uXAMcwICQ=\r\n=L1Im\r\n-----END PGP SIGNATURE-----\r\n"
      },
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "maintainers": [
        {
          "name": "jheer",
          "email": "jeffrey.heer@gmail.com"
        },
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "kanitw",
          "email": "kanitw@gmail.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_1.1.1_1663809046169_0.8960383576176574"
      },
      "_hasShrinkwrap": false
    },
    "1.1.2-next.0": {
      "name": "ts-json-schema-generator",
      "version": "1.1.2-next.0",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "MooYeol Prescott Lee",
          "email": "mooyoul@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=10.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.11",
        "commander": "^9.4.0",
        "glob": "^8.0.3",
        "json5": "^2.2.1",
        "normalize-path": "^3.0.0",
        "safe-stable-stringify": "^2.4.0",
        "typescript": "~4.8.3"
      },
      "devDependencies": {
        "@auto-it/conventional-commits": "^10.37.6",
        "@auto-it/first-time-contributor": "^10.37.6",
        "@babel/core": "^7.19.1",
        "@babel/preset-env": "^7.19.1",
        "@babel/preset-typescript": "^7.18.6",
        "@types/glob": "^8.0.0",
        "@types/jest": "^29.0.3",
        "@types/node": "^18.7.18",
        "@types/normalize-path": "^3.0.0",
        "@typescript-eslint/eslint-plugin": "^5.38.0",
        "@typescript-eslint/parser": "^5.38.0",
        "ajv": "^8.11.0",
        "ajv-formats": "^2.1.1",
        "auto": "^10.37.6",
        "chai": "^4.3.6",
        "cross-env": "^7.0.3",
        "eslint": "^8.23.1",
        "eslint-config-prettier": "^8.5.0",
        "eslint-plugin-prettier": "^4.2.1",
        "jest": "^29.0.3",
        "jest-junit": "^14.0.1",
        "prettier": "^2.7.1",
        "ts-node": "^10.9.1",
        "vega": "^5.22.1",
        "vega-lite": "^5.5.0"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint \"{src,test,factory}/**/*.ts\"",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "cross-env FAST_TEST=1 jest test/ --verbose",
        "test:coverage": "yarn jest test/ --collectCoverage=true",
        "test:update": "cross-env UPDATE_SCHEMA=true yarn test:fast",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node-transpile-only ts-json-schema-generator.ts",
        "release": "yarn build && auto shipit"
      },
      "readme": "# ts-json-schema-generator\n\n![Test](https://github.com/vega/ts-json-schema-generator/workflows/Test/badge.svg)\n[![codecov](https://codecov.io/gh/vega/ts-json-schema-generator/branch/master/graph/badge.svg)](https://codecov.io/gh/vega/ts-json-schema-generator)\n[![npm version](https://img.shields.io/npm/v/ts-json-schema-generator.svg)](https://www.npmjs.com/package/ts-json-schema-generator)\n\nExtended version of [https://github.com/xiag-ag/typescript-to-json-schema](https://github.com/xiag-ag/typescript-to-json-schema).\n\nInspired by [`YousefED/typescript-json-schema`](https://github.com/YousefED/typescript-json-schema). Here's the differences list:\n\n-   this implementation avoids the use of `typeChecker.getTypeAtLocation()` (so probably it keeps correct type aliases)\n-   processing AST and formatting JSON schema have been split into two independent steps\n-   not exported types, interfaces, enums are not exposed in the `definitions` section in the JSON schema\n\n## Contributors\n\nThis project is made possible by a [community of contributors](https://github.com/vega/ts-json-schema-generator/graphs/contributors). We welcome contributions of any kind (issues, code, documentation, examples, tests,...). Please read our [code of conduct](https://vega.github.io/vega/about/code-of-conduct).\n\n## CLI Usage\n\n```bash\nnpm install --save ts-json-schema-generator\n./node_modules/.bin/ts-json-schema-generator --path 'my/project/**/*.ts' --type 'My.Type.Name'\n```\n\nNote that different platforms (e.g. Windows) may use different path separators so you may have to adjust the command above.\n\n## Programmatic Usage\n\n```js\n// main.js\n\nconst tsj = require(\"ts-json-schema-generator\");\nconst fs = require(\"fs\");\n\n/** @type {import('ts-json-schema-generator/dist/src/Config').Config} */\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst output_path = \"path/to/output/file\";\n\nconst schema = tsj.createGenerator(config).createSchema(config.type);\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\nRun the schema generator via `node main.js`.\n\n### Custom formatting\n\nExtending the built-in formatting is possible by creating a custom formatter and adding it to the main formatter:\n\n1. First we create a formatter, in this case for formatting function types:\n\n```ts\n// my-function-formatter.ts\nimport { BaseType, Definition, FunctionType, SubTypeFormatter } from \"ts-json-schema-generator\";\nimport ts from \"typescript\";\n\nexport class MyFunctionTypeFormatter implements SubTypeFormatter {\n    // You can skip this line if you don't need childTypeFormatter\n    public constructor(private childTypeFormatter: TypeFormatter) {}\n\n    public supportsType(type: FunctionType): boolean {\n        return type instanceof FunctionType;\n    }\n\n    public getDefinition(type: FunctionType): Definition {\n        // Return a custom schema for the function property.\n        return {\n            type: \"object\",\n            properties: {\n                isFunction: {\n                    type: \"boolean\",\n                    const: true,\n                },\n            },\n        };\n    }\n\n    // If this type does NOT HAVE children, generally all you need is:\n    public getChildren(type: FunctionType): BaseType[] {\n        return [];\n    }\n\n    // However, if children ARE supported, you'll need something similar to\n    // this (see src/TypeFormatter/{Array,Definition,etc}.ts for some examples):\n    public getChildren(type: FunctionType): BaseType[] {\n        return this.childTypeFormatter.getChildren(type.getType());\n    }\n}\n```\n\n2. Then we add the formatter as a child to the core formatter using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyFunctionTypeFormatter } from \"./my-function-formatter.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\n// We configure the formatter an add our custom formatter to it.\nconst formatter = createFormatter(config, (fmt, circularReferenceTypeFormatter) => {\n    // If your formatter DOES NOT support children, e.g. getChildren() { return [] }:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter());\n    // If your formatter DOES support children, you'll need this reference too:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter(circularReferenceTypeFormatter));\n});\n\nconst program = createProgram(config);\nconst parser = createParser(program, config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n### Custom parsing\n\nSimilar to custom formatting, extending the built-in parsing works practically the same way:\n\n1. First we create a parser, in this case for parsing construct types:\n\n```ts\n// my-constructor-parser.ts\nimport { Context, StringType, ReferenceType, BaseType, SubNodeParser } from \"ts-json-schema-generator\";\n// use typescript exported by TJS to avoid version conflict\nimport ts from \"ts-json-schema-generator\";\n\nexport class MyConstructorParser implements SubNodeParser {\n    supportsNode(node: ts.Node): boolean {\n        return node.kind === ts.SyntaxKind.ConstructorType;\n    }\n    createType(node: ts.Node, context: Context, reference?: ReferenceType): BaseType | undefined {\n        return new StringType(); // Treat constructors as strings in this example\n    }\n}\n```\n\n2. Then we add the parser as a child to the core parser using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyConstructorParser } from \"./my-constructor-parser.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst program = createProgram(config);\n\n// We configure the parser an add our custom parser to it.\nconst parser = createParser(program, config, (prs) => {\n    prs.addNodeParser(new MyConstructorParser());\n});\n\nconst formatter = createFormatter(config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n## Options\n\n```\n-p, --path 'index.ts'\n    The path to the TypeScript source file. If this is not provided, the type will be searched in the project specified in the `.tsconfig`.\n\n-t, --type 'My.Type.Name'\n    The type the generated schema will represent. If omitted, the generated schema will contain all\n    types found in the files matching path. The same is true if '*' is specified.\n\n-i, --id 'generatedSchemaId'\n    The `$id` of the generated schema. If omitted, there will be no `$id`.\n\n-e, --expose <all|none|export>\n    all: Create shared $ref definitions for all types.\n    none: Do not create shared $ref definitions.\n    export (default): Create shared $ref definitions only for exported types (not tagged as `@internal`).\n\n-f, --tsconfig 'my/project/tsconfig.json'\n    Use a custom tsconfig file for processing typescript (see https://www.typescriptlang.org/docs/handbook/tsconfig-json.html) instead of the default:\n    {\n        \"compilerOptions\": {\n            \"noEmit\": true,\n            \"emitDecoratorMetadata\": true,\n            \"experimentalDecorators\": true,\n            \"target\": \"ES5\",\n            \"module\": \"CommonJS\",\n            \"strictNullChecks\": false,\n        }\n    }\n\n-j, --jsDoc <extended|none|basic>\n    none: Do not use JsDoc annotations.\n    basic: Read JsDoc annotations to provide schema properties.\n    extended (default): Also read @nullable, and @asType annotations.\n\n--unstable\n    Do not sort properties.\n\n--strict-tuples\n    Do not allow additional items on tuples.\n\n--no-top-ref\n    Do not create a top-level $ref definition.\n\n--no-type-check\n    Skip type checks for better performance.\n\n--no-ref-encode\n    Do not encode references. According to the standard, references must be valid URIs but some tools do not support encoded references.\n\n--validation-keywords\n    Provide additional validation keywords to include.\n\n-o, --out\n    Specify the output file path. Without this option, the generator logs the response in the console.\n\n--additional-properties <true|false>\n    Controls whether or not to allow additional properties for objects that have no index signature.\n\n    true: Additional properties are allowed\n    false (default): Additional properties are not allowed\n\n--minify\n    Minify generated schema (default: false)\n```\n\n## Current state\n\n-   `interface` types\n-   `enum` types\n-   `union`, `tuple`, `type[]` types\n-   `Date`, `RegExp` types\n-   `string`, `boolean`, `number` types\n-   `\"value\"`, `123`, `true`, `false`, `null`, `undefined` literals\n-   type aliases\n-   generics\n-   `typeof`\n-   `keyof`\n-   conditional types\n\n## Run locally\n\n`yarn --silent run run --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\n## Debug\n\n`yarn --silent run debug --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\nAnd connect via the debugger protocol.\n\n[AST Explorer](https://astexplorer.net/) is amazing for developers of this tool!\n\n## Publish\n\nPublishing is handled by a 2-branch [pre-release process](https://intuit.github.io/auto/docs/generated/shipit#next-branch-default), configured in `publish-auto.yml`. All changes should be based off the default `next` branch, and are published automatically.\n\n-   PRs made into the default branch are auto-deployed to the `next` pre-release tag on NPM. The result can be installed with `npm install ts-json-schema-generator@next`\n    -   When merging into `next`, please use the `squash and merge` strategy.\n-   To release a new stable version, open a PR from `next` into `stable` using this [compare link](https://github.com/vega/ts-json-schema-generator/compare/stable...next).\n    -   When merging from `next` into `stable`, please use the `create a merge commit` strategy.\n",
      "readmeFilename": "README.md",
      "gitHead": "278e79186135d55fbc094e48939eb2ea148ffda3",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@1.1.2-next.0",
      "_nodeVersion": "16.17.0",
      "_npmVersion": "8.15.0",
      "dist": {
        "integrity": "sha512-tqgTSoqcMMgifPY+6z47Z07R///N/ob0qqT6cZEraFESYL+DQkwT6pYgBA4+TviOLKllp8FqVEs9TzRlq78AlQ==",
        "shasum": "f8d5fdd3631edd6088ccb8dea1d7301bef5c213d",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-1.1.2-next.0.tgz",
        "fileCount": 708,
        "unpackedSize": 855759,
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIQCFyiXh1lsLnhORcqi//n3bHEMXmTtaN1T8XZ/zTO84+AIgRTfFkzKe36cms2cNXavqw/ALhuH/P+iTmLn1iiUTL+o="
          }
        ],
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJjL7saACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2VmoZxw//cZc9yaaKy1GogEPTgCGmQe4dyHYAGuDD0y5ltvKjrPH+6UzY\r\nDjEAPdroUZZ5bgiTJr3XnpoHFyUQSvs6aFgA92pDI5hyepNt+DNy8Q5Mjcog\r\nk6/UW98sB4jrNwdYE3X6dJFPkNolTLhMqc13YJ3qYlu3Is1OyqMf2JqjPWPd\r\nj6ZLPr3kh4ptudMDToUmd+MqE0VXQOxAdJSHopMGFiT+dIbA7V7aPMXSzAZ7\r\nVadLpoypmUMeYrR6fMbKuMYyrZR47kSAlF4ZDjLoCY30Da/i5nQYWLzTGx4E\r\n1O0/+bsnvUV/oGAWnh7fkFsRkAZbfSry/SD7/4T4yojJJvPsBH8pr2iJGOCI\r\nFF/iuJN2EsTq5h3/CgWY9x8Syhj/JuCy1wPs+2BUW2Gr5xim2r/svcpQTnC9\r\n+34GysGL9WnsVaaetCte8AndtGZIbBcSmv1sdbzNoBoo2egfKGTDxPf+pLiI\r\nAL5cYS65l/0Hkm41xVIuJMIJlRoV6V74getgiOXSGuPqNGHxIsShTO9/8oeF\r\ncy8D53M6PYxxGhaACY/aSF9uBEh76JvplhLLrSn5VDwMPE12HPlBkWDOYyLS\r\nlA5/I0KnERJo/Q33hJGs6yRZBCz0/tAfW3E9kVBkWeEKZzqQKQs+X8/7tdu4\r\nioHzXN8fd8Lm/LmSUkkh20apaP0VbxkaSIo=\r\n=MVlB\r\n-----END PGP SIGNATURE-----\r\n"
      },
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "maintainers": [
        {
          "name": "jheer",
          "email": "jeffrey.heer@gmail.com"
        },
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "kanitw",
          "email": "kanitw@gmail.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_1.1.2-next.0_1664072474620_0.05956195657608854"
      },
      "_hasShrinkwrap": false
    },
    "1.1.2": {
      "name": "ts-json-schema-generator",
      "version": "1.1.2",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "MooYeol Prescott Lee",
          "email": "mooyoul@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=10.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.11",
        "commander": "^9.4.0",
        "glob": "^8.0.3",
        "json5": "^2.2.1",
        "normalize-path": "^3.0.0",
        "safe-stable-stringify": "^2.4.0",
        "typescript": "~4.8.3"
      },
      "devDependencies": {
        "@auto-it/conventional-commits": "^10.37.6",
        "@auto-it/first-time-contributor": "^10.37.6",
        "@babel/core": "^7.19.1",
        "@babel/preset-env": "^7.19.1",
        "@babel/preset-typescript": "^7.18.6",
        "@types/glob": "^8.0.0",
        "@types/jest": "^29.0.3",
        "@types/node": "^18.7.18",
        "@types/normalize-path": "^3.0.0",
        "@typescript-eslint/eslint-plugin": "^5.38.0",
        "@typescript-eslint/parser": "^5.38.0",
        "ajv": "^8.11.0",
        "ajv-formats": "^2.1.1",
        "auto": "^10.37.6",
        "chai": "^4.3.6",
        "cross-env": "^7.0.3",
        "eslint": "^8.23.1",
        "eslint-config-prettier": "^8.5.0",
        "eslint-plugin-prettier": "^4.2.1",
        "jest": "^29.0.3",
        "jest-junit": "^14.0.1",
        "prettier": "^2.7.1",
        "ts-node": "^10.9.1",
        "vega": "^5.22.1",
        "vega-lite": "^5.5.0"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint \"{src,test,factory}/**/*.ts\"",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "cross-env FAST_TEST=1 jest test/ --verbose",
        "test:coverage": "yarn jest test/ --collectCoverage=true",
        "test:update": "cross-env UPDATE_SCHEMA=true yarn test:fast",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node-transpile-only ts-json-schema-generator.ts",
        "release": "yarn build && auto shipit"
      },
      "gitHead": "9babda4afd7f83fb4cf2b3c8598032bea38d284b",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@1.1.2",
      "_nodeVersion": "16.17.0",
      "_npmVersion": "8.15.0",
      "dist": {
        "integrity": "sha512-XMnxvndJFJEYv3NBmW7Po5bGajKdK2qH8Q078eDy60srK9+nEvbT9nLCRKd2IV/RQ7a+oc5FNylvZWveqh7jeQ==",
        "shasum": "29a0c878733b6a1bb0346fce02b1ebb8b96effa3",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-1.1.2.tgz",
        "fileCount": 708,
        "unpackedSize": 856063,
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEQCIBubLnqLwf8sbmRt+k0fZsPre++yyxLF6U2d8Yc+cbFCAiA+D20AWmusBEhwHOVpvwYsSqLNges/lUpSN9h8pJ5LRQ=="
          }
        ],
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJjNLWlACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2VmpKnw//YZ+OO2sGYUC3rtGwAaHsIGLBxDsHeEujHrfn/82kOLR83IhL\r\n6EfijRu2I/okKMXLiIcaozIJb6bGXyhblWCf0wBQtKJlLWhep+cZgskPqeqA\r\n24Up0ILHLqMncM/bW9kfX9AUT9IPYYtDU03DnmUTriV3nsLngaI21rPguQxa\r\n3FJFfXjPm55hitR/hQSJZv/6wGL9BpQ1iWMJTuBs/a4oWv8dv7u3xjYQ2Fuo\r\naupMSS5PJpleyOnSK0hkPP3zseI2G/PJfFVGkc2Qqm1NVhGnmAlUmlg1+RGW\r\nSubftbfw5ZoL1RSJ/bgmVXcqQoFwiycN+drsuQo9Yr+0Y8qi4d1UYaG9EvDh\r\nvS0HhePyl747ioQ8Y+kxDK4b994ttoqzg9TnT+YdUshrjbbI/n/2lWcEKlKS\r\nGusxdanUVLLBw8UTHnHz8N2J2IPl15XwTEO/gTZzqYlkcAJL/DuM3i8M7W0H\r\nzKRdnDMOxVI8bDazn7KNYpBbZ5Vg+gfy1Eq78WFLv9txr8a5zhOO23gcC1AA\r\naYi9QeRq/Px/mHLsCfWeNmhkQfy2zKZphLegfi1t7nO8wYpg2lZqiEmwn357\r\nNPkAW7M13u8oWqtjDerNXYVZezI3LpYWq8cAmNEKFldXew/p6/gF72x51XPK\r\n+CDpF2Wl4ekyymSrjacTC95G/4YWNDTLXnA=\r\n=4Lkz\r\n-----END PGP SIGNATURE-----\r\n"
      },
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "maintainers": [
        {
          "name": "jheer",
          "email": "jeffrey.heer@gmail.com"
        },
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "kanitw",
          "email": "kanitw@gmail.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_1.1.2_1664398756993_0.9112799476226574"
      },
      "_hasShrinkwrap": false
    },
    "1.2.0-next.0": {
      "name": "ts-json-schema-generator",
      "version": "1.2.0-next.0",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "MooYeol Prescott Lee",
          "email": "mooyoul@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=10.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.11",
        "commander": "^9.4.0",
        "glob": "^8.0.3",
        "json5": "^2.2.1",
        "normalize-path": "^3.0.0",
        "safe-stable-stringify": "^2.4.0",
        "typescript": "~4.8.3"
      },
      "devDependencies": {
        "@auto-it/conventional-commits": "^10.37.6",
        "@auto-it/first-time-contributor": "^10.37.6",
        "@babel/core": "^7.19.1",
        "@babel/preset-env": "^7.19.1",
        "@babel/preset-typescript": "^7.18.6",
        "@types/glob": "^8.0.0",
        "@types/jest": "^29.0.3",
        "@types/node": "^18.7.18",
        "@types/normalize-path": "^3.0.0",
        "@typescript-eslint/eslint-plugin": "^5.38.0",
        "@typescript-eslint/parser": "^5.38.0",
        "ajv": "^8.11.0",
        "ajv-formats": "^2.1.1",
        "auto": "^10.37.6",
        "chai": "^4.3.6",
        "cross-env": "^7.0.3",
        "eslint": "^8.23.1",
        "eslint-config-prettier": "^8.5.0",
        "eslint-plugin-prettier": "^4.2.1",
        "jest": "^29.0.3",
        "jest-junit": "^14.0.1",
        "prettier": "^2.7.1",
        "ts-node": "^10.9.1",
        "vega": "^5.22.1",
        "vega-lite": "^5.5.0"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint \"{src,test,factory}/**/*.ts\"",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "cross-env FAST_TEST=1 jest test/ --verbose",
        "test:coverage": "yarn jest test/ --collectCoverage=true",
        "test:update": "cross-env UPDATE_SCHEMA=true yarn test:fast",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node-transpile-only ts-json-schema-generator.ts",
        "release": "yarn build && auto shipit"
      },
      "readme": "# ts-json-schema-generator\n\n![Test](https://github.com/vega/ts-json-schema-generator/workflows/Test/badge.svg)\n[![codecov](https://codecov.io/gh/vega/ts-json-schema-generator/branch/master/graph/badge.svg)](https://codecov.io/gh/vega/ts-json-schema-generator)\n[![npm version](https://img.shields.io/npm/v/ts-json-schema-generator.svg)](https://www.npmjs.com/package/ts-json-schema-generator)\n\nExtended version of [https://github.com/xiag-ag/typescript-to-json-schema](https://github.com/xiag-ag/typescript-to-json-schema).\n\nInspired by [`YousefED/typescript-json-schema`](https://github.com/YousefED/typescript-json-schema). Here's the differences list:\n\n-   this implementation avoids the use of `typeChecker.getTypeAtLocation()` (so probably it keeps correct type aliases)\n-   processing AST and formatting JSON schema have been split into two independent steps\n-   not exported types, interfaces, enums are not exposed in the `definitions` section in the JSON schema\n\n## Contributors\n\nThis project is made possible by a [community of contributors](https://github.com/vega/ts-json-schema-generator/graphs/contributors). We welcome contributions of any kind (issues, code, documentation, examples, tests,...). Please read our [code of conduct](https://vega.github.io/vega/about/code-of-conduct).\n\n## CLI Usage\n\n```bash\nnpm install --save ts-json-schema-generator\n./node_modules/.bin/ts-json-schema-generator --path 'my/project/**/*.ts' --type 'My.Type.Name'\n```\n\nNote that different platforms (e.g. Windows) may use different path separators so you may have to adjust the command above.\n\n## Programmatic Usage\n\n```js\n// main.js\n\nconst tsj = require(\"ts-json-schema-generator\");\nconst fs = require(\"fs\");\n\n/** @type {import('ts-json-schema-generator/dist/src/Config').Config} */\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst output_path = \"path/to/output/file\";\n\nconst schema = tsj.createGenerator(config).createSchema(config.type);\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\nRun the schema generator via `node main.js`.\n\n### Custom formatting\n\nExtending the built-in formatting is possible by creating a custom formatter and adding it to the main formatter:\n\n1. First we create a formatter, in this case for formatting function types:\n\n```ts\n// my-function-formatter.ts\nimport { BaseType, Definition, FunctionType, SubTypeFormatter } from \"ts-json-schema-generator\";\nimport ts from \"typescript\";\n\nexport class MyFunctionTypeFormatter implements SubTypeFormatter {\n    // You can skip this line if you don't need childTypeFormatter\n    public constructor(private childTypeFormatter: TypeFormatter) {}\n\n    public supportsType(type: FunctionType): boolean {\n        return type instanceof FunctionType;\n    }\n\n    public getDefinition(type: FunctionType): Definition {\n        // Return a custom schema for the function property.\n        return {\n            type: \"object\",\n            properties: {\n                isFunction: {\n                    type: \"boolean\",\n                    const: true,\n                },\n            },\n        };\n    }\n\n    // If this type does NOT HAVE children, generally all you need is:\n    public getChildren(type: FunctionType): BaseType[] {\n        return [];\n    }\n\n    // However, if children ARE supported, you'll need something similar to\n    // this (see src/TypeFormatter/{Array,Definition,etc}.ts for some examples):\n    public getChildren(type: FunctionType): BaseType[] {\n        return this.childTypeFormatter.getChildren(type.getType());\n    }\n}\n```\n\n2. Then we add the formatter as a child to the core formatter using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyFunctionTypeFormatter } from \"./my-function-formatter.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\n// We configure the formatter an add our custom formatter to it.\nconst formatter = createFormatter(config, (fmt, circularReferenceTypeFormatter) => {\n    // If your formatter DOES NOT support children, e.g. getChildren() { return [] }:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter());\n    // If your formatter DOES support children, you'll need this reference too:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter(circularReferenceTypeFormatter));\n});\n\nconst program = createProgram(config);\nconst parser = createParser(program, config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n### Custom parsing\n\nSimilar to custom formatting, extending the built-in parsing works practically the same way:\n\n1. First we create a parser, in this case for parsing construct types:\n\n```ts\n// my-constructor-parser.ts\nimport { Context, StringType, ReferenceType, BaseType, SubNodeParser } from \"ts-json-schema-generator\";\n// use typescript exported by TJS to avoid version conflict\nimport ts from \"ts-json-schema-generator\";\n\nexport class MyConstructorParser implements SubNodeParser {\n    supportsNode(node: ts.Node): boolean {\n        return node.kind === ts.SyntaxKind.ConstructorType;\n    }\n    createType(node: ts.Node, context: Context, reference?: ReferenceType): BaseType | undefined {\n        return new StringType(); // Treat constructors as strings in this example\n    }\n}\n```\n\n2. Then we add the parser as a child to the core parser using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyConstructorParser } from \"./my-constructor-parser.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst program = createProgram(config);\n\n// We configure the parser an add our custom parser to it.\nconst parser = createParser(program, config, (prs) => {\n    prs.addNodeParser(new MyConstructorParser());\n});\n\nconst formatter = createFormatter(config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n## Options\n\n```\n-p, --path 'index.ts'\n    The path to the TypeScript source file. If this is not provided, the type will be searched in the project specified in the `.tsconfig`.\n\n-t, --type 'My.Type.Name'\n    The type the generated schema will represent. If omitted, the generated schema will contain all\n    types found in the files matching path. The same is true if '*' is specified.\n\n-i, --id 'generatedSchemaId'\n    The `$id` of the generated schema. If omitted, there will be no `$id`.\n\n-e, --expose <all|none|export>\n    all: Create shared $ref definitions for all types.\n    none: Do not create shared $ref definitions.\n    export (default): Create shared $ref definitions only for exported types (not tagged as `@internal`).\n\n-f, --tsconfig 'my/project/tsconfig.json'\n    Use a custom tsconfig file for processing typescript (see https://www.typescriptlang.org/docs/handbook/tsconfig-json.html) instead of the default:\n    {\n        \"compilerOptions\": {\n            \"noEmit\": true,\n            \"emitDecoratorMetadata\": true,\n            \"experimentalDecorators\": true,\n            \"target\": \"ES5\",\n            \"module\": \"CommonJS\",\n            \"strictNullChecks\": false,\n        }\n    }\n\n-j, --jsDoc <extended|none|basic>\n    none: Do not use JsDoc annotations.\n    basic: Read JsDoc annotations to provide schema properties.\n    extended (default): Also read @nullable, and @asType annotations.\n\n--unstable\n    Do not sort properties.\n\n--strict-tuples\n    Do not allow additional items on tuples.\n\n--no-top-ref\n    Do not create a top-level $ref definition.\n\n--no-type-check\n    Skip type checks for better performance.\n\n--no-ref-encode\n    Do not encode references. According to the standard, references must be valid URIs but some tools do not support encoded references.\n\n--validation-keywords\n    Provide additional validation keywords to include.\n\n-o, --out\n    Specify the output file path. Without this option, the generator logs the response in the console.\n\n--additional-properties <true|false>\n    Controls whether or not to allow additional properties for objects that have no index signature.\n\n    true: Additional properties are allowed\n    false (default): Additional properties are not allowed\n\n--minify\n    Minify generated schema (default: false)\n```\n\n## Current state\n\n-   `interface` types\n-   `enum` types\n-   `union`, `tuple`, `type[]` types\n-   `Date`, `RegExp` types\n-   `string`, `boolean`, `number` types\n-   `\"value\"`, `123`, `true`, `false`, `null`, `undefined` literals\n-   type aliases\n-   generics\n-   `typeof`\n-   `keyof`\n-   conditional types\n\n## Run locally\n\n`yarn --silent run run --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\n## Debug\n\n`yarn --silent run debug --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\nAnd connect via the debugger protocol.\n\n[AST Explorer](https://astexplorer.net/) is amazing for developers of this tool!\n\n## Publish\n\nPublishing is handled by a 2-branch [pre-release process](https://intuit.github.io/auto/docs/generated/shipit#next-branch-default), configured in `publish-auto.yml`. All changes should be based off the default `next` branch, and are published automatically.\n\n-   PRs made into the default branch are auto-deployed to the `next` pre-release tag on NPM. The result can be installed with `npm install ts-json-schema-generator@next`\n    -   When merging into `next`, please use the `squash and merge` strategy.\n-   To release a new stable version, open a PR from `next` into `stable` using this [compare link](https://github.com/vega/ts-json-schema-generator/compare/stable...next).\n    -   When merging from `next` into `stable`, please use the `create a merge commit` strategy.\n",
      "readmeFilename": "README.md",
      "gitHead": "028906c80c98f27479c2c63eb11fc331ab65ecbe",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@1.2.0-next.0",
      "_nodeVersion": "16.17.1",
      "_npmVersion": "8.15.0",
      "dist": {
        "integrity": "sha512-32dIpv2BOfXXesBY8Srd+Lq0pbpF6JMmh9mYRP5uvaY+IR70xBk+Y1++V8G+bY1Dl9HVyTu8Qz+fHCdHIhUY1w==",
        "shasum": "03841dddf2e03fb074fb12e25e8abec2bd9cdb2f",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-1.2.0-next.0.tgz",
        "fileCount": 708,
        "unpackedSize": 858107,
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEQCIHWMn+tSigdxjK9S8uYvc3FhPNHRgSNxL6IGduvG11FFAiBjUub6l/dOaNe9FZvJbMDD4cQIMOf6DS4+12LxlVVL6Q=="
          }
        ],
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJjTA9fACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2VmrngQ//SPvk753OKerkm8uETZFr3zT+RomTU4sjj3LHCUpBY0IPNUWg\r\nMwlMVjMF+krdgMJ26+D8Cg6txTX0TJ1J2QGHnVsx2KmVgTZOdBgquo6Yn9yL\r\nq6SaEsf/u2mxuOe+s4GGPHlkYI14siKo0LyXjyIITFSLOIDxC0Kexg+Q+x/C\r\nu9gyQd96upBUZ47wx1Kg1xAEsyCLaScs/1sQVzTnpptVwRH3a5VoVeGrO/Hg\r\nrS6WjS5A4LWX44oGZbZD0XsxTpv53DVPOJBjNMvNRKB8j2vQhD2rH2vF9L+B\r\nc51r1Ng6/HA/uu8uFKJ/PL8gm5euc9avdaR83dkpt66JO3bHRrMPC1wt2SHC\r\n9RviryPpuM2X5QveFa7siqNDIeihRMwwQ6XR8zunckVy4P8cmf3N1S9q+ln2\r\n91+won6p0ekiUcdnG0EQKrG43LD3tedBcHQW/jlAl66/tHGYI1fYgKsu1d18\r\nkYn/qDXBQU0kZXaJaygoF6Oh8TZYaQIoUFrdB7MPGnIq/z9C5zhHj04XuYU6\r\nFY+sc39DgjovZoAwMZ27+znMUBPTG3eFvW837R3a4pI8Mo5wrTJ2erEz/WQF\r\nFFKkvgOlK7bVCT4PRmLvfQBHZlqLsTzUaO+VDqc8osHyD4b2DV+3HVis+4xT\r\nKhraqbA4xkiDtNzRIUL4kdNnKsws5XwWH3o=\r\n=4Kew\r\n-----END PGP SIGNATURE-----\r\n"
      },
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "maintainers": [
        {
          "name": "jheer",
          "email": "jeffrey.heer@gmail.com"
        },
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "kanitw",
          "email": "kanitw@gmail.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_1.2.0-next.0_1665929055186_0.5966456135482838"
      },
      "_hasShrinkwrap": false
    },
    "1.2.0-next.1": {
      "name": "ts-json-schema-generator",
      "version": "1.2.0-next.1",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "MooYeol Prescott Lee",
          "email": "mooyoul@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=10.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.11",
        "commander": "^9.4.0",
        "glob": "^8.0.3",
        "json5": "^2.2.1",
        "normalize-path": "^3.0.0",
        "safe-stable-stringify": "^2.4.0",
        "typescript": "~4.8.3"
      },
      "devDependencies": {
        "@auto-it/conventional-commits": "^10.37.6",
        "@auto-it/first-time-contributor": "^10.37.6",
        "@babel/core": "^7.19.1",
        "@babel/preset-env": "^7.19.1",
        "@babel/preset-typescript": "^7.18.6",
        "@types/glob": "^8.0.0",
        "@types/jest": "^29.0.3",
        "@types/node": "^18.7.18",
        "@types/normalize-path": "^3.0.0",
        "@typescript-eslint/eslint-plugin": "^5.38.0",
        "@typescript-eslint/parser": "^5.38.0",
        "ajv": "^8.11.0",
        "ajv-formats": "^2.1.1",
        "auto": "^10.37.6",
        "chai": "^4.3.6",
        "cross-env": "^7.0.3",
        "eslint": "^8.23.1",
        "eslint-config-prettier": "^8.5.0",
        "eslint-plugin-prettier": "^4.2.1",
        "jest": "^29.0.3",
        "jest-junit": "^14.0.1",
        "prettier": "^2.7.1",
        "ts-node": "^10.9.1",
        "vega": "^5.22.1",
        "vega-lite": "^5.5.0"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint \"{src,test,factory}/**/*.ts\"",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "cross-env FAST_TEST=1 jest test/ --verbose",
        "test:coverage": "yarn jest test/ --collectCoverage=true",
        "test:update": "cross-env UPDATE_SCHEMA=true yarn test:fast",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node-transpile-only ts-json-schema-generator.ts",
        "release": "yarn build && auto shipit"
      },
      "readme": "# ts-json-schema-generator\n\n![Test](https://github.com/vega/ts-json-schema-generator/workflows/Test/badge.svg)\n[![codecov](https://codecov.io/gh/vega/ts-json-schema-generator/branch/master/graph/badge.svg)](https://codecov.io/gh/vega/ts-json-schema-generator)\n[![npm version](https://img.shields.io/npm/v/ts-json-schema-generator.svg)](https://www.npmjs.com/package/ts-json-schema-generator)\n\nExtended version of [https://github.com/xiag-ag/typescript-to-json-schema](https://github.com/xiag-ag/typescript-to-json-schema).\n\nInspired by [`YousefED/typescript-json-schema`](https://github.com/YousefED/typescript-json-schema). Here's the differences list:\n\n-   this implementation avoids the use of `typeChecker.getTypeAtLocation()` (so probably it keeps correct type aliases)\n-   processing AST and formatting JSON schema have been split into two independent steps\n-   not exported types, interfaces, enums are not exposed in the `definitions` section in the JSON schema\n\n## Contributors\n\nThis project is made possible by a [community of contributors](https://github.com/vega/ts-json-schema-generator/graphs/contributors). We welcome contributions of any kind (issues, code, documentation, examples, tests,...). Please read our [code of conduct](https://vega.github.io/vega/about/code-of-conduct).\n\n## CLI Usage\n\n```bash\nnpm install --save ts-json-schema-generator\n./node_modules/.bin/ts-json-schema-generator --path 'my/project/**/*.ts' --type 'My.Type.Name'\n```\n\nNote that different platforms (e.g. Windows) may use different path separators so you may have to adjust the command above.\n\n## Programmatic Usage\n\n```js\n// main.js\n\nconst tsj = require(\"ts-json-schema-generator\");\nconst fs = require(\"fs\");\n\n/** @type {import('ts-json-schema-generator/dist/src/Config').Config} */\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst output_path = \"path/to/output/file\";\n\nconst schema = tsj.createGenerator(config).createSchema(config.type);\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\nRun the schema generator via `node main.js`.\n\n### Custom formatting\n\nExtending the built-in formatting is possible by creating a custom formatter and adding it to the main formatter:\n\n1. First we create a formatter, in this case for formatting function types:\n\n```ts\n// my-function-formatter.ts\nimport { BaseType, Definition, FunctionType, SubTypeFormatter } from \"ts-json-schema-generator\";\nimport ts from \"typescript\";\n\nexport class MyFunctionTypeFormatter implements SubTypeFormatter {\n    // You can skip this line if you don't need childTypeFormatter\n    public constructor(private childTypeFormatter: TypeFormatter) {}\n\n    public supportsType(type: FunctionType): boolean {\n        return type instanceof FunctionType;\n    }\n\n    public getDefinition(type: FunctionType): Definition {\n        // Return a custom schema for the function property.\n        return {\n            type: \"object\",\n            properties: {\n                isFunction: {\n                    type: \"boolean\",\n                    const: true,\n                },\n            },\n        };\n    }\n\n    // If this type does NOT HAVE children, generally all you need is:\n    public getChildren(type: FunctionType): BaseType[] {\n        return [];\n    }\n\n    // However, if children ARE supported, you'll need something similar to\n    // this (see src/TypeFormatter/{Array,Definition,etc}.ts for some examples):\n    public getChildren(type: FunctionType): BaseType[] {\n        return this.childTypeFormatter.getChildren(type.getType());\n    }\n}\n```\n\n2. Then we add the formatter as a child to the core formatter using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyFunctionTypeFormatter } from \"./my-function-formatter.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\n// We configure the formatter an add our custom formatter to it.\nconst formatter = createFormatter(config, (fmt, circularReferenceTypeFormatter) => {\n    // If your formatter DOES NOT support children, e.g. getChildren() { return [] }:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter());\n    // If your formatter DOES support children, you'll need this reference too:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter(circularReferenceTypeFormatter));\n});\n\nconst program = createProgram(config);\nconst parser = createParser(program, config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n### Custom parsing\n\nSimilar to custom formatting, extending the built-in parsing works practically the same way:\n\n1. First we create a parser, in this case for parsing construct types:\n\n```ts\n// my-constructor-parser.ts\nimport { Context, StringType, ReferenceType, BaseType, SubNodeParser } from \"ts-json-schema-generator\";\n// use typescript exported by TJS to avoid version conflict\nimport ts from \"ts-json-schema-generator\";\n\nexport class MyConstructorParser implements SubNodeParser {\n    supportsNode(node: ts.Node): boolean {\n        return node.kind === ts.SyntaxKind.ConstructorType;\n    }\n    createType(node: ts.Node, context: Context, reference?: ReferenceType): BaseType | undefined {\n        return new StringType(); // Treat constructors as strings in this example\n    }\n}\n```\n\n2. Then we add the parser as a child to the core parser using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyConstructorParser } from \"./my-constructor-parser.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst program = createProgram(config);\n\n// We configure the parser an add our custom parser to it.\nconst parser = createParser(program, config, (prs) => {\n    prs.addNodeParser(new MyConstructorParser());\n});\n\nconst formatter = createFormatter(config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n## Options\n\n```\n-p, --path 'index.ts'\n    The path to the TypeScript source file. If this is not provided, the type will be searched in the project specified in the `.tsconfig`.\n\n-t, --type 'My.Type.Name'\n    The type the generated schema will represent. If omitted, the generated schema will contain all\n    types found in the files matching path. The same is true if '*' is specified.\n\n-i, --id 'generatedSchemaId'\n    The `$id` of the generated schema. If omitted, there will be no `$id`.\n\n-e, --expose <all|none|export>\n    all: Create shared $ref definitions for all types.\n    none: Do not create shared $ref definitions.\n    export (default): Create shared $ref definitions only for exported types (not tagged as `@internal`).\n\n-f, --tsconfig 'my/project/tsconfig.json'\n    Use a custom tsconfig file for processing typescript (see https://www.typescriptlang.org/docs/handbook/tsconfig-json.html) instead of the default:\n    {\n        \"compilerOptions\": {\n            \"noEmit\": true,\n            \"emitDecoratorMetadata\": true,\n            \"experimentalDecorators\": true,\n            \"target\": \"ES5\",\n            \"module\": \"CommonJS\",\n            \"strictNullChecks\": false,\n        }\n    }\n\n-j, --jsDoc <extended|none|basic>\n    none: Do not use JsDoc annotations.\n    basic: Read JsDoc annotations to provide schema properties.\n    extended (default): Also read @nullable, and @asType annotations.\n\n--unstable\n    Do not sort properties.\n\n--strict-tuples\n    Do not allow additional items on tuples.\n\n--no-top-ref\n    Do not create a top-level $ref definition.\n\n--no-type-check\n    Skip type checks for better performance.\n\n--no-ref-encode\n    Do not encode references. According to the standard, references must be valid URIs but some tools do not support encoded references.\n\n--validation-keywords\n    Provide additional validation keywords to include.\n\n-o, --out\n    Specify the output file path. Without this option, the generator logs the response in the console.\n\n--additional-properties <true|false>\n    Controls whether or not to allow additional properties for objects that have no index signature.\n\n    true: Additional properties are allowed\n    false (default): Additional properties are not allowed\n\n--minify\n    Minify generated schema (default: false)\n```\n\n## Current state\n\n-   `interface` types\n-   `enum` types\n-   `union`, `tuple`, `type[]` types\n-   `Date`, `RegExp` types\n-   `string`, `boolean`, `number` types\n-   `\"value\"`, `123`, `true`, `false`, `null`, `undefined` literals\n-   type aliases\n-   generics\n-   `typeof`\n-   `keyof`\n-   conditional types\n\n## Run locally\n\n`yarn --silent run run --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\n## Debug\n\n`yarn --silent run debug --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\nAnd connect via the debugger protocol.\n\n[AST Explorer](https://astexplorer.net/) is amazing for developers of this tool!\n\n## Publish\n\nPublishing is handled by a 2-branch [pre-release process](https://intuit.github.io/auto/docs/generated/shipit#next-branch-default), configured in `publish-auto.yml`. All changes should be based off the default `next` branch, and are published automatically.\n\n-   PRs made into the default branch are auto-deployed to the `next` pre-release tag on NPM. The result can be installed with `npm install ts-json-schema-generator@next`\n    -   When merging into `next`, please use the `squash and merge` strategy.\n-   To release a new stable version, open a PR from `next` into `stable` using this [compare link](https://github.com/vega/ts-json-schema-generator/compare/stable...next).\n    -   When merging from `next` into `stable`, please use the `create a merge commit` strategy.\n",
      "readmeFilename": "README.md",
      "gitHead": "a1ef3031b14f70a307c6e0a2c429eaa075fa287d",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@1.2.0-next.1",
      "_nodeVersion": "16.17.1",
      "_npmVersion": "8.15.0",
      "dist": {
        "integrity": "sha512-hXEVOkmAJzcjTW5t3+5ZVfcPFNyCDr21gBeo930YOwOj8g8VMXWc4DIamjGRkME7KltvCiUCQCVJCFgbMPc7Rw==",
        "shasum": "fea004a4a72656cb6d46bfdcd24b80bac12ad1e5",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-1.2.0-next.1.tgz",
        "fileCount": 708,
        "unpackedSize": 859762,
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCICT0+Rw3YTUWEEWuWHxqhY4eiHZYxvItz4MjzrtQapiaAiEAipWuFiWBLM1CgWZlK6Hoc3SCrj17SsX5mPuoq49WKO8="
          }
        ],
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJjTVN/ACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2Vmr/Hw/9FwHzV+s0opgzKYJ+EF6avdUmo+BV75ZHRJU+jvv2/oM++SiN\r\n7gTNC60YuAMqjpTigcElVIA4wTCi1cd3eHvdes49b0Sb8hs+8QK3F6xbxZXS\r\nPMDT8+K1Nib27w+kx4Pqh52o7OQOD6kPnovPPohbjyzhMygx1r76ub9gMoCy\r\nNCv2WmGdrUj7VUSphgYLes5mhNY7p47NzQ/ol1JHXoL2GxQEBLf2xfB8aLrd\r\nh3718P50uBVAkXS54jPKPtC3ABBbcLJvBHQRVQXkwTpn8uXB0NWMkeNlYbUc\r\nrWEli0O3uSsQL7HO2D2jlVRpHHHhS/YXx2DbMZtaHi4diDXHEQB1mK7osxC6\r\nRqDr8xegx+T2cKXFQ2YSDYb5AXVnAmFRKgeUy+Pi/zrDWsgqZPn/Xi32zCoz\r\n+nrv+/0yGxXcH9J4YWnFquD+PDSTDokKcPDYiP09NfuK9W7dzJ4GhfFMrH1P\r\n76DXcFaiNq0Dsd1h14wOTgUR1yO2cxlDMVNWsE5Xd+NPgVIQwmm3H/X7jiEe\r\nAzpdMf+fimwBCy+Trh67ngiE3Ve2nzkElIwBNk/WDeTxVDHWVzSxPrLb7Z1Z\r\nA/8XepF7qbzuCUEvCbUSnUUr2uGSlCpriM0FAr6ouY7O7VVa3YxsIRYy7EIB\r\n8vEwOe127ZTwceRECQBUXlxatT5wuq+OhP4=\r\n=ROx+\r\n-----END PGP SIGNATURE-----\r\n"
      },
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "maintainers": [
        {
          "name": "jheer",
          "email": "jeffrey.heer@gmail.com"
        },
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "kanitw",
          "email": "kanitw@gmail.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_1.2.0-next.1_1666012031180_0.7649483237577228"
      },
      "_hasShrinkwrap": false
    },
    "1.2.0-next.2": {
      "name": "ts-json-schema-generator",
      "version": "1.2.0-next.2",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "MooYeol Prescott Lee",
          "email": "mooyoul@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=10.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.11",
        "commander": "^9.4.0",
        "glob": "^8.0.3",
        "json5": "^2.2.1",
        "normalize-path": "^3.0.0",
        "safe-stable-stringify": "^2.4.0",
        "typescript": "~4.8.3"
      },
      "devDependencies": {
        "@auto-it/conventional-commits": "^10.37.6",
        "@auto-it/first-time-contributor": "^10.37.6",
        "@babel/core": "^7.19.1",
        "@babel/preset-env": "^7.19.1",
        "@babel/preset-typescript": "^7.18.6",
        "@types/glob": "^8.0.0",
        "@types/jest": "^29.0.3",
        "@types/node": "^18.7.18",
        "@types/normalize-path": "^3.0.0",
        "@typescript-eslint/eslint-plugin": "^5.38.0",
        "@typescript-eslint/parser": "^5.38.0",
        "ajv": "^8.11.0",
        "ajv-formats": "^2.1.1",
        "auto": "^10.37.6",
        "chai": "^4.3.6",
        "cross-env": "^7.0.3",
        "eslint": "^8.23.1",
        "eslint-config-prettier": "^8.5.0",
        "eslint-plugin-prettier": "^4.2.1",
        "jest": "^29.0.3",
        "jest-junit": "^15.0.0",
        "prettier": "^2.7.1",
        "ts-node": "^10.9.1",
        "vega": "^5.22.1",
        "vega-lite": "^5.5.0"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint \"{src,test,factory}/**/*.ts\"",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "cross-env FAST_TEST=1 jest test/ --verbose",
        "test:coverage": "yarn jest test/ --collectCoverage=true",
        "test:update": "cross-env UPDATE_SCHEMA=true yarn test:fast",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node-transpile-only ts-json-schema-generator.ts",
        "release": "yarn build && auto shipit"
      },
      "readme": "# ts-json-schema-generator\n\n![Test](https://github.com/vega/ts-json-schema-generator/workflows/Test/badge.svg)\n[![codecov](https://codecov.io/gh/vega/ts-json-schema-generator/branch/master/graph/badge.svg)](https://codecov.io/gh/vega/ts-json-schema-generator)\n[![npm version](https://img.shields.io/npm/v/ts-json-schema-generator.svg)](https://www.npmjs.com/package/ts-json-schema-generator)\n\nExtended version of [https://github.com/xiag-ag/typescript-to-json-schema](https://github.com/xiag-ag/typescript-to-json-schema).\n\nInspired by [`YousefED/typescript-json-schema`](https://github.com/YousefED/typescript-json-schema). Here's the differences list:\n\n-   this implementation avoids the use of `typeChecker.getTypeAtLocation()` (so probably it keeps correct type aliases)\n-   processing AST and formatting JSON schema have been split into two independent steps\n-   not exported types, interfaces, enums are not exposed in the `definitions` section in the JSON schema\n\n## Contributors\n\nThis project is made possible by a [community of contributors](https://github.com/vega/ts-json-schema-generator/graphs/contributors). We welcome contributions of any kind (issues, code, documentation, examples, tests,...). Please read our [code of conduct](https://vega.github.io/vega/about/code-of-conduct).\n\n## CLI Usage\n\n```bash\nnpm install --save ts-json-schema-generator\n./node_modules/.bin/ts-json-schema-generator --path 'my/project/**/*.ts' --type 'My.Type.Name'\n```\n\nNote that different platforms (e.g. Windows) may use different path separators so you may have to adjust the command above.\n\n## Programmatic Usage\n\n```js\n// main.js\n\nconst tsj = require(\"ts-json-schema-generator\");\nconst fs = require(\"fs\");\n\n/** @type {import('ts-json-schema-generator/dist/src/Config').Config} */\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst output_path = \"path/to/output/file\";\n\nconst schema = tsj.createGenerator(config).createSchema(config.type);\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\nRun the schema generator via `node main.js`.\n\n### Custom formatting\n\nExtending the built-in formatting is possible by creating a custom formatter and adding it to the main formatter:\n\n1. First we create a formatter, in this case for formatting function types:\n\n```ts\n// my-function-formatter.ts\nimport { BaseType, Definition, FunctionType, SubTypeFormatter } from \"ts-json-schema-generator\";\nimport ts from \"typescript\";\n\nexport class MyFunctionTypeFormatter implements SubTypeFormatter {\n    // You can skip this line if you don't need childTypeFormatter\n    public constructor(private childTypeFormatter: TypeFormatter) {}\n\n    public supportsType(type: FunctionType): boolean {\n        return type instanceof FunctionType;\n    }\n\n    public getDefinition(type: FunctionType): Definition {\n        // Return a custom schema for the function property.\n        return {\n            type: \"object\",\n            properties: {\n                isFunction: {\n                    type: \"boolean\",\n                    const: true,\n                },\n            },\n        };\n    }\n\n    // If this type does NOT HAVE children, generally all you need is:\n    public getChildren(type: FunctionType): BaseType[] {\n        return [];\n    }\n\n    // However, if children ARE supported, you'll need something similar to\n    // this (see src/TypeFormatter/{Array,Definition,etc}.ts for some examples):\n    public getChildren(type: FunctionType): BaseType[] {\n        return this.childTypeFormatter.getChildren(type.getType());\n    }\n}\n```\n\n2. Then we add the formatter as a child to the core formatter using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyFunctionTypeFormatter } from \"./my-function-formatter.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\n// We configure the formatter an add our custom formatter to it.\nconst formatter = createFormatter(config, (fmt, circularReferenceTypeFormatter) => {\n    // If your formatter DOES NOT support children, e.g. getChildren() { return [] }:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter());\n    // If your formatter DOES support children, you'll need this reference too:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter(circularReferenceTypeFormatter));\n});\n\nconst program = createProgram(config);\nconst parser = createParser(program, config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n### Custom parsing\n\nSimilar to custom formatting, extending the built-in parsing works practically the same way:\n\n1. First we create a parser, in this case for parsing construct types:\n\n```ts\n// my-constructor-parser.ts\nimport { Context, StringType, ReferenceType, BaseType, SubNodeParser } from \"ts-json-schema-generator\";\n// use typescript exported by TJS to avoid version conflict\nimport ts from \"ts-json-schema-generator\";\n\nexport class MyConstructorParser implements SubNodeParser {\n    supportsNode(node: ts.Node): boolean {\n        return node.kind === ts.SyntaxKind.ConstructorType;\n    }\n    createType(node: ts.Node, context: Context, reference?: ReferenceType): BaseType | undefined {\n        return new StringType(); // Treat constructors as strings in this example\n    }\n}\n```\n\n2. Then we add the parser as a child to the core parser using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyConstructorParser } from \"./my-constructor-parser.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst program = createProgram(config);\n\n// We configure the parser an add our custom parser to it.\nconst parser = createParser(program, config, (prs) => {\n    prs.addNodeParser(new MyConstructorParser());\n});\n\nconst formatter = createFormatter(config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n## Options\n\n```\n-p, --path 'index.ts'\n    The path to the TypeScript source file. If this is not provided, the type will be searched in the project specified in the `.tsconfig`.\n\n-t, --type 'My.Type.Name'\n    The type the generated schema will represent. If omitted, the generated schema will contain all\n    types found in the files matching path. The same is true if '*' is specified.\n\n-i, --id 'generatedSchemaId'\n    The `$id` of the generated schema. If omitted, there will be no `$id`.\n\n-e, --expose <all|none|export>\n    all: Create shared $ref definitions for all types.\n    none: Do not create shared $ref definitions.\n    export (default): Create shared $ref definitions only for exported types (not tagged as `@internal`).\n\n-f, --tsconfig 'my/project/tsconfig.json'\n    Use a custom tsconfig file for processing typescript (see https://www.typescriptlang.org/docs/handbook/tsconfig-json.html) instead of the default:\n    {\n        \"compilerOptions\": {\n            \"noEmit\": true,\n            \"emitDecoratorMetadata\": true,\n            \"experimentalDecorators\": true,\n            \"target\": \"ES5\",\n            \"module\": \"CommonJS\",\n            \"strictNullChecks\": false,\n        }\n    }\n\n-j, --jsDoc <extended|none|basic>\n    none: Do not use JsDoc annotations.\n    basic: Read JsDoc annotations to provide schema properties.\n    extended (default): Also read @nullable, and @asType annotations.\n\n--unstable\n    Do not sort properties.\n\n--strict-tuples\n    Do not allow additional items on tuples.\n\n--no-top-ref\n    Do not create a top-level $ref definition.\n\n--no-type-check\n    Skip type checks for better performance.\n\n--no-ref-encode\n    Do not encode references. According to the standard, references must be valid URIs but some tools do not support encoded references.\n\n--validation-keywords\n    Provide additional validation keywords to include.\n\n-o, --out\n    Specify the output file path. Without this option, the generator logs the response in the console.\n\n--additional-properties <true|false>\n    Controls whether or not to allow additional properties for objects that have no index signature.\n\n    true: Additional properties are allowed\n    false (default): Additional properties are not allowed\n\n--minify\n    Minify generated schema (default: false)\n```\n\n## Current state\n\n-   `interface` types\n-   `enum` types\n-   `union`, `tuple`, `type[]` types\n-   `Date`, `RegExp`, `URL` types\n-   `string`, `boolean`, `number` types\n-   `\"value\"`, `123`, `true`, `false`, `null`, `undefined` literals\n-   type aliases\n-   generics\n-   `typeof`\n-   `keyof`\n-   conditional types\n\n## Run locally\n\n`yarn --silent run run --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\n## Debug\n\n`yarn --silent run debug --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\nAnd connect via the debugger protocol.\n\n[AST Explorer](https://astexplorer.net/) is amazing for developers of this tool!\n\n## Publish\n\nPublishing is handled by a 2-branch [pre-release process](https://intuit.github.io/auto/docs/generated/shipit#next-branch-default), configured in `publish-auto.yml`. All changes should be based off the default `next` branch, and are published automatically.\n\n-   PRs made into the default branch are auto-deployed to the `next` pre-release tag on NPM. The result can be installed with `npm install ts-json-schema-generator@next`\n    -   When merging into `next`, please use the `squash and merge` strategy.\n-   To release a new stable version, open a PR from `next` into `stable` using this [compare link](https://github.com/vega/ts-json-schema-generator/compare/stable...next).\n    -   When merging from `next` into `stable`, please use the `create a merge commit` strategy.\n",
      "readmeFilename": "README.md",
      "gitHead": "2ba0135ee0649d16bff664d985b4aec526c5b9fc",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@1.2.0-next.2",
      "_nodeVersion": "16.18.0",
      "_npmVersion": "8.19.2",
      "dist": {
        "integrity": "sha512-zg7Y9lzl5v7gqsfDuUsdWbD8RoswcS+X8k26TlMqkqDbzO26E26yVBe1ddyU/PqJXB3RNynWHREnZz+fKqKjCQ==",
        "shasum": "f07652929d0fa3c66372bea72a8e906dc6b524e0",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-1.2.0-next.2.tgz",
        "fileCount": 708,
        "unpackedSize": 866425,
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEQCIBKC8SJ2zIe/8NUsd+tbDpzkhyImuT6l/JtMpEJfKie6AiAGd4d5jQyzix2ynwfOhKPfe45EKpwDqlBgswz1K7vRsw=="
          }
        ],
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJjfNBmACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2VmqcQA//TxvdRnj/lrr0FnuOLDHVAjSXDGl2oAedO7nBn4WXSqaeZy0w\r\nUASTYf9FM4htJs3HMYSbM2380kyuBlOmq4sWlFUruqBzc76JAORRzlXOUuk3\r\n8W8KIeVh0Vl9OlRZBCQY6Dd44G1drLTt/Qac5YuxTTwdOjc4C/HPK980l9zP\r\nDpaIdceW5cPJc7j18klJKxaXSvpu6WjH2sUXUK17htqutIHboUoqp5V7dpv4\r\nEhiVkt+dG0v/e2JCbnNI0CqKr55Nm5n2ezYNVF2n7Eu9KXXZ7E8LE1JMyz0I\r\nteWZ0THmyRG57gDDvyZq7q7aKs8D4gQ8nZN/XYaX7AEMvKW17vYMl7rkt7RN\r\nPLBrzkDgM8TucCLdC8HK+yf8u4S5RS7I2IeUWwicPn7zTomtdvZStgE2i4Vv\r\nFEFIqpSxEf8aIXi4wMghXBGGkN7Is3wlaylOcMc/0vB39BFAhntUgPZZ8LJX\r\nf2bGbMVgq59EGvHtIWE8KUkMLBa400luzRwKeONhLEgA4sHNZ+S3o1LjFwNw\r\nV8U9RKH4bzIu64iLTrwC0dELHLRI7gv2+4Bu/5z83qVPqLGXzDkKkkqgn6M2\r\nF43+jNegZ/ejlYxnRjSeyTukDt7SjPiq8bV0zYLaUZxfZo3TmgYGuVcR/uUN\r\n5fcLJLarba97Y/GLPdTzG4pE+Dx5tsWDqNE=\r\n=mRp3\r\n-----END PGP SIGNATURE-----\r\n"
      },
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "maintainers": [
        {
          "name": "jheer",
          "email": "jeffrey.heer@gmail.com"
        },
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "kanitw",
          "email": "kanitw@gmail.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_1.2.0-next.2_1669124198376_0.448677973579394"
      },
      "_hasShrinkwrap": false
    },
    "1.2.0-next.3": {
      "name": "ts-json-schema-generator",
      "version": "1.2.0-next.3",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "MooYeol Prescott Lee",
          "email": "mooyoul@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=10.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.11",
        "commander": "^9.4.0",
        "glob": "^8.0.3",
        "json5": "^2.2.1",
        "normalize-path": "^3.0.0",
        "safe-stable-stringify": "^2.4.0",
        "typescript": "~4.8.3"
      },
      "devDependencies": {
        "@auto-it/conventional-commits": "^10.37.6",
        "@auto-it/first-time-contributor": "^10.37.6",
        "@babel/core": "^7.19.1",
        "@babel/preset-env": "^7.19.1",
        "@babel/preset-typescript": "^7.18.6",
        "@types/glob": "^8.0.0",
        "@types/jest": "^29.0.3",
        "@types/node": "^18.7.18",
        "@types/normalize-path": "^3.0.0",
        "@typescript-eslint/eslint-plugin": "^5.38.0",
        "@typescript-eslint/parser": "^5.38.0",
        "ajv": "^8.11.0",
        "ajv-formats": "^2.1.1",
        "auto": "^10.37.6",
        "chai": "^4.3.6",
        "cross-env": "^7.0.3",
        "eslint": "^8.23.1",
        "eslint-config-prettier": "^8.5.0",
        "eslint-plugin-prettier": "^4.2.1",
        "jest": "^29.0.3",
        "jest-junit": "^15.0.0",
        "prettier": "^2.7.1",
        "ts-node": "^10.9.1",
        "vega": "^5.22.1",
        "vega-lite": "^5.5.0"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint \"{src,test,factory}/**/*.ts\"",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "cross-env FAST_TEST=1 jest test/ --verbose",
        "test:coverage": "yarn jest test/ --collectCoverage=true",
        "test:update": "cross-env UPDATE_SCHEMA=true yarn test:fast",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node-transpile-only ts-json-schema-generator.ts",
        "release": "yarn build && auto shipit"
      },
      "readme": "# ts-json-schema-generator\n\n![Test](https://github.com/vega/ts-json-schema-generator/workflows/Test/badge.svg)\n[![codecov](https://codecov.io/gh/vega/ts-json-schema-generator/branch/master/graph/badge.svg)](https://codecov.io/gh/vega/ts-json-schema-generator)\n[![npm version](https://img.shields.io/npm/v/ts-json-schema-generator.svg)](https://www.npmjs.com/package/ts-json-schema-generator)\n\nExtended version of [https://github.com/xiag-ag/typescript-to-json-schema](https://github.com/xiag-ag/typescript-to-json-schema).\n\nInspired by [`YousefED/typescript-json-schema`](https://github.com/YousefED/typescript-json-schema). Here's the differences list:\n\n-   this implementation avoids the use of `typeChecker.getTypeAtLocation()` (so probably it keeps correct type aliases)\n-   processing AST and formatting JSON schema have been split into two independent steps\n-   not exported types, interfaces, enums are not exposed in the `definitions` section in the JSON schema\n\n## Contributors\n\nThis project is made possible by a [community of contributors](https://github.com/vega/ts-json-schema-generator/graphs/contributors). We welcome contributions of any kind (issues, code, documentation, examples, tests,...). Please read our [code of conduct](https://vega.github.io/vega/about/code-of-conduct).\n\n## CLI Usage\n\n```bash\nnpm install --save ts-json-schema-generator\n./node_modules/.bin/ts-json-schema-generator --path 'my/project/**/*.ts' --type 'My.Type.Name'\n```\n\nNote that different platforms (e.g. Windows) may use different path separators so you may have to adjust the command above.\n\n## Programmatic Usage\n\n```js\n// main.js\n\nconst tsj = require(\"ts-json-schema-generator\");\nconst fs = require(\"fs\");\n\n/** @type {import('ts-json-schema-generator/dist/src/Config').Config} */\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst output_path = \"path/to/output/file\";\n\nconst schema = tsj.createGenerator(config).createSchema(config.type);\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\nRun the schema generator via `node main.js`.\n\n### Custom formatting\n\nExtending the built-in formatting is possible by creating a custom formatter and adding it to the main formatter:\n\n1. First we create a formatter, in this case for formatting function types:\n\n```ts\n// my-function-formatter.ts\nimport { BaseType, Definition, FunctionType, SubTypeFormatter } from \"ts-json-schema-generator\";\nimport ts from \"typescript\";\n\nexport class MyFunctionTypeFormatter implements SubTypeFormatter {\n    // You can skip this line if you don't need childTypeFormatter\n    public constructor(private childTypeFormatter: TypeFormatter) {}\n\n    public supportsType(type: FunctionType): boolean {\n        return type instanceof FunctionType;\n    }\n\n    public getDefinition(type: FunctionType): Definition {\n        // Return a custom schema for the function property.\n        return {\n            type: \"object\",\n            properties: {\n                isFunction: {\n                    type: \"boolean\",\n                    const: true,\n                },\n            },\n        };\n    }\n\n    // If this type does NOT HAVE children, generally all you need is:\n    public getChildren(type: FunctionType): BaseType[] {\n        return [];\n    }\n\n    // However, if children ARE supported, you'll need something similar to\n    // this (see src/TypeFormatter/{Array,Definition,etc}.ts for some examples):\n    public getChildren(type: FunctionType): BaseType[] {\n        return this.childTypeFormatter.getChildren(type.getType());\n    }\n}\n```\n\n2. Then we add the formatter as a child to the core formatter using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyFunctionTypeFormatter } from \"./my-function-formatter.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\n// We configure the formatter an add our custom formatter to it.\nconst formatter = createFormatter(config, (fmt, circularReferenceTypeFormatter) => {\n    // If your formatter DOES NOT support children, e.g. getChildren() { return [] }:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter());\n    // If your formatter DOES support children, you'll need this reference too:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter(circularReferenceTypeFormatter));\n});\n\nconst program = createProgram(config);\nconst parser = createParser(program, config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n### Custom parsing\n\nSimilar to custom formatting, extending the built-in parsing works practically the same way:\n\n1. First we create a parser, in this case for parsing construct types:\n\n```ts\n// my-constructor-parser.ts\nimport { Context, StringType, ReferenceType, BaseType, SubNodeParser } from \"ts-json-schema-generator\";\n// use typescript exported by TJS to avoid version conflict\nimport ts from \"ts-json-schema-generator\";\n\nexport class MyConstructorParser implements SubNodeParser {\n    supportsNode(node: ts.Node): boolean {\n        return node.kind === ts.SyntaxKind.ConstructorType;\n    }\n    createType(node: ts.Node, context: Context, reference?: ReferenceType): BaseType | undefined {\n        return new StringType(); // Treat constructors as strings in this example\n    }\n}\n```\n\n2. Then we add the parser as a child to the core parser using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyConstructorParser } from \"./my-constructor-parser.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst program = createProgram(config);\n\n// We configure the parser an add our custom parser to it.\nconst parser = createParser(program, config, (prs) => {\n    prs.addNodeParser(new MyConstructorParser());\n});\n\nconst formatter = createFormatter(config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n## Options\n\n```\n-p, --path 'index.ts'\n    The path to the TypeScript source file. If this is not provided, the type will be searched in the project specified in the `.tsconfig`.\n\n-t, --type 'My.Type.Name'\n    The type the generated schema will represent. If omitted, the generated schema will contain all\n    types found in the files matching path. The same is true if '*' is specified.\n\n-i, --id 'generatedSchemaId'\n    The `$id` of the generated schema. If omitted, there will be no `$id`.\n\n-e, --expose <all|none|export>\n    all: Create shared $ref definitions for all types.\n    none: Do not create shared $ref definitions.\n    export (default): Create shared $ref definitions only for exported types (not tagged as `@internal`).\n\n-f, --tsconfig 'my/project/tsconfig.json'\n    Use a custom tsconfig file for processing typescript (see https://www.typescriptlang.org/docs/handbook/tsconfig-json.html) instead of the default:\n    {\n        \"compilerOptions\": {\n            \"noEmit\": true,\n            \"emitDecoratorMetadata\": true,\n            \"experimentalDecorators\": true,\n            \"target\": \"ES5\",\n            \"module\": \"CommonJS\",\n            \"strictNullChecks\": false,\n        }\n    }\n\n-j, --jsDoc <extended|none|basic>\n    none: Do not use JsDoc annotations.\n    basic: Read JsDoc annotations to provide schema properties.\n    extended (default): Also read @nullable, and @asType annotations.\n\n--unstable\n    Do not sort properties.\n\n--strict-tuples\n    Do not allow additional items on tuples.\n\n--no-top-ref\n    Do not create a top-level $ref definition.\n\n--no-type-check\n    Skip type checks for better performance.\n\n--no-ref-encode\n    Do not encode references. According to the standard, references must be valid URIs but some tools do not support encoded references.\n\n--validation-keywords\n    Provide additional validation keywords to include.\n\n-o, --out\n    Specify the output file path. Without this option, the generator logs the response in the console.\n\n--additional-properties <true|false>\n    Controls whether or not to allow additional properties for objects that have no index signature.\n\n    true: Additional properties are allowed\n    false (default): Additional properties are not allowed\n\n--minify\n    Minify generated schema (default: false)\n```\n\n## Current state\n\n-   `interface` types\n-   `enum` types\n-   `union`, `tuple`, `type[]` types\n-   `Date`, `RegExp`, `URL` types\n-   `string`, `boolean`, `number` types\n-   `\"value\"`, `123`, `true`, `false`, `null`, `undefined` literals\n-   type aliases\n-   generics\n-   `typeof`\n-   `keyof`\n-   conditional types\n\n## Run locally\n\n`yarn --silent run run --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\n## Debug\n\n`yarn --silent run debug --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\nAnd connect via the debugger protocol.\n\n[AST Explorer](https://astexplorer.net/) is amazing for developers of this tool!\n\n## Publish\n\nPublishing is handled by a 2-branch [pre-release process](https://intuit.github.io/auto/docs/generated/shipit#next-branch-default), configured in `publish-auto.yml`. All changes should be based off the default `next` branch, and are published automatically.\n\n-   PRs made into the default branch are auto-deployed to the `next` pre-release tag on NPM. The result can be installed with `npm install ts-json-schema-generator@next`\n    -   When merging into `next`, please use the `squash and merge` strategy.\n-   To release a new stable version, open a PR from `next` into `stable` using this [compare link](https://github.com/vega/ts-json-schema-generator/compare/stable...next).\n    -   When merging from `next` into `stable`, please use the `create a merge commit` strategy.\n",
      "readmeFilename": "README.md",
      "gitHead": "62a17a961eae152e263b5ef6aef7b944d9cf91b3",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@1.2.0-next.3",
      "_nodeVersion": "16.18.1",
      "_npmVersion": "8.19.2",
      "dist": {
        "integrity": "sha512-cSUdxQ5rTAIxO/Bl13LZJdFF51WTx2GVobYvR1v+SdgqW2+gWm550VTsaWfTN0V8C+iidzYDLKyyzFExeGplEQ==",
        "shasum": "fcfc2fcec95fb69b0f2e78f34df6cb952abff544",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-1.2.0-next.3.tgz",
        "fileCount": 708,
        "unpackedSize": 868176,
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIGlaXK4PxkuzIlXR5Lpqc63pEBTQTvMGu8rdRwhwZXYcAiEA0Hl0X2Z550cnJY4kOnp2FspdNp8qIggJvTeCZlJ/ksc="
          }
        ],
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJjirnuACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2VmrQjw//cU7rnry66MgrOIE82cXSOJNOFCtGvzRKUZf6LxGzCvvBEAt7\r\nt2fWnxyTAbnwPs65CgM0p3m8fHDyAy01jHrUn51vvy0H+KrqYipR6O4Ek3s0\r\n2tOSJ0Vmd7zIUtIkpEerLH5iA8c1hoMRk41atuILBmRsGh3EMxH0BVghQ5hB\r\nKvvb+YWg8Lukod0bFHobQGDRJJ80NXYg2ayS0yavvTe9IfOd4M2Y+GEu3QFv\r\ndtRO61giHMUeVcKOZoLHz9ql813UoxHGN8xQZ72XUE/LNE41tJaHqKPQmTDT\r\nEiosXzfF0sJZWajmYzzn7z3IXch+ignH0lGvhv9hO56VlZe+iO53e1/pcj91\r\n193TbZUm2klPXuxk/srlnX4Jh+iRbYjr+r8f38sYWepIoO/CgrKeXXClb63O\r\nl/TnFUhu/NL8+DvosotNlE2n6z+aGL+Vjsh3gx4Gss+j2PY7p7yg9jCJsevE\r\n3cgP5+gU1ecMT+dVOEw+MVijCyN7jt5bRMF8GDoUSfPya9MTTCyfXV31pC9m\r\no2n2eAY6QM7bjA7bR9dF2lpqm6kMIh/DOMnQEAA+I2u9LWW70oCMef5lz+sB\r\nCskT+LfWJgMkz0EjqY1J+5CYFVrCqyCX32vfRz1z22ffu/NpX4zATeUY6Cx8\r\n0TqNay4//MQlsrtcpJvaSJyOP8q7BxDaVW4=\r\n=6+mF\r\n-----END PGP SIGNATURE-----\r\n"
      },
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "maintainers": [
        {
          "name": "jheer",
          "email": "jeffrey.heer@gmail.com"
        },
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "kanitw",
          "email": "kanitw@gmail.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_1.2.0-next.3_1670035950234_0.24774711807045335"
      },
      "_hasShrinkwrap": false
    },
    "1.1.3--canary.1487.fdad021.0": {
      "name": "ts-json-schema-generator",
      "version": "1.1.3--canary.1487.fdad021.0",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "MooYeol Prescott Lee",
          "email": "mooyoul@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=10.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.11",
        "commander": "^9.4.1",
        "glob": "^8.0.3",
        "json5": "^2.2.1",
        "normalize-path": "^3.0.0",
        "safe-stable-stringify": "^2.4.1",
        "typescript": "~4.9.3"
      },
      "devDependencies": {
        "@auto-it/conventional-commits": "^10.37.6",
        "@auto-it/first-time-contributor": "^10.37.6",
        "@babel/core": "^7.20.5",
        "@babel/preset-env": "^7.20.2",
        "@babel/preset-typescript": "^7.18.6",
        "@types/glob": "^8.0.0",
        "@types/jest": "^29.2.3",
        "@types/node": "^18.11.10",
        "@types/normalize-path": "^3.0.0",
        "@typescript-eslint/eslint-plugin": "^5.45.0",
        "@typescript-eslint/parser": "^5.45.0",
        "ajv": "^8.11.2",
        "ajv-formats": "^2.1.1",
        "auto": "^10.37.6",
        "chai": "^4.3.7",
        "cross-env": "^7.0.3",
        "eslint": "^8.29.0",
        "eslint-config-prettier": "^8.5.0",
        "eslint-plugin-prettier": "^4.2.1",
        "jest": "^29.3.1",
        "jest-junit": "^15.0.0",
        "prettier": "^2.8.0",
        "ts-node": "^10.9.1",
        "vega": "^5.22.1",
        "vega-lite": "^5.6.0"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint \"{src,test,factory}/**/*.ts\"",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "cross-env FAST_TEST=1 jest test/ --verbose",
        "test:coverage": "yarn jest test/ --collectCoverage=true",
        "test:update": "cross-env UPDATE_SCHEMA=true yarn test:fast",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node-transpile-only ts-json-schema-generator.ts",
        "release": "yarn build && auto shipit"
      },
      "readme": "# ts-json-schema-generator\n\n![Test](https://github.com/vega/ts-json-schema-generator/workflows/Test/badge.svg)\n[![codecov](https://codecov.io/gh/vega/ts-json-schema-generator/branch/master/graph/badge.svg)](https://codecov.io/gh/vega/ts-json-schema-generator)\n[![npm version](https://img.shields.io/npm/v/ts-json-schema-generator.svg)](https://www.npmjs.com/package/ts-json-schema-generator)\n\nExtended version of [https://github.com/xiag-ag/typescript-to-json-schema](https://github.com/xiag-ag/typescript-to-json-schema).\n\nInspired by [`YousefED/typescript-json-schema`](https://github.com/YousefED/typescript-json-schema). Here's the differences list:\n\n-   this implementation avoids the use of `typeChecker.getTypeAtLocation()` (so probably it keeps correct type aliases)\n-   processing AST and formatting JSON schema have been split into two independent steps\n-   not exported types, interfaces, enums are not exposed in the `definitions` section in the JSON schema\n\n## Contributors\n\nThis project is made possible by a [community of contributors](https://github.com/vega/ts-json-schema-generator/graphs/contributors). We welcome contributions of any kind (issues, code, documentation, examples, tests,...). Please read our [code of conduct](https://vega.github.io/vega/about/code-of-conduct).\n\n## CLI Usage\n\n```bash\nnpm install --save ts-json-schema-generator\n./node_modules/.bin/ts-json-schema-generator --path 'my/project/**/*.ts' --type 'My.Type.Name'\n```\n\nNote that different platforms (e.g. Windows) may use different path separators so you may have to adjust the command above.\n\n## Programmatic Usage\n\n```js\n// main.js\n\nconst tsj = require(\"ts-json-schema-generator\");\nconst fs = require(\"fs\");\n\n/** @type {import('ts-json-schema-generator/dist/src/Config').Config} */\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst output_path = \"path/to/output/file\";\n\nconst schema = tsj.createGenerator(config).createSchema(config.type);\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\nRun the schema generator via `node main.js`.\n\n### Custom formatting\n\nExtending the built-in formatting is possible by creating a custom formatter and adding it to the main formatter:\n\n1. First we create a formatter, in this case for formatting function types:\n\n```ts\n// my-function-formatter.ts\nimport { BaseType, Definition, FunctionType, SubTypeFormatter } from \"ts-json-schema-generator\";\nimport ts from \"typescript\";\n\nexport class MyFunctionTypeFormatter implements SubTypeFormatter {\n    // You can skip this line if you don't need childTypeFormatter\n    public constructor(private childTypeFormatter: TypeFormatter) {}\n\n    public supportsType(type: FunctionType): boolean {\n        return type instanceof FunctionType;\n    }\n\n    public getDefinition(type: FunctionType): Definition {\n        // Return a custom schema for the function property.\n        return {\n            type: \"object\",\n            properties: {\n                isFunction: {\n                    type: \"boolean\",\n                    const: true,\n                },\n            },\n        };\n    }\n\n    // If this type does NOT HAVE children, generally all you need is:\n    public getChildren(type: FunctionType): BaseType[] {\n        return [];\n    }\n\n    // However, if children ARE supported, you'll need something similar to\n    // this (see src/TypeFormatter/{Array,Definition,etc}.ts for some examples):\n    public getChildren(type: FunctionType): BaseType[] {\n        return this.childTypeFormatter.getChildren(type.getType());\n    }\n}\n```\n\n2. Then we add the formatter as a child to the core formatter using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyFunctionTypeFormatter } from \"./my-function-formatter.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\n// We configure the formatter an add our custom formatter to it.\nconst formatter = createFormatter(config, (fmt, circularReferenceTypeFormatter) => {\n    // If your formatter DOES NOT support children, e.g. getChildren() { return [] }:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter());\n    // If your formatter DOES support children, you'll need this reference too:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter(circularReferenceTypeFormatter));\n});\n\nconst program = createProgram(config);\nconst parser = createParser(program, config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n### Custom parsing\n\nSimilar to custom formatting, extending the built-in parsing works practically the same way:\n\n1. First we create a parser, in this case for parsing construct types:\n\n```ts\n// my-constructor-parser.ts\nimport { Context, StringType, ReferenceType, BaseType, SubNodeParser } from \"ts-json-schema-generator\";\n// use typescript exported by TJS to avoid version conflict\nimport ts from \"ts-json-schema-generator\";\n\nexport class MyConstructorParser implements SubNodeParser {\n    supportsNode(node: ts.Node): boolean {\n        return node.kind === ts.SyntaxKind.ConstructorType;\n    }\n    createType(node: ts.Node, context: Context, reference?: ReferenceType): BaseType | undefined {\n        return new StringType(); // Treat constructors as strings in this example\n    }\n}\n```\n\n2. Then we add the parser as a child to the core parser using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyConstructorParser } from \"./my-constructor-parser.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst program = createProgram(config);\n\n// We configure the parser an add our custom parser to it.\nconst parser = createParser(program, config, (prs) => {\n    prs.addNodeParser(new MyConstructorParser());\n});\n\nconst formatter = createFormatter(config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n## Options\n\n```\n-p, --path 'index.ts'\n    The path to the TypeScript source file. If this is not provided, the type will be searched in the project specified in the `.tsconfig`.\n\n-t, --type 'My.Type.Name'\n    The type the generated schema will represent. If omitted, the generated schema will contain all\n    types found in the files matching path. The same is true if '*' is specified.\n\n-i, --id 'generatedSchemaId'\n    The `$id` of the generated schema. If omitted, there will be no `$id`.\n\n-e, --expose <all|none|export>\n    all: Create shared $ref definitions for all types.\n    none: Do not create shared $ref definitions.\n    export (default): Create shared $ref definitions only for exported types (not tagged as `@internal`).\n\n-f, --tsconfig 'my/project/tsconfig.json'\n    Use a custom tsconfig file for processing typescript (see https://www.typescriptlang.org/docs/handbook/tsconfig-json.html) instead of the default:\n    {\n        \"compilerOptions\": {\n            \"noEmit\": true,\n            \"emitDecoratorMetadata\": true,\n            \"experimentalDecorators\": true,\n            \"target\": \"ES5\",\n            \"module\": \"CommonJS\",\n            \"strictNullChecks\": false,\n        }\n    }\n\n-j, --jsDoc <extended|none|basic>\n    none: Do not use JsDoc annotations.\n    basic: Read JsDoc annotations to provide schema properties.\n    extended (default): Also read @nullable, and @asType annotations.\n\n--unstable\n    Do not sort properties.\n\n--strict-tuples\n    Do not allow additional items on tuples.\n\n--no-top-ref\n    Do not create a top-level $ref definition.\n\n--no-type-check\n    Skip type checks for better performance.\n\n--no-ref-encode\n    Do not encode references. According to the standard, references must be valid URIs but some tools do not support encoded references.\n\n--validation-keywords\n    Provide additional validation keywords to include.\n\n-o, --out\n    Specify the output file path. Without this option, the generator logs the response in the console.\n\n--additional-properties <true|false>\n    Controls whether or not to allow additional properties for objects that have no index signature.\n\n    true: Additional properties are allowed\n    false (default): Additional properties are not allowed\n\n--minify\n    Minify generated schema (default: false)\n```\n\n## Current state\n\n-   `interface` types\n-   `enum` types\n-   `union`, `tuple`, `type[]` types\n-   `Date`, `RegExp`, `URL` types\n-   `string`, `boolean`, `number` types\n-   `\"value\"`, `123`, `true`, `false`, `null`, `undefined` literals\n-   type aliases\n-   generics\n-   `typeof`\n-   `keyof`\n-   conditional types\n\n## Run locally\n\n`yarn --silent run run --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\n## Debug\n\n`yarn --silent run debug --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\nAnd connect via the debugger protocol.\n\n[AST Explorer](https://astexplorer.net/) is amazing for developers of this tool!\n\n## Publish\n\nPublishing is handled by a 2-branch [pre-release process](https://intuit.github.io/auto/docs/generated/shipit#next-branch-default), configured in `publish-auto.yml`. All changes should be based off the default `next` branch, and are published automatically.\n\n-   PRs made into the default branch are auto-deployed to the `next` pre-release tag on NPM. The result can be installed with `npm install ts-json-schema-generator@next`\n    -   When merging into `next`, please use the `squash and merge` strategy.\n-   To release a new stable version, open a PR from `next` into `stable` using this [compare link](https://github.com/vega/ts-json-schema-generator/compare/stable...next).\n    -   When merging from `next` into `stable`, please use the `create a merge commit` strategy.\n",
      "readmeFilename": "README.md",
      "gitHead": "fdad0216e67196288bce561b611619a91b878270",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@1.1.3--canary.1487.fdad021.0",
      "_nodeVersion": "16.18.1",
      "_npmVersion": "8.19.2",
      "dist": {
        "integrity": "sha512-N+7iHk6SjYkqb3xSj2Qf33Nu4PuTqmaS0jQ99OaxXufEbqG4uQUMfu1ly3T21J2rKtGsnzEDav/kKVOyxpI8Rw==",
        "shasum": "6e699f18de27b96fac5e45bfb022c5d82712ee8b",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-1.1.3--canary.1487.fdad021.0.tgz",
        "fileCount": 708,
        "unpackedSize": 867975,
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEQCIGSctakAcFsdnxqotFSngD8ceRCk9HjbRgPSU7uJ/6XxAiARAlfstxubIwGoh7UO/JQ2sfD0HwQ2ZL7kEoyAdFG6WA=="
          }
        ],
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJjiruRACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2VmrUvg//Vbl9191QNlXGnmR0PgRntntavuSyMVzFnZLbK0mGYWCiuvN0\r\n9aotpTJEhOLK+L2pZR0yb50zUkoUxq7AfpsmqV2c2DfKXPvG2VekYF7RH5SM\r\nsO+ONgWRrYnv3M+rM33AdFqnBKKTH0gmZBc0m0lovbRdaPsjrfy4JdyuInZa\r\n265RAGwW4WNNFwnXyqNNF7bLVzud/q+RdarmXV2aI+/ce+tLvPX45ttDAkpA\r\nv4UFhBQhKCX6me9/El0EJO+IImiO4EoaweA2aQOXfd9qVY/n5Eifpi6Q18x2\r\nW51KJeFlT5K33XxD+pO9OuoJLsJlY/iccf9A3FmUJStGO+WpfXe76xQ/Izqh\r\n/JAmGLPUaaBemkR0rMMqKyZgCyUncE2fR4bQNvl/UdBLJt2YAc+8fbm0HbLE\r\nYweonK0NL3pZcCYM3q3/2Of/CGvk2tt4AUMiBlNDqzZeWPUF1xl95+3K/Yvs\r\nZoqOEXMldsKz41f8cwF/Uzjxmy7TZrinVxERBNrSKkfPHYY7SW34zADxb0Dc\r\nICmBgyk1Pw4BsMxZkcmjm1jjfhxTteIVPFnhapaUj2hRMVGF/bXscx2CSAJa\r\n8vnEdGyi43m77dtaRqa9ErpMPsUoBzhIEi9NEX8O0DOKHufoNRZ1POrq9XPY\r\nSDx00hvLwhQakfgzSJqVb1EZS7JSmMIDpyk=\r\n=0xB1\r\n-----END PGP SIGNATURE-----\r\n"
      },
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "maintainers": [
        {
          "name": "jheer",
          "email": "jeffrey.heer@gmail.com"
        },
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "kanitw",
          "email": "kanitw@gmail.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_1.1.3--canary.1487.fdad021.0_1670036369753_0.09829805259574309"
      },
      "_hasShrinkwrap": false
    },
    "1.1.3--canary.1489.d176f88.0": {
      "name": "ts-json-schema-generator",
      "version": "1.1.3--canary.1489.d176f88.0",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "MooYeol Prescott Lee",
          "email": "mooyoul@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=10.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.11",
        "commander": "^9.4.1",
        "glob": "^8.0.3",
        "json5": "^2.2.1",
        "normalize-path": "^3.0.0",
        "safe-stable-stringify": "^2.4.1",
        "typescript": "~4.9.3"
      },
      "devDependencies": {
        "@auto-it/conventional-commits": "^10.37.6",
        "@auto-it/first-time-contributor": "^10.37.6",
        "@babel/core": "^7.20.5",
        "@babel/preset-env": "^7.20.2",
        "@babel/preset-typescript": "^7.18.6",
        "@types/glob": "^8.0.0",
        "@types/jest": "^29.2.3",
        "@types/node": "^18.11.10",
        "@types/normalize-path": "^3.0.0",
        "@typescript-eslint/eslint-plugin": "^5.45.0",
        "@typescript-eslint/parser": "^5.45.0",
        "ajv": "^8.11.2",
        "ajv-formats": "^2.1.1",
        "auto": "^10.37.6",
        "chai": "^4.3.7",
        "cross-env": "^7.0.3",
        "eslint": "^8.29.0",
        "eslint-config-prettier": "^8.5.0",
        "eslint-plugin-prettier": "^4.2.1",
        "jest": "^29.3.1",
        "jest-junit": "^15.0.0",
        "prettier": "^2.8.0",
        "ts-node": "^10.9.1",
        "vega": "^5.22.1",
        "vega-lite": "^5.6.0"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint \"{src,test,factory}/**/*.ts\"",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "cross-env FAST_TEST=1 jest test/ --verbose",
        "test:coverage": "yarn jest test/ --collectCoverage=true",
        "test:update": "cross-env UPDATE_SCHEMA=true yarn test:fast",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node-transpile-only ts-json-schema-generator.ts",
        "release": "yarn build && auto shipit"
      },
      "readme": "# ts-json-schema-generator\n\n![Test](https://github.com/vega/ts-json-schema-generator/workflows/Test/badge.svg)\n[![codecov](https://codecov.io/gh/vega/ts-json-schema-generator/branch/master/graph/badge.svg)](https://codecov.io/gh/vega/ts-json-schema-generator)\n[![npm version](https://img.shields.io/npm/v/ts-json-schema-generator.svg)](https://www.npmjs.com/package/ts-json-schema-generator)\n\nExtended version of [https://github.com/xiag-ag/typescript-to-json-schema](https://github.com/xiag-ag/typescript-to-json-schema).\n\nInspired by [`YousefED/typescript-json-schema`](https://github.com/YousefED/typescript-json-schema). Here's the differences list:\n\n-   this implementation avoids the use of `typeChecker.getTypeAtLocation()` (so probably it keeps correct type aliases)\n-   processing AST and formatting JSON schema have been split into two independent steps\n-   not exported types, interfaces, enums are not exposed in the `definitions` section in the JSON schema\n\n## Contributors\n\nThis project is made possible by a [community of contributors](https://github.com/vega/ts-json-schema-generator/graphs/contributors). We welcome contributions of any kind (issues, code, documentation, examples, tests,...). Please read our [code of conduct](https://vega.github.io/vega/about/code-of-conduct).\n\n## CLI Usage\n\nRun the schema generator with npx:\n\n```bash\nnpx ts-json-schema-generator --path 'my/project/**/*.ts' --type 'My.Type.Name'\n```\n\nOr install the package and then run it\n\n```bash\nnpm install --save ts-json-schema-generator\n./node_modules/.bin/ts-json-schema-generator --path 'my/project/**/*.ts' --type 'My.Type.Name'\n```\n\nNote that different platforms (e.g. Windows) may use different path separators so you may have to adjust the command above.\n\nAlso note that you need to quote paths with `*` as otherwise the shell will expand the paths and therefore only pass the first path to the generator.\n\n## Programmatic Usage\n\n```js\n// main.js\n\nconst tsj = require(\"ts-json-schema-generator\");\nconst fs = require(\"fs\");\n\n/** @type {import('ts-json-schema-generator/dist/src/Config').Config} */\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst output_path = \"path/to/output/file\";\n\nconst schema = tsj.createGenerator(config).createSchema(config.type);\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\nRun the schema generator via `node main.js`.\n\n### Custom formatting\n\nExtending the built-in formatting is possible by creating a custom formatter and adding it to the main formatter:\n\n1. First we create a formatter, in this case for formatting function types:\n\n```ts\n// my-function-formatter.ts\nimport { BaseType, Definition, FunctionType, SubTypeFormatter } from \"ts-json-schema-generator\";\nimport ts from \"typescript\";\n\nexport class MyFunctionTypeFormatter implements SubTypeFormatter {\n    // You can skip this line if you don't need childTypeFormatter\n    public constructor(private childTypeFormatter: TypeFormatter) {}\n\n    public supportsType(type: FunctionType): boolean {\n        return type instanceof FunctionType;\n    }\n\n    public getDefinition(type: FunctionType): Definition {\n        // Return a custom schema for the function property.\n        return {\n            type: \"object\",\n            properties: {\n                isFunction: {\n                    type: \"boolean\",\n                    const: true,\n                },\n            },\n        };\n    }\n\n    // If this type does NOT HAVE children, generally all you need is:\n    public getChildren(type: FunctionType): BaseType[] {\n        return [];\n    }\n\n    // However, if children ARE supported, you'll need something similar to\n    // this (see src/TypeFormatter/{Array,Definition,etc}.ts for some examples):\n    public getChildren(type: FunctionType): BaseType[] {\n        return this.childTypeFormatter.getChildren(type.getType());\n    }\n}\n```\n\n2. Then we add the formatter as a child to the core formatter using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyFunctionTypeFormatter } from \"./my-function-formatter.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\n// We configure the formatter an add our custom formatter to it.\nconst formatter = createFormatter(config, (fmt, circularReferenceTypeFormatter) => {\n    // If your formatter DOES NOT support children, e.g. getChildren() { return [] }:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter());\n    // If your formatter DOES support children, you'll need this reference too:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter(circularReferenceTypeFormatter));\n});\n\nconst program = createProgram(config);\nconst parser = createParser(program, config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n### Custom parsing\n\nSimilar to custom formatting, extending the built-in parsing works practically the same way:\n\n1. First we create a parser, in this case for parsing construct types:\n\n```ts\n// my-constructor-parser.ts\nimport { Context, StringType, ReferenceType, BaseType, SubNodeParser } from \"ts-json-schema-generator\";\n// use typescript exported by TJS to avoid version conflict\nimport ts from \"ts-json-schema-generator\";\n\nexport class MyConstructorParser implements SubNodeParser {\n    supportsNode(node: ts.Node): boolean {\n        return node.kind === ts.SyntaxKind.ConstructorType;\n    }\n    createType(node: ts.Node, context: Context, reference?: ReferenceType): BaseType | undefined {\n        return new StringType(); // Treat constructors as strings in this example\n    }\n}\n```\n\n2. Then we add the parser as a child to the core parser using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyConstructorParser } from \"./my-constructor-parser.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst program = createProgram(config);\n\n// We configure the parser an add our custom parser to it.\nconst parser = createParser(program, config, (prs) => {\n    prs.addNodeParser(new MyConstructorParser());\n});\n\nconst formatter = createFormatter(config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n## Options\n\n```\n-p, --path 'index.ts'\n    The path to the TypeScript source file. If this is not provided, the type will be searched in the project specified in the `.tsconfig`.\n\n-t, --type 'My.Type.Name'\n    The type the generated schema will represent. If omitted, the generated schema will contain all\n    types found in the files matching path. The same is true if '*' is specified.\n\n-i, --id 'generatedSchemaId'\n    The `$id` of the generated schema. If omitted, there will be no `$id`.\n\n-e, --expose <all|none|export>\n    all: Create shared $ref definitions for all types.\n    none: Do not create shared $ref definitions.\n    export (default): Create shared $ref definitions only for exported types (not tagged as `@internal`).\n\n-f, --tsconfig 'my/project/tsconfig.json'\n    Use a custom tsconfig file for processing typescript (see https://www.typescriptlang.org/docs/handbook/tsconfig-json.html) instead of the default:\n    {\n        \"compilerOptions\": {\n            \"noEmit\": true,\n            \"emitDecoratorMetadata\": true,\n            \"experimentalDecorators\": true,\n            \"target\": \"ES5\",\n            \"module\": \"CommonJS\",\n            \"strictNullChecks\": false,\n        }\n    }\n\n-j, --jsDoc <extended|none|basic>\n    none: Do not use JsDoc annotations.\n    basic: Read JsDoc annotations to provide schema properties.\n    extended (default): Also read @nullable, and @asType annotations.\n\n--unstable\n    Do not sort properties.\n\n--strict-tuples\n    Do not allow additional items on tuples.\n\n--no-top-ref\n    Do not create a top-level $ref definition.\n\n--no-type-check\n    Skip type checks for better performance.\n\n--no-ref-encode\n    Do not encode references. According to the standard, references must be valid URIs but some tools do not support encoded references.\n\n--validation-keywords\n    Provide additional validation keywords to include.\n\n-o, --out\n    Specify the output file path. Without this option, the generator logs the response in the console.\n\n--additional-properties <true|false>\n    Controls whether or not to allow additional properties for objects that have no index signature.\n\n    true: Additional properties are allowed\n    false (default): Additional properties are not allowed\n\n--minify\n    Minify generated schema (default: false)\n```\n\n## Current state\n\n-   `interface` types\n-   `enum` types\n-   `union`, `tuple`, `type[]` types\n-   `Date`, `RegExp`, `URL` types\n-   `string`, `boolean`, `number` types\n-   `\"value\"`, `123`, `true`, `false`, `null`, `undefined` literals\n-   type aliases\n-   generics\n-   `typeof`\n-   `keyof`\n-   conditional types\n\n## Run locally\n\n`yarn --silent run run --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\n## Debug\n\n`yarn --silent run debug --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\nAnd connect via the debugger protocol.\n\n[AST Explorer](https://astexplorer.net/) is amazing for developers of this tool!\n\n## Publish\n\nPublishing is handled by a 2-branch [pre-release process](https://intuit.github.io/auto/docs/generated/shipit#next-branch-default), configured in `publish-auto.yml`. All changes should be based off the default `next` branch, and are published automatically.\n\n-   PRs made into the default branch are auto-deployed to the `next` pre-release tag on NPM. The result can be installed with `npm install ts-json-schema-generator@next`\n    -   When merging into `next`, please use the `squash and merge` strategy.\n-   To release a new stable version, open a PR from `next` into `stable` using this [compare link](https://github.com/vega/ts-json-schema-generator/compare/stable...next).\n    -   When merging from `next` into `stable`, please use the `create a merge commit` strategy.\n",
      "readmeFilename": "README.md",
      "gitHead": "d176f8849bd92c3dc47fdcfc05a0849b368a44c9",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@1.1.3--canary.1489.d176f88.0",
      "_nodeVersion": "16.18.1",
      "_npmVersion": "8.19.2",
      "dist": {
        "integrity": "sha512-dp9FkxFqAQ3P8h4nLhb0T4ipfo2JD5HbclC8+oASrX1ePV8KP1ea/m0mdGBkNMSpECYVQkNJRDQ7RfnrOf0Paw==",
        "shasum": "f9a5f7c5bef59e973d4d9b082766fa9984634ef9",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-1.1.3--canary.1489.d176f88.0.tgz",
        "fileCount": 708,
        "unpackedSize": 868294,
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEQCIGxuW0Cx/yUloXm/ulaYTwFdpaFdEDnZqLZseJjv4wALAiAtyp77Mr6wFnvy5g4Sg8qehAniQ8gBPvT30mdqKJI4Qw=="
          }
        ],
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJjjLIOACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2VmqZ5Q/8D1S6a8h5JgC2Gl5AEDews23UuiDBxwJsVdMeqBOGqV6JIApK\r\nYz4YJh00+efxTFM8SQzYp1Xn33H2S9KgZDWMD/Z61XdEQ10E/7ddptMsoRAc\r\ntdF9etysFSrKR5Ueu9VzSRAUyjItiY2rb46WY4xxal0mhgNvQszVhBeShCrG\r\nvHS42RRaKjpVPyM7dM3QmsSBJr6Gk8sGwY5XlraUpzIy7dsd4vUMYBK3cBsc\r\nW/igfUXcLE9FS0e19OjOYswstK3xkVtH2a6cBMuuVpWPBoUiFHJEasHq1pVR\r\nZuIvEHQPb92GwKfbVTawmLf2MMPLZQGzBQpXTEj5N+JCpZTAT/R3hAPoeSM7\r\ngFhUIhgf1XCKbjUbvZokK1cbSU5yrLOcP9z/BMGdC8iZcciAz0QuRfwzI4CN\r\nLMl42ZEuvWCDA5B3V9WK5HnD4Tw+d5Vg6CEc8KtzDljs6fyRxKWlA/rlHSJZ\r\nqQwt7k4HkXloi30LJGZYwRwjqfL7ya5Oy2AD5K9qKCbLGFd38yTmPkpZk9QD\r\nVLPsixSqEpn+SD5heV2zFtDL3lMbTC8H92qGGGeCjjQuKBZ6fUKs7oFk7o+e\r\nkUjqbgTmGLJUddi4uLlJspG9QAqMd2Pa+RKJbDkw97f6u90ZYxFBlna/53li\r\nOjBthzMZaGAUEHp6rxzwj3nzxwLpJfBxP7g=\r\n=GX09\r\n-----END PGP SIGNATURE-----\r\n"
      },
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "maintainers": [
        {
          "name": "jheer",
          "email": "jeffrey.heer@gmail.com"
        },
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "kanitw",
          "email": "kanitw@gmail.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_1.1.3--canary.1489.d176f88.0_1670165006015_0.8770588821158274"
      },
      "_hasShrinkwrap": false
    },
    "1.1.3--canary.1490.fdad021.0": {
      "name": "ts-json-schema-generator",
      "version": "1.1.3--canary.1490.fdad021.0",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "MooYeol Prescott Lee",
          "email": "mooyoul@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=10.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.11",
        "commander": "^9.4.1",
        "glob": "^8.0.3",
        "json5": "^2.2.1",
        "normalize-path": "^3.0.0",
        "safe-stable-stringify": "^2.4.1",
        "typescript": "~4.9.3"
      },
      "devDependencies": {
        "@auto-it/conventional-commits": "^10.37.6",
        "@auto-it/first-time-contributor": "^10.37.6",
        "@babel/core": "^7.20.5",
        "@babel/preset-env": "^7.20.2",
        "@babel/preset-typescript": "^7.18.6",
        "@types/glob": "^8.0.0",
        "@types/jest": "^29.2.3",
        "@types/node": "^18.11.10",
        "@types/normalize-path": "^3.0.0",
        "@typescript-eslint/eslint-plugin": "^5.45.0",
        "@typescript-eslint/parser": "^5.45.0",
        "ajv": "^8.11.2",
        "ajv-formats": "^2.1.1",
        "auto": "^10.37.6",
        "chai": "^4.3.7",
        "cross-env": "^7.0.3",
        "eslint": "^8.29.0",
        "eslint-config-prettier": "^8.5.0",
        "eslint-plugin-prettier": "^4.2.1",
        "jest": "^29.3.1",
        "jest-junit": "^15.0.0",
        "prettier": "^2.8.0",
        "ts-node": "^10.9.1",
        "vega": "^5.22.1",
        "vega-lite": "^5.6.0"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint \"{src,test,factory}/**/*.ts\"",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "cross-env FAST_TEST=1 jest test/ --verbose",
        "test:coverage": "yarn jest test/ --collectCoverage=true",
        "test:update": "cross-env UPDATE_SCHEMA=true yarn test:fast",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node-transpile-only ts-json-schema-generator.ts",
        "release": "yarn build && auto shipit"
      },
      "readme": "# ts-json-schema-generator\n\n![Test](https://github.com/vega/ts-json-schema-generator/workflows/Test/badge.svg)\n[![codecov](https://codecov.io/gh/vega/ts-json-schema-generator/branch/master/graph/badge.svg)](https://codecov.io/gh/vega/ts-json-schema-generator)\n[![npm version](https://img.shields.io/npm/v/ts-json-schema-generator.svg)](https://www.npmjs.com/package/ts-json-schema-generator)\n\nExtended version of [https://github.com/xiag-ag/typescript-to-json-schema](https://github.com/xiag-ag/typescript-to-json-schema).\n\nInspired by [`YousefED/typescript-json-schema`](https://github.com/YousefED/typescript-json-schema). Here's the differences list:\n\n-   this implementation avoids the use of `typeChecker.getTypeAtLocation()` (so probably it keeps correct type aliases)\n-   processing AST and formatting JSON schema have been split into two independent steps\n-   not exported types, interfaces, enums are not exposed in the `definitions` section in the JSON schema\n\n## Contributors\n\nThis project is made possible by a [community of contributors](https://github.com/vega/ts-json-schema-generator/graphs/contributors). We welcome contributions of any kind (issues, code, documentation, examples, tests,...). Please read our [code of conduct](https://vega.github.io/vega/about/code-of-conduct).\n\n## CLI Usage\n\n```bash\nnpm install --save ts-json-schema-generator\n./node_modules/.bin/ts-json-schema-generator --path 'my/project/**/*.ts' --type 'My.Type.Name'\n```\n\nNote that different platforms (e.g. Windows) may use different path separators so you may have to adjust the command above.\n\n## Programmatic Usage\n\n```js\n// main.js\n\nconst tsj = require(\"ts-json-schema-generator\");\nconst fs = require(\"fs\");\n\n/** @type {import('ts-json-schema-generator/dist/src/Config').Config} */\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst output_path = \"path/to/output/file\";\n\nconst schema = tsj.createGenerator(config).createSchema(config.type);\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\nRun the schema generator via `node main.js`.\n\n### Custom formatting\n\nExtending the built-in formatting is possible by creating a custom formatter and adding it to the main formatter:\n\n1. First we create a formatter, in this case for formatting function types:\n\n```ts\n// my-function-formatter.ts\nimport { BaseType, Definition, FunctionType, SubTypeFormatter } from \"ts-json-schema-generator\";\nimport ts from \"typescript\";\n\nexport class MyFunctionTypeFormatter implements SubTypeFormatter {\n    // You can skip this line if you don't need childTypeFormatter\n    public constructor(private childTypeFormatter: TypeFormatter) {}\n\n    public supportsType(type: FunctionType): boolean {\n        return type instanceof FunctionType;\n    }\n\n    public getDefinition(type: FunctionType): Definition {\n        // Return a custom schema for the function property.\n        return {\n            type: \"object\",\n            properties: {\n                isFunction: {\n                    type: \"boolean\",\n                    const: true,\n                },\n            },\n        };\n    }\n\n    // If this type does NOT HAVE children, generally all you need is:\n    public getChildren(type: FunctionType): BaseType[] {\n        return [];\n    }\n\n    // However, if children ARE supported, you'll need something similar to\n    // this (see src/TypeFormatter/{Array,Definition,etc}.ts for some examples):\n    public getChildren(type: FunctionType): BaseType[] {\n        return this.childTypeFormatter.getChildren(type.getType());\n    }\n}\n```\n\n2. Then we add the formatter as a child to the core formatter using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyFunctionTypeFormatter } from \"./my-function-formatter.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\n// We configure the formatter an add our custom formatter to it.\nconst formatter = createFormatter(config, (fmt, circularReferenceTypeFormatter) => {\n    // If your formatter DOES NOT support children, e.g. getChildren() { return [] }:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter());\n    // If your formatter DOES support children, you'll need this reference too:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter(circularReferenceTypeFormatter));\n});\n\nconst program = createProgram(config);\nconst parser = createParser(program, config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n### Custom parsing\n\nSimilar to custom formatting, extending the built-in parsing works practically the same way:\n\n1. First we create a parser, in this case for parsing construct types:\n\n```ts\n// my-constructor-parser.ts\nimport { Context, StringType, ReferenceType, BaseType, SubNodeParser } from \"ts-json-schema-generator\";\n// use typescript exported by TJS to avoid version conflict\nimport ts from \"ts-json-schema-generator\";\n\nexport class MyConstructorParser implements SubNodeParser {\n    supportsNode(node: ts.Node): boolean {\n        return node.kind === ts.SyntaxKind.ConstructorType;\n    }\n    createType(node: ts.Node, context: Context, reference?: ReferenceType): BaseType | undefined {\n        return new StringType(); // Treat constructors as strings in this example\n    }\n}\n```\n\n2. Then we add the parser as a child to the core parser using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyConstructorParser } from \"./my-constructor-parser.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst program = createProgram(config);\n\n// We configure the parser an add our custom parser to it.\nconst parser = createParser(program, config, (prs) => {\n    prs.addNodeParser(new MyConstructorParser());\n});\n\nconst formatter = createFormatter(config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n## Options\n\n```\n-p, --path 'index.ts'\n    The path to the TypeScript source file. If this is not provided, the type will be searched in the project specified in the `.tsconfig`.\n\n-t, --type 'My.Type.Name'\n    The type the generated schema will represent. If omitted, the generated schema will contain all\n    types found in the files matching path. The same is true if '*' is specified.\n\n-i, --id 'generatedSchemaId'\n    The `$id` of the generated schema. If omitted, there will be no `$id`.\n\n-e, --expose <all|none|export>\n    all: Create shared $ref definitions for all types.\n    none: Do not create shared $ref definitions.\n    export (default): Create shared $ref definitions only for exported types (not tagged as `@internal`).\n\n-f, --tsconfig 'my/project/tsconfig.json'\n    Use a custom tsconfig file for processing typescript (see https://www.typescriptlang.org/docs/handbook/tsconfig-json.html) instead of the default:\n    {\n        \"compilerOptions\": {\n            \"noEmit\": true,\n            \"emitDecoratorMetadata\": true,\n            \"experimentalDecorators\": true,\n            \"target\": \"ES5\",\n            \"module\": \"CommonJS\",\n            \"strictNullChecks\": false,\n        }\n    }\n\n-j, --jsDoc <extended|none|basic>\n    none: Do not use JsDoc annotations.\n    basic: Read JsDoc annotations to provide schema properties.\n    extended (default): Also read @nullable, and @asType annotations.\n\n--unstable\n    Do not sort properties.\n\n--strict-tuples\n    Do not allow additional items on tuples.\n\n--no-top-ref\n    Do not create a top-level $ref definition.\n\n--no-type-check\n    Skip type checks for better performance.\n\n--no-ref-encode\n    Do not encode references. According to the standard, references must be valid URIs but some tools do not support encoded references.\n\n--validation-keywords\n    Provide additional validation keywords to include.\n\n-o, --out\n    Specify the output file path. Without this option, the generator logs the response in the console.\n\n--additional-properties <true|false>\n    Controls whether or not to allow additional properties for objects that have no index signature.\n\n    true: Additional properties are allowed\n    false (default): Additional properties are not allowed\n\n--minify\n    Minify generated schema (default: false)\n```\n\n## Current state\n\n-   `interface` types\n-   `enum` types\n-   `union`, `tuple`, `type[]` types\n-   `Date`, `RegExp`, `URL` types\n-   `string`, `boolean`, `number` types\n-   `\"value\"`, `123`, `true`, `false`, `null`, `undefined` literals\n-   type aliases\n-   generics\n-   `typeof`\n-   `keyof`\n-   conditional types\n\n## Run locally\n\n`yarn --silent run run --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\n## Debug\n\n`yarn --silent run debug --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\nAnd connect via the debugger protocol.\n\n[AST Explorer](https://astexplorer.net/) is amazing for developers of this tool!\n\n## Publish\n\nPublishing is handled by a 2-branch [pre-release process](https://intuit.github.io/auto/docs/generated/shipit#next-branch-default), configured in `publish-auto.yml`. All changes should be based off the default `next` branch, and are published automatically.\n\n-   PRs made into the default branch are auto-deployed to the `next` pre-release tag on NPM. The result can be installed with `npm install ts-json-schema-generator@next`\n    -   When merging into `next`, please use the `squash and merge` strategy.\n-   To release a new stable version, open a PR from `next` into `stable` using this [compare link](https://github.com/vega/ts-json-schema-generator/compare/stable...next).\n    -   When merging from `next` into `stable`, please use the `create a merge commit` strategy.\n",
      "readmeFilename": "README.md",
      "gitHead": "fdad0216e67196288bce561b611619a91b878270",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@1.1.3--canary.1490.fdad021.0",
      "_nodeVersion": "16.18.1",
      "_npmVersion": "8.19.2",
      "dist": {
        "integrity": "sha512-gDE8X6rPPDkTwz2JGNEfV7yQSnaVhJFTeLRHamWEcccVkPV9gd8es565lSX7k+Fxuv8aU/4lUeGERgIobO0q+Q==",
        "shasum": "14a0f363ba8c1c8374d5ba5eb2fd0e257ff01d59",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-1.1.3--canary.1490.fdad021.0.tgz",
        "fileCount": 708,
        "unpackedSize": 867975,
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIQDgJUsQO3dnS5PkXmcB4tMm7anJf4ZD84javHg/hHVvxgIgW6eozYJoc+Ze9Gz0HD5U6dwbDiBES5G5CBL3jeeWeKQ="
          }
        ],
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJjj2C/ACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2VmoVmRAAj+qOYChwgC81ceST7surMKiwf2xtpa8vZqgf3mkEmUZ5DgG3\r\nUgSg6NKD0uoX7pG8iybpFrGTIrW1xdmemXbUFDOTcXUZcJWUvCTIfIqKnsvs\r\n3N0Pb93MlqQLaIhq/pRwuI1mdxnLKLGA8yIbYugSN8/7oNkPtl+L1tKYaXrm\r\nHF7SAsrq2kXHr2bD79xB7rkZ6NicVIYG/l5FDvPhg/7U1ixVNveJAPmeEPLq\r\ngayv3rG02JvJzd7ZD42luTWFzVy1+m4R5dIYB/VzAG9RqNfwjxzOvu9xoaRU\r\nZg6yGpjpNKzmC6/r3b59QbQHtCm7zvW//8T9R676wEVv99Ul/RMJ4cY6TOSj\r\nZw2SKcUvl1rmpEeKmvGNWsFARCAuyFdpUBS54apLqoxmjKgu04/5NDHwCJVT\r\n42FQvG2eNseY5bdbP/8iCTisGT1tgiFguqG4jodczcmN4PPmMy6dp3l3gdjz\r\n0gBdRF4pZuKxUBoB4LD3Gb2SDR/Zu7BKUw901DlLCY5eCEM+1D5zOmda3tmz\r\nWpO9BQM0LjOR8av2ngQyqQwJ5m7GGgChMgsNJY2fYyfC4hEj7Omk3t1jmdQx\r\ne6bsfiV7iizlIEnGyI3ebSvcrQpIVlF/y/SxFimilP/sRpfSG9p3rL60FYQW\r\nUH8Ju0vpLPWB2PbfMSzN9NvraKxFItulb3w=\r\n=LvQX\r\n-----END PGP SIGNATURE-----\r\n"
      },
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "maintainers": [
        {
          "name": "jheer",
          "email": "jeffrey.heer@gmail.com"
        },
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "kanitw",
          "email": "kanitw@gmail.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_1.1.3--canary.1490.fdad021.0_1670340799165_0.8991348531584693"
      },
      "_hasShrinkwrap": false
    },
    "1.2.0-next.4": {
      "name": "ts-json-schema-generator",
      "version": "1.2.0-next.4",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "MooYeol Prescott Lee",
          "email": "mooyoul@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=10.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.11",
        "commander": "^9.4.1",
        "glob": "^8.0.3",
        "json5": "^2.2.1",
        "normalize-path": "^3.0.0",
        "safe-stable-stringify": "^2.4.1",
        "typescript": "~4.9.3"
      },
      "devDependencies": {
        "@auto-it/conventional-commits": "^10.37.6",
        "@auto-it/first-time-contributor": "^10.37.6",
        "@babel/core": "^7.20.5",
        "@babel/preset-env": "^7.20.2",
        "@babel/preset-typescript": "^7.18.6",
        "@types/glob": "^8.0.0",
        "@types/jest": "^29.2.3",
        "@types/node": "^18.11.10",
        "@types/normalize-path": "^3.0.0",
        "@typescript-eslint/eslint-plugin": "^5.45.0",
        "@typescript-eslint/parser": "^5.45.0",
        "ajv": "^8.11.2",
        "ajv-formats": "^2.1.1",
        "auto": "^10.37.6",
        "chai": "^4.3.7",
        "cross-env": "^7.0.3",
        "eslint": "^8.29.0",
        "eslint-config-prettier": "^8.5.0",
        "eslint-plugin-prettier": "^4.2.1",
        "jest": "^29.3.1",
        "jest-junit": "^15.0.0",
        "prettier": "^2.8.0",
        "ts-node": "^10.9.1",
        "vega": "^5.22.1",
        "vega-lite": "^5.6.0"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint \"{src,test,factory}/**/*.ts\"",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "cross-env FAST_TEST=1 jest test/ --verbose",
        "test:coverage": "yarn jest test/ --collectCoverage=true",
        "test:update": "cross-env UPDATE_SCHEMA=true yarn test:fast",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node-transpile-only ts-json-schema-generator.ts",
        "release": "yarn build && auto shipit"
      },
      "readme": "# ts-json-schema-generator\n\n![Test](https://github.com/vega/ts-json-schema-generator/workflows/Test/badge.svg)\n[![codecov](https://codecov.io/gh/vega/ts-json-schema-generator/branch/master/graph/badge.svg)](https://codecov.io/gh/vega/ts-json-schema-generator)\n[![npm version](https://img.shields.io/npm/v/ts-json-schema-generator.svg)](https://www.npmjs.com/package/ts-json-schema-generator)\n\nExtended version of [https://github.com/xiag-ag/typescript-to-json-schema](https://github.com/xiag-ag/typescript-to-json-schema).\n\nInspired by [`YousefED/typescript-json-schema`](https://github.com/YousefED/typescript-json-schema). Here's the differences list:\n\n-   this implementation avoids the use of `typeChecker.getTypeAtLocation()` (so probably it keeps correct type aliases)\n-   processing AST and formatting JSON schema have been split into two independent steps\n-   not exported types, interfaces, enums are not exposed in the `definitions` section in the JSON schema\n\n## Contributors\n\nThis project is made possible by a [community of contributors](https://github.com/vega/ts-json-schema-generator/graphs/contributors). We welcome contributions of any kind (issues, code, documentation, examples, tests,...). Please read our [code of conduct](https://vega.github.io/vega/about/code-of-conduct).\n\n## CLI Usage\n\nRun the schema generator with npx:\n\n```bash\nnpx ts-json-schema-generator --path 'my/project/**/*.ts' --type 'My.Type.Name'\n```\n\nOr install the package and then run it\n\n```bash\nnpm install --save ts-json-schema-generator\n./node_modules/.bin/ts-json-schema-generator --path 'my/project/**/*.ts' --type 'My.Type.Name'\n```\n\nNote that different platforms (e.g. Windows) may use different path separators so you may have to adjust the command above.\n\nAlso note that you need to quote paths with `*` as otherwise the shell will expand the paths and therefore only pass the first path to the generator.\n\n## Programmatic Usage\n\n```js\n// main.js\n\nconst tsj = require(\"ts-json-schema-generator\");\nconst fs = require(\"fs\");\n\n/** @type {import('ts-json-schema-generator/dist/src/Config').Config} */\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst output_path = \"path/to/output/file\";\n\nconst schema = tsj.createGenerator(config).createSchema(config.type);\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\nRun the schema generator via `node main.js`.\n\n### Custom formatting\n\nExtending the built-in formatting is possible by creating a custom formatter and adding it to the main formatter:\n\n1. First we create a formatter, in this case for formatting function types:\n\n```ts\n// my-function-formatter.ts\nimport { BaseType, Definition, FunctionType, SubTypeFormatter } from \"ts-json-schema-generator\";\nimport ts from \"typescript\";\n\nexport class MyFunctionTypeFormatter implements SubTypeFormatter {\n    // You can skip this line if you don't need childTypeFormatter\n    public constructor(private childTypeFormatter: TypeFormatter) {}\n\n    public supportsType(type: FunctionType): boolean {\n        return type instanceof FunctionType;\n    }\n\n    public getDefinition(type: FunctionType): Definition {\n        // Return a custom schema for the function property.\n        return {\n            type: \"object\",\n            properties: {\n                isFunction: {\n                    type: \"boolean\",\n                    const: true,\n                },\n            },\n        };\n    }\n\n    // If this type does NOT HAVE children, generally all you need is:\n    public getChildren(type: FunctionType): BaseType[] {\n        return [];\n    }\n\n    // However, if children ARE supported, you'll need something similar to\n    // this (see src/TypeFormatter/{Array,Definition,etc}.ts for some examples):\n    public getChildren(type: FunctionType): BaseType[] {\n        return this.childTypeFormatter.getChildren(type.getType());\n    }\n}\n```\n\n2. Then we add the formatter as a child to the core formatter using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyFunctionTypeFormatter } from \"./my-function-formatter.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\n// We configure the formatter an add our custom formatter to it.\nconst formatter = createFormatter(config, (fmt, circularReferenceTypeFormatter) => {\n    // If your formatter DOES NOT support children, e.g. getChildren() { return [] }:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter());\n    // If your formatter DOES support children, you'll need this reference too:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter(circularReferenceTypeFormatter));\n});\n\nconst program = createProgram(config);\nconst parser = createParser(program, config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n### Custom parsing\n\nSimilar to custom formatting, extending the built-in parsing works practically the same way:\n\n1. First we create a parser, in this case for parsing construct types:\n\n```ts\n// my-constructor-parser.ts\nimport { Context, StringType, ReferenceType, BaseType, SubNodeParser } from \"ts-json-schema-generator\";\n// use typescript exported by TJS to avoid version conflict\nimport ts from \"ts-json-schema-generator\";\n\nexport class MyConstructorParser implements SubNodeParser {\n    supportsNode(node: ts.Node): boolean {\n        return node.kind === ts.SyntaxKind.ConstructorType;\n    }\n    createType(node: ts.Node, context: Context, reference?: ReferenceType): BaseType | undefined {\n        return new StringType(); // Treat constructors as strings in this example\n    }\n}\n```\n\n2. Then we add the parser as a child to the core parser using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyConstructorParser } from \"./my-constructor-parser.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst program = createProgram(config);\n\n// We configure the parser an add our custom parser to it.\nconst parser = createParser(program, config, (prs) => {\n    prs.addNodeParser(new MyConstructorParser());\n});\n\nconst formatter = createFormatter(config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n## Options\n\n```\n-p, --path 'index.ts'\n    The path to the TypeScript source file. If this is not provided, the type will be searched in the project specified in the `.tsconfig`.\n\n-t, --type 'My.Type.Name'\n    The type the generated schema will represent. If omitted, the generated schema will contain all\n    types found in the files matching path. The same is true if '*' is specified.\n\n-i, --id 'generatedSchemaId'\n    The `$id` of the generated schema. If omitted, there will be no `$id`.\n\n-e, --expose <all|none|export>\n    all: Create shared $ref definitions for all types.\n    none: Do not create shared $ref definitions.\n    export (default): Create shared $ref definitions only for exported types (not tagged as `@internal`).\n\n-f, --tsconfig 'my/project/tsconfig.json'\n    Use a custom tsconfig file for processing typescript (see https://www.typescriptlang.org/docs/handbook/tsconfig-json.html) instead of the default:\n    {\n        \"compilerOptions\": {\n            \"noEmit\": true,\n            \"emitDecoratorMetadata\": true,\n            \"experimentalDecorators\": true,\n            \"target\": \"ES5\",\n            \"module\": \"CommonJS\",\n            \"strictNullChecks\": false,\n        }\n    }\n\n-j, --jsDoc <extended|none|basic>\n    none: Do not use JsDoc annotations.\n    basic: Read JsDoc annotations to provide schema properties.\n    extended (default): Also read @nullable, and @asType annotations.\n\n--unstable\n    Do not sort properties.\n\n--strict-tuples\n    Do not allow additional items on tuples.\n\n--no-top-ref\n    Do not create a top-level $ref definition.\n\n--no-type-check\n    Skip type checks for better performance.\n\n--no-ref-encode\n    Do not encode references. According to the standard, references must be valid URIs but some tools do not support encoded references.\n\n--validation-keywords\n    Provide additional validation keywords to include.\n\n-o, --out\n    Specify the output file path. Without this option, the generator logs the response in the console.\n\n--additional-properties <true|false>\n    Controls whether or not to allow additional properties for objects that have no index signature.\n\n    true: Additional properties are allowed\n    false (default): Additional properties are not allowed\n\n--minify\n    Minify generated schema (default: false)\n```\n\n## Current state\n\n-   `interface` types\n-   `enum` types\n-   `union`, `tuple`, `type[]` types\n-   `Date`, `RegExp`, `URL` types\n-   `string`, `boolean`, `number` types\n-   `\"value\"`, `123`, `true`, `false`, `null`, `undefined` literals\n-   type aliases\n-   generics\n-   `typeof`\n-   `keyof`\n-   conditional types\n\n## Run locally\n\n`yarn --silent run run --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\n## Debug\n\n`yarn --silent run debug --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\nAnd connect via the debugger protocol.\n\n[AST Explorer](https://astexplorer.net/) is amazing for developers of this tool!\n\n## Publish\n\nPublishing is handled by a 2-branch [pre-release process](https://intuit.github.io/auto/docs/generated/shipit#next-branch-default), configured in `publish-auto.yml`. All changes should be based off the default `next` branch, and are published automatically.\n\n-   PRs made into the default branch are auto-deployed to the `next` pre-release tag on NPM. The result can be installed with `npm install ts-json-schema-generator@next`\n    -   When merging into `next`, please use the `squash and merge` strategy.\n-   To release a new stable version, open a PR from `next` into `stable` using this [compare link](https://github.com/vega/ts-json-schema-generator/compare/stable...next).\n    -   When merging from `next` into `stable`, please use the `create a merge commit` strategy.\n",
      "readmeFilename": "README.md",
      "gitHead": "738addd6052abf343753fcf91ee9602c4d01b5dd",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@1.2.0-next.4",
      "_nodeVersion": "16.18.1",
      "_npmVersion": "8.19.2",
      "dist": {
        "integrity": "sha512-qleZkZKwScaNm1D/yQDoiD0Gr4oZDwYiIlYUb9C9FepH9e+cibjWpbc/Moo4UczD8APgMIXJyBNwyTbTzbPmhw==",
        "shasum": "ce71ffb14961b736ddd42afd4314f82eb0145c50",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-1.2.0-next.4.tgz",
        "fileCount": 708,
        "unpackedSize": 870484,
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIQCK/reD6BCqQyL406799pFODeRmtRnzzVYzKv3OFKLyQgIgbD9ltg1vB64cmrftLIQ7Cp92h51OZnmHP3462grUWm8="
          }
        ],
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJjk1hEACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2VmoZ2Q//Wb1FRWSh6dnlD6Euy1JW3BYEdCXI78ffoegr6SOHAFliEFUN\r\nqKD3aXvQC32GhmOC5f1Th4cGx67TlhlGVb4LUKWqLLYmKIQKpCE+hhNfsgyr\r\n7KJvTEMJK+fRmu/h29ZljMnmWdc/A0GzWT04X4kdn1/bQl8KOG7RxJNj+T6M\r\nb8C4PJHZxwisOPQY2QIh+X0yNZdjDOJdOcDjx1LqR5PZoTMQ9hjXuhjyyLZ9\r\n/ZCm23tqaEl6FkF3MTy6h4U98ijUbWYsQt+BNGWtWeD93FoAJXeVykKI5b6p\r\nDY+4I3xwvcTFE4xpts7PmwXy+e6bga/hQBLqy9+wRH9xpZ3Wy1/WvYDZVZZE\r\nPnWigsYYg7yVnzSviy4z+lzxfHn3VPdxGtQC6x/ZYvbua2d+HoHkMHGZzN7Q\r\nA2zzXCB2i9BCivVANt1ygqRIGXdyfnLUtPH0Fq0d+hYxLPwppfWayjQ5f3GN\r\n1CX7yn9DoUuqnPKKws0/JzoZBq0iJWlnLVv9CD5rwHQPPLk8ZRH6SGaR+kOQ\r\nh6TCFzZMjP8OelxhuQJHi0UJa/PPj7PpQcZ4w/1AerDy/iqCIvYeugq+KsRy\r\nCy013Ph2Ja4nicv2qFxbljRMEh6OdSRZRiMDbheS0HlSBsFrJ5ORG6oTCVzt\r\nLV1a7yk8bk+5VZY+XEjaSYKFIWao1l+zdnM=\r\n=AUsk\r\n-----END PGP SIGNATURE-----\r\n"
      },
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "maintainers": [
        {
          "name": "jheer",
          "email": "jeffrey.heer@gmail.com"
        },
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "kanitw",
          "email": "kanitw@gmail.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_1.2.0-next.4_1670600772121_0.27686625225918826"
      },
      "_hasShrinkwrap": false
    },
    "1.2.0-next.5": {
      "name": "ts-json-schema-generator",
      "version": "1.2.0-next.5",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "MooYeol Prescott Lee",
          "email": "mooyoul@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=10.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.11",
        "commander": "^9.4.1",
        "glob": "^8.0.3",
        "json5": "^2.2.1",
        "normalize-path": "^3.0.0",
        "safe-stable-stringify": "^2.4.1",
        "typescript": "~4.9.3"
      },
      "devDependencies": {
        "@auto-it/conventional-commits": "^10.37.6",
        "@auto-it/first-time-contributor": "^10.37.6",
        "@babel/core": "^7.20.5",
        "@babel/preset-env": "^7.20.2",
        "@babel/preset-typescript": "^7.18.6",
        "@types/glob": "^8.0.0",
        "@types/jest": "^29.2.3",
        "@types/node": "^18.11.10",
        "@types/normalize-path": "^3.0.0",
        "@typescript-eslint/eslint-plugin": "^5.45.0",
        "@typescript-eslint/parser": "^5.45.0",
        "ajv": "^8.11.2",
        "ajv-formats": "^2.1.1",
        "auto": "^10.37.6",
        "chai": "^4.3.7",
        "cross-env": "^7.0.3",
        "eslint": "^8.29.0",
        "eslint-config-prettier": "^8.5.0",
        "eslint-plugin-prettier": "^4.2.1",
        "jest": "^29.3.1",
        "jest-junit": "^15.0.0",
        "prettier": "^2.8.0",
        "ts-node": "^10.9.1",
        "vega": "^5.22.1",
        "vega-lite": "^5.6.0"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint \"{src,test,factory}/**/*.ts\"",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "cross-env FAST_TEST=1 jest test/ --verbose",
        "test:coverage": "yarn jest test/ --collectCoverage=true",
        "test:update": "cross-env UPDATE_SCHEMA=true yarn test:fast",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node-transpile-only ts-json-schema-generator.ts",
        "release": "yarn build && auto shipit"
      },
      "readme": "# ts-json-schema-generator\n\n![Test](https://github.com/vega/ts-json-schema-generator/workflows/Test/badge.svg)\n[![codecov](https://codecov.io/gh/vega/ts-json-schema-generator/branch/master/graph/badge.svg)](https://codecov.io/gh/vega/ts-json-schema-generator)\n[![npm version](https://img.shields.io/npm/v/ts-json-schema-generator.svg)](https://www.npmjs.com/package/ts-json-schema-generator)\n\nExtended version of [https://github.com/xiag-ag/typescript-to-json-schema](https://github.com/xiag-ag/typescript-to-json-schema).\n\nInspired by [`YousefED/typescript-json-schema`](https://github.com/YousefED/typescript-json-schema). Here's the differences list:\n\n-   this implementation avoids the use of `typeChecker.getTypeAtLocation()` (so probably it keeps correct type aliases)\n-   processing AST and formatting JSON schema have been split into two independent steps\n-   not exported types, interfaces, enums are not exposed in the `definitions` section in the JSON schema\n\n## Contributors\n\nThis project is made possible by a [community of contributors](https://github.com/vega/ts-json-schema-generator/graphs/contributors). We welcome contributions of any kind (issues, code, documentation, examples, tests,...). Please read our [code of conduct](https://vega.github.io/vega/about/code-of-conduct).\n\n## CLI Usage\n\nRun the schema generator with npx:\n\n```bash\nnpx ts-json-schema-generator --path 'my/project/**/*.ts' --type 'My.Type.Name'\n```\n\nOr install the package and then run it\n\n```bash\nnpm install --save ts-json-schema-generator\n./node_modules/.bin/ts-json-schema-generator --path 'my/project/**/*.ts' --type 'My.Type.Name'\n```\n\nNote that different platforms (e.g. Windows) may use different path separators so you may have to adjust the command above.\n\nAlso note that you need to quote paths with `*` as otherwise the shell will expand the paths and therefore only pass the first path to the generator.\n\n## Programmatic Usage\n\n```js\n// main.js\n\nconst tsj = require(\"ts-json-schema-generator\");\nconst fs = require(\"fs\");\n\n/** @type {import('ts-json-schema-generator/dist/src/Config').Config} */\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst output_path = \"path/to/output/file\";\n\nconst schema = tsj.createGenerator(config).createSchema(config.type);\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\nRun the schema generator via `node main.js`.\n\n### Custom formatting\n\nExtending the built-in formatting is possible by creating a custom formatter and adding it to the main formatter:\n\n1. First we create a formatter, in this case for formatting function types:\n\n```ts\n// my-function-formatter.ts\nimport { BaseType, Definition, FunctionType, SubTypeFormatter } from \"ts-json-schema-generator\";\nimport ts from \"typescript\";\n\nexport class MyFunctionTypeFormatter implements SubTypeFormatter {\n    // You can skip this line if you don't need childTypeFormatter\n    public constructor(private childTypeFormatter: TypeFormatter) {}\n\n    public supportsType(type: FunctionType): boolean {\n        return type instanceof FunctionType;\n    }\n\n    public getDefinition(type: FunctionType): Definition {\n        // Return a custom schema for the function property.\n        return {\n            type: \"object\",\n            properties: {\n                isFunction: {\n                    type: \"boolean\",\n                    const: true,\n                },\n            },\n        };\n    }\n\n    // If this type does NOT HAVE children, generally all you need is:\n    public getChildren(type: FunctionType): BaseType[] {\n        return [];\n    }\n\n    // However, if children ARE supported, you'll need something similar to\n    // this (see src/TypeFormatter/{Array,Definition,etc}.ts for some examples):\n    public getChildren(type: FunctionType): BaseType[] {\n        return this.childTypeFormatter.getChildren(type.getType());\n    }\n}\n```\n\n2. Then we add the formatter as a child to the core formatter using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyFunctionTypeFormatter } from \"./my-function-formatter.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\n// We configure the formatter an add our custom formatter to it.\nconst formatter = createFormatter(config, (fmt, circularReferenceTypeFormatter) => {\n    // If your formatter DOES NOT support children, e.g. getChildren() { return [] }:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter());\n    // If your formatter DOES support children, you'll need this reference too:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter(circularReferenceTypeFormatter));\n});\n\nconst program = createProgram(config);\nconst parser = createParser(program, config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n### Custom parsing\n\nSimilar to custom formatting, extending the built-in parsing works practically the same way:\n\n1. First we create a parser, in this case for parsing construct types:\n\n```ts\n// my-constructor-parser.ts\nimport { Context, StringType, ReferenceType, BaseType, SubNodeParser } from \"ts-json-schema-generator\";\n// use typescript exported by TJS to avoid version conflict\nimport ts from \"ts-json-schema-generator\";\n\nexport class MyConstructorParser implements SubNodeParser {\n    supportsNode(node: ts.Node): boolean {\n        return node.kind === ts.SyntaxKind.ConstructorType;\n    }\n    createType(node: ts.Node, context: Context, reference?: ReferenceType): BaseType | undefined {\n        return new StringType(); // Treat constructors as strings in this example\n    }\n}\n```\n\n2. Then we add the parser as a child to the core parser using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyConstructorParser } from \"./my-constructor-parser.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst program = createProgram(config);\n\n// We configure the parser an add our custom parser to it.\nconst parser = createParser(program, config, (prs) => {\n    prs.addNodeParser(new MyConstructorParser());\n});\n\nconst formatter = createFormatter(config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n## Options\n\n```\n-p, --path 'index.ts'\n    The path to the TypeScript source file. If this is not provided, the type will be searched in the project specified in the `.tsconfig`.\n\n-t, --type 'My.Type.Name'\n    The type the generated schema will represent. If omitted, the generated schema will contain all\n    types found in the files matching path. The same is true if '*' is specified.\n\n-i, --id 'generatedSchemaId'\n    The `$id` of the generated schema. If omitted, there will be no `$id`.\n\n-e, --expose <all|none|export>\n    all: Create shared $ref definitions for all types.\n    none: Do not create shared $ref definitions.\n    export (default): Create shared $ref definitions only for exported types (not tagged as `@internal`).\n\n-f, --tsconfig 'my/project/tsconfig.json'\n    Use a custom tsconfig file for processing typescript (see https://www.typescriptlang.org/docs/handbook/tsconfig-json.html) instead of the default:\n    {\n        \"compilerOptions\": {\n            \"noEmit\": true,\n            \"emitDecoratorMetadata\": true,\n            \"experimentalDecorators\": true,\n            \"target\": \"ES5\",\n            \"module\": \"CommonJS\",\n            \"strictNullChecks\": false,\n        }\n    }\n\n-j, --jsDoc <extended|none|basic>\n    none: Do not use JsDoc annotations.\n    basic: Read JsDoc annotations to provide schema properties.\n    extended (default): Also read @nullable, and @asType annotations.\n\n--unstable\n    Do not sort properties.\n\n--strict-tuples\n    Do not allow additional items on tuples.\n\n--no-top-ref\n    Do not create a top-level $ref definition.\n\n--no-type-check\n    Skip type checks for better performance.\n\n--no-ref-encode\n    Do not encode references. According to the standard, references must be valid URIs but some tools do not support encoded references.\n\n--validation-keywords\n    Provide additional validation keywords to include.\n\n-o, --out\n    Specify the output file path. Without this option, the generator logs the response in the console.\n\n--additional-properties <true|false>\n    Controls whether or not to allow additional properties for objects that have no index signature.\n\n    true: Additional properties are allowed\n    false (default): Additional properties are not allowed\n\n--minify\n    Minify generated schema (default: false)\n```\n\n## Current state\n\n-   `interface` types\n-   `enum` types\n-   `union`, `tuple`, `type[]` types\n-   `Date`, `RegExp`, `URL` types\n-   `string`, `boolean`, `number` types\n-   `\"value\"`, `123`, `true`, `false`, `null`, `undefined` literals\n-   type aliases\n-   generics\n-   `typeof`\n-   `keyof`\n-   conditional types\n\n## Run locally\n\n`yarn --silent run run --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\n## Debug\n\n`yarn --silent run debug --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\nAnd connect via the debugger protocol.\n\n[AST Explorer](https://astexplorer.net/) is amazing for developers of this tool!\n\n## Publish\n\nPublishing is handled by a 2-branch [pre-release process](https://intuit.github.io/auto/docs/generated/shipit#next-branch-default), configured in `publish-auto.yml`. All changes should be based off the default `next` branch, and are published automatically.\n\n-   PRs made into the default branch are auto-deployed to the `next` pre-release tag on NPM. The result can be installed with `npm install ts-json-schema-generator@next`\n    -   When merging into `next`, please use the `squash and merge` strategy.\n-   To release a new stable version, open a PR from `next` into `stable` using this [compare link](https://github.com/vega/ts-json-schema-generator/compare/stable...next).\n    -   When merging from `next` into `stable`, please use the `create a merge commit` strategy.\n",
      "readmeFilename": "README.md",
      "gitHead": "df2de31002c4955fa46709f8758c9fa93a923c32",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@1.2.0-next.5",
      "_nodeVersion": "16.18.1",
      "_npmVersion": "8.19.2",
      "dist": {
        "integrity": "sha512-ZLwQNZMewHuyUHK3WpTYD37FuZ92dnjWxqGS74GYeRMcuaJtGor10JyIsxFRiNyjK9enXmDjLcxANIS2qafs6w==",
        "shasum": "72f53a8567b3e2a3bb0bd5bbdb69f8c074776563",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-1.2.0-next.5.tgz",
        "fileCount": 708,
        "unpackedSize": 873480,
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEYCIQDyqd6u9YXyOTk7Gzo0+fNTNSV400hfoQNKAirBktAU8QIhAN+dz18cSov5c0w+qUp/wvi59HNcwNzobtXoiexy+nNp"
          }
        ],
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJjooURACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2Vmrsmg//boYaYG20+WFNaaiFI4L/1dFriMbQrouzRIaFHIrGb9jWBIfJ\r\n3zc6izhRWeQPtAhZCOZDZkq/7vM860JMeRTfU71QA/9wLV0H7rXgy6kyzYVh\r\new0pGoNSOKoHeNxJhIw+1UUkN61cvj83yeQxqwAOrgnsrfiJcRgedIWf3f6j\r\n6hseonlYxOOd5aAjNA3Tl5rBWLTe3nHl94J4yTKB/OlRLamAres5sROQfULE\r\n6sh7X13ulXq05oalcthjWSwmzhrjJ7qDkRLGnt/YlpFWbUbJg0CCqKBzMwcp\r\nwflqzr8k6HXn6PJNtiMiZH/9Zi1W5KXBmyL1ndNxmT1ikwSkQWBc+p2M7PAk\r\njG68VhBN844sGB/JIwXEJH1cPnBtoY0QmPiVyATD9eIKUenRi1qnZwgji1nQ\r\n3xX2cWFh3lqz9SpfwORdmlW0tfQketsAGId0A0ACZ8UuA3IiGej6O/5PIbOO\r\nEbnEcMKuShfWdbmPp/Ygvgk0denchpHpA80KgWjkKVfnpPy4hDnYAM3SUhMX\r\n1YtR9WyX1XyyIcLhxd6jRP517Gi+JTcBDYSmJHZ5vOWVMB4X/XBQcs2Tq/h6\r\nc/K5X/V6xAq/Qd2QTGMLu84De6rUPQmP2td8CeVIcBarK+1UNVIgCaAlHxxC\r\nZ4I/ijZZ5keztrjNJopCvwc7RDpwv3zpoz8=\r\n=bVZE\r\n-----END PGP SIGNATURE-----\r\n"
      },
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "maintainers": [
        {
          "name": "jheer",
          "email": "jeffrey.heer@gmail.com"
        },
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "kanitw",
          "email": "kanitw@gmail.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_1.2.0-next.5_1671595281549_0.057087210338055305"
      },
      "_hasShrinkwrap": false
    },
    "1.2.0-next.6": {
      "name": "ts-json-schema-generator",
      "version": "1.2.0-next.6",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "MooYeol Prescott Lee",
          "email": "mooyoul@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=10.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.11",
        "commander": "^9.4.1",
        "glob": "^8.0.3",
        "json5": "^2.2.1",
        "normalize-path": "^3.0.0",
        "safe-stable-stringify": "^2.4.1",
        "typescript": "~4.9.3"
      },
      "devDependencies": {
        "@auto-it/conventional-commits": "^10.37.6",
        "@auto-it/first-time-contributor": "^10.37.6",
        "@babel/core": "^7.20.5",
        "@babel/preset-env": "^7.20.2",
        "@babel/preset-typescript": "^7.18.6",
        "@types/glob": "^8.0.0",
        "@types/jest": "^29.2.3",
        "@types/node": "^18.11.10",
        "@types/normalize-path": "^3.0.0",
        "@typescript-eslint/eslint-plugin": "^5.45.0",
        "@typescript-eslint/parser": "^5.45.0",
        "ajv": "^8.11.2",
        "ajv-formats": "^2.1.1",
        "auto": "^10.37.6",
        "chai": "^4.3.7",
        "cross-env": "^7.0.3",
        "eslint": "^8.29.0",
        "eslint-config-prettier": "^8.5.0",
        "eslint-plugin-prettier": "^4.2.1",
        "jest": "^29.3.1",
        "jest-junit": "^15.0.0",
        "prettier": "^2.8.0",
        "ts-node": "^10.9.1",
        "vega": "^5.22.1",
        "vega-lite": "^5.6.0"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint \"{src,test,factory}/**/*.ts\"",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "cross-env FAST_TEST=1 jest test/ --verbose",
        "test:coverage": "yarn jest test/ --collectCoverage=true",
        "test:update": "cross-env UPDATE_SCHEMA=true yarn test:fast",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node-transpile-only ts-json-schema-generator.ts",
        "release": "yarn build && auto shipit"
      },
      "readme": "# ts-json-schema-generator\n\n![Test](https://github.com/vega/ts-json-schema-generator/workflows/Test/badge.svg)\n[![codecov](https://codecov.io/gh/vega/ts-json-schema-generator/branch/master/graph/badge.svg)](https://codecov.io/gh/vega/ts-json-schema-generator)\n[![npm version](https://img.shields.io/npm/v/ts-json-schema-generator.svg)](https://www.npmjs.com/package/ts-json-schema-generator)\n\nExtended version of [https://github.com/xiag-ag/typescript-to-json-schema](https://github.com/xiag-ag/typescript-to-json-schema).\n\nInspired by [`YousefED/typescript-json-schema`](https://github.com/YousefED/typescript-json-schema). Here's the differences list:\n\n-   this implementation avoids the use of `typeChecker.getTypeAtLocation()` (so probably it keeps correct type aliases)\n-   processing AST and formatting JSON schema have been split into two independent steps\n-   not exported types, interfaces, enums are not exposed in the `definitions` section in the JSON schema\n\n## Contributors\n\nThis project is made possible by a [community of contributors](https://github.com/vega/ts-json-schema-generator/graphs/contributors). We welcome contributions of any kind (issues, code, documentation, examples, tests,...). Please read our [code of conduct](https://vega.github.io/vega/about/code-of-conduct).\n\n## CLI Usage\n\nRun the schema generator with npx:\n\n```bash\nnpx ts-json-schema-generator --path 'my/project/**/*.ts' --type 'My.Type.Name'\n```\n\nOr install the package and then run it\n\n```bash\nnpm install --save ts-json-schema-generator\n./node_modules/.bin/ts-json-schema-generator --path 'my/project/**/*.ts' --type 'My.Type.Name'\n```\n\nNote that different platforms (e.g. Windows) may use different path separators so you may have to adjust the command above.\n\nAlso note that you need to quote paths with `*` as otherwise the shell will expand the paths and therefore only pass the first path to the generator.\n\n## Programmatic Usage\n\n```js\n// main.js\n\nconst tsj = require(\"ts-json-schema-generator\");\nconst fs = require(\"fs\");\n\n/** @type {import('ts-json-schema-generator/dist/src/Config').Config} */\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst output_path = \"path/to/output/file\";\n\nconst schema = tsj.createGenerator(config).createSchema(config.type);\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\nRun the schema generator via `node main.js`.\n\n### Custom formatting\n\nExtending the built-in formatting is possible by creating a custom formatter and adding it to the main formatter:\n\n1. First we create a formatter, in this case for formatting function types:\n\n```ts\n// my-function-formatter.ts\nimport { BaseType, Definition, FunctionType, SubTypeFormatter } from \"ts-json-schema-generator\";\nimport ts from \"typescript\";\n\nexport class MyFunctionTypeFormatter implements SubTypeFormatter {\n    // You can skip this line if you don't need childTypeFormatter\n    public constructor(private childTypeFormatter: TypeFormatter) {}\n\n    public supportsType(type: FunctionType): boolean {\n        return type instanceof FunctionType;\n    }\n\n    public getDefinition(type: FunctionType): Definition {\n        // Return a custom schema for the function property.\n        return {\n            type: \"object\",\n            properties: {\n                isFunction: {\n                    type: \"boolean\",\n                    const: true,\n                },\n            },\n        };\n    }\n\n    // If this type does NOT HAVE children, generally all you need is:\n    public getChildren(type: FunctionType): BaseType[] {\n        return [];\n    }\n\n    // However, if children ARE supported, you'll need something similar to\n    // this (see src/TypeFormatter/{Array,Definition,etc}.ts for some examples):\n    public getChildren(type: FunctionType): BaseType[] {\n        return this.childTypeFormatter.getChildren(type.getType());\n    }\n}\n```\n\n2. Then we add the formatter as a child to the core formatter using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyFunctionTypeFormatter } from \"./my-function-formatter.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\n// We configure the formatter an add our custom formatter to it.\nconst formatter = createFormatter(config, (fmt, circularReferenceTypeFormatter) => {\n    // If your formatter DOES NOT support children, e.g. getChildren() { return [] }:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter());\n    // If your formatter DOES support children, you'll need this reference too:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter(circularReferenceTypeFormatter));\n});\n\nconst program = createProgram(config);\nconst parser = createParser(program, config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n### Custom parsing\n\nSimilar to custom formatting, extending the built-in parsing works practically the same way:\n\n1. First we create a parser, in this case for parsing construct types:\n\n```ts\n// my-constructor-parser.ts\nimport { Context, StringType, ReferenceType, BaseType, SubNodeParser } from \"ts-json-schema-generator\";\n// use typescript exported by TJS to avoid version conflict\nimport ts from \"ts-json-schema-generator\";\n\nexport class MyConstructorParser implements SubNodeParser {\n    supportsNode(node: ts.Node): boolean {\n        return node.kind === ts.SyntaxKind.ConstructorType;\n    }\n    createType(node: ts.Node, context: Context, reference?: ReferenceType): BaseType | undefined {\n        return new StringType(); // Treat constructors as strings in this example\n    }\n}\n```\n\n2. Then we add the parser as a child to the core parser using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyConstructorParser } from \"./my-constructor-parser.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst program = createProgram(config);\n\n// We configure the parser an add our custom parser to it.\nconst parser = createParser(program, config, (prs) => {\n    prs.addNodeParser(new MyConstructorParser());\n});\n\nconst formatter = createFormatter(config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n## Options\n\n```\n-p, --path 'index.ts'\n    The path to the TypeScript source file. If this is not provided, the type will be searched in the project specified in the `.tsconfig`.\n\n-t, --type 'My.Type.Name'\n    The type the generated schema will represent. If omitted, the generated schema will contain all\n    types found in the files matching path. The same is true if '*' is specified.\n\n-i, --id 'generatedSchemaId'\n    The `$id` of the generated schema. If omitted, there will be no `$id`.\n\n-e, --expose <all|none|export>\n    all: Create shared $ref definitions for all types.\n    none: Do not create shared $ref definitions.\n    export (default): Create shared $ref definitions only for exported types (not tagged as `@internal`).\n\n-f, --tsconfig 'my/project/tsconfig.json'\n    Use a custom tsconfig file for processing typescript (see https://www.typescriptlang.org/docs/handbook/tsconfig-json.html) instead of the default:\n    {\n        \"compilerOptions\": {\n            \"noEmit\": true,\n            \"emitDecoratorMetadata\": true,\n            \"experimentalDecorators\": true,\n            \"target\": \"ES5\",\n            \"module\": \"CommonJS\",\n            \"strictNullChecks\": false,\n        }\n    }\n\n-j, --jsDoc <extended|none|basic>\n    none: Do not use JsDoc annotations.\n    basic: Read JsDoc annotations to provide schema properties.\n    extended (default): Also read @nullable, and @asType annotations.\n\n--unstable\n    Do not sort properties.\n\n--strict-tuples\n    Do not allow additional items on tuples.\n\n--no-top-ref\n    Do not create a top-level $ref definition.\n\n--no-type-check\n    Skip type checks for better performance.\n\n--no-ref-encode\n    Do not encode references. According to the standard, references must be valid URIs but some tools do not support encoded references.\n\n--validation-keywords\n    Provide additional validation keywords to include.\n\n-o, --out\n    Specify the output file path. Without this option, the generator logs the response in the console.\n\n--additional-properties <true|false>\n    Controls whether or not to allow additional properties for objects that have no index signature.\n\n    true: Additional properties are allowed\n    false (default): Additional properties are not allowed\n\n--minify\n    Minify generated schema (default: false)\n```\n\n## Current state\n\n-   `interface` types\n-   `enum` types\n-   `union`, `tuple`, `type[]` types\n-   `Date`, `RegExp`, `URL` types\n-   `string`, `boolean`, `number` types\n-   `\"value\"`, `123`, `true`, `false`, `null`, `undefined` literals\n-   type aliases\n-   generics\n-   `typeof`\n-   `keyof`\n-   conditional types\n\n## Run locally\n\n`yarn --silent run run --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\n## Debug\n\n`yarn --silent run debug --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\nAnd connect via the debugger protocol.\n\n[AST Explorer](https://astexplorer.net/) is amazing for developers of this tool!\n\n## Publish\n\nPublishing is handled by a 2-branch [pre-release process](https://intuit.github.io/auto/docs/generated/shipit#next-branch-default), configured in `publish-auto.yml`. All changes should be based off the default `next` branch, and are published automatically.\n\n-   PRs made into the default branch are auto-deployed to the `next` pre-release tag on NPM. The result can be installed with `npm install ts-json-schema-generator@next`\n    -   When merging into `next`, please use the `squash and merge` strategy.\n-   To release a new stable version, open a PR from `next` into `stable` using this [compare link](https://github.com/vega/ts-json-schema-generator/compare/stable...next).\n    -   When merging from `next` into `stable`, please use the `create a merge commit` strategy.\n",
      "readmeFilename": "README.md",
      "gitHead": "888f691d87322f6defe560a1f0862226c9403ec2",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@1.2.0-next.6",
      "_nodeVersion": "16.18.1",
      "_npmVersion": "8.19.2",
      "dist": {
        "integrity": "sha512-0IiL5/UHTWSzfR99WF6mQr1ZShNTV30Cmy3l5f8OvVIMZDjWmGAJfnEZkdGVAMMaaa0Z5KRt2TS6lneblYnt3g==",
        "shasum": "33248b873e985253270449c112f6c40624c13488",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-1.2.0-next.6.tgz",
        "fileCount": 716,
        "unpackedSize": 877439,
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIQDS9GFXXtzVbJFDCCya6sSPWIBzboj/Rb+iTyetBYfKpQIgZA2Lgy79vhse9e0QFPb/e92F8UJo7kYzo1K59Dy8daQ="
          }
        ],
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJjoyFsACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2VmqNxg//e0tfrb49/OVGopcM62MtVdrgc/nj/qV4z5aRuCawSLcc0LAX\r\nVuyeHkcbcln/NOQ8tE3/jKNuSpSDX0yxYaxAv8V7Nqg6jkP7xoPxomAcenAd\r\nDsKhm2+DnLJbd4+AePT/UmnMd22InMP5cHGkhCjDlPZW65lfxLdRjzacEB/w\r\nirq3Y1g4e79O2QX8nhHCufdV3hNWLlqOSVazFfpjlqPDX3y+LSLCe6Y7frZR\r\nOOKjwvQ7EUOZolTXKO+/NMkTo26AZMqnMSJTfkCsLnTxkII387QpkTVykOTR\r\n51uNc/xVE2eC0cqv6Ch19j63f6eWz6KfxUG7Odp4aoOIauNgOCjk4hty71kO\r\n23WQs4o3n/KjrYBvxIWD5vfGt/X6VWFoDAlrlBbRv4BxhI3QHBGUnTOJlb+t\r\nS7ERVN+7TdGrstvSipIg9MOd5C8MfOfIzgBTKtrlcZcnvclrrdraCMTR351S\r\ni1glT1NKAYvxBIi9uV/eBoXlQTWwecH0rY26OLmDE8nAaaTOnOslKy+QTjHu\r\nDu2JsztDbfQ3U9Zmg3Jciuo4eTBfug0bdweeDlcRJKHWzdqk3pT9Wk0jlHCA\r\nzbzCYrqcYaAOiV/xscLwb9uyA7YyY31IBDpdm/pYQ359jcOPq5CMAxwWXBYO\r\nVoYcr+O3I3aRR/sYzuNBHvzIuR2sevMq+XQ=\r\n=eY8E\r\n-----END PGP SIGNATURE-----\r\n"
      },
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "maintainers": [
        {
          "name": "jheer",
          "email": "jeffrey.heer@gmail.com"
        },
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "kanitw",
          "email": "kanitw@gmail.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_1.2.0-next.6_1671635308296_0.9602375464459652"
      },
      "_hasShrinkwrap": false
    },
    "1.2.0-next.7": {
      "name": "ts-json-schema-generator",
      "version": "1.2.0-next.7",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "MooYeol Prescott Lee",
          "email": "mooyoul@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=10.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.11",
        "commander": "^9.4.1",
        "glob": "^8.0.3",
        "json5": "^2.2.1",
        "normalize-path": "^3.0.0",
        "safe-stable-stringify": "^2.4.1",
        "typescript": "~4.9.3"
      },
      "devDependencies": {
        "@auto-it/conventional-commits": "^10.37.6",
        "@auto-it/first-time-contributor": "^10.37.6",
        "@babel/core": "^7.20.5",
        "@babel/preset-env": "^7.20.2",
        "@babel/preset-typescript": "^7.18.6",
        "@types/glob": "^8.0.0",
        "@types/jest": "^29.2.3",
        "@types/node": "^18.11.10",
        "@types/normalize-path": "^3.0.0",
        "@typescript-eslint/eslint-plugin": "^5.45.0",
        "@typescript-eslint/parser": "^5.45.0",
        "ajv": "^8.11.2",
        "ajv-formats": "^2.1.1",
        "auto": "^10.37.6",
        "chai": "^4.3.7",
        "cross-env": "^7.0.3",
        "eslint": "^8.29.0",
        "eslint-config-prettier": "^8.5.0",
        "eslint-plugin-prettier": "^4.2.1",
        "jest": "^29.3.1",
        "jest-junit": "^15.0.0",
        "prettier": "^2.8.0",
        "ts-node": "^10.9.1",
        "vega": "^5.22.1",
        "vega-lite": "^5.6.0"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint \"{src,test,factory}/**/*.ts\"",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "cross-env FAST_TEST=1 jest test/ --verbose",
        "test:coverage": "yarn jest test/ --collectCoverage=true",
        "test:update": "cross-env UPDATE_SCHEMA=true yarn test:fast",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node-transpile-only ts-json-schema-generator.ts",
        "release": "yarn build && auto shipit"
      },
      "readme": "# ts-json-schema-generator\n\n![Test](https://github.com/vega/ts-json-schema-generator/workflows/Test/badge.svg)\n[![codecov](https://codecov.io/gh/vega/ts-json-schema-generator/branch/master/graph/badge.svg)](https://codecov.io/gh/vega/ts-json-schema-generator)\n[![npm version](https://img.shields.io/npm/v/ts-json-schema-generator.svg)](https://www.npmjs.com/package/ts-json-schema-generator)\n\nExtended version of [https://github.com/xiag-ag/typescript-to-json-schema](https://github.com/xiag-ag/typescript-to-json-schema).\n\nInspired by [`YousefED/typescript-json-schema`](https://github.com/YousefED/typescript-json-schema). Here's the differences list:\n\n-   this implementation avoids the use of `typeChecker.getTypeAtLocation()` (so probably it keeps correct type aliases)\n-   processing AST and formatting JSON schema have been split into two independent steps\n-   not exported types, interfaces, enums are not exposed in the `definitions` section in the JSON schema\n\n## Contributors\n\nThis project is made possible by a [community of contributors](https://github.com/vega/ts-json-schema-generator/graphs/contributors). We welcome contributions of any kind (issues, code, documentation, examples, tests,...). Please read our [code of conduct](https://vega.github.io/vega/about/code-of-conduct).\n\n## CLI Usage\n\nRun the schema generator with npx:\n\n```bash\nnpx ts-json-schema-generator --path 'my/project/**/*.ts' --type 'My.Type.Name'\n```\n\nOr install the package and then run it\n\n```bash\nnpm install --save ts-json-schema-generator\n./node_modules/.bin/ts-json-schema-generator --path 'my/project/**/*.ts' --type 'My.Type.Name'\n```\n\nNote that different platforms (e.g. Windows) may use different path separators so you may have to adjust the command above.\n\nAlso note that you need to quote paths with `*` as otherwise the shell will expand the paths and therefore only pass the first path to the generator.\n\n## Programmatic Usage\n\n```js\n// main.js\n\nconst tsj = require(\"ts-json-schema-generator\");\nconst fs = require(\"fs\");\n\n/** @type {import('ts-json-schema-generator/dist/src/Config').Config} */\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst output_path = \"path/to/output/file\";\n\nconst schema = tsj.createGenerator(config).createSchema(config.type);\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\nRun the schema generator via `node main.js`.\n\n### Custom formatting\n\nExtending the built-in formatting is possible by creating a custom formatter and adding it to the main formatter:\n\n1. First we create a formatter, in this case for formatting function types:\n\n```ts\n// my-function-formatter.ts\nimport { BaseType, Definition, FunctionType, SubTypeFormatter } from \"ts-json-schema-generator\";\nimport ts from \"typescript\";\n\nexport class MyFunctionTypeFormatter implements SubTypeFormatter {\n    // You can skip this line if you don't need childTypeFormatter\n    public constructor(private childTypeFormatter: TypeFormatter) {}\n\n    public supportsType(type: FunctionType): boolean {\n        return type instanceof FunctionType;\n    }\n\n    public getDefinition(type: FunctionType): Definition {\n        // Return a custom schema for the function property.\n        return {\n            type: \"object\",\n            properties: {\n                isFunction: {\n                    type: \"boolean\",\n                    const: true,\n                },\n            },\n        };\n    }\n\n    // If this type does NOT HAVE children, generally all you need is:\n    public getChildren(type: FunctionType): BaseType[] {\n        return [];\n    }\n\n    // However, if children ARE supported, you'll need something similar to\n    // this (see src/TypeFormatter/{Array,Definition,etc}.ts for some examples):\n    public getChildren(type: FunctionType): BaseType[] {\n        return this.childTypeFormatter.getChildren(type.getType());\n    }\n}\n```\n\n2. Then we add the formatter as a child to the core formatter using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyFunctionTypeFormatter } from \"./my-function-formatter.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\n// We configure the formatter an add our custom formatter to it.\nconst formatter = createFormatter(config, (fmt, circularReferenceTypeFormatter) => {\n    // If your formatter DOES NOT support children, e.g. getChildren() { return [] }:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter());\n    // If your formatter DOES support children, you'll need this reference too:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter(circularReferenceTypeFormatter));\n});\n\nconst program = createProgram(config);\nconst parser = createParser(program, config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n### Custom parsing\n\nSimilar to custom formatting, extending the built-in parsing works practically the same way:\n\n1. First we create a parser, in this case for parsing construct types:\n\n```ts\n// my-constructor-parser.ts\nimport { Context, StringType, ReferenceType, BaseType, SubNodeParser } from \"ts-json-schema-generator\";\n// use typescript exported by TJS to avoid version conflict\nimport ts from \"ts-json-schema-generator\";\n\nexport class MyConstructorParser implements SubNodeParser {\n    supportsNode(node: ts.Node): boolean {\n        return node.kind === ts.SyntaxKind.ConstructorType;\n    }\n    createType(node: ts.Node, context: Context, reference?: ReferenceType): BaseType | undefined {\n        return new StringType(); // Treat constructors as strings in this example\n    }\n}\n```\n\n2. Then we add the parser as a child to the core parser using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyConstructorParser } from \"./my-constructor-parser.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst program = createProgram(config);\n\n// We configure the parser an add our custom parser to it.\nconst parser = createParser(program, config, (prs) => {\n    prs.addNodeParser(new MyConstructorParser());\n});\n\nconst formatter = createFormatter(config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n## Options\n\n```\n-p, --path 'index.ts'\n    The path to the TypeScript source file. If this is not provided, the type will be searched in the project specified in the `.tsconfig`.\n\n-t, --type 'My.Type.Name'\n    The type the generated schema will represent. If omitted, the generated schema will contain all\n    types found in the files matching path. The same is true if '*' is specified.\n\n-i, --id 'generatedSchemaId'\n    The `$id` of the generated schema. If omitted, there will be no `$id`.\n\n-e, --expose <all|none|export>\n    all: Create shared $ref definitions for all types.\n    none: Do not create shared $ref definitions.\n    export (default): Create shared $ref definitions only for exported types (not tagged as `@internal`).\n\n-f, --tsconfig 'my/project/tsconfig.json'\n    Use a custom tsconfig file for processing typescript (see https://www.typescriptlang.org/docs/handbook/tsconfig-json.html) instead of the default:\n    {\n        \"compilerOptions\": {\n            \"noEmit\": true,\n            \"emitDecoratorMetadata\": true,\n            \"experimentalDecorators\": true,\n            \"target\": \"ES5\",\n            \"module\": \"CommonJS\",\n            \"strictNullChecks\": false,\n        }\n    }\n\n-j, --jsDoc <extended|none|basic>\n    none: Do not use JsDoc annotations.\n    basic: Read JsDoc annotations to provide schema properties.\n    extended (default): Also read @nullable, and @asType annotations.\n\n--unstable\n    Do not sort properties.\n\n--strict-tuples\n    Do not allow additional items on tuples.\n\n--no-top-ref\n    Do not create a top-level $ref definition.\n\n--no-type-check\n    Skip type checks for better performance.\n\n--no-ref-encode\n    Do not encode references. According to the standard, references must be valid URIs but some tools do not support encoded references.\n\n--validation-keywords\n    Provide additional validation keywords to include.\n\n-o, --out\n    Specify the output file path. Without this option, the generator logs the response in the console.\n\n--additional-properties <true|false>\n    Controls whether or not to allow additional properties for objects that have no index signature.\n\n    true: Additional properties are allowed\n    false (default): Additional properties are not allowed\n\n--minify\n    Minify generated schema (default: false)\n```\n\n## Current state\n\n-   `interface` types\n-   `enum` types\n-   `union`, `tuple`, `type[]` types\n-   `Date`, `RegExp`, `URL` types\n-   `string`, `boolean`, `number` types\n-   `\"value\"`, `123`, `true`, `false`, `null`, `undefined` literals\n-   type aliases\n-   generics\n-   `typeof`\n-   `keyof`\n-   conditional types\n\n## Run locally\n\n`yarn --silent run run --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\n## Debug\n\n`yarn --silent run debug --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\nAnd connect via the debugger protocol.\n\n[AST Explorer](https://astexplorer.net/) is amazing for developers of this tool!\n\n## Publish\n\nPublishing is handled by a 2-branch [pre-release process](https://intuit.github.io/auto/docs/generated/shipit#next-branch-default), configured in `publish-auto.yml`. All changes should be based off the default `next` branch, and are published automatically.\n\n-   PRs made into the default branch are auto-deployed to the `next` pre-release tag on NPM. The result can be installed with `npm install ts-json-schema-generator@next`\n    -   When merging into `next`, please use the `squash and merge` strategy.\n-   To release a new stable version, open a PR from `next` into `stable` using this [compare link](https://github.com/vega/ts-json-schema-generator/compare/stable...next).\n    -   When merging from `next` into `stable`, please use the `create a merge commit` strategy.\n",
      "readmeFilename": "README.md",
      "gitHead": "0ac5df136b539c3b73e0c3acc3473a634243458d",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@1.2.0-next.7",
      "_nodeVersion": "16.18.1",
      "_npmVersion": "8.19.2",
      "dist": {
        "integrity": "sha512-lZb5+A50YrUcf7jnEyOU/PnaQ/RjR/+BpO9dsSd9GaxKNSEhOvVXP6R1BPuWfnfBG1e+X9qyBELBQ1t7MbuSCQ==",
        "shasum": "9fa9e30640285e980723fbb9281f5fe607b4f4e4",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-1.2.0-next.7.tgz",
        "fileCount": 716,
        "unpackedSize": 879252,
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEQCHz5SEYv5q+cANkKrF8WZOEVZJVTW3FUUASjQIo069S8CIQC8tGUnoYp078mM2kRAYrLadu/kfdB8BnWohw54BOARsw=="
          }
        ],
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJjpJBQACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2VmpWCBAAoGdvQWbmHCvavEOd+KtMAv6AROnT4dKPW6jq0JVWl3gZbagn\r\nopLMBYZ+Lw8TfePT/su3w98Sl1jAYfQpDTLtDZl5Y0NX5lA24VUldFSLEfRK\r\nVq5Xagr/m4HRoE9PRBFqoB/lJbdhW1tb1Ef5BxjgND/8IU2epdlFm1jGAIBO\r\nXIY45Xc11UowCvLjSpW8jWGbDUk/94Re5Kj5jfXwf6ITaEDdU5GUHsbX0qF7\r\ng0w9Sh7nHuTuGcZSAOxMZOUeGbS/bgcfUDSD2cwXfsG5IT3AQiBf1BOqFvrV\r\nUbBVu5cXwlIFLWn11fUr5uwpryY9VzDgOnJ/Ztu0XmdZAPB8U8d5OuOBAieR\r\nBTjPGJD0ZrwJeYsFoYafBcbu+71FKKER/+8bKQ9GrR0TpSfrVu/Ewyn+6GIv\r\nN4CC/NDcp7gforBghOmLEsrYvR3CexD8g1/QVT5hz2APw1tMKrmQGY4uSyJ7\r\nLrPDGPzIo4OTmsfsoaAUcB02yl2wn3MeXa7T7xl0vXwSv1EHmqcCETLXLky6\r\nssJDbvB144pj2gexzrL4eoRj8vNTacFBkaLlbSFrqSQKz86+NCwLpZY2DRLm\r\n1Lo99GCQy81JwNSdHbut/IYf45/6gBvPa4LmHB+mdpDQ/ApG78HtOW018fAC\r\neZcemzUm62jNYqY/am8eiW6v1ek0u5yUAZk=\r\n=Nkh+\r\n-----END PGP SIGNATURE-----\r\n"
      },
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "maintainers": [
        {
          "name": "jheer",
          "email": "jeffrey.heer@gmail.com"
        },
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "kanitw",
          "email": "kanitw@gmail.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_1.2.0-next.7_1671729231848_0.1944943442231737"
      },
      "_hasShrinkwrap": false
    },
    "1.2.0": {
      "name": "ts-json-schema-generator",
      "version": "1.2.0",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "MooYeol Prescott Lee",
          "email": "mooyoul@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=10.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.11",
        "commander": "^9.4.1",
        "glob": "^8.0.3",
        "json5": "^2.2.1",
        "normalize-path": "^3.0.0",
        "safe-stable-stringify": "^2.4.1",
        "typescript": "~4.9.3"
      },
      "devDependencies": {
        "@auto-it/conventional-commits": "^10.37.6",
        "@auto-it/first-time-contributor": "^10.37.6",
        "@babel/core": "^7.20.5",
        "@babel/preset-env": "^7.20.2",
        "@babel/preset-typescript": "^7.18.6",
        "@types/glob": "^8.0.0",
        "@types/jest": "^29.2.3",
        "@types/node": "^18.11.10",
        "@types/normalize-path": "^3.0.0",
        "@typescript-eslint/eslint-plugin": "^5.45.0",
        "@typescript-eslint/parser": "^5.45.0",
        "ajv": "^8.11.2",
        "ajv-formats": "^2.1.1",
        "auto": "^10.37.6",
        "chai": "^4.3.7",
        "cross-env": "^7.0.3",
        "eslint": "^8.29.0",
        "eslint-config-prettier": "^8.5.0",
        "eslint-plugin-prettier": "^4.2.1",
        "jest": "^29.3.1",
        "jest-junit": "^15.0.0",
        "prettier": "^2.8.0",
        "ts-node": "^10.9.1",
        "vega": "^5.22.1",
        "vega-lite": "^5.6.0"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint \"{src,test,factory}/**/*.ts\"",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "cross-env FAST_TEST=1 jest test/ --verbose",
        "test:coverage": "yarn jest test/ --collectCoverage=true",
        "test:update": "cross-env UPDATE_SCHEMA=true yarn test:fast",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node-transpile-only ts-json-schema-generator.ts",
        "release": "yarn build && auto shipit"
      },
      "gitHead": "17f47aa3fba70dd305b2347a388df818299266ad",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@1.2.0",
      "_nodeVersion": "16.18.1",
      "_npmVersion": "8.19.2",
      "dist": {
        "integrity": "sha512-tUMeO3ZvA12d3HHh7T/AK8W5hmUhDRNtqWRHSMN3ZRbUFt+UmV0oX8k1RK4SA+a+BKNHpmW2v06MS49e8Fi3Yg==",
        "shasum": "5ccce26c7475ff60a034885bff6bd38e574fb073",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-1.2.0.tgz",
        "fileCount": 716,
        "unpackedSize": 879238,
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEQCIDIgUhGr6EdZdcIAqOoOh5HBgQJ71doW+dnaRnqX1GmhAiB8gOqj6gqZCLHZXDBd3jji8uu23J4+orQ9r5311oGXRg=="
          }
        ],
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJjpJSGACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2Vmpypw/8Duh3PzgEissndFpBIRRLSCG2JBygxqZ1MPPnZd9RBA1JW48P\r\nkG/O0/Hq6Y4gddhFN187vYSRUJ4tnGrcDTSYwaC7KPsB3KhHhkwPI4MPIJX1\r\njhduuVzVs3Ac0NLtB609YUj5UFVoWStAs6++OFFuSWJTa0v6IWhhOrhh0jCK\r\nLkwtACQ5FqtoLBi4DnxlnbXT2350igbiIWrEPGchKb1+Lv6wG+1hmdruAHQp\r\nAs6SZ/PXiqmiMzdpETYQPuJ8kDX1w/bk8MTf/2bh11v/KhBi2xmx1kOCnSMq\r\n0Bdy57wo8YiYkn2JUH4j+12is+Yl+/OsOBxOLUgMvLP0Fc7/HgUcksvnypUR\r\nblfLPji1NmaXWTNY+RJKGrVebex1SUtrKrjrF82WytHW9zzBWmHsryQm42ly\r\nmaGYl0ek9rPyeSShOMb2L6ety8nioMS2kJQmaIBFHIQU0ZDT+cwyWgxtMNWP\r\nhrVfbwF0xdbIwxa8k1uVVwb7SKgYdjIoj7QYmbHivGIDlPjKlIK6pMEvANu/\r\nLP7Iv1BJtkBF8+Gci2zsF6lFX8WzSxsydG7f4PX88kC5Nbnt8ANz18OQImSQ\r\n/jICZeEaNGwQLsZkETvVmrRWSvDDXm3YvHvnYjuYM2ETNlh7JEXdjl6/PX+r\r\n1+LI5BfxoyGhj9PRfE1ekaTanFrSB+78AIQ=\r\n=sBWH\r\n-----END PGP SIGNATURE-----\r\n"
      },
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "maintainers": [
        {
          "name": "jheer",
          "email": "jeffrey.heer@gmail.com"
        },
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "kanitw",
          "email": "kanitw@gmail.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_1.2.0_1671730310673_0.8929596392234049"
      },
      "_hasShrinkwrap": false
    },
    "1.2.1-next.0": {
      "name": "ts-json-schema-generator",
      "version": "1.2.1-next.0",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "MooYeol Prescott Lee",
          "email": "mooyoul@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=10.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.11",
        "commander": "^10.0.0",
        "glob": "^8.0.3",
        "json5": "^2.2.1",
        "normalize-path": "^3.0.0",
        "safe-stable-stringify": "^2.4.1",
        "typescript": "~4.9.3"
      },
      "devDependencies": {
        "@auto-it/conventional-commits": "^10.37.6",
        "@auto-it/first-time-contributor": "^10.37.6",
        "@babel/core": "^7.20.5",
        "@babel/preset-env": "^7.20.2",
        "@babel/preset-typescript": "^7.18.6",
        "@types/glob": "^8.0.0",
        "@types/jest": "^29.2.3",
        "@types/node": "^18.11.10",
        "@types/normalize-path": "^3.0.0",
        "@typescript-eslint/eslint-plugin": "^5.45.0",
        "@typescript-eslint/parser": "^5.45.0",
        "ajv": "^8.11.2",
        "ajv-formats": "^2.1.1",
        "auto": "^10.37.6",
        "chai": "^4.3.7",
        "cross-env": "^7.0.3",
        "eslint": "^8.29.0",
        "eslint-config-prettier": "^8.5.0",
        "eslint-plugin-prettier": "^4.2.1",
        "jest": "^29.3.1",
        "jest-junit": "^15.0.0",
        "prettier": "^2.8.0",
        "ts-node": "^10.9.1",
        "vega": "^5.22.1",
        "vega-lite": "^5.6.0"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint \"{src,test,factory}/**/*.ts\"",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "cross-env FAST_TEST=1 jest test/ --verbose",
        "test:coverage": "yarn jest test/ --collectCoverage=true",
        "test:update": "cross-env UPDATE_SCHEMA=true yarn test:fast",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node-transpile-only ts-json-schema-generator.ts",
        "release": "yarn build && auto shipit"
      },
      "readme": "# ts-json-schema-generator\n\n![Test](https://github.com/vega/ts-json-schema-generator/workflows/Test/badge.svg)\n[![codecov](https://codecov.io/gh/vega/ts-json-schema-generator/branch/master/graph/badge.svg)](https://codecov.io/gh/vega/ts-json-schema-generator)\n[![npm version](https://img.shields.io/npm/v/ts-json-schema-generator.svg)](https://www.npmjs.com/package/ts-json-schema-generator)\n\nExtended version of [https://github.com/xiag-ag/typescript-to-json-schema](https://github.com/xiag-ag/typescript-to-json-schema).\n\nInspired by [`YousefED/typescript-json-schema`](https://github.com/YousefED/typescript-json-schema). Here's the differences list:\n\n-   this implementation avoids the use of `typeChecker.getTypeAtLocation()` (so probably it keeps correct type aliases)\n-   processing AST and formatting JSON schema have been split into two independent steps\n-   not exported types, interfaces, enums are not exposed in the `definitions` section in the JSON schema\n\n## Contributors\n\nThis project is made possible by a [community of contributors](https://github.com/vega/ts-json-schema-generator/graphs/contributors). We welcome contributions of any kind (issues, code, documentation, examples, tests,...). Please read our [code of conduct](https://vega.github.io/vega/about/code-of-conduct).\n\n## CLI Usage\n\nRun the schema generator with npx:\n\n```bash\nnpx ts-json-schema-generator --path 'my/project/**/*.ts' --type 'My.Type.Name'\n```\n\nOr install the package and then run it\n\n```bash\nnpm install --save ts-json-schema-generator\n./node_modules/.bin/ts-json-schema-generator --path 'my/project/**/*.ts' --type 'My.Type.Name'\n```\n\nNote that different platforms (e.g. Windows) may use different path separators so you may have to adjust the command above.\n\nAlso note that you need to quote paths with `*` as otherwise the shell will expand the paths and therefore only pass the first path to the generator.\n\n## Programmatic Usage\n\n```js\n// main.js\n\nconst tsj = require(\"ts-json-schema-generator\");\nconst fs = require(\"fs\");\n\n/** @type {import('ts-json-schema-generator/dist/src/Config').Config} */\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst output_path = \"path/to/output/file\";\n\nconst schema = tsj.createGenerator(config).createSchema(config.type);\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\nRun the schema generator via `node main.js`.\n\n### Custom formatting\n\nExtending the built-in formatting is possible by creating a custom formatter and adding it to the main formatter:\n\n1. First we create a formatter, in this case for formatting function types:\n\n```ts\n// my-function-formatter.ts\nimport { BaseType, Definition, FunctionType, SubTypeFormatter } from \"ts-json-schema-generator\";\nimport ts from \"typescript\";\n\nexport class MyFunctionTypeFormatter implements SubTypeFormatter {\n    // You can skip this line if you don't need childTypeFormatter\n    public constructor(private childTypeFormatter: TypeFormatter) {}\n\n    public supportsType(type: FunctionType): boolean {\n        return type instanceof FunctionType;\n    }\n\n    public getDefinition(type: FunctionType): Definition {\n        // Return a custom schema for the function property.\n        return {\n            type: \"object\",\n            properties: {\n                isFunction: {\n                    type: \"boolean\",\n                    const: true,\n                },\n            },\n        };\n    }\n\n    // If this type does NOT HAVE children, generally all you need is:\n    public getChildren(type: FunctionType): BaseType[] {\n        return [];\n    }\n\n    // However, if children ARE supported, you'll need something similar to\n    // this (see src/TypeFormatter/{Array,Definition,etc}.ts for some examples):\n    public getChildren(type: FunctionType): BaseType[] {\n        return this.childTypeFormatter.getChildren(type.getType());\n    }\n}\n```\n\n2. Then we add the formatter as a child to the core formatter using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyFunctionTypeFormatter } from \"./my-function-formatter.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\n// We configure the formatter an add our custom formatter to it.\nconst formatter = createFormatter(config, (fmt, circularReferenceTypeFormatter) => {\n    // If your formatter DOES NOT support children, e.g. getChildren() { return [] }:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter());\n    // If your formatter DOES support children, you'll need this reference too:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter(circularReferenceTypeFormatter));\n});\n\nconst program = createProgram(config);\nconst parser = createParser(program, config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n### Custom parsing\n\nSimilar to custom formatting, extending the built-in parsing works practically the same way:\n\n1. First we create a parser, in this case for parsing construct types:\n\n```ts\n// my-constructor-parser.ts\nimport { Context, StringType, ReferenceType, BaseType, SubNodeParser } from \"ts-json-schema-generator\";\n// use typescript exported by TJS to avoid version conflict\nimport ts from \"ts-json-schema-generator\";\n\nexport class MyConstructorParser implements SubNodeParser {\n    supportsNode(node: ts.Node): boolean {\n        return node.kind === ts.SyntaxKind.ConstructorType;\n    }\n    createType(node: ts.Node, context: Context, reference?: ReferenceType): BaseType | undefined {\n        return new StringType(); // Treat constructors as strings in this example\n    }\n}\n```\n\n2. Then we add the parser as a child to the core parser using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyConstructorParser } from \"./my-constructor-parser.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst program = createProgram(config);\n\n// We configure the parser an add our custom parser to it.\nconst parser = createParser(program, config, (prs) => {\n    prs.addNodeParser(new MyConstructorParser());\n});\n\nconst formatter = createFormatter(config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n## Options\n\n```\n-p, --path 'index.ts'\n    The path to the TypeScript source file. If this is not provided, the type will be searched in the project specified in the `.tsconfig`.\n\n-t, --type 'My.Type.Name'\n    The type the generated schema will represent. If omitted, the generated schema will contain all\n    types found in the files matching path. The same is true if '*' is specified.\n\n-i, --id 'generatedSchemaId'\n    The `$id` of the generated schema. If omitted, there will be no `$id`.\n\n-e, --expose <all|none|export>\n    all: Create shared $ref definitions for all types.\n    none: Do not create shared $ref definitions.\n    export (default): Create shared $ref definitions only for exported types (not tagged as `@internal`).\n\n-f, --tsconfig 'my/project/tsconfig.json'\n    Use a custom tsconfig file for processing typescript (see https://www.typescriptlang.org/docs/handbook/tsconfig-json.html) instead of the default:\n    {\n        \"compilerOptions\": {\n            \"noEmit\": true,\n            \"emitDecoratorMetadata\": true,\n            \"experimentalDecorators\": true,\n            \"target\": \"ES5\",\n            \"module\": \"CommonJS\",\n            \"strictNullChecks\": false,\n        }\n    }\n\n-j, --jsDoc <extended|none|basic>\n    none: Do not use JsDoc annotations.\n    basic: Read JsDoc annotations to provide schema properties.\n    extended (default): Also read @nullable, and @asType annotations.\n\n--unstable\n    Do not sort properties.\n\n--strict-tuples\n    Do not allow additional items on tuples.\n\n--no-top-ref\n    Do not create a top-level $ref definition.\n\n--no-type-check\n    Skip type checks for better performance.\n\n--no-ref-encode\n    Do not encode references. According to the standard, references must be valid URIs but some tools do not support encoded references.\n\n--validation-keywords\n    Provide additional validation keywords to include.\n\n-o, --out\n    Specify the output file path. Without this option, the generator logs the response in the console.\n\n--additional-properties <true|false>\n    Controls whether or not to allow additional properties for objects that have no index signature.\n\n    true: Additional properties are allowed\n    false (default): Additional properties are not allowed\n\n--minify\n    Minify generated schema (default: false)\n```\n\n## Current state\n\n-   `interface` types\n-   `enum` types\n-   `union`, `tuple`, `type[]` types\n-   `Date`, `RegExp`, `URL` types\n-   `string`, `boolean`, `number` types\n-   `\"value\"`, `123`, `true`, `false`, `null`, `undefined` literals\n-   type aliases\n-   generics\n-   `typeof`\n-   `keyof`\n-   conditional types\n\n## Run locally\n\n`yarn --silent run run --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\n## Debug\n\n`yarn --silent run debug --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\nAnd connect via the debugger protocol.\n\n[AST Explorer](https://astexplorer.net/) is amazing for developers of this tool!\n\n## Publish\n\nPublishing is handled by a 2-branch [pre-release process](https://intuit.github.io/auto/docs/generated/shipit#next-branch-default), configured in `publish-auto.yml`. All changes should be based off the default `next` branch, and are published automatically.\n\n-   PRs made into the default branch are auto-deployed to the `next` pre-release tag on NPM. The result can be installed with `npm install ts-json-schema-generator@next`\n    -   When merging into `next`, please use the `squash and merge` strategy.\n-   To release a new stable version, open a PR from `next` into `stable` using this [compare link](https://github.com/vega/ts-json-schema-generator/compare/stable...next).\n    -   When merging from `next` into `stable`, please use the `create a merge commit` strategy.\n",
      "readmeFilename": "README.md",
      "gitHead": "d32af625f0f05e057e189dc1181dbfa2974d6621",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@1.2.1-next.0",
      "_nodeVersion": "16.19.0",
      "_npmVersion": "8.19.3",
      "dist": {
        "integrity": "sha512-qCSUYOkLWRcNjXK3PnHBw9h/DD4ki2vmUxUfUcl+yl2WV4fTxS1cPfySEBd7ywo7sd7DLcldeJyIwxCr07FZEA==",
        "shasum": "9954986f983f18d4395cae7844b00f2c048526b8",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-1.2.1-next.0.tgz",
        "fileCount": 716,
        "unpackedSize": 880335,
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIEQjT8+KAqZGNK2SMvZM0ZtY/6o6gEG2m3abpdqDLkFYAiEAh9J/VH44FzS7gca4Mf1R3ko1KHW1gXM3t+xgyvDqXoI="
          }
        ],
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJjysPqACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2Vmpwkw/+NQw5GIp9HODXC1ANXae7lepjZcDEFVTZLUouR3Z78ENp0oNe\r\n2FI/FtjRoH93ZPCWqU5tVC4upWZa2cBGm2EKzjFsPJvycSQm1rali5I0LNVg\r\njGl44PKybVn10asUh+yLhPGWX8AQxTiAxv8m+ZL65dqb7o/QNJhuJXZBjAan\r\nBaDSgBIDXDWa2jbtWzOaKst0dHWFihRNE1W5YgufoiTCOC14CKSvoNeZseep\r\nTDOqJlwiQJXPjuCPzfIqwcngV/7jeVU22CD1vclpfmz7k6AVjOa9TIPoE0Y1\r\ndCAQfl+/6CrKFZLmmeJLjydwnXTt8XfM7ygV1auIws0Npc2YEbly/Db86cba\r\nlU8wfJk1dSjr+Jh6Zkt37v/7iPbqpyV12+25bUXbBc0ZsgMSa423eQPkujiF\r\ntEzVTGYe7gknncjY66BwzSuLu2QeJ23W94QprFYFYZEHJiSq4O8zInTvlJ1D\r\n+D0c16KksTnZDhvhpi1QgtpmEAj+zI4Gs82P0bQF/x1Mt/O+M4/VU99aaeeP\r\nmjosHOUxOeezr269gf8kk0zefdzKaL4Adfzj3UG+57HUoILfpyT6rDQmaL5J\r\nsy10MpTnKqtsnb555eB4RK/1au5B9m45xk61HS/4cA3S/DcD0BQN0Jfm7rX2\r\nbDhyZE9VGJuD4wfso4PV3Y9am8fmVkMlVlI=\r\n=ulVO\r\n-----END PGP SIGNATURE-----\r\n"
      },
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "maintainers": [
        {
          "name": "jheer",
          "email": "jeffrey.heer@gmail.com"
        },
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "kanitw",
          "email": "kanitw@gmail.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_1.2.1-next.0_1674232810643_0.8969591171357933"
      },
      "_hasShrinkwrap": false
    },
    "1.2.1-next.1": {
      "name": "ts-json-schema-generator",
      "version": "1.2.1-next.1",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "MooYeol Prescott Lee",
          "email": "mooyoul@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=10.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.11",
        "commander": "^10.0.0",
        "glob": "^8.0.3",
        "json5": "^2.2.1",
        "normalize-path": "^3.0.0",
        "safe-stable-stringify": "^2.4.1",
        "typescript": "~4.9.3"
      },
      "devDependencies": {
        "@auto-it/conventional-commits": "^10.37.6",
        "@auto-it/first-time-contributor": "^10.37.6",
        "@babel/core": "^7.20.5",
        "@babel/preset-env": "^7.20.2",
        "@babel/preset-typescript": "^7.18.6",
        "@types/glob": "^8.0.0",
        "@types/jest": "^29.2.3",
        "@types/node": "^18.11.10",
        "@types/normalize-path": "^3.0.0",
        "@typescript-eslint/eslint-plugin": "^5.45.0",
        "@typescript-eslint/parser": "^5.45.0",
        "ajv": "^8.11.2",
        "ajv-formats": "^2.1.1",
        "auto": "^10.37.6",
        "chai": "^4.3.7",
        "cross-env": "^7.0.3",
        "eslint": "^8.29.0",
        "eslint-config-prettier": "^8.5.0",
        "eslint-plugin-prettier": "^4.2.1",
        "jest": "^29.3.1",
        "jest-junit": "^15.0.0",
        "prettier": "^2.8.0",
        "ts-node": "^10.9.1",
        "vega": "^5.22.1",
        "vega-lite": "^5.6.0"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint \"{src,test,factory}/**/*.ts\"",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "cross-env FAST_TEST=1 jest test/ --verbose",
        "test:coverage": "yarn jest test/ --collectCoverage=true",
        "test:update": "cross-env UPDATE_SCHEMA=true yarn test:fast",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node-transpile-only ts-json-schema-generator.ts",
        "release": "yarn build && auto shipit"
      },
      "readme": "# ts-json-schema-generator\n\n![Test](https://github.com/vega/ts-json-schema-generator/workflows/Test/badge.svg)\n[![codecov](https://codecov.io/gh/vega/ts-json-schema-generator/branch/master/graph/badge.svg)](https://codecov.io/gh/vega/ts-json-schema-generator)\n[![npm version](https://img.shields.io/npm/v/ts-json-schema-generator.svg)](https://www.npmjs.com/package/ts-json-schema-generator)\n\nExtended version of [https://github.com/xiag-ag/typescript-to-json-schema](https://github.com/xiag-ag/typescript-to-json-schema).\n\nInspired by [`YousefED/typescript-json-schema`](https://github.com/YousefED/typescript-json-schema). Here's the differences list:\n\n-   this implementation avoids the use of `typeChecker.getTypeAtLocation()` (so probably it keeps correct type aliases)\n-   processing AST and formatting JSON schema have been split into two independent steps\n-   not exported types, interfaces, enums are not exposed in the `definitions` section in the JSON schema\n\n## Contributors\n\nThis project is made possible by a [community of contributors](https://github.com/vega/ts-json-schema-generator/graphs/contributors). We welcome contributions of any kind (issues, code, documentation, examples, tests,...). Please read our [code of conduct](https://vega.github.io/vega/about/code-of-conduct).\n\n## CLI Usage\n\nRun the schema generator with npx:\n\n```bash\nnpx ts-json-schema-generator --path 'my/project/**/*.ts' --type 'My.Type.Name'\n```\n\nOr install the package and then run it\n\n```bash\nnpm install --save ts-json-schema-generator\n./node_modules/.bin/ts-json-schema-generator --path 'my/project/**/*.ts' --type 'My.Type.Name'\n```\n\nNote that different platforms (e.g. Windows) may use different path separators so you may have to adjust the command above.\n\nAlso note that you need to quote paths with `*` as otherwise the shell will expand the paths and therefore only pass the first path to the generator.\n\n## Programmatic Usage\n\n```js\n// main.js\n\nconst tsj = require(\"ts-json-schema-generator\");\nconst fs = require(\"fs\");\n\n/** @type {import('ts-json-schema-generator/dist/src/Config').Config} */\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst output_path = \"path/to/output/file\";\n\nconst schema = tsj.createGenerator(config).createSchema(config.type);\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\nRun the schema generator via `node main.js`.\n\n### Custom formatting\n\nExtending the built-in formatting is possible by creating a custom formatter and adding it to the main formatter:\n\n1. First we create a formatter, in this case for formatting function types:\n\n```ts\n// my-function-formatter.ts\nimport { BaseType, Definition, FunctionType, SubTypeFormatter } from \"ts-json-schema-generator\";\nimport ts from \"typescript\";\n\nexport class MyFunctionTypeFormatter implements SubTypeFormatter {\n    // You can skip this line if you don't need childTypeFormatter\n    public constructor(private childTypeFormatter: TypeFormatter) {}\n\n    public supportsType(type: FunctionType): boolean {\n        return type instanceof FunctionType;\n    }\n\n    public getDefinition(type: FunctionType): Definition {\n        // Return a custom schema for the function property.\n        return {\n            type: \"object\",\n            properties: {\n                isFunction: {\n                    type: \"boolean\",\n                    const: true,\n                },\n            },\n        };\n    }\n\n    // If this type does NOT HAVE children, generally all you need is:\n    public getChildren(type: FunctionType): BaseType[] {\n        return [];\n    }\n\n    // However, if children ARE supported, you'll need something similar to\n    // this (see src/TypeFormatter/{Array,Definition,etc}.ts for some examples):\n    public getChildren(type: FunctionType): BaseType[] {\n        return this.childTypeFormatter.getChildren(type.getType());\n    }\n}\n```\n\n2. Then we add the formatter as a child to the core formatter using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyFunctionTypeFormatter } from \"./my-function-formatter.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\n// We configure the formatter an add our custom formatter to it.\nconst formatter = createFormatter(config, (fmt, circularReferenceTypeFormatter) => {\n    // If your formatter DOES NOT support children, e.g. getChildren() { return [] }:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter());\n    // If your formatter DOES support children, you'll need this reference too:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter(circularReferenceTypeFormatter));\n});\n\nconst program = createProgram(config);\nconst parser = createParser(program, config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n### Custom parsing\n\nSimilar to custom formatting, extending the built-in parsing works practically the same way:\n\n1. First we create a parser, in this case for parsing construct types:\n\n```ts\n// my-constructor-parser.ts\nimport { Context, StringType, ReferenceType, BaseType, SubNodeParser } from \"ts-json-schema-generator\";\n// use typescript exported by TJS to avoid version conflict\nimport ts from \"ts-json-schema-generator\";\n\nexport class MyConstructorParser implements SubNodeParser {\n    supportsNode(node: ts.Node): boolean {\n        return node.kind === ts.SyntaxKind.ConstructorType;\n    }\n    createType(node: ts.Node, context: Context, reference?: ReferenceType): BaseType | undefined {\n        return new StringType(); // Treat constructors as strings in this example\n    }\n}\n```\n\n2. Then we add the parser as a child to the core parser using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyConstructorParser } from \"./my-constructor-parser.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst program = createProgram(config);\n\n// We configure the parser an add our custom parser to it.\nconst parser = createParser(program, config, (prs) => {\n    prs.addNodeParser(new MyConstructorParser());\n});\n\nconst formatter = createFormatter(config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n## Options\n\n```\n-p, --path 'index.ts'\n    The path to the TypeScript source file. If this is not provided, the type will be searched in the project specified in the `.tsconfig`.\n\n-t, --type 'My.Type.Name'\n    The type the generated schema will represent. If omitted, the generated schema will contain all\n    types found in the files matching path. The same is true if '*' is specified.\n\n-i, --id 'generatedSchemaId'\n    The `$id` of the generated schema. If omitted, there will be no `$id`.\n\n-e, --expose <all|none|export>\n    all: Create shared $ref definitions for all types.\n    none: Do not create shared $ref definitions.\n    export (default): Create shared $ref definitions only for exported types (not tagged as `@internal`).\n\n-f, --tsconfig 'my/project/tsconfig.json'\n    Use a custom tsconfig file for processing typescript (see https://www.typescriptlang.org/docs/handbook/tsconfig-json.html) instead of the default:\n    {\n        \"compilerOptions\": {\n            \"noEmit\": true,\n            \"emitDecoratorMetadata\": true,\n            \"experimentalDecorators\": true,\n            \"target\": \"ES5\",\n            \"module\": \"CommonJS\",\n            \"strictNullChecks\": false,\n        }\n    }\n\n-j, --jsDoc <extended|none|basic>\n    none: Do not use JsDoc annotations.\n    basic: Read JsDoc annotations to provide schema properties.\n    extended (default): Also read @nullable, and @asType annotations.\n\n--unstable\n    Do not sort properties.\n\n--strict-tuples\n    Do not allow additional items on tuples.\n\n--no-top-ref\n    Do not create a top-level $ref definition.\n\n--no-type-check\n    Skip type checks for better performance.\n\n--no-ref-encode\n    Do not encode references. According to the standard, references must be valid URIs but some tools do not support encoded references.\n\n--validation-keywords\n    Provide additional validation keywords to include.\n\n-o, --out\n    Specify the output file path. Without this option, the generator logs the response in the console.\n\n--additional-properties <true|false>\n    Controls whether or not to allow additional properties for objects that have no index signature.\n\n    true: Additional properties are allowed\n    false (default): Additional properties are not allowed\n\n--minify\n    Minify generated schema (default: false)\n```\n\n## Current state\n\n-   `interface` types\n-   `enum` types\n-   `union`, `tuple`, `type[]` types\n-   `Date`, `RegExp`, `URL` types\n-   `string`, `boolean`, `number` types\n-   `\"value\"`, `123`, `true`, `false`, `null`, `undefined` literals\n-   type aliases\n-   generics\n-   `typeof`\n-   `keyof`\n-   conditional types\n\n## Run locally\n\n`yarn --silent run run --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\n## Debug\n\n`yarn --silent run debug --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\nAnd connect via the debugger protocol.\n\n[AST Explorer](https://astexplorer.net/) is amazing for developers of this tool!\n\n## Publish\n\nPublishing is handled by a 2-branch [pre-release process](https://intuit.github.io/auto/docs/generated/shipit#next-branch-default), configured in `publish-auto.yml`. All changes should be based off the default `next` branch, and are published automatically.\n\n-   PRs made into the default branch are auto-deployed to the `next` pre-release tag on NPM. The result can be installed with `npm install ts-json-schema-generator@next`\n    -   When merging into `next`, please use the `squash and merge` strategy.\n-   To release a new stable version, open a PR from `next` into `stable` using this [compare link](https://github.com/vega/ts-json-schema-generator/compare/stable...next).\n    -   When merging from `next` into `stable`, please use the `create a merge commit` strategy.\n",
      "readmeFilename": "README.md",
      "gitHead": "8d95b0a6110c06e48bd1bbf8bb5169d76c70df58",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@1.2.1-next.1",
      "_nodeVersion": "16.19.0",
      "_npmVersion": "8.19.3",
      "dist": {
        "integrity": "sha512-85Z5vTZbUgxZtpboZqTeGWdm1PfmEgfKFQz4GNSgU1d3AqUYynKmphO0RnqNsklCJzQc4Hlv6ydmWf2/ZBaQpA==",
        "shasum": "0fa3d31e3f4b8abbd3ea4a713bd4f17013918c07",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-1.2.1-next.1.tgz",
        "fileCount": 716,
        "unpackedSize": 880590,
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIQCKO4E3RTrFXw5I6R0OhYawvskrWnxeMYh5CaJVRDLgqgIgLA5IB5yDdZ8dhB3w2UMqUZzEXSOO4gQiaQAz5ZUl9x8="
          }
        ],
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJj08lkACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2VmrBpg//Q45SgQsGM2yfl0iY0AB+HtjCJJSHjNnzOFP5mDbYlF0uZY67\r\nJ68CVyZpOZ2+zKHG03PRP7xEB8O9k8GbiVVQhNAf9SAlYONvEac5g1bWfIQL\r\nJboI7w+798p3dI9a8QldrQRW9DSnHLOOKY0WK0xvY5r+UFpjxpSP9ia49hBL\r\nVCrZf3L2DbsPoHfMTS0wwAArhkDy6Dek6qnIo8roXowwPMRc7vZoQWbsTQgx\r\nSPJyx1oECmduDcJy5Uvpm12O6A1wcEMQmEphd/8TaFff6wCsNultKErC0sHq\r\nH+VdGMaPfc4cCE7lEDwfDhZb3nVVOf+BqQFGZtWbFGpNUeO/tOrXmeZeflEj\r\nIk8fjwFV8M23sXw1Md1iTq4jdldPrSr4LQMEzOY+ckeTbfIvUvX4+J1wiHUM\r\nuuTVy8ihV52crO+ilXScWCimURphZ0erA43JmjhNDpMOTtoX639bLbHOeVV+\r\nRnPf/6iMDRbfwN8kOZzDv56pLtAKueNansPdwgQw9Slmwd30TGIGjLssC85V\r\nh008oFyzlNUAtMypU8T3DTpLmPXH8fiT0aIPCuRDybJiAkzZzeuE+NC9A5w8\r\ntFSe3/Ld1fxsL+I+5yuhhJxU4MVKh41POY4hnBQFFynhVW1Qn2tqckaG67OG\r\npnIbmtrkq+Noda3OFaoZ4IuAuWujB7hWjnE=\r\n=5Mms\r\n-----END PGP SIGNATURE-----\r\n"
      },
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "maintainers": [
        {
          "name": "jheer",
          "email": "jeffrey.heer@gmail.com"
        },
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "kanitw",
          "email": "kanitw@gmail.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_1.2.1-next.1_1674824035908_0.5337461678822277"
      },
      "_hasShrinkwrap": false
    },
    "1.2.1--canary.1546.3e5f67d.0": {
      "name": "ts-json-schema-generator",
      "version": "1.2.1--canary.1546.3e5f67d.0",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "MooYeol Prescott Lee",
          "email": "mooyoul@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=10.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.11",
        "commander": "^10.0.0",
        "glob": "^8.0.3",
        "json5": "^2.2.1",
        "normalize-path": "^3.0.0",
        "safe-stable-stringify": "^2.4.1",
        "typescript": "~4.9.3"
      },
      "devDependencies": {
        "@auto-it/conventional-commits": "^10.37.6",
        "@auto-it/first-time-contributor": "^10.37.6",
        "@babel/core": "^7.20.5",
        "@babel/preset-env": "^7.20.2",
        "@babel/preset-typescript": "^7.18.6",
        "@types/glob": "^8.0.0",
        "@types/jest": "^29.2.3",
        "@types/node": "^18.11.10",
        "@types/normalize-path": "^3.0.0",
        "@typescript-eslint/eslint-plugin": "^5.45.0",
        "@typescript-eslint/parser": "^5.45.0",
        "ajv": "^8.11.2",
        "ajv-formats": "^2.1.1",
        "auto": "^10.37.6",
        "chai": "^4.3.7",
        "cross-env": "^7.0.3",
        "eslint": "^8.29.0",
        "eslint-config-prettier": "^8.5.0",
        "eslint-plugin-prettier": "^4.2.1",
        "jest": "^29.3.1",
        "jest-junit": "^15.0.0",
        "prettier": "^2.8.0",
        "ts-node": "^10.9.1",
        "vega": "^5.22.1",
        "vega-lite": "^5.6.0"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint \"{src,test,factory}/**/*.ts\"",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "cross-env FAST_TEST=1 jest test/ --verbose",
        "test:coverage": "yarn jest test/ --collectCoverage=true",
        "test:update": "cross-env UPDATE_SCHEMA=true yarn test:fast",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node-transpile-only ts-json-schema-generator.ts",
        "release": "yarn build && auto shipit"
      },
      "readme": "# ts-json-schema-generator\n\n![Test](https://github.com/vega/ts-json-schema-generator/workflows/Test/badge.svg)\n[![codecov](https://codecov.io/gh/vega/ts-json-schema-generator/branch/master/graph/badge.svg)](https://codecov.io/gh/vega/ts-json-schema-generator)\n[![npm version](https://img.shields.io/npm/v/ts-json-schema-generator.svg)](https://www.npmjs.com/package/ts-json-schema-generator)\n\nExtended version of [https://github.com/xiag-ag/typescript-to-json-schema](https://github.com/xiag-ag/typescript-to-json-schema).\n\nInspired by [`YousefED/typescript-json-schema`](https://github.com/YousefED/typescript-json-schema). Here's the differences list:\n\n-   this implementation avoids the use of `typeChecker.getTypeAtLocation()` (so probably it keeps correct type aliases)\n-   processing AST and formatting JSON schema have been split into two independent steps\n-   not exported types, interfaces, enums are not exposed in the `definitions` section in the JSON schema\n\n## Contributors\n\nThis project is made possible by a [community of contributors](https://github.com/vega/ts-json-schema-generator/graphs/contributors). We welcome contributions of any kind (issues, code, documentation, examples, tests,...). Please read our [code of conduct](https://vega.github.io/vega/about/code-of-conduct).\n\n## CLI Usage\n\nRun the schema generator with npx:\n\n```bash\nnpx ts-json-schema-generator --path 'my/project/**/*.ts' --type 'My.Type.Name'\n```\n\nOr install the package and then run it\n\n```bash\nnpm install --save ts-json-schema-generator\n./node_modules/.bin/ts-json-schema-generator --path 'my/project/**/*.ts' --type 'My.Type.Name'\n```\n\nNote that different platforms (e.g. Windows) may use different path separators so you may have to adjust the command above.\n\nAlso note that you need to quote paths with `*` as otherwise the shell will expand the paths and therefore only pass the first path to the generator.\n\n## Programmatic Usage\n\n```js\n// main.js\n\nconst tsj = require(\"ts-json-schema-generator\");\nconst fs = require(\"fs\");\n\n/** @type {import('ts-json-schema-generator/dist/src/Config').Config} */\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst output_path = \"path/to/output/file\";\n\nconst schema = tsj.createGenerator(config).createSchema(config.type);\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\nRun the schema generator via `node main.js`.\n\n### Custom formatting\n\nExtending the built-in formatting is possible by creating a custom formatter and adding it to the main formatter:\n\n1. First we create a formatter, in this case for formatting function types:\n\n```ts\n// my-function-formatter.ts\nimport { BaseType, Definition, FunctionType, SubTypeFormatter } from \"ts-json-schema-generator\";\nimport ts from \"typescript\";\n\nexport class MyFunctionTypeFormatter implements SubTypeFormatter {\n    // You can skip this line if you don't need childTypeFormatter\n    public constructor(private childTypeFormatter: TypeFormatter) {}\n\n    public supportsType(type: FunctionType): boolean {\n        return type instanceof FunctionType;\n    }\n\n    public getDefinition(type: FunctionType): Definition {\n        // Return a custom schema for the function property.\n        return {\n            type: \"object\",\n            properties: {\n                isFunction: {\n                    type: \"boolean\",\n                    const: true,\n                },\n            },\n        };\n    }\n\n    // If this type does NOT HAVE children, generally all you need is:\n    public getChildren(type: FunctionType): BaseType[] {\n        return [];\n    }\n\n    // However, if children ARE supported, you'll need something similar to\n    // this (see src/TypeFormatter/{Array,Definition,etc}.ts for some examples):\n    public getChildren(type: FunctionType): BaseType[] {\n        return this.childTypeFormatter.getChildren(type.getType());\n    }\n}\n```\n\n2. Then we add the formatter as a child to the core formatter using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyFunctionTypeFormatter } from \"./my-function-formatter.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\n// We configure the formatter an add our custom formatter to it.\nconst formatter = createFormatter(config, (fmt, circularReferenceTypeFormatter) => {\n    // If your formatter DOES NOT support children, e.g. getChildren() { return [] }:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter());\n    // If your formatter DOES support children, you'll need this reference too:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter(circularReferenceTypeFormatter));\n});\n\nconst program = createProgram(config);\nconst parser = createParser(program, config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n### Custom parsing\n\nSimilar to custom formatting, extending the built-in parsing works practically the same way:\n\n1. First we create a parser, in this case for parsing construct types:\n\n```ts\n// my-constructor-parser.ts\nimport { Context, StringType, ReferenceType, BaseType, SubNodeParser } from \"ts-json-schema-generator\";\n// use typescript exported by TJS to avoid version conflict\nimport ts from \"ts-json-schema-generator\";\n\nexport class MyConstructorParser implements SubNodeParser {\n    supportsNode(node: ts.Node): boolean {\n        return node.kind === ts.SyntaxKind.ConstructorType;\n    }\n    createType(node: ts.Node, context: Context, reference?: ReferenceType): BaseType | undefined {\n        return new StringType(); // Treat constructors as strings in this example\n    }\n}\n```\n\n2. Then we add the parser as a child to the core parser using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyConstructorParser } from \"./my-constructor-parser.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst program = createProgram(config);\n\n// We configure the parser an add our custom parser to it.\nconst parser = createParser(program, config, (prs) => {\n    prs.addNodeParser(new MyConstructorParser());\n});\n\nconst formatter = createFormatter(config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n## Options\n\n```\n-p, --path 'index.ts'\n    The path to the TypeScript source file. If this is not provided, the type will be searched in the project specified in the `.tsconfig`.\n\n-t, --type 'My.Type.Name'\n    The type the generated schema will represent. If omitted, the generated schema will contain all\n    types found in the files matching path. The same is true if '*' is specified.\n\n-i, --id 'generatedSchemaId'\n    The `$id` of the generated schema. If omitted, there will be no `$id`.\n\n-e, --expose <all|none|export>\n    all: Create shared $ref definitions for all types.\n    none: Do not create shared $ref definitions.\n    export (default): Create shared $ref definitions only for exported types (not tagged as `@internal`).\n\n-f, --tsconfig 'my/project/tsconfig.json'\n    Use a custom tsconfig file for processing typescript (see https://www.typescriptlang.org/docs/handbook/tsconfig-json.html) instead of the default:\n    {\n        \"compilerOptions\": {\n            \"noEmit\": true,\n            \"emitDecoratorMetadata\": true,\n            \"experimentalDecorators\": true,\n            \"target\": \"ES5\",\n            \"module\": \"CommonJS\",\n            \"strictNullChecks\": false,\n        }\n    }\n\n-j, --jsDoc <extended|none|basic>\n    none: Do not use JsDoc annotations.\n    basic: Read JsDoc annotations to provide schema properties.\n    extended (default): Also read @nullable, and @asType annotations.\n\n--unstable\n    Do not sort properties.\n\n--strict-tuples\n    Do not allow additional items on tuples.\n\n--no-top-ref\n    Do not create a top-level $ref definition.\n\n--no-type-check\n    Skip type checks for better performance.\n\n--no-ref-encode\n    Do not encode references. According to the standard, references must be valid URIs but some tools do not support encoded references.\n\n--validation-keywords\n    Provide additional validation keywords to include.\n\n-o, --out\n    Specify the output file path. Without this option, the generator logs the response in the console.\n\n--additional-properties <true|false>\n    Controls whether or not to allow additional properties for objects that have no index signature.\n\n    true: Additional properties are allowed\n    false (default): Additional properties are not allowed\n\n--minify\n    Minify generated schema (default: false)\n```\n\n## Current state\n\n-   `interface` types\n-   `enum` types\n-   `union`, `tuple`, `type[]` types\n-   `Date`, `RegExp`, `URL` types\n-   `string`, `boolean`, `number` types\n-   `\"value\"`, `123`, `true`, `false`, `null`, `undefined` literals\n-   type aliases\n-   generics\n-   `typeof`\n-   `keyof`\n-   conditional types\n\n## Run locally\n\n`yarn --silent run run --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\n## Debug\n\n`yarn --silent run debug --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\nAnd connect via the debugger protocol.\n\n[AST Explorer](https://astexplorer.net/) is amazing for developers of this tool!\n\n## Publish\n\nPublishing is handled by a 2-branch [pre-release process](https://intuit.github.io/auto/docs/generated/shipit#next-branch-default), configured in `publish-auto.yml`. All changes should be based off the default `next` branch, and are published automatically.\n\n-   PRs made into the default branch are auto-deployed to the `next` pre-release tag on NPM. The result can be installed with `npm install ts-json-schema-generator@next`\n    -   When merging into `next`, please use the `squash and merge` strategy.\n-   To release a new stable version, open a PR from `next` into `stable` using this [compare link](https://github.com/vega/ts-json-schema-generator/compare/stable...next).\n    -   When merging from `next` into `stable`, please use the `create a merge commit` strategy.\n",
      "readmeFilename": "README.md",
      "gitHead": "3e5f67d406bdcb5e109614268bb51c55df48e76f",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@1.2.1--canary.1546.3e5f67d.0",
      "_nodeVersion": "16.19.0",
      "_npmVersion": "8.19.3",
      "dist": {
        "integrity": "sha512-OdvvbLNf+m2UcqdJmyjz48vPcuTa/Mt6vOVL1RKsKwf69zJxB4H71qhxgGu5eAA7gOVj3ymX0pSWmLh4VMro7g==",
        "shasum": "793314aa9168c4013a47e06b59e2931a70a96cbc",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-1.2.1--canary.1546.3e5f67d.0.tgz",
        "fileCount": 716,
        "unpackedSize": 880579,
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIQCMlCFFPdVmjOhz1trNT1AFJoOEPnFD2QNr0pFX6c1KVAIgb/1ncHFRZcUPxV9C5lepvPfKGMsSwbBtU9bS19gcvwM="
          }
        ],
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJj0+nAACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2VmowxQ//d8uuDJVyZSxaYbhfjc5dvbkJ8y5szA9ELmrBz2SKyZgoZVjy\r\nTuRmmZJ45VLdBUDaiXzypEGun54mvC1wc+ClBY4WdYSF9xtRBSAJvIlKHIbU\r\nAf5+/Qj+mKJkDKA/5nsBP+dDPXQlCFVl32G6bYPZs6IsBrzX4JFelm/qiOP4\r\ntwIkMOIOoAx5U8HQVKgPXezJdHOTGRZtmKweg6h+bmmXAgrHhLpr0Kzpx0Ja\r\nkWaKb+IqaN9U72nETy48vNBESy5D9c6mdDjzKUZfzXyb768lEVMVWHCezVpA\r\nSV31W/kbl3RxMY7+VUEDSKPhgXbJ3tHuhdWg8mZxcMRggMPJ5zJ4jBSj6IFB\r\n1vk3nT49V/3Jm64HuKI42BWBxgOd5lgclYSuzkJ4LPp5A0mlIML/36+Gzzwi\r\neyH+1arRz5tpARXvzKm8q/qWC9yNi6qo2Hk49P34+EugImOFDZ/FubeDqsMQ\r\n9iu7SyHT895KcI2Qq45ZvO5qrQI3KZ0FCwfA0o1v3Y5jkeSYyhylV1QQNOPC\r\nf3hQsRsZo+FoYRbeZD7g4iSVN/tvVqKZ+55588dUAoyPCI8nh30rdi/I4FLg\r\nadsj6KoqLvmHEZ7a05A3x8FkKcA1DXT7XRuwjRd5Ck3t9226WOU1nted2957\r\n6ayPer0NLx/6DgRG4TKinCQWBJLLKMPiYMM=\r\n=7BIb\r\n-----END PGP SIGNATURE-----\r\n"
      },
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "maintainers": [
        {
          "name": "jheer",
          "email": "jeffrey.heer@gmail.com"
        },
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "kanitw",
          "email": "kanitw@gmail.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_1.2.1--canary.1546.3e5f67d.0_1674832320383_0.911021597253014"
      },
      "_hasShrinkwrap": false
    },
    "1.2.1-next.2": {
      "name": "ts-json-schema-generator",
      "version": "1.2.1-next.2",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "MooYeol Prescott Lee",
          "email": "mooyoul@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=10.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.11",
        "commander": "^10.0.0",
        "glob": "^8.0.3",
        "json5": "^2.2.1",
        "normalize-path": "^3.0.0",
        "safe-stable-stringify": "^2.4.1",
        "typescript": "~4.9.3"
      },
      "devDependencies": {
        "@auto-it/conventional-commits": "^10.37.6",
        "@auto-it/first-time-contributor": "^10.37.6",
        "@babel/core": "^7.20.5",
        "@babel/preset-env": "^7.20.2",
        "@babel/preset-typescript": "^7.18.6",
        "@types/glob": "^8.0.0",
        "@types/jest": "^29.2.3",
        "@types/node": "^18.11.10",
        "@types/normalize-path": "^3.0.0",
        "@typescript-eslint/eslint-plugin": "^5.45.0",
        "@typescript-eslint/parser": "^5.45.0",
        "ajv": "^8.11.2",
        "ajv-formats": "^2.1.1",
        "auto": "^10.37.6",
        "chai": "^4.3.7",
        "cross-env": "^7.0.3",
        "eslint": "^8.29.0",
        "eslint-config-prettier": "^8.5.0",
        "eslint-plugin-prettier": "^4.2.1",
        "jest": "^29.3.1",
        "jest-junit": "^15.0.0",
        "prettier": "^2.8.0",
        "ts-node": "^10.9.1",
        "vega": "^5.22.1",
        "vega-lite": "^5.6.0"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint \"{src,test,factory}/**/*.ts\"",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "cross-env FAST_TEST=1 jest test/ --verbose",
        "test:coverage": "yarn jest test/ --collectCoverage=true",
        "test:update": "cross-env UPDATE_SCHEMA=true yarn test:fast",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node-transpile-only ts-json-schema-generator.ts",
        "release": "yarn build && auto shipit"
      },
      "readme": "# ts-json-schema-generator\n\n![Test](https://github.com/vega/ts-json-schema-generator/workflows/Test/badge.svg)\n[![codecov](https://codecov.io/gh/vega/ts-json-schema-generator/branch/master/graph/badge.svg)](https://codecov.io/gh/vega/ts-json-schema-generator)\n[![npm version](https://img.shields.io/npm/v/ts-json-schema-generator.svg)](https://www.npmjs.com/package/ts-json-schema-generator)\n\nExtended version of [https://github.com/xiag-ag/typescript-to-json-schema](https://github.com/xiag-ag/typescript-to-json-schema).\n\nInspired by [`YousefED/typescript-json-schema`](https://github.com/YousefED/typescript-json-schema). Here's the differences list:\n\n-   this implementation avoids the use of `typeChecker.getTypeAtLocation()` (so probably it keeps correct type aliases)\n-   processing AST and formatting JSON schema have been split into two independent steps\n-   not exported types, interfaces, enums are not exposed in the `definitions` section in the JSON schema\n\n## Contributors\n\nThis project is made possible by a [community of contributors](https://github.com/vega/ts-json-schema-generator/graphs/contributors). We welcome contributions of any kind (issues, code, documentation, examples, tests,...). Please read our [code of conduct](https://vega.github.io/vega/about/code-of-conduct).\n\n## CLI Usage\n\nRun the schema generator with npx:\n\n```bash\nnpx ts-json-schema-generator --path 'my/project/**/*.ts' --type 'My.Type.Name'\n```\n\nOr install the package and then run it\n\n```bash\nnpm install --save ts-json-schema-generator\n./node_modules/.bin/ts-json-schema-generator --path 'my/project/**/*.ts' --type 'My.Type.Name'\n```\n\nNote that different platforms (e.g. Windows) may use different path separators so you may have to adjust the command above.\n\nAlso note that you need to quote paths with `*` as otherwise the shell will expand the paths and therefore only pass the first path to the generator.\n\n## Programmatic Usage\n\n```js\n// main.js\n\nconst tsj = require(\"ts-json-schema-generator\");\nconst fs = require(\"fs\");\n\n/** @type {import('ts-json-schema-generator/dist/src/Config').Config} */\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst output_path = \"path/to/output/file\";\n\nconst schema = tsj.createGenerator(config).createSchema(config.type);\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\nRun the schema generator via `node main.js`.\n\n### Custom formatting\n\nExtending the built-in formatting is possible by creating a custom formatter and adding it to the main formatter:\n\n1. First we create a formatter, in this case for formatting function types:\n\n```ts\n// my-function-formatter.ts\nimport { BaseType, Definition, FunctionType, SubTypeFormatter } from \"ts-json-schema-generator\";\nimport ts from \"typescript\";\n\nexport class MyFunctionTypeFormatter implements SubTypeFormatter {\n    // You can skip this line if you don't need childTypeFormatter\n    public constructor(private childTypeFormatter: TypeFormatter) {}\n\n    public supportsType(type: FunctionType): boolean {\n        return type instanceof FunctionType;\n    }\n\n    public getDefinition(type: FunctionType): Definition {\n        // Return a custom schema for the function property.\n        return {\n            type: \"object\",\n            properties: {\n                isFunction: {\n                    type: \"boolean\",\n                    const: true,\n                },\n            },\n        };\n    }\n\n    // If this type does NOT HAVE children, generally all you need is:\n    public getChildren(type: FunctionType): BaseType[] {\n        return [];\n    }\n\n    // However, if children ARE supported, you'll need something similar to\n    // this (see src/TypeFormatter/{Array,Definition,etc}.ts for some examples):\n    public getChildren(type: FunctionType): BaseType[] {\n        return this.childTypeFormatter.getChildren(type.getType());\n    }\n}\n```\n\n2. Then we add the formatter as a child to the core formatter using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyFunctionTypeFormatter } from \"./my-function-formatter.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\n// We configure the formatter an add our custom formatter to it.\nconst formatter = createFormatter(config, (fmt, circularReferenceTypeFormatter) => {\n    // If your formatter DOES NOT support children, e.g. getChildren() { return [] }:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter());\n    // If your formatter DOES support children, you'll need this reference too:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter(circularReferenceTypeFormatter));\n});\n\nconst program = createProgram(config);\nconst parser = createParser(program, config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n### Custom parsing\n\nSimilar to custom formatting, extending the built-in parsing works practically the same way:\n\n1. First we create a parser, in this case for parsing construct types:\n\n```ts\n// my-constructor-parser.ts\nimport { Context, StringType, ReferenceType, BaseType, SubNodeParser } from \"ts-json-schema-generator\";\n// use typescript exported by TJS to avoid version conflict\nimport ts from \"ts-json-schema-generator\";\n\nexport class MyConstructorParser implements SubNodeParser {\n    supportsNode(node: ts.Node): boolean {\n        return node.kind === ts.SyntaxKind.ConstructorType;\n    }\n    createType(node: ts.Node, context: Context, reference?: ReferenceType): BaseType | undefined {\n        return new StringType(); // Treat constructors as strings in this example\n    }\n}\n```\n\n2. Then we add the parser as a child to the core parser using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyConstructorParser } from \"./my-constructor-parser.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst program = createProgram(config);\n\n// We configure the parser an add our custom parser to it.\nconst parser = createParser(program, config, (prs) => {\n    prs.addNodeParser(new MyConstructorParser());\n});\n\nconst formatter = createFormatter(config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n## Options\n\n```\n-p, --path 'index.ts'\n    The path to the TypeScript source file. If this is not provided, the type will be searched in the project specified in the `.tsconfig`.\n\n-t, --type 'My.Type.Name'\n    The type the generated schema will represent. If omitted, the generated schema will contain all\n    types found in the files matching path. The same is true if '*' is specified.\n\n-i, --id 'generatedSchemaId'\n    The `$id` of the generated schema. If omitted, there will be no `$id`.\n\n-e, --expose <all|none|export>\n    all: Create shared $ref definitions for all types.\n    none: Do not create shared $ref definitions.\n    export (default): Create shared $ref definitions only for exported types (not tagged as `@internal`).\n\n-f, --tsconfig 'my/project/tsconfig.json'\n    Use a custom tsconfig file for processing typescript (see https://www.typescriptlang.org/docs/handbook/tsconfig-json.html) instead of the default:\n    {\n        \"compilerOptions\": {\n            \"noEmit\": true,\n            \"emitDecoratorMetadata\": true,\n            \"experimentalDecorators\": true,\n            \"target\": \"ES5\",\n            \"module\": \"CommonJS\",\n            \"strictNullChecks\": false,\n        }\n    }\n\n-j, --jsDoc <extended|none|basic>\n    none: Do not use JsDoc annotations.\n    basic: Read JsDoc annotations to provide schema properties.\n    extended (default): Also read @nullable, and @asType annotations.\n\n--unstable\n    Do not sort properties.\n\n--strict-tuples\n    Do not allow additional items on tuples.\n\n--no-top-ref\n    Do not create a top-level $ref definition.\n\n--no-type-check\n    Skip type checks for better performance.\n\n--no-ref-encode\n    Do not encode references. According to the standard, references must be valid URIs but some tools do not support encoded references.\n\n--validation-keywords\n    Provide additional validation keywords to include.\n\n-o, --out\n    Specify the output file path. Without this option, the generator logs the response in the console.\n\n--additional-properties <true|false>\n    Controls whether or not to allow additional properties for objects that have no index signature.\n\n    true: Additional properties are allowed\n    false (default): Additional properties are not allowed\n\n--minify\n    Minify generated schema (default: false)\n```\n\n## Current state\n\n-   `interface` types\n-   `enum` types\n-   `union`, `tuple`, `type[]` types\n-   `Date`, `RegExp`, `URL` types\n-   `string`, `boolean`, `number` types\n-   `\"value\"`, `123`, `true`, `false`, `null`, `undefined` literals\n-   type aliases\n-   generics\n-   `typeof`\n-   `keyof`\n-   conditional types\n\n## Run locally\n\n`yarn --silent run run --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\n## Debug\n\n`yarn --silent run debug --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\nAnd connect via the debugger protocol.\n\n[AST Explorer](https://astexplorer.net/) is amazing for developers of this tool!\n\n## Publish\n\nPublishing is handled by a 2-branch [pre-release process](https://intuit.github.io/auto/docs/generated/shipit#next-branch-default), configured in `publish-auto.yml`. All changes should be based off the default `next` branch, and are published automatically.\n\n-   PRs made into the default branch are auto-deployed to the `next` pre-release tag on NPM. The result can be installed with `npm install ts-json-schema-generator@next`\n    -   When merging into `next`, please use the `squash and merge` strategy.\n-   To release a new stable version, open a PR from `next` into `stable` using this [compare link](https://github.com/vega/ts-json-schema-generator/compare/stable...next).\n    -   When merging from `next` into `stable`, please use the `create a merge commit` strategy.\n",
      "readmeFilename": "README.md",
      "gitHead": "48775f94e21023e6b8ede05661216212b748e9e8",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@1.2.1-next.2",
      "_nodeVersion": "16.19.0",
      "_npmVersion": "8.19.3",
      "dist": {
        "integrity": "sha512-skMP1rWI88bhEZsJoa3WciVfDOva0DwfCO8RlpOeD6TaXd+LBJNI3gANkui1YvnqFGhExyOByiUjfxSH9G8xlg==",
        "shasum": "881021689e2d484df864d72d8c71e482644ad56d",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-1.2.1-next.2.tgz",
        "fileCount": 716,
        "unpackedSize": 880732,
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEQCIDXb32OxDe4dNpM+rB5PPvqX2hRCsVszeh87mrD2M/U5AiALCwVakj0v6RPQ9wbqGu/Ej4OshMnMnGB2cv0F96yCWQ=="
          }
        ],
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJj2XfNACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2Vmq3axAAhaSBnXPVjvEbzW47mHz/JXOtO9lBAhYcrhy1j0T/3Wyebhml\r\nWZJUHmEPCRhxWqtqMO4/VwHhp5PnwzBn3ZrmhEYaoFLVRhY4bQDmVD+F+3Lm\r\nGTH8Ip6BRO93eMH5OAO6j4Qubbdm4vBH3FDDjLxAsBOr3mLmGp/dREbvAVC9\r\nUJz3Vu44c2CQMhdF5QBYvzPuiP65HhEuVvLUgmPGKDHCOMVRXx8kY9npQsIX\r\nEr9+YpuGwQVhYBIXBE9imnnDlfoLsILzxOM+vwbrMOI2hdV2REnGgF2dNWe7\r\ng1TVTu9+Bent0BPm5NzsSOayVYFrNFs4w0mW+52+14NoN95c8mVgvZphDbBH\r\nsKcFc5J6Pb9835kZ09rCcV8GV3Hj/IPnyGvwo2+dN751lYYBPEVd+RVUE0nQ\r\nBHkzATZMde5iUyGQLY0hIp8fLYkLzFlHJ4gS8dFIcjcpqev3FijSYtVwbwlZ\r\nxSRyyPHySj5soSz2ZcoNVCMYGSSCFgrIZj+SJ0NwrOyo8abugmHKj45Gv7eN\r\nTddWY0YH3gS0NhrOqqrtQbXkO+7pF3s+BsFEkI1iyIaTIrKK98Kxm588oH5J\r\n1t3xa74eXhDhsKdV2ZZOx5kI1LnVZApy2lqxakcaH1Tel3ubs+Lwy4kQfuxI\r\neySYwPYfJs7ZaUSQaD7+4u1ZgbbVxyef/mk=\r\n=QO3u\r\n-----END PGP SIGNATURE-----\r\n"
      },
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "maintainers": [
        {
          "name": "jheer",
          "email": "jeffrey.heer@gmail.com"
        },
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "kanitw",
          "email": "kanitw@gmail.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_1.2.1-next.2_1675196365140_0.06284110890053429"
      },
      "_hasShrinkwrap": false
    },
    "1.3.0-next.0": {
      "name": "ts-json-schema-generator",
      "version": "1.3.0-next.0",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "MooYeol Prescott Lee",
          "email": "mooyoul@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=10.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.11",
        "commander": "^10.0.0",
        "glob": "^8.0.3",
        "json5": "^2.2.1",
        "normalize-path": "^3.0.0",
        "safe-stable-stringify": "^2.4.1",
        "typescript": "~4.9.3"
      },
      "devDependencies": {
        "@auto-it/conventional-commits": "^10.37.6",
        "@auto-it/first-time-contributor": "^10.37.6",
        "@babel/core": "^7.20.5",
        "@babel/preset-env": "^7.20.2",
        "@babel/preset-typescript": "^7.18.6",
        "@types/glob": "^8.0.0",
        "@types/jest": "^29.2.3",
        "@types/node": "^18.11.10",
        "@types/normalize-path": "^3.0.0",
        "@typescript-eslint/eslint-plugin": "^5.45.0",
        "@typescript-eslint/parser": "^5.45.0",
        "ajv": "^8.11.2",
        "ajv-formats": "^2.1.1",
        "auto": "^10.37.6",
        "chai": "^4.3.7",
        "cross-env": "^7.0.3",
        "eslint": "^8.29.0",
        "eslint-config-prettier": "^8.5.0",
        "eslint-plugin-prettier": "^4.2.1",
        "jest": "^29.3.1",
        "jest-junit": "^15.0.0",
        "prettier": "^2.8.0",
        "ts-node": "^10.9.1",
        "vega": "^5.22.1",
        "vega-lite": "^5.6.0"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint \"{src,test,factory}/**/*.ts\"",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "cross-env FAST_TEST=1 jest test/ --verbose",
        "test:coverage": "yarn jest test/ --collectCoverage=true",
        "test:update": "cross-env UPDATE_SCHEMA=true yarn test:fast",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node-transpile-only ts-json-schema-generator.ts",
        "release": "yarn build && auto shipit"
      },
      "readme": "# ts-json-schema-generator\n\n![Test](https://github.com/vega/ts-json-schema-generator/workflows/Test/badge.svg)\n[![codecov](https://codecov.io/gh/vega/ts-json-schema-generator/branch/master/graph/badge.svg)](https://codecov.io/gh/vega/ts-json-schema-generator)\n[![npm version](https://img.shields.io/npm/v/ts-json-schema-generator.svg)](https://www.npmjs.com/package/ts-json-schema-generator)\n\nExtended version of [https://github.com/xiag-ag/typescript-to-json-schema](https://github.com/xiag-ag/typescript-to-json-schema).\n\nInspired by [`YousefED/typescript-json-schema`](https://github.com/YousefED/typescript-json-schema). Here's the differences list:\n\n-   this implementation avoids the use of `typeChecker.getTypeAtLocation()` (so probably it keeps correct type aliases)\n-   processing AST and formatting JSON schema have been split into two independent steps\n-   not exported types, interfaces, enums are not exposed in the `definitions` section in the JSON schema\n\n## Contributors\n\nThis project is made possible by a [community of contributors](https://github.com/vega/ts-json-schema-generator/graphs/contributors). We welcome contributions of any kind (issues, code, documentation, examples, tests,...). Please read our [code of conduct](https://vega.github.io/vega/about/code-of-conduct).\n\n## CLI Usage\n\nRun the schema generator with npx:\n\n```bash\nnpx ts-json-schema-generator --path 'my/project/**/*.ts' --type 'My.Type.Name'\n```\n\nOr install the package and then run it\n\n```bash\nnpm install --save ts-json-schema-generator\n./node_modules/.bin/ts-json-schema-generator --path 'my/project/**/*.ts' --type 'My.Type.Name'\n```\n\nNote that different platforms (e.g. Windows) may use different path separators so you may have to adjust the command above.\n\nAlso note that you need to quote paths with `*` as otherwise the shell will expand the paths and therefore only pass the first path to the generator.\n\n## Programmatic Usage\n\n```js\n// main.js\n\nconst tsj = require(\"ts-json-schema-generator\");\nconst fs = require(\"fs\");\n\n/** @type {import('ts-json-schema-generator/dist/src/Config').Config} */\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst output_path = \"path/to/output/file\";\n\nconst schema = tsj.createGenerator(config).createSchema(config.type);\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\nRun the schema generator via `node main.js`.\n\n### Custom formatting\n\nExtending the built-in formatting is possible by creating a custom formatter and adding it to the main formatter:\n\n1. First we create a formatter, in this case for formatting function types:\n\n```ts\n// my-function-formatter.ts\nimport { BaseType, Definition, FunctionType, SubTypeFormatter } from \"ts-json-schema-generator\";\nimport ts from \"typescript\";\n\nexport class MyFunctionTypeFormatter implements SubTypeFormatter {\n    // You can skip this line if you don't need childTypeFormatter\n    public constructor(private childTypeFormatter: TypeFormatter) {}\n\n    public supportsType(type: FunctionType): boolean {\n        return type instanceof FunctionType;\n    }\n\n    public getDefinition(type: FunctionType): Definition {\n        // Return a custom schema for the function property.\n        return {\n            type: \"object\",\n            properties: {\n                isFunction: {\n                    type: \"boolean\",\n                    const: true,\n                },\n            },\n        };\n    }\n\n    // If this type does NOT HAVE children, generally all you need is:\n    public getChildren(type: FunctionType): BaseType[] {\n        return [];\n    }\n\n    // However, if children ARE supported, you'll need something similar to\n    // this (see src/TypeFormatter/{Array,Definition,etc}.ts for some examples):\n    public getChildren(type: FunctionType): BaseType[] {\n        return this.childTypeFormatter.getChildren(type.getType());\n    }\n}\n```\n\n2. Then we add the formatter as a child to the core formatter using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyFunctionTypeFormatter } from \"./my-function-formatter.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\n// We configure the formatter an add our custom formatter to it.\nconst formatter = createFormatter(config, (fmt, circularReferenceTypeFormatter) => {\n    // If your formatter DOES NOT support children, e.g. getChildren() { return [] }:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter());\n    // If your formatter DOES support children, you'll need this reference too:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter(circularReferenceTypeFormatter));\n});\n\nconst program = createProgram(config);\nconst parser = createParser(program, config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n### Custom parsing\n\nSimilar to custom formatting, extending the built-in parsing works practically the same way:\n\n1. First we create a parser, in this case for parsing construct types:\n\n```ts\n// my-constructor-parser.ts\nimport { Context, StringType, ReferenceType, BaseType, SubNodeParser } from \"ts-json-schema-generator\";\n// use typescript exported by TJS to avoid version conflict\nimport ts from \"ts-json-schema-generator\";\n\nexport class MyConstructorParser implements SubNodeParser {\n    supportsNode(node: ts.Node): boolean {\n        return node.kind === ts.SyntaxKind.ConstructorType;\n    }\n    createType(node: ts.Node, context: Context, reference?: ReferenceType): BaseType | undefined {\n        return new StringType(); // Treat constructors as strings in this example\n    }\n}\n```\n\n2. Then we add the parser as a child to the core parser using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyConstructorParser } from \"./my-constructor-parser.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst program = createProgram(config);\n\n// We configure the parser an add our custom parser to it.\nconst parser = createParser(program, config, (prs) => {\n    prs.addNodeParser(new MyConstructorParser());\n});\n\nconst formatter = createFormatter(config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n## Options\n\n```\n-p, --path 'index.ts'\n    The path to the TypeScript source file. If this is not provided, the type will be searched in the project specified in the `.tsconfig`.\n\n-t, --type 'My.Type.Name'\n    The type the generated schema will represent. If omitted, the generated schema will contain all\n    types found in the files matching path. The same is true if '*' is specified.\n\n-i, --id 'generatedSchemaId'\n    The `$id` of the generated schema. If omitted, there will be no `$id`.\n\n-e, --expose <all|none|export>\n    all: Create shared $ref definitions for all types.\n    none: Do not create shared $ref definitions.\n    export (default): Create shared $ref definitions only for exported types (not tagged as `@internal`).\n\n-f, --tsconfig 'my/project/tsconfig.json'\n    Use a custom tsconfig file for processing typescript (see https://www.typescriptlang.org/docs/handbook/tsconfig-json.html) instead of the default:\n    {\n        \"compilerOptions\": {\n            \"noEmit\": true,\n            \"emitDecoratorMetadata\": true,\n            \"experimentalDecorators\": true,\n            \"target\": \"ES5\",\n            \"module\": \"CommonJS\",\n            \"strictNullChecks\": false,\n        }\n    }\n\n-j, --jsDoc <extended|none|basic>\n    none: Do not use JsDoc annotations.\n    basic: Read JsDoc annotations to provide schema properties.\n    extended (default): Also read @nullable, and @asType annotations.\n\n--unstable\n    Do not sort properties.\n\n--strict-tuples\n    Do not allow additional items on tuples.\n\n--no-top-ref\n    Do not create a top-level $ref definition.\n\n--no-type-check\n    Skip type checks for better performance.\n\n--no-ref-encode\n    Do not encode references. According to the standard, references must be valid URIs but some tools do not support encoded references.\n\n--validation-keywords\n    Provide additional validation keywords to include.\n\n-o, --out\n    Specify the output file path. Without this option, the generator logs the response in the console.\n\n--additional-properties <true|false>\n    Controls whether or not to allow additional properties for objects that have no index signature.\n\n    true: Additional properties are allowed\n    false (default): Additional properties are not allowed\n\n--minify\n    Minify generated schema (default: false)\n```\n\n## Current state\n\n-   `interface` types\n-   `enum` types\n-   `union`, `tuple`, `type[]` types\n-   `Date`, `RegExp`, `URL` types\n-   `string`, `boolean`, `number` types\n-   `\"value\"`, `123`, `true`, `false`, `null`, `undefined` literals\n-   type aliases\n-   generics\n-   `typeof`\n-   `keyof`\n-   conditional types\n\n## Run locally\n\n`yarn --silent run run --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\n## Debug\n\n`yarn --silent run debug --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\nAnd connect via the debugger protocol.\n\n[AST Explorer](https://astexplorer.net/) is amazing for developers of this tool!\n\n## Publish\n\nPublishing is handled by a 2-branch [pre-release process](https://intuit.github.io/auto/docs/generated/shipit#next-branch-default), configured in `publish-auto.yml`. All changes should be based off the default `next` branch, and are published automatically.\n\n-   PRs made into the default branch are auto-deployed to the `next` pre-release tag on NPM. The result can be installed with `npm install ts-json-schema-generator@next`\n    -   When merging into `next`, please use the `squash and merge` strategy.\n-   To release a new stable version, open a PR from `next` into `stable` using this [compare link](https://github.com/vega/ts-json-schema-generator/compare/stable...next).\n    -   When merging from `next` into `stable`, please use the `create a merge commit` strategy.\n",
      "readmeFilename": "README.md",
      "gitHead": "898525113e9763f592664232a50824ca4da64d02",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@1.3.0-next.0",
      "_nodeVersion": "18.14.1",
      "_npmVersion": "9.3.1",
      "dist": {
        "integrity": "sha512-yhP+caD99pBChwJeRpCD7B0tYpdMxcO9/wqX7ynvlapP4HKp1Fpt95XabYFgbITjmf9sEVfnGMwaxOpqP6qhJw==",
        "shasum": "7b31b8f38ca23ce31dacd9173b3325e3dad846b6",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-1.3.0-next.0.tgz",
        "fileCount": 716,
        "unpackedSize": 884460,
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIQD89pOtAybXVcNv8eNBPx0JWL7ZFhTYY9UTEe55i0LemQIgCDhV6hOFjhzBs0av3ERb6c5uiAHcQsGk4nPd8ED7JHg="
          }
        ],
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJj9XB8ACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2VmrZAA//bqi3Rpr8urwKvbCbEu/c6BStdPxQbliKsD542Du96+7QQf+P\r\nfCdOZWfdgjhNhuCtwk6aqpTFMWijIjPlI7pVn7rOaB/z+J3ikNK+LJ9mrlja\r\nyfqhPmGrHQ8Ljlxjid36VKQ/iambYYRBiGQyV93fbfodhWvjNvkZXBwzffAG\r\nORtThnhnY0KJx/8nq8sTjxbB0g+QEc1qTSAXgxTFy9urpLfP4DUJ8icWtJM3\r\noyFar//MSZ2BBdHXw9otd2fWmvXW24Qy/rUWhqLlg1czYqwTTyIUeoUjvEV5\r\nJxtrWRcIu1xyjA70krqgb7KEQPXVFEbRWca2s/2h8uXU8IjXd3joufHWKcfY\r\nMz3utpsjbozZJQRR+mvvWDta1noaKrdONkH40H1R1AKBzFNFAklE3f7/v/aZ\r\nY2mmpWleuf5AvTC3zClh/n5zDtOZNra/NzddIWw3Ly7B0ZgTptjsVtPXr5dy\r\nAzVGv0lUwq3HmreyynSDOhqN3MbxS2e70681C+QyeSqKhOiYNzW6qP4/DVG+\r\nuFF/5ZXIuh8lWCSwp8ubLDR6DTtm4NhKlRyxK/zun/rAkbhM5W7lTerXoE41\r\n98OdlkL89Nl4v9c3G8x0GNT38MUnwpfB/Jq2HXDangx8yHtWN+ddxIITdXiI\r\nCN0EXJXRKpGv76U0X7P/zbe0g0GQ1t+YJU4=\r\n=K2Yw\r\n-----END PGP SIGNATURE-----\r\n"
      },
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "maintainers": [
        {
          "name": "jheer",
          "email": "jeffrey.heer@gmail.com"
        },
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "kanitw",
          "email": "kanitw@gmail.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_1.3.0-next.0_1677029499719_0.14881652645935906"
      },
      "_hasShrinkwrap": false
    },
    "1.2.1--canary.1593.b692d84.0": {
      "name": "ts-json-schema-generator",
      "version": "1.2.1--canary.1593.b692d84.0",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "MooYeol Prescott Lee",
          "email": "mooyoul@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=10.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.11",
        "commander": "^10.0.0",
        "glob": "^8.0.3",
        "json5": "^2.2.1",
        "normalize-path": "^3.0.0",
        "safe-stable-stringify": "^2.4.1",
        "typescript": "~4.9.3"
      },
      "devDependencies": {
        "@auto-it/conventional-commits": "^10.37.6",
        "@auto-it/first-time-contributor": "^10.37.6",
        "@babel/core": "^7.20.5",
        "@babel/preset-env": "^7.20.2",
        "@babel/preset-typescript": "^7.18.6",
        "@types/glob": "^8.0.0",
        "@types/jest": "^29.2.3",
        "@types/node": "^18.11.10",
        "@types/normalize-path": "^3.0.0",
        "@typescript-eslint/eslint-plugin": "^5.45.0",
        "@typescript-eslint/parser": "^5.45.0",
        "ajv": "^8.11.2",
        "ajv-formats": "^2.1.1",
        "auto": "^10.37.6",
        "chai": "^4.3.7",
        "cross-env": "^7.0.3",
        "eslint": "^8.29.0",
        "eslint-config-prettier": "^8.5.0",
        "eslint-plugin-prettier": "^4.2.1",
        "jest": "^29.3.1",
        "jest-junit": "^15.0.0",
        "prettier": "^2.8.0",
        "ts-node": "^10.9.1",
        "vega": "^5.22.1",
        "vega-lite": "^5.6.0"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint \"{src,test,factory}/**/*.ts\"",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "cross-env FAST_TEST=1 jest test/ --verbose",
        "test:coverage": "yarn jest test/ --collectCoverage=true",
        "test:update": "cross-env UPDATE_SCHEMA=true yarn test:fast",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node-transpile-only ts-json-schema-generator.ts",
        "release": "yarn build && auto shipit"
      },
      "readme": "# ts-json-schema-generator\n\n![Test](https://github.com/vega/ts-json-schema-generator/workflows/Test/badge.svg)\n[![codecov](https://codecov.io/gh/vega/ts-json-schema-generator/branch/master/graph/badge.svg)](https://codecov.io/gh/vega/ts-json-schema-generator)\n[![npm version](https://img.shields.io/npm/v/ts-json-schema-generator.svg)](https://www.npmjs.com/package/ts-json-schema-generator)\n\nExtended version of [https://github.com/xiag-ag/typescript-to-json-schema](https://github.com/xiag-ag/typescript-to-json-schema).\n\nInspired by [`YousefED/typescript-json-schema`](https://github.com/YousefED/typescript-json-schema). Here's the differences list:\n\n-   this implementation avoids the use of `typeChecker.getTypeAtLocation()` (so probably it keeps correct type aliases)\n-   processing AST and formatting JSON schema have been split into two independent steps\n-   not exported types, interfaces, enums are not exposed in the `definitions` section in the JSON schema\n\n## Contributors\n\nThis project is made possible by a [community of contributors](https://github.com/vega/ts-json-schema-generator/graphs/contributors). We welcome contributions of any kind (issues, code, documentation, examples, tests,...). Please read our [code of conduct](https://vega.github.io/vega/about/code-of-conduct).\n\n## CLI Usage\n\nRun the schema generator with npx:\n\n```bash\nnpx ts-json-schema-generator --path 'my/project/**/*.ts' --type 'My.Type.Name'\n```\n\nOr install the package and then run it\n\n```bash\nnpm install --save ts-json-schema-generator\n./node_modules/.bin/ts-json-schema-generator --path 'my/project/**/*.ts' --type 'My.Type.Name'\n```\n\nNote that different platforms (e.g. Windows) may use different path separators so you may have to adjust the command above.\n\nAlso note that you need to quote paths with `*` as otherwise the shell will expand the paths and therefore only pass the first path to the generator.\n\n## Programmatic Usage\n\n```js\n// main.js\n\nconst tsj = require(\"ts-json-schema-generator\");\nconst fs = require(\"fs\");\n\n/** @type {import('ts-json-schema-generator/dist/src/Config').Config} */\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst output_path = \"path/to/output/file\";\n\nconst schema = tsj.createGenerator(config).createSchema(config.type);\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\nRun the schema generator via `node main.js`.\n\n### Custom formatting\n\nExtending the built-in formatting is possible by creating a custom formatter and adding it to the main formatter:\n\n1. First we create a formatter, in this case for formatting function types:\n\n```ts\n// my-function-formatter.ts\nimport { BaseType, Definition, FunctionType, SubTypeFormatter } from \"ts-json-schema-generator\";\nimport ts from \"typescript\";\n\nexport class MyFunctionTypeFormatter implements SubTypeFormatter {\n    // You can skip this line if you don't need childTypeFormatter\n    public constructor(private childTypeFormatter: TypeFormatter) {}\n\n    public supportsType(type: FunctionType): boolean {\n        return type instanceof FunctionType;\n    }\n\n    public getDefinition(type: FunctionType): Definition {\n        // Return a custom schema for the function property.\n        return {\n            type: \"object\",\n            properties: {\n                isFunction: {\n                    type: \"boolean\",\n                    const: true,\n                },\n            },\n        };\n    }\n\n    // If this type does NOT HAVE children, generally all you need is:\n    public getChildren(type: FunctionType): BaseType[] {\n        return [];\n    }\n\n    // However, if children ARE supported, you'll need something similar to\n    // this (see src/TypeFormatter/{Array,Definition,etc}.ts for some examples):\n    public getChildren(type: FunctionType): BaseType[] {\n        return this.childTypeFormatter.getChildren(type.getType());\n    }\n}\n```\n\n2. Then we add the formatter as a child to the core formatter using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyFunctionTypeFormatter } from \"./my-function-formatter.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\n// We configure the formatter an add our custom formatter to it.\nconst formatter = createFormatter(config, (fmt, circularReferenceTypeFormatter) => {\n    // If your formatter DOES NOT support children, e.g. getChildren() { return [] }:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter());\n    // If your formatter DOES support children, you'll need this reference too:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter(circularReferenceTypeFormatter));\n});\n\nconst program = createProgram(config);\nconst parser = createParser(program, config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n### Custom parsing\n\nSimilar to custom formatting, extending the built-in parsing works practically the same way:\n\n1. First we create a parser, in this case for parsing construct types:\n\n```ts\n// my-constructor-parser.ts\nimport { Context, StringType, ReferenceType, BaseType, SubNodeParser } from \"ts-json-schema-generator\";\n// use typescript exported by TJS to avoid version conflict\nimport ts from \"ts-json-schema-generator\";\n\nexport class MyConstructorParser implements SubNodeParser {\n    supportsNode(node: ts.Node): boolean {\n        return node.kind === ts.SyntaxKind.ConstructorType;\n    }\n    createType(node: ts.Node, context: Context, reference?: ReferenceType): BaseType | undefined {\n        return new StringType(); // Treat constructors as strings in this example\n    }\n}\n```\n\n2. Then we add the parser as a child to the core parser using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyConstructorParser } from \"./my-constructor-parser.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst program = createProgram(config);\n\n// We configure the parser an add our custom parser to it.\nconst parser = createParser(program, config, (prs) => {\n    prs.addNodeParser(new MyConstructorParser());\n});\n\nconst formatter = createFormatter(config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n## Options\n\n```\n-p, --path 'index.ts'\n    The path to the TypeScript source file. If this is not provided, the type will be searched in the project specified in the `.tsconfig`.\n\n-t, --type 'My.Type.Name'\n    The type the generated schema will represent. If omitted, the generated schema will contain all\n    types found in the files matching path. The same is true if '*' is specified.\n\n-i, --id 'generatedSchemaId'\n    The `$id` of the generated schema. If omitted, there will be no `$id`.\n\n-e, --expose <all|none|export>\n    all: Create shared $ref definitions for all types.\n    none: Do not create shared $ref definitions.\n    export (default): Create shared $ref definitions only for exported types (not tagged as `@internal`).\n\n-f, --tsconfig 'my/project/tsconfig.json'\n    Use a custom tsconfig file for processing typescript (see https://www.typescriptlang.org/docs/handbook/tsconfig-json.html) instead of the default:\n    {\n        \"compilerOptions\": {\n            \"noEmit\": true,\n            \"emitDecoratorMetadata\": true,\n            \"experimentalDecorators\": true,\n            \"target\": \"ES5\",\n            \"module\": \"CommonJS\",\n            \"strictNullChecks\": false,\n        }\n    }\n\n-j, --jsDoc <extended|none|basic>\n    none: Do not use JsDoc annotations.\n    basic: Read JsDoc annotations to provide schema properties.\n    extended (default): Also read @nullable, and @asType annotations.\n\n--unstable\n    Do not sort properties.\n\n--strict-tuples\n    Do not allow additional items on tuples.\n\n--no-top-ref\n    Do not create a top-level $ref definition.\n\n--no-type-check\n    Skip type checks for better performance.\n\n--no-ref-encode\n    Do not encode references. According to the standard, references must be valid URIs but some tools do not support encoded references.\n\n--validation-keywords\n    Provide additional validation keywords to include.\n\n-o, --out\n    Specify the output file path. Without this option, the generator logs the response in the console.\n\n--additional-properties <true|false>\n    Controls whether or not to allow additional properties for objects that have no index signature.\n\n    true: Additional properties are allowed\n    false (default): Additional properties are not allowed\n\n--minify\n    Minify generated schema (default: false)\n```\n\n## Current state\n\n-   `interface` types\n-   `enum` types\n-   `union`, `tuple`, `type[]` types\n-   `Date`, `RegExp`, `URL` types\n-   `string`, `boolean`, `number` types\n-   `\"value\"`, `123`, `true`, `false`, `null`, `undefined` literals\n-   type aliases\n-   generics\n-   `typeof`\n-   `keyof`\n-   conditional types\n\n## Run locally\n\n`yarn --silent run run --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\n## Debug\n\n`yarn --silent run debug --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\nAnd connect via the debugger protocol.\n\n[AST Explorer](https://astexplorer.net/) is amazing for developers of this tool!\n\n## Publish\n\nPublishing is handled by a 2-branch [pre-release process](https://intuit.github.io/auto/docs/generated/shipit#next-branch-default), configured in `publish-auto.yml`. All changes should be based off the default `next` branch, and are published automatically.\n\n-   PRs made into the default branch are auto-deployed to the `next` pre-release tag on NPM. The result can be installed with `npm install ts-json-schema-generator@next`\n    -   When merging into `next`, please use the `squash and merge` strategy.\n-   To release a new stable version, open a PR from `next` into `stable` using this [compare link](https://github.com/vega/ts-json-schema-generator/compare/stable...next).\n    -   When merging from `next` into `stable`, please use the `create a merge commit` strategy.\n",
      "readmeFilename": "README.md",
      "gitHead": "b692d8477ba683a6c7e33fba91afdc2eaf94faeb",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@1.2.1--canary.1593.b692d84.0",
      "_nodeVersion": "18.14.2",
      "_npmVersion": "9.5.0",
      "dist": {
        "integrity": "sha512-fgSB5bvCU5ZORb9yvvaLwfrRF+ymHlXv64vj9weCFJyqs4x/UpbuMQlvESTDHQHVAm1V9vnLFHRTuIswq/TVjQ==",
        "shasum": "e03bd36f2b7e8d31f6e6112d550c12526109bf9a",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-1.2.1--canary.1593.b692d84.0.tgz",
        "fileCount": 716,
        "unpackedSize": 885187,
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIQDpK/g5CfaPuM1GZWXq1swL23dr+g5y2Oflr2ug9WOmigIgIY7B1EmE+pYFLcucXDDuxfeFkINd/ryYyNZQZ3K4Tww="
          }
        ],
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJkAiO9ACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2Vmp1ahAAgRfLFUAwfPaUuvbbG49CLME19hViDjykwCOQqodP+8jmegFj\r\nOejF2y5nK/4Mj9XBB1QK8wVu7Iu/l9cUFbiP6EiRiwN0c4F+VfG0BKIcFGke\r\n33wJItCoIid9JeCiaDRbM0LPfj/EDP3SSQdtLLW4cRR/Ncbrp+sRXHMEonBw\r\nzuNAZBAziewIDHifvECw1ljoeBKdp8JoHJyRzFRVnQilt9svlU67k4C9aS1q\r\nZmbC7+zclfzGBEbgXxh6l7PhvD5hoNvSq384zB3KdFoNDudmHVx/Z4i/bu/9\r\ngop070eRWoR56wuLk4FN7FfZwxK80/d0P8aRvW+hfjY9IkJwI+f/66lK8OzE\r\npCImkRwTxiu4gmEzBDWp/GoTaDlUklzqE2/gozc3NG0ifTGInJXytiEgB1I7\r\nwitTUql0V25Xo6Z0jCEs2vrJoGns1gRXJCC9lWMpjGANZpMvlQt+/383oPz2\r\ni+kIeNwqmfGKxl+PNncXp/GgfCByv2ZPRbNXL+UHUEqkWsIeknF45UMKVsSw\r\ndY+cmhzc+aExJwUO1o1iNvHb1t4zoAkdf0GOiRXZ8DYvMrnD9SQoTu+C5E/Z\r\nrxMlsfDKQfg6TaTzI/TSTiFi5Qx7nWwaZtGyeROUz8e2Sqjqw5X4gtA4rRla\r\ngmbZT9iy8WdV5MMo1tYHBMUm+bdpuzpqVjg=\r\n=PRgm\r\n-----END PGP SIGNATURE-----\r\n"
      },
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "maintainers": [
        {
          "name": "jheer",
          "email": "jeffrey.heer@gmail.com"
        },
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "kanitw",
          "email": "kanitw@gmail.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_1.2.1--canary.1593.b692d84.0_1677861821480_0.04121902579794101"
      },
      "_hasShrinkwrap": false
    },
    "1.3.0--canary.1593.e6a3b2b.0": {
      "name": "ts-json-schema-generator",
      "version": "1.3.0--canary.1593.e6a3b2b.0",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "MooYeol Prescott Lee",
          "email": "mooyoul@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=10.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.11",
        "commander": "^10.0.0",
        "glob": "^8.0.3",
        "json5": "^2.2.1",
        "normalize-path": "^3.0.0",
        "safe-stable-stringify": "^2.4.1",
        "typescript": "~4.9.3"
      },
      "devDependencies": {
        "@auto-it/conventional-commits": "^10.37.6",
        "@auto-it/first-time-contributor": "^10.37.6",
        "@babel/core": "^7.20.5",
        "@babel/preset-env": "^7.20.2",
        "@babel/preset-typescript": "^7.18.6",
        "@types/glob": "^8.0.0",
        "@types/jest": "^29.2.3",
        "@types/node": "^18.11.10",
        "@types/normalize-path": "^3.0.0",
        "@typescript-eslint/eslint-plugin": "^5.45.0",
        "@typescript-eslint/parser": "^5.45.0",
        "ajv": "^8.11.2",
        "ajv-formats": "^2.1.1",
        "auto": "^10.37.6",
        "chai": "^4.3.7",
        "cross-env": "^7.0.3",
        "eslint": "^8.29.0",
        "eslint-config-prettier": "^8.5.0",
        "eslint-plugin-prettier": "^4.2.1",
        "jest": "^29.3.1",
        "jest-junit": "^15.0.0",
        "prettier": "^2.8.0",
        "ts-node": "^10.9.1",
        "vega": "^5.22.1",
        "vega-lite": "^5.6.0"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint \"{src,test,factory}/**/*.ts\"",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "cross-env FAST_TEST=1 jest test/ --verbose",
        "test:coverage": "yarn jest test/ --collectCoverage=true",
        "test:update": "cross-env UPDATE_SCHEMA=true yarn test:fast",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node-transpile-only ts-json-schema-generator.ts",
        "release": "yarn build && auto shipit"
      },
      "readme": "# ts-json-schema-generator\n\n![Test](https://github.com/vega/ts-json-schema-generator/workflows/Test/badge.svg)\n[![codecov](https://codecov.io/gh/vega/ts-json-schema-generator/branch/master/graph/badge.svg)](https://codecov.io/gh/vega/ts-json-schema-generator)\n[![npm version](https://img.shields.io/npm/v/ts-json-schema-generator.svg)](https://www.npmjs.com/package/ts-json-schema-generator)\n\nExtended version of [https://github.com/xiag-ag/typescript-to-json-schema](https://github.com/xiag-ag/typescript-to-json-schema).\n\nInspired by [`YousefED/typescript-json-schema`](https://github.com/YousefED/typescript-json-schema). Here's the differences list:\n\n-   this implementation avoids the use of `typeChecker.getTypeAtLocation()` (so probably it keeps correct type aliases)\n-   processing AST and formatting JSON schema have been split into two independent steps\n-   not exported types, interfaces, enums are not exposed in the `definitions` section in the JSON schema\n\n## Contributors\n\nThis project is made possible by a [community of contributors](https://github.com/vega/ts-json-schema-generator/graphs/contributors). We welcome contributions of any kind (issues, code, documentation, examples, tests,...). Please read our [code of conduct](https://vega.github.io/vega/about/code-of-conduct).\n\n## CLI Usage\n\nRun the schema generator with npx:\n\n```bash\nnpx ts-json-schema-generator --path 'my/project/**/*.ts' --type 'My.Type.Name'\n```\n\nOr install the package and then run it\n\n```bash\nnpm install --save ts-json-schema-generator\n./node_modules/.bin/ts-json-schema-generator --path 'my/project/**/*.ts' --type 'My.Type.Name'\n```\n\nNote that different platforms (e.g. Windows) may use different path separators so you may have to adjust the command above.\n\nAlso note that you need to quote paths with `*` as otherwise the shell will expand the paths and therefore only pass the first path to the generator.\n\n## Programmatic Usage\n\n```js\n// main.js\n\nconst tsj = require(\"ts-json-schema-generator\");\nconst fs = require(\"fs\");\n\n/** @type {import('ts-json-schema-generator/dist/src/Config').Config} */\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst output_path = \"path/to/output/file\";\n\nconst schema = tsj.createGenerator(config).createSchema(config.type);\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\nRun the schema generator via `node main.js`.\n\n### Custom formatting\n\nExtending the built-in formatting is possible by creating a custom formatter and adding it to the main formatter:\n\n1. First we create a formatter, in this case for formatting function types:\n\n```ts\n// my-function-formatter.ts\nimport { BaseType, Definition, FunctionType, SubTypeFormatter } from \"ts-json-schema-generator\";\nimport ts from \"typescript\";\n\nexport class MyFunctionTypeFormatter implements SubTypeFormatter {\n    // You can skip this line if you don't need childTypeFormatter\n    public constructor(private childTypeFormatter: TypeFormatter) {}\n\n    public supportsType(type: FunctionType): boolean {\n        return type instanceof FunctionType;\n    }\n\n    public getDefinition(type: FunctionType): Definition {\n        // Return a custom schema for the function property.\n        return {\n            type: \"object\",\n            properties: {\n                isFunction: {\n                    type: \"boolean\",\n                    const: true,\n                },\n            },\n        };\n    }\n\n    // If this type does NOT HAVE children, generally all you need is:\n    public getChildren(type: FunctionType): BaseType[] {\n        return [];\n    }\n\n    // However, if children ARE supported, you'll need something similar to\n    // this (see src/TypeFormatter/{Array,Definition,etc}.ts for some examples):\n    public getChildren(type: FunctionType): BaseType[] {\n        return this.childTypeFormatter.getChildren(type.getType());\n    }\n}\n```\n\n2. Then we add the formatter as a child to the core formatter using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyFunctionTypeFormatter } from \"./my-function-formatter.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\n// We configure the formatter an add our custom formatter to it.\nconst formatter = createFormatter(config, (fmt, circularReferenceTypeFormatter) => {\n    // If your formatter DOES NOT support children, e.g. getChildren() { return [] }:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter());\n    // If your formatter DOES support children, you'll need this reference too:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter(circularReferenceTypeFormatter));\n});\n\nconst program = createProgram(config);\nconst parser = createParser(program, config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n### Custom parsing\n\nSimilar to custom formatting, extending the built-in parsing works practically the same way:\n\n1. First we create a parser, in this case for parsing construct types:\n\n```ts\n// my-constructor-parser.ts\nimport { Context, StringType, ReferenceType, BaseType, SubNodeParser } from \"ts-json-schema-generator\";\n// use typescript exported by TJS to avoid version conflict\nimport ts from \"ts-json-schema-generator\";\n\nexport class MyConstructorParser implements SubNodeParser {\n    supportsNode(node: ts.Node): boolean {\n        return node.kind === ts.SyntaxKind.ConstructorType;\n    }\n    createType(node: ts.Node, context: Context, reference?: ReferenceType): BaseType | undefined {\n        return new StringType(); // Treat constructors as strings in this example\n    }\n}\n```\n\n2. Then we add the parser as a child to the core parser using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyConstructorParser } from \"./my-constructor-parser.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst program = createProgram(config);\n\n// We configure the parser an add our custom parser to it.\nconst parser = createParser(program, config, (prs) => {\n    prs.addNodeParser(new MyConstructorParser());\n});\n\nconst formatter = createFormatter(config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n## Options\n\n```\n-p, --path 'index.ts'\n    The path to the TypeScript source file. If this is not provided, the type will be searched in the project specified in the `.tsconfig`.\n\n-t, --type 'My.Type.Name'\n    The type the generated schema will represent. If omitted, the generated schema will contain all\n    types found in the files matching path. The same is true if '*' is specified.\n\n-i, --id 'generatedSchemaId'\n    The `$id` of the generated schema. If omitted, there will be no `$id`.\n\n-e, --expose <all|none|export>\n    all: Create shared $ref definitions for all types.\n    none: Do not create shared $ref definitions.\n    export (default): Create shared $ref definitions only for exported types (not tagged as `@internal`).\n\n-f, --tsconfig 'my/project/tsconfig.json'\n    Use a custom tsconfig file for processing typescript (see https://www.typescriptlang.org/docs/handbook/tsconfig-json.html) instead of the default:\n    {\n        \"compilerOptions\": {\n            \"noEmit\": true,\n            \"emitDecoratorMetadata\": true,\n            \"experimentalDecorators\": true,\n            \"target\": \"ES5\",\n            \"module\": \"CommonJS\",\n            \"strictNullChecks\": false,\n        }\n    }\n\n-j, --jsDoc <extended|none|basic>\n    none: Do not use JsDoc annotations.\n    basic: Read JsDoc annotations to provide schema properties.\n    extended (default): Also read @nullable, and @asType annotations.\n\n--unstable\n    Do not sort properties.\n\n--strict-tuples\n    Do not allow additional items on tuples.\n\n--no-top-ref\n    Do not create a top-level $ref definition.\n\n--no-type-check\n    Skip type checks for better performance.\n\n--no-ref-encode\n    Do not encode references. According to the standard, references must be valid URIs but some tools do not support encoded references.\n\n--validation-keywords\n    Provide additional validation keywords to include.\n\n-o, --out\n    Specify the output file path. Without this option, the generator logs the response in the console.\n\n--additional-properties <true|false>\n    Controls whether or not to allow additional properties for objects that have no index signature.\n\n    true: Additional properties are allowed\n    false (default): Additional properties are not allowed\n\n--minify\n    Minify generated schema (default: false)\n```\n\n## Current state\n\n-   `interface` types\n-   `enum` types\n-   `union`, `tuple`, `type[]` types\n-   `Date`, `RegExp`, `URL` types\n-   `string`, `boolean`, `number` types\n-   `\"value\"`, `123`, `true`, `false`, `null`, `undefined` literals\n-   type aliases\n-   generics\n-   `typeof`\n-   `keyof`\n-   conditional types\n\n## Run locally\n\n`yarn --silent run run --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\n## Debug\n\n`yarn --silent run debug --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\nAnd connect via the debugger protocol.\n\n[AST Explorer](https://astexplorer.net/) is amazing for developers of this tool!\n\n## Publish\n\nPublishing is handled by a 2-branch [pre-release process](https://intuit.github.io/auto/docs/generated/shipit#next-branch-default), configured in `publish-auto.yml`. All changes should be based off the default `next` branch, and are published automatically.\n\n-   PRs made into the default branch are auto-deployed to the `next` pre-release tag on NPM. The result can be installed with `npm install ts-json-schema-generator@next`\n    -   When merging into `next`, please use the `squash and merge` strategy.\n-   To release a new stable version, open a PR from `next` into `stable` using this [compare link](https://github.com/vega/ts-json-schema-generator/compare/stable...next).\n    -   When merging from `next` into `stable`, please use the `create a merge commit` strategy.\n",
      "readmeFilename": "README.md",
      "gitHead": "e6a3b2bf5a389892739bedbe3f071df98a0c043b",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@1.3.0--canary.1593.e6a3b2b.0",
      "_nodeVersion": "18.14.2",
      "_npmVersion": "9.5.0",
      "dist": {
        "integrity": "sha512-sh+1Uz9tMJB7d6l0WZHizS21tvVytNLJPK2lGM6cz1OObkkljd0rHVcfRai63z1JjQVyjNeUmTfrU15pEUq0dg==",
        "shasum": "f574d8b2acf66df2d21dd23c307d0f054a59a51a",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-1.3.0--canary.1593.e6a3b2b.0.tgz",
        "fileCount": 716,
        "unpackedSize": 885929,
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEYCIQC9bxMcwFbfp2IIwtpqgT8tPbCPIZoZwfSbV66zXo5qmAIhAPI7lJJeW/kApD9cgQ12fKoy5VewKimyyqchmqhByCir"
          }
        ],
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJkAiQXACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2VmqxAQ//c+w/wqovwfrgrw7DHXoTTxjx6pgMaTGdrJZIpBzOPLRgOYw/\r\nTSwmF/wP3PYyZ+pyFvMKiBvdfAGmkKEFLjhJFwrTvlSnXArVQPE22CoK4Y10\r\nwESTBYhRfR8HLK6soEGZEfAZ7MRX2NfR2SJ6psz6vNHZVj6lGbQhu01CQ+M2\r\n5wQe1nQnq6XFcgVYwgObTjHVP6tbO4CHe30GlWUE5fIB7BxPyO68LvC+f9Ku\r\nlzVedQM4jvuN9bsxaxYgOFRHnWwsDQfbHLfWc+13SIq901jZkQEu674bHN4J\r\ndnC0I/kVfkTnCtOo5JrszGEBosPCJO9j9BM5Ab1y7PeIL0HV1AXp7ICVcHcw\r\nfUR0/CFUlL0o1DEqWxm110qY048zMLYOT7CZPA931d0dH7hCyAhuS/ZHhroT\r\n3FPd1zYspf69AOZni2YfmzwikT+uTNUu3BMWg7iP4QlX69eq2rq1FR8LQXbw\r\nul9odiL2jhT+2TfD2eMDBqa/ZLp8I8yKTaOfJkZtkrOcfZPqZwaJ5LjZF801\r\nMJn0LOBUTmIR3aguS5DB1SCNgJSanZoqjmi1f2fIFHIN5mjxJ33l2Dbldmz7\r\nAjLGf633Qb3wIK2seQn1D1y5n3/q7zidBI3j8LHW4F4BKe6DnV3i4z7eQdPJ\r\nhDXNTK3aJaTiV2CWdLIQOY0D/VXgmbcWa2c=\r\n=9NY3\r\n-----END PGP SIGNATURE-----\r\n"
      },
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "maintainers": [
        {
          "name": "jheer",
          "email": "jeffrey.heer@gmail.com"
        },
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "kanitw",
          "email": "kanitw@gmail.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_1.3.0--canary.1593.e6a3b2b.0_1677861911240_0.07690325879621862"
      },
      "_hasShrinkwrap": false
    },
    "1.3.0--canary.1593.8d550bb.0": {
      "name": "ts-json-schema-generator",
      "version": "1.3.0--canary.1593.8d550bb.0",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "MooYeol Prescott Lee",
          "email": "mooyoul@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=10.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.11",
        "commander": "^10.0.0",
        "glob": "^8.0.3",
        "json5": "^2.2.1",
        "normalize-path": "^3.0.0",
        "safe-stable-stringify": "^2.4.1",
        "typescript": "~4.9.3"
      },
      "devDependencies": {
        "@auto-it/conventional-commits": "^10.37.6",
        "@auto-it/first-time-contributor": "^10.37.6",
        "@babel/core": "^7.20.5",
        "@babel/preset-env": "^7.20.2",
        "@babel/preset-typescript": "^7.18.6",
        "@types/glob": "^8.0.0",
        "@types/jest": "^29.2.3",
        "@types/node": "^18.11.10",
        "@types/normalize-path": "^3.0.0",
        "@typescript-eslint/eslint-plugin": "^5.45.0",
        "@typescript-eslint/parser": "^5.45.0",
        "ajv": "^8.11.2",
        "ajv-formats": "^2.1.1",
        "auto": "^10.37.6",
        "chai": "^4.3.7",
        "cross-env": "^7.0.3",
        "eslint": "^8.29.0",
        "eslint-config-prettier": "^8.5.0",
        "eslint-plugin-prettier": "^4.2.1",
        "jest": "^29.3.1",
        "jest-junit": "^15.0.0",
        "prettier": "^2.8.0",
        "ts-node": "^10.9.1",
        "vega": "^5.22.1",
        "vega-lite": "^5.6.0"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint \"{src,test,factory}/**/*.ts\"",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "cross-env FAST_TEST=1 jest test/ --verbose",
        "test:coverage": "yarn jest test/ --collectCoverage=true",
        "test:update": "cross-env UPDATE_SCHEMA=true yarn test:fast",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node-transpile-only ts-json-schema-generator.ts",
        "release": "yarn build && auto shipit"
      },
      "readme": "# ts-json-schema-generator\n\n![Test](https://github.com/vega/ts-json-schema-generator/workflows/Test/badge.svg)\n[![codecov](https://codecov.io/gh/vega/ts-json-schema-generator/branch/master/graph/badge.svg)](https://codecov.io/gh/vega/ts-json-schema-generator)\n[![npm version](https://img.shields.io/npm/v/ts-json-schema-generator.svg)](https://www.npmjs.com/package/ts-json-schema-generator)\n\nExtended version of [https://github.com/xiag-ag/typescript-to-json-schema](https://github.com/xiag-ag/typescript-to-json-schema).\n\nInspired by [`YousefED/typescript-json-schema`](https://github.com/YousefED/typescript-json-schema). Here's the differences list:\n\n-   this implementation avoids the use of `typeChecker.getTypeAtLocation()` (so probably it keeps correct type aliases)\n-   processing AST and formatting JSON schema have been split into two independent steps\n-   not exported types, interfaces, enums are not exposed in the `definitions` section in the JSON schema\n\n## Contributors\n\nThis project is made possible by a [community of contributors](https://github.com/vega/ts-json-schema-generator/graphs/contributors). We welcome contributions of any kind (issues, code, documentation, examples, tests,...). Please read our [code of conduct](https://vega.github.io/vega/about/code-of-conduct).\n\n## CLI Usage\n\nRun the schema generator with npx:\n\n```bash\nnpx ts-json-schema-generator --path 'my/project/**/*.ts' --type 'My.Type.Name'\n```\n\nOr install the package and then run it\n\n```bash\nnpm install --save ts-json-schema-generator\n./node_modules/.bin/ts-json-schema-generator --path 'my/project/**/*.ts' --type 'My.Type.Name'\n```\n\nNote that different platforms (e.g. Windows) may use different path separators so you may have to adjust the command above.\n\nAlso note that you need to quote paths with `*` as otherwise the shell will expand the paths and therefore only pass the first path to the generator.\n\n## Programmatic Usage\n\n```js\n// main.js\n\nconst tsj = require(\"ts-json-schema-generator\");\nconst fs = require(\"fs\");\n\n/** @type {import('ts-json-schema-generator/dist/src/Config').Config} */\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst output_path = \"path/to/output/file\";\n\nconst schema = tsj.createGenerator(config).createSchema(config.type);\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\nRun the schema generator via `node main.js`.\n\n### Custom formatting\n\nExtending the built-in formatting is possible by creating a custom formatter and adding it to the main formatter:\n\n1. First we create a formatter, in this case for formatting function types:\n\n```ts\n// my-function-formatter.ts\nimport { BaseType, Definition, FunctionType, SubTypeFormatter } from \"ts-json-schema-generator\";\nimport ts from \"typescript\";\n\nexport class MyFunctionTypeFormatter implements SubTypeFormatter {\n    // You can skip this line if you don't need childTypeFormatter\n    public constructor(private childTypeFormatter: TypeFormatter) {}\n\n    public supportsType(type: FunctionType): boolean {\n        return type instanceof FunctionType;\n    }\n\n    public getDefinition(type: FunctionType): Definition {\n        // Return a custom schema for the function property.\n        return {\n            type: \"object\",\n            properties: {\n                isFunction: {\n                    type: \"boolean\",\n                    const: true,\n                },\n            },\n        };\n    }\n\n    // If this type does NOT HAVE children, generally all you need is:\n    public getChildren(type: FunctionType): BaseType[] {\n        return [];\n    }\n\n    // However, if children ARE supported, you'll need something similar to\n    // this (see src/TypeFormatter/{Array,Definition,etc}.ts for some examples):\n    public getChildren(type: FunctionType): BaseType[] {\n        return this.childTypeFormatter.getChildren(type.getType());\n    }\n}\n```\n\n2. Then we add the formatter as a child to the core formatter using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyFunctionTypeFormatter } from \"./my-function-formatter.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\n// We configure the formatter an add our custom formatter to it.\nconst formatter = createFormatter(config, (fmt, circularReferenceTypeFormatter) => {\n    // If your formatter DOES NOT support children, e.g. getChildren() { return [] }:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter());\n    // If your formatter DOES support children, you'll need this reference too:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter(circularReferenceTypeFormatter));\n});\n\nconst program = createProgram(config);\nconst parser = createParser(program, config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n### Custom parsing\n\nSimilar to custom formatting, extending the built-in parsing works practically the same way:\n\n1. First we create a parser, in this case for parsing construct types:\n\n```ts\n// my-constructor-parser.ts\nimport { Context, StringType, ReferenceType, BaseType, SubNodeParser } from \"ts-json-schema-generator\";\n// use typescript exported by TJS to avoid version conflict\nimport ts from \"ts-json-schema-generator\";\n\nexport class MyConstructorParser implements SubNodeParser {\n    supportsNode(node: ts.Node): boolean {\n        return node.kind === ts.SyntaxKind.ConstructorType;\n    }\n    createType(node: ts.Node, context: Context, reference?: ReferenceType): BaseType | undefined {\n        return new StringType(); // Treat constructors as strings in this example\n    }\n}\n```\n\n2. Then we add the parser as a child to the core parser using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyConstructorParser } from \"./my-constructor-parser.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst program = createProgram(config);\n\n// We configure the parser an add our custom parser to it.\nconst parser = createParser(program, config, (prs) => {\n    prs.addNodeParser(new MyConstructorParser());\n});\n\nconst formatter = createFormatter(config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n## Options\n\n```\n-p, --path 'index.ts'\n    The path to the TypeScript source file. If this is not provided, the type will be searched in the project specified in the `.tsconfig`.\n\n-t, --type 'My.Type.Name'\n    The type the generated schema will represent. If omitted, the generated schema will contain all\n    types found in the files matching path. The same is true if '*' is specified.\n\n-i, --id 'generatedSchemaId'\n    The `$id` of the generated schema. If omitted, there will be no `$id`.\n\n-e, --expose <all|none|export>\n    all: Create shared $ref definitions for all types.\n    none: Do not create shared $ref definitions.\n    export (default): Create shared $ref definitions only for exported types (not tagged as `@internal`).\n\n-f, --tsconfig 'my/project/tsconfig.json'\n    Use a custom tsconfig file for processing typescript (see https://www.typescriptlang.org/docs/handbook/tsconfig-json.html) instead of the default:\n    {\n        \"compilerOptions\": {\n            \"noEmit\": true,\n            \"emitDecoratorMetadata\": true,\n            \"experimentalDecorators\": true,\n            \"target\": \"ES5\",\n            \"module\": \"CommonJS\",\n            \"strictNullChecks\": false,\n        }\n    }\n\n-j, --jsDoc <extended|none|basic>\n    none: Do not use JsDoc annotations.\n    basic: Read JsDoc annotations to provide schema properties.\n    extended (default): Also read @nullable, and @asType annotations.\n\n--unstable\n    Do not sort properties.\n\n--strict-tuples\n    Do not allow additional items on tuples.\n\n--no-top-ref\n    Do not create a top-level $ref definition.\n\n--no-type-check\n    Skip type checks for better performance.\n\n--no-ref-encode\n    Do not encode references. According to the standard, references must be valid URIs but some tools do not support encoded references.\n\n--validation-keywords\n    Provide additional validation keywords to include.\n\n-o, --out\n    Specify the output file path. Without this option, the generator logs the response in the console.\n\n--additional-properties <true|false>\n    Controls whether or not to allow additional properties for objects that have no index signature.\n\n    true: Additional properties are allowed\n    false (default): Additional properties are not allowed\n\n--minify\n    Minify generated schema (default: false)\n```\n\n## Current state\n\n-   `interface` types\n-   `enum` types\n-   `union`, `tuple`, `type[]` types\n-   `Date`, `RegExp`, `URL` types\n-   `string`, `boolean`, `number` types\n-   `\"value\"`, `123`, `true`, `false`, `null`, `undefined` literals\n-   type aliases\n-   generics\n-   `typeof`\n-   `keyof`\n-   conditional types\n\n## Run locally\n\n`yarn --silent run run --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\n## Debug\n\n`yarn --silent run debug --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\nAnd connect via the debugger protocol.\n\n[AST Explorer](https://astexplorer.net/) is amazing for developers of this tool!\n\n## Publish\n\nPublishing is handled by a 2-branch [pre-release process](https://intuit.github.io/auto/docs/generated/shipit#next-branch-default), configured in `publish-auto.yml`. All changes should be based off the default `next` branch, and are published automatically.\n\n-   PRs made into the default branch are auto-deployed to the `next` pre-release tag on NPM. The result can be installed with `npm install ts-json-schema-generator@next`\n    -   When merging into `next`, please use the `squash and merge` strategy.\n-   To release a new stable version, open a PR from `next` into `stable` using this [compare link](https://github.com/vega/ts-json-schema-generator/compare/stable...next).\n    -   When merging from `next` into `stable`, please use the `create a merge commit` strategy.\n",
      "readmeFilename": "README.md",
      "gitHead": "8d550bb4e9b64c6c25e357a086f3f469919bc980",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@1.3.0--canary.1593.8d550bb.0",
      "_nodeVersion": "18.14.2",
      "_npmVersion": "9.5.0",
      "dist": {
        "integrity": "sha512-Xn8n8D7VCXTaco3Y7a1qpD6wejrIB07jZJjW0N1G6hSc21kp3BkW54NK4RMMF1a5ElJeZdp6E0n2NYovTuv5QA==",
        "shasum": "effc73224031a5e7c7b6bece3d556a46b223a579",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-1.3.0--canary.1593.8d550bb.0.tgz",
        "fileCount": 716,
        "unpackedSize": 885628,
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIGd15ua60GtUpTUPs6f3wDRXZ+pOCoISJF0cLoYM8/UWAiEA4XFT8QzyIKic51QQZOqCp5ZtdIAeF799r+S6JnCDBYg="
          }
        ],
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJkAiSTACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2Vmqobg/+NTEBgVK/wTbEswsRaDiIq5tNt+rJCc2LFgjSaW07q87tgMM0\r\n1+fOhXwDAIwuMuJK8OpyBAMBNpBaKvSVgUOvOEdXWQOi2zHlGo9CW4GDIbJD\r\nAUmTBstJqmf21EwkceJu5ye68J1ZXRY24Z6OXtiOLh4sqDcEb6u7Aw4QbRnJ\r\ntXl8qPNYn6fSBLirk8DUmmyIqmGm4VfhyuuLN7BCiwcg4Q/60PY98pjvAY6X\r\n+WEOxcb9BRCW78FKgkMOBLBc4JqNyjRJ5yGxiHcsXrRXexBlKyl20Y9eYvDz\r\nBSolj7xCDMbMclYSRnw9Y65Cgzx58kgGJAQuzqlEJML2eXa5tt6DhisTEKDP\r\nq/UJoxSiTpMjzPPhJD+1hXnXXvv4Rpt/Qcnb+mUQCz71Wvz5IugLDLWSUMqa\r\nbLPgMJ23LulCSq2+s+ptSoJezEeC23l7fc2AO5ULeBUgwwk77AFVCCtY3V8C\r\n9Ry1zh6I1Ko8VshoDQLuzmydTPiF/jJhFDLBy/004aFKqxSPiuAzuZvdL7X7\r\nMXNDFs/Rd4tUuNLKcxvwPwv/q4xXXbDJ4/pRBe/nz4QzQhLyUbh1LbwP6z1w\r\nuhe3KBpmboDK8Ce8wwGoZaPeWWy0DceC8KHq8wEo27g5kooAsocYN7W6XmQI\r\nFLsuXmyzXIDifrH9tdtE3yAyLufBdGaBWPU=\r\n=Z91S\r\n-----END PGP SIGNATURE-----\r\n"
      },
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "maintainers": [
        {
          "name": "jheer",
          "email": "jeffrey.heer@gmail.com"
        },
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "kanitw",
          "email": "kanitw@gmail.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_1.3.0--canary.1593.8d550bb.0_1677862035139_0.7771288634283122"
      },
      "_hasShrinkwrap": false
    },
    "1.3.0--canary.1594.8aec388.0": {
      "name": "ts-json-schema-generator",
      "version": "1.3.0--canary.1594.8aec388.0",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "MooYeol Prescott Lee",
          "email": "mooyoul@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=10.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.11",
        "commander": "^10.0.0",
        "glob": "^8.0.3",
        "json5": "^2.2.1",
        "normalize-path": "^3.0.0",
        "safe-stable-stringify": "^2.4.1",
        "typescript": "~4.9.3"
      },
      "devDependencies": {
        "@auto-it/conventional-commits": "^10.37.6",
        "@auto-it/first-time-contributor": "^10.37.6",
        "@babel/core": "^7.20.5",
        "@babel/preset-env": "^7.20.2",
        "@babel/preset-typescript": "^7.18.6",
        "@types/glob": "^8.0.0",
        "@types/jest": "^29.2.3",
        "@types/node": "^18.11.10",
        "@types/normalize-path": "^3.0.0",
        "@typescript-eslint/eslint-plugin": "^5.45.0",
        "@typescript-eslint/parser": "^5.45.0",
        "ajv": "^8.11.2",
        "ajv-formats": "^2.1.1",
        "auto": "^10.37.6",
        "chai": "^4.3.7",
        "cross-env": "^7.0.3",
        "eslint": "^8.29.0",
        "eslint-config-prettier": "^8.5.0",
        "eslint-plugin-prettier": "^4.2.1",
        "jest": "^29.3.1",
        "jest-junit": "^15.0.0",
        "prettier": "^2.8.0",
        "ts-node": "^10.9.1",
        "vega": "^5.22.1",
        "vega-lite": "^5.6.0"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint \"{src,test,factory}/**/*.ts\"",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "cross-env FAST_TEST=1 jest test/ --verbose",
        "test:coverage": "yarn jest test/ --collectCoverage=true",
        "test:update": "cross-env UPDATE_SCHEMA=true yarn test:fast",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node-transpile-only ts-json-schema-generator.ts",
        "release": "yarn build && auto shipit"
      },
      "readme": "# ts-json-schema-generator\n\n![Test](https://github.com/vega/ts-json-schema-generator/workflows/Test/badge.svg)\n[![codecov](https://codecov.io/gh/vega/ts-json-schema-generator/branch/master/graph/badge.svg)](https://codecov.io/gh/vega/ts-json-schema-generator)\n[![npm version](https://img.shields.io/npm/v/ts-json-schema-generator.svg)](https://www.npmjs.com/package/ts-json-schema-generator)\n\nExtended version of [https://github.com/xiag-ag/typescript-to-json-schema](https://github.com/xiag-ag/typescript-to-json-schema).\n\nInspired by [`YousefED/typescript-json-schema`](https://github.com/YousefED/typescript-json-schema). Here's the differences list:\n\n-   this implementation avoids the use of `typeChecker.getTypeAtLocation()` (so probably it keeps correct type aliases)\n-   processing AST and formatting JSON schema have been split into two independent steps\n-   not exported types, interfaces, enums are not exposed in the `definitions` section in the JSON schema\n\n## Contributors\n\nThis project is made possible by a [community of contributors](https://github.com/vega/ts-json-schema-generator/graphs/contributors). We welcome contributions of any kind (issues, code, documentation, examples, tests,...). Please read our [code of conduct](https://vega.github.io/vega/about/code-of-conduct).\n\n## CLI Usage\n\nRun the schema generator with npx:\n\n```bash\nnpx ts-json-schema-generator --path 'my/project/**/*.ts' --type 'My.Type.Name'\n```\n\nOr install the package and then run it\n\n```bash\nnpm install --save ts-json-schema-generator\n./node_modules/.bin/ts-json-schema-generator --path 'my/project/**/*.ts' --type 'My.Type.Name'\n```\n\nNote that different platforms (e.g. Windows) may use different path separators so you may have to adjust the command above.\n\nAlso note that you need to quote paths with `*` as otherwise the shell will expand the paths and therefore only pass the first path to the generator.\n\n## Programmatic Usage\n\n```js\n// main.js\n\nconst tsj = require(\"ts-json-schema-generator\");\nconst fs = require(\"fs\");\n\n/** @type {import('ts-json-schema-generator/dist/src/Config').Config} */\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst output_path = \"path/to/output/file\";\n\nconst schema = tsj.createGenerator(config).createSchema(config.type);\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\nRun the schema generator via `node main.js`.\n\n### Custom formatting\n\nExtending the built-in formatting is possible by creating a custom formatter and adding it to the main formatter:\n\n1. First we create a formatter, in this case for formatting function types:\n\n```ts\n// my-function-formatter.ts\nimport { BaseType, Definition, FunctionType, SubTypeFormatter } from \"ts-json-schema-generator\";\nimport ts from \"typescript\";\n\nexport class MyFunctionTypeFormatter implements SubTypeFormatter {\n    // You can skip this line if you don't need childTypeFormatter\n    public constructor(private childTypeFormatter: TypeFormatter) {}\n\n    public supportsType(type: FunctionType): boolean {\n        return type instanceof FunctionType;\n    }\n\n    public getDefinition(type: FunctionType): Definition {\n        // Return a custom schema for the function property.\n        return {\n            type: \"object\",\n            properties: {\n                isFunction: {\n                    type: \"boolean\",\n                    const: true,\n                },\n            },\n        };\n    }\n\n    // If this type does NOT HAVE children, generally all you need is:\n    public getChildren(type: FunctionType): BaseType[] {\n        return [];\n    }\n\n    // However, if children ARE supported, you'll need something similar to\n    // this (see src/TypeFormatter/{Array,Definition,etc}.ts for some examples):\n    public getChildren(type: FunctionType): BaseType[] {\n        return this.childTypeFormatter.getChildren(type.getType());\n    }\n}\n```\n\n2. Then we add the formatter as a child to the core formatter using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyFunctionTypeFormatter } from \"./my-function-formatter.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\n// We configure the formatter an add our custom formatter to it.\nconst formatter = createFormatter(config, (fmt, circularReferenceTypeFormatter) => {\n    // If your formatter DOES NOT support children, e.g. getChildren() { return [] }:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter());\n    // If your formatter DOES support children, you'll need this reference too:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter(circularReferenceTypeFormatter));\n});\n\nconst program = createProgram(config);\nconst parser = createParser(program, config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n### Custom parsing\n\nSimilar to custom formatting, extending the built-in parsing works practically the same way:\n\n1. First we create a parser, in this case for parsing construct types:\n\n```ts\n// my-constructor-parser.ts\nimport { Context, StringType, ReferenceType, BaseType, SubNodeParser } from \"ts-json-schema-generator\";\n// use typescript exported by TJS to avoid version conflict\nimport ts from \"ts-json-schema-generator\";\n\nexport class MyConstructorParser implements SubNodeParser {\n    supportsNode(node: ts.Node): boolean {\n        return node.kind === ts.SyntaxKind.ConstructorType;\n    }\n    createType(node: ts.Node, context: Context, reference?: ReferenceType): BaseType | undefined {\n        return new StringType(); // Treat constructors as strings in this example\n    }\n}\n```\n\n2. Then we add the parser as a child to the core parser using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyConstructorParser } from \"./my-constructor-parser.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst program = createProgram(config);\n\n// We configure the parser an add our custom parser to it.\nconst parser = createParser(program, config, (prs) => {\n    prs.addNodeParser(new MyConstructorParser());\n});\n\nconst formatter = createFormatter(config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n## Options\n\n```\n-p, --path 'index.ts'\n    The path to the TypeScript source file. If this is not provided, the type will be searched in the project specified in the `.tsconfig`.\n\n-t, --type 'My.Type.Name'\n    The type the generated schema will represent. If omitted, the generated schema will contain all\n    types found in the files matching path. The same is true if '*' is specified.\n\n-i, --id 'generatedSchemaId'\n    The `$id` of the generated schema. If omitted, there will be no `$id`.\n\n-e, --expose <all|none|export>\n    all: Create shared $ref definitions for all types.\n    none: Do not create shared $ref definitions.\n    export (default): Create shared $ref definitions only for exported types (not tagged as `@internal`).\n\n-f, --tsconfig 'my/project/tsconfig.json'\n    Use a custom tsconfig file for processing typescript (see https://www.typescriptlang.org/docs/handbook/tsconfig-json.html) instead of the default:\n    {\n        \"compilerOptions\": {\n            \"noEmit\": true,\n            \"emitDecoratorMetadata\": true,\n            \"experimentalDecorators\": true,\n            \"target\": \"ES5\",\n            \"module\": \"CommonJS\",\n            \"strictNullChecks\": false,\n        }\n    }\n\n-j, --jsDoc <extended|none|basic>\n    none: Do not use JsDoc annotations.\n    basic: Read JsDoc annotations to provide schema properties.\n    extended (default): Also read @nullable, and @asType annotations.\n\n--unstable\n    Do not sort properties.\n\n--strict-tuples\n    Do not allow additional items on tuples.\n\n--no-top-ref\n    Do not create a top-level $ref definition.\n\n--no-type-check\n    Skip type checks for better performance.\n\n--no-ref-encode\n    Do not encode references. According to the standard, references must be valid URIs but some tools do not support encoded references.\n\n--validation-keywords\n    Provide additional validation keywords to include.\n\n-o, --out\n    Specify the output file path. Without this option, the generator logs the response in the console.\n\n--additional-properties <true|false>\n    Controls whether or not to allow additional properties for objects that have no index signature.\n\n    true: Additional properties are allowed\n    false (default): Additional properties are not allowed\n\n--minify\n    Minify generated schema (default: false)\n```\n\n## Current state\n\n-   `interface` types\n-   `enum` types\n-   `union`, `tuple`, `type[]` types\n-   `Date`, `RegExp`, `URL` types\n-   `string`, `boolean`, `number` types\n-   `\"value\"`, `123`, `true`, `false`, `null`, `undefined` literals\n-   type aliases\n-   generics\n-   `typeof`\n-   `keyof`\n-   conditional types\n\n## Run locally\n\n`yarn --silent run run --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\n## Debug\n\n`yarn --silent run debug --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\nAnd connect via the debugger protocol.\n\n[AST Explorer](https://astexplorer.net/) is amazing for developers of this tool!\n\n## Publish\n\nPublishing is handled by a 2-branch [pre-release process](https://intuit.github.io/auto/docs/generated/shipit#next-branch-default), configured in `publish-auto.yml`. All changes should be based off the default `next` branch, and are published automatically.\n\n-   PRs made into the default branch are auto-deployed to the `next` pre-release tag on NPM. The result can be installed with `npm install ts-json-schema-generator@next`\n    -   When merging into `next`, please use the `squash and merge` strategy.\n-   To release a new stable version, open a PR from `next` into `stable` using this [compare link](https://github.com/vega/ts-json-schema-generator/compare/stable...next).\n    -   When merging from `next` into `stable`, please use the `create a merge commit` strategy.\n",
      "readmeFilename": "README.md",
      "gitHead": "8aec3886a773413b877ce45c8128d97afaf53343",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@1.3.0--canary.1594.8aec388.0",
      "_nodeVersion": "18.14.2",
      "_npmVersion": "9.5.0",
      "dist": {
        "integrity": "sha512-0Y3iZpPHZtCXCqalKNUIADJBDpIXrFBFQeoIDQPK1qymej/9mlfy64zrAPkFfA8pTLJo+KIww+P9urOlIt64gQ==",
        "shasum": "aa6dc9e3b69242ab9111f57a6276e739683b6f27",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-1.3.0--canary.1594.8aec388.0.tgz",
        "fileCount": 716,
        "unpackedSize": 884873,
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEQCIEvMvngOy9EiSri9mmMfOdsJx3+Tm3ezZSAZTEO5RBQLAiBupRXxpT1cQsxoxcaMNye7ZBjid86Nms/xHl6mAUnF9w=="
          }
        ],
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJkAiUIACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2VmoBlxAAg5otV1R3wyMsT/BrDCairqvCPXF6KxsP//hb6NRHwY+totrz\r\nRgCsE3f5ahUo1ItMZJ0ID41dri6XdH5qgovktLoy01LZfzXvpUcO0qAxNByy\r\nZgd8Yzffo5XAOBv+SwQy6OC2o/8AatZURYEDbvrQpHpbRUwic4QoHvKgQVyP\r\nesNSmN2zDzYk6IfAicnl5rGY8g1bsDaN/y3AaBPGngHteRaE3hlz87tFjc/g\r\nAyOaZCkHTkBjhqM4Dm3EdGw5m2HRXx9h2mq92fyXOVg1ZCwN90ygBU7ogQdl\r\nnxf8Ei4MC5HTy/UAX7iiklbUd07I4PQGSL4Dr1+fIZo+2hlPU5Qmk/XYPFW9\r\nCUKjMpJrt8JS2GkwtVOUMoe8Rjr6wOs1+WZbloMQCsQV95vdB+7nRFx3vA6t\r\npZkx9E8FrkgtsaWGE6DCqhImFvIEza7HZN5+D6+XIFGw4mIpx5ZB3+Ml9NoZ\r\nyx0UlEYn/BayYo5ml/KbViX+nWspZT3UJOkWsRHoMQUx7ScmrJGfARWxNW9w\r\nqNTIfQ1JR5AeTLBYFMrlCL48rT4tcLSk+6tq6n1ClSY2AKUGvCc3TMWNkkvU\r\npRtx7c3/kgpN6FwLk951v+jJmsNFcf4IHam4vynU45Irob4Ie2DW+ZeFYgOd\r\nGRLtE4Gzwg0Qz19BnnFYb/jjV5IRQQoK0w4=\r\n=N7FF\r\n-----END PGP SIGNATURE-----\r\n"
      },
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "maintainers": [
        {
          "name": "jheer",
          "email": "jeffrey.heer@gmail.com"
        },
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "kanitw",
          "email": "kanitw@gmail.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_1.3.0--canary.1594.8aec388.0_1677862151944_0.5534751792035464"
      },
      "_hasShrinkwrap": false
    },
    "1.3.0-next.1": {
      "name": "ts-json-schema-generator",
      "version": "1.3.0-next.1",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "MooYeol Prescott Lee",
          "email": "mooyoul@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=10.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.11",
        "commander": "^10.0.0",
        "glob": "^8.0.3",
        "json5": "^2.2.1",
        "normalize-path": "^3.0.0",
        "safe-stable-stringify": "^2.4.1",
        "typescript": "~4.9.3"
      },
      "devDependencies": {
        "@auto-it/conventional-commits": "^10.37.6",
        "@auto-it/first-time-contributor": "^10.37.6",
        "@babel/core": "^7.20.5",
        "@babel/preset-env": "^7.20.2",
        "@babel/preset-typescript": "^7.18.6",
        "@types/glob": "^8.0.0",
        "@types/jest": "^29.2.3",
        "@types/node": "^18.11.10",
        "@types/normalize-path": "^3.0.0",
        "@typescript-eslint/eslint-plugin": "^5.45.0",
        "@typescript-eslint/parser": "^5.45.0",
        "ajv": "^8.11.2",
        "ajv-formats": "^2.1.1",
        "auto": "^10.37.6",
        "chai": "^4.3.7",
        "cross-env": "^7.0.3",
        "eslint": "^8.29.0",
        "eslint-config-prettier": "^8.5.0",
        "eslint-plugin-prettier": "^4.2.1",
        "jest": "^29.3.1",
        "jest-junit": "^15.0.0",
        "prettier": "^2.8.0",
        "ts-node": "^10.9.1",
        "vega": "^5.22.1",
        "vega-lite": "^5.6.0"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint \"{src,test,factory}/**/*.ts\"",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "cross-env FAST_TEST=1 jest test/ --verbose",
        "test:coverage": "yarn jest test/ --collectCoverage=true",
        "test:update": "cross-env UPDATE_SCHEMA=true yarn test:fast",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node-transpile-only ts-json-schema-generator.ts",
        "release": "yarn build && auto shipit"
      },
      "readme": "# ts-json-schema-generator\n\n![Test](https://github.com/vega/ts-json-schema-generator/workflows/Test/badge.svg)\n[![codecov](https://codecov.io/gh/vega/ts-json-schema-generator/branch/master/graph/badge.svg)](https://codecov.io/gh/vega/ts-json-schema-generator)\n[![npm version](https://img.shields.io/npm/v/ts-json-schema-generator.svg)](https://www.npmjs.com/package/ts-json-schema-generator)\n\nExtended version of [https://github.com/xiag-ag/typescript-to-json-schema](https://github.com/xiag-ag/typescript-to-json-schema).\n\nInspired by [`YousefED/typescript-json-schema`](https://github.com/YousefED/typescript-json-schema). Here's the differences list:\n\n-   this implementation avoids the use of `typeChecker.getTypeAtLocation()` (so probably it keeps correct type aliases)\n-   processing AST and formatting JSON schema have been split into two independent steps\n-   not exported types, interfaces, enums are not exposed in the `definitions` section in the JSON schema\n\n## Contributors\n\nThis project is made possible by a [community of contributors](https://github.com/vega/ts-json-schema-generator/graphs/contributors). We welcome contributions of any kind (issues, code, documentation, examples, tests,...). Please read our [code of conduct](https://vega.github.io/vega/about/code-of-conduct).\n\n## CLI Usage\n\nRun the schema generator with npx:\n\n```bash\nnpx ts-json-schema-generator --path 'my/project/**/*.ts' --type 'My.Type.Name'\n```\n\nOr install the package and then run it\n\n```bash\nnpm install --save ts-json-schema-generator\n./node_modules/.bin/ts-json-schema-generator --path 'my/project/**/*.ts' --type 'My.Type.Name'\n```\n\nNote that different platforms (e.g. Windows) may use different path separators so you may have to adjust the command above.\n\nAlso note that you need to quote paths with `*` as otherwise the shell will expand the paths and therefore only pass the first path to the generator.\n\n## Programmatic Usage\n\n```js\n// main.js\n\nconst tsj = require(\"ts-json-schema-generator\");\nconst fs = require(\"fs\");\n\n/** @type {import('ts-json-schema-generator/dist/src/Config').Config} */\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst output_path = \"path/to/output/file\";\n\nconst schema = tsj.createGenerator(config).createSchema(config.type);\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\nRun the schema generator via `node main.js`.\n\n### Custom formatting\n\nExtending the built-in formatting is possible by creating a custom formatter and adding it to the main formatter:\n\n1. First we create a formatter, in this case for formatting function types:\n\n```ts\n// my-function-formatter.ts\nimport { BaseType, Definition, FunctionType, SubTypeFormatter } from \"ts-json-schema-generator\";\nimport ts from \"typescript\";\n\nexport class MyFunctionTypeFormatter implements SubTypeFormatter {\n    // You can skip this line if you don't need childTypeFormatter\n    public constructor(private childTypeFormatter: TypeFormatter) {}\n\n    public supportsType(type: FunctionType): boolean {\n        return type instanceof FunctionType;\n    }\n\n    public getDefinition(type: FunctionType): Definition {\n        // Return a custom schema for the function property.\n        return {\n            type: \"object\",\n            properties: {\n                isFunction: {\n                    type: \"boolean\",\n                    const: true,\n                },\n            },\n        };\n    }\n\n    // If this type does NOT HAVE children, generally all you need is:\n    public getChildren(type: FunctionType): BaseType[] {\n        return [];\n    }\n\n    // However, if children ARE supported, you'll need something similar to\n    // this (see src/TypeFormatter/{Array,Definition,etc}.ts for some examples):\n    public getChildren(type: FunctionType): BaseType[] {\n        return this.childTypeFormatter.getChildren(type.getType());\n    }\n}\n```\n\n2. Then we add the formatter as a child to the core formatter using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyFunctionTypeFormatter } from \"./my-function-formatter.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\n// We configure the formatter an add our custom formatter to it.\nconst formatter = createFormatter(config, (fmt, circularReferenceTypeFormatter) => {\n    // If your formatter DOES NOT support children, e.g. getChildren() { return [] }:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter());\n    // If your formatter DOES support children, you'll need this reference too:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter(circularReferenceTypeFormatter));\n});\n\nconst program = createProgram(config);\nconst parser = createParser(program, config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n### Custom parsing\n\nSimilar to custom formatting, extending the built-in parsing works practically the same way:\n\n1. First we create a parser, in this case for parsing construct types:\n\n```ts\n// my-constructor-parser.ts\nimport { Context, StringType, ReferenceType, BaseType, SubNodeParser } from \"ts-json-schema-generator\";\n// use typescript exported by TJS to avoid version conflict\nimport ts from \"ts-json-schema-generator\";\n\nexport class MyConstructorParser implements SubNodeParser {\n    supportsNode(node: ts.Node): boolean {\n        return node.kind === ts.SyntaxKind.ConstructorType;\n    }\n    createType(node: ts.Node, context: Context, reference?: ReferenceType): BaseType | undefined {\n        return new StringType(); // Treat constructors as strings in this example\n    }\n}\n```\n\n2. Then we add the parser as a child to the core parser using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyConstructorParser } from \"./my-constructor-parser.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst program = createProgram(config);\n\n// We configure the parser an add our custom parser to it.\nconst parser = createParser(program, config, (prs) => {\n    prs.addNodeParser(new MyConstructorParser());\n});\n\nconst formatter = createFormatter(config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n## Options\n\n```\n-p, --path 'index.ts'\n    The path to the TypeScript source file. If this is not provided, the type will be searched in the project specified in the `.tsconfig`.\n\n-t, --type 'My.Type.Name'\n    The type the generated schema will represent. If omitted, the generated schema will contain all\n    types found in the files matching path. The same is true if '*' is specified.\n\n-i, --id 'generatedSchemaId'\n    The `$id` of the generated schema. If omitted, there will be no `$id`.\n\n-e, --expose <all|none|export>\n    all: Create shared $ref definitions for all types.\n    none: Do not create shared $ref definitions.\n    export (default): Create shared $ref definitions only for exported types (not tagged as `@internal`).\n\n-f, --tsconfig 'my/project/tsconfig.json'\n    Use a custom tsconfig file for processing typescript (see https://www.typescriptlang.org/docs/handbook/tsconfig-json.html) instead of the default:\n    {\n        \"compilerOptions\": {\n            \"noEmit\": true,\n            \"emitDecoratorMetadata\": true,\n            \"experimentalDecorators\": true,\n            \"target\": \"ES5\",\n            \"module\": \"CommonJS\",\n            \"strictNullChecks\": false,\n        }\n    }\n\n-j, --jsDoc <extended|none|basic>\n    none: Do not use JsDoc annotations.\n    basic: Read JsDoc annotations to provide schema properties.\n    extended (default): Also read @nullable, and @asType annotations.\n\n--unstable\n    Do not sort properties.\n\n--strict-tuples\n    Do not allow additional items on tuples.\n\n--no-top-ref\n    Do not create a top-level $ref definition.\n\n--no-type-check\n    Skip type checks for better performance.\n\n--no-ref-encode\n    Do not encode references. According to the standard, references must be valid URIs but some tools do not support encoded references.\n\n--validation-keywords\n    Provide additional validation keywords to include.\n\n-o, --out\n    Specify the output file path. Without this option, the generator logs the response in the console.\n\n--additional-properties <true|false>\n    Controls whether or not to allow additional properties for objects that have no index signature.\n\n    true: Additional properties are allowed\n    false (default): Additional properties are not allowed\n\n--minify\n    Minify generated schema (default: false)\n```\n\n## Current state\n\n-   `interface` types\n-   `enum` types\n-   `union`, `tuple`, `type[]` types\n-   `Date`, `RegExp`, `URL` types\n-   `string`, `boolean`, `number` types\n-   `\"value\"`, `123`, `true`, `false`, `null`, `undefined` literals\n-   type aliases\n-   generics\n-   `typeof`\n-   `keyof`\n-   conditional types\n\n## Run locally\n\n`yarn --silent run run --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\n## Debug\n\n`yarn --silent run debug --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\nAnd connect via the debugger protocol.\n\n[AST Explorer](https://astexplorer.net/) is amazing for developers of this tool!\n\n## Publish\n\nPublishing is handled by a 2-branch [pre-release process](https://intuit.github.io/auto/docs/generated/shipit#next-branch-default), configured in `publish-auto.yml`. All changes should be based off the default `next` branch, and are published automatically.\n\n-   PRs made into the default branch are auto-deployed to the `next` pre-release tag on NPM. The result can be installed with `npm install ts-json-schema-generator@next`\n    -   When merging into `next`, please use the `squash and merge` strategy.\n-   To release a new stable version, open a PR from `next` into `stable` using this [compare link](https://github.com/vega/ts-json-schema-generator/compare/stable...next).\n    -   When merging from `next` into `stable`, please use the `create a merge commit` strategy.\n",
      "readmeFilename": "README.md",
      "gitHead": "9b2b4bda2a053d6d00aa758d0b1e68352a6256c8",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@1.3.0-next.1",
      "_nodeVersion": "18.14.2",
      "_npmVersion": "9.5.0",
      "dist": {
        "integrity": "sha512-E+cRWdvRdXExNj2SEtbHmL8gcmuyW6GYoRZBmyDBTI1H7yKcfGkWWAFlAm67saYSLxnatZN0f5ctobpfKMreuQ==",
        "shasum": "ce2451f8c6b77900e7047067e22117b915554182",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-1.3.0-next.1.tgz",
        "fileCount": 716,
        "unpackedSize": 884409,
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEYCIQD4wzul22w7JjyxtAbp+O92RnPc0Oo/T8sIN04p+KisygIhAIVMEpVIUNi8adyk0qDMSrAS88B1myqeAfkaHzZuS8NL"
          }
        ],
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJkAjrfACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2VmpAeQ/+KTGfuanqe4AA+8ItCIunIc51VaeltYsfjGOYmeaaOhPdFZUf\r\n+Kpxrs5X/zbBr1v7a7wbtvs5fkRJUt5+jcz/DKFWe9XTuCUxD0UXCl1nIxHB\r\nEv6wNz+mxGwA8m4eVcwHYMF5QgG7xZbY7X+Js6NlDJT26rFLWR974c6ADNl9\r\n9mrNVGjUZNeKBUquW21iQxw+ZlzUqGWarYrXA5b1yxtl3CproxaojZPhxhdI\r\nG2zCbQ4Er0Syb19bMbJBEaCLCJ8R+UxFeLUxfliBmpdkjaepsBMAHjCgh8Au\r\n0cIVVCXB8GOUt2mRUHVgcbn8vwwXidMteNmXYet7CBb9pmfSo2tNxy/6SUPJ\r\nfkGiE3tWZcB6Ispj44d/SqX6kzSUZVY1YSjKYlxLvCBTcgSdi4jr9tt+9v4+\r\nY7KsikJONBr5k2AFg1k3gKhtw4EcIuV78mZ9b3cUDN6eK3w0ZV58dt/Jn2Yk\r\nz9cmqJtYCG0qnhEf14MQQ0mPjOadFN6dMIhJ/txHeO7i+lX3ZYGLY1vuiDVm\r\najoa7uCeJhF5FkkWwJVDEuZTVP124z4Zz9Etwk4AZL5ifE8lz8P/U9o/dCTk\r\nJANxBobrt+b4b+qkHzaKg/pTzvM5LQ184pSI5arotb8RlnZoLpEZsCODauWN\r\nZ3VvNfRwhqLlow3P1q4diA8QnBElaDWWGzY=\r\n=G+UT\r\n-----END PGP SIGNATURE-----\r\n"
      },
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "maintainers": [
        {
          "name": "jheer",
          "email": "jeffrey.heer@gmail.com"
        },
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "kanitw",
          "email": "kanitw@gmail.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_1.3.0-next.1_1677867743057_0.2559430195795074"
      },
      "_hasShrinkwrap": false
    },
    "1.2.1--canary.1594.c05565b.0": {
      "name": "ts-json-schema-generator",
      "version": "1.2.1--canary.1594.c05565b.0",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "MooYeol Prescott Lee",
          "email": "mooyoul@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=10.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.11",
        "commander": "^10.0.0",
        "glob": "^8.0.3",
        "json5": "^2.2.1",
        "normalize-path": "^3.0.0",
        "safe-stable-stringify": "^2.4.1",
        "typescript": "~4.9.3"
      },
      "devDependencies": {
        "@auto-it/conventional-commits": "^10.37.6",
        "@auto-it/first-time-contributor": "^10.37.6",
        "@babel/core": "^7.20.5",
        "@babel/preset-env": "^7.20.2",
        "@babel/preset-typescript": "^7.18.6",
        "@types/glob": "^8.0.0",
        "@types/jest": "^29.2.3",
        "@types/node": "^18.11.10",
        "@types/normalize-path": "^3.0.0",
        "@typescript-eslint/eslint-plugin": "^5.45.0",
        "@typescript-eslint/parser": "^5.45.0",
        "ajv": "^8.11.2",
        "ajv-formats": "^2.1.1",
        "auto": "^10.37.6",
        "chai": "^4.3.7",
        "cross-env": "^7.0.3",
        "eslint": "^8.29.0",
        "eslint-config-prettier": "^8.5.0",
        "eslint-plugin-prettier": "^4.2.1",
        "jest": "^29.3.1",
        "jest-junit": "^15.0.0",
        "prettier": "^2.8.0",
        "ts-node": "^10.9.1",
        "vega": "^5.22.1",
        "vega-lite": "^5.6.0"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint \"{src,test,factory}/**/*.ts\"",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "cross-env FAST_TEST=1 jest test/ --verbose",
        "test:coverage": "yarn jest test/ --collectCoverage=true",
        "test:update": "cross-env UPDATE_SCHEMA=true yarn test:fast",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node-transpile-only ts-json-schema-generator.ts",
        "release": "yarn build && auto shipit"
      },
      "readme": "# ts-json-schema-generator\n\n![Test](https://github.com/vega/ts-json-schema-generator/workflows/Test/badge.svg)\n[![codecov](https://codecov.io/gh/vega/ts-json-schema-generator/branch/master/graph/badge.svg)](https://codecov.io/gh/vega/ts-json-schema-generator)\n[![npm version](https://img.shields.io/npm/v/ts-json-schema-generator.svg)](https://www.npmjs.com/package/ts-json-schema-generator)\n\nExtended version of [https://github.com/xiag-ag/typescript-to-json-schema](https://github.com/xiag-ag/typescript-to-json-schema).\n\nInspired by [`YousefED/typescript-json-schema`](https://github.com/YousefED/typescript-json-schema). Here's the differences list:\n\n-   this implementation avoids the use of `typeChecker.getTypeAtLocation()` (so probably it keeps correct type aliases)\n-   processing AST and formatting JSON schema have been split into two independent steps\n-   not exported types, interfaces, enums are not exposed in the `definitions` section in the JSON schema\n\n## Contributors\n\nThis project is made possible by a [community of contributors](https://github.com/vega/ts-json-schema-generator/graphs/contributors). We welcome contributions of any kind (issues, code, documentation, examples, tests,...). Please read our [code of conduct](https://vega.github.io/vega/about/code-of-conduct).\n\n## CLI Usage\n\nRun the schema generator with npx:\n\n```bash\nnpx ts-json-schema-generator --path 'my/project/**/*.ts' --type 'My.Type.Name'\n```\n\nOr install the package and then run it\n\n```bash\nnpm install --save ts-json-schema-generator\n./node_modules/.bin/ts-json-schema-generator --path 'my/project/**/*.ts' --type 'My.Type.Name'\n```\n\nNote that different platforms (e.g. Windows) may use different path separators so you may have to adjust the command above.\n\nAlso note that you need to quote paths with `*` as otherwise the shell will expand the paths and therefore only pass the first path to the generator.\n\n## Programmatic Usage\n\n```js\n// main.js\n\nconst tsj = require(\"ts-json-schema-generator\");\nconst fs = require(\"fs\");\n\n/** @type {import('ts-json-schema-generator/dist/src/Config').Config} */\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst output_path = \"path/to/output/file\";\n\nconst schema = tsj.createGenerator(config).createSchema(config.type);\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\nRun the schema generator via `node main.js`.\n\n### Custom formatting\n\nExtending the built-in formatting is possible by creating a custom formatter and adding it to the main formatter:\n\n1. First we create a formatter, in this case for formatting function types:\n\n```ts\n// my-function-formatter.ts\nimport { BaseType, Definition, FunctionType, SubTypeFormatter } from \"ts-json-schema-generator\";\nimport ts from \"typescript\";\n\nexport class MyFunctionTypeFormatter implements SubTypeFormatter {\n    // You can skip this line if you don't need childTypeFormatter\n    public constructor(private childTypeFormatter: TypeFormatter) {}\n\n    public supportsType(type: FunctionType): boolean {\n        return type instanceof FunctionType;\n    }\n\n    public getDefinition(type: FunctionType): Definition {\n        // Return a custom schema for the function property.\n        return {\n            type: \"object\",\n            properties: {\n                isFunction: {\n                    type: \"boolean\",\n                    const: true,\n                },\n            },\n        };\n    }\n\n    // If this type does NOT HAVE children, generally all you need is:\n    public getChildren(type: FunctionType): BaseType[] {\n        return [];\n    }\n\n    // However, if children ARE supported, you'll need something similar to\n    // this (see src/TypeFormatter/{Array,Definition,etc}.ts for some examples):\n    public getChildren(type: FunctionType): BaseType[] {\n        return this.childTypeFormatter.getChildren(type.getType());\n    }\n}\n```\n\n2. Then we add the formatter as a child to the core formatter using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyFunctionTypeFormatter } from \"./my-function-formatter.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\n// We configure the formatter an add our custom formatter to it.\nconst formatter = createFormatter(config, (fmt, circularReferenceTypeFormatter) => {\n    // If your formatter DOES NOT support children, e.g. getChildren() { return [] }:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter());\n    // If your formatter DOES support children, you'll need this reference too:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter(circularReferenceTypeFormatter));\n});\n\nconst program = createProgram(config);\nconst parser = createParser(program, config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n### Custom parsing\n\nSimilar to custom formatting, extending the built-in parsing works practically the same way:\n\n1. First we create a parser, in this case for parsing construct types:\n\n```ts\n// my-constructor-parser.ts\nimport { Context, StringType, ReferenceType, BaseType, SubNodeParser } from \"ts-json-schema-generator\";\n// use typescript exported by TJS to avoid version conflict\nimport ts from \"ts-json-schema-generator\";\n\nexport class MyConstructorParser implements SubNodeParser {\n    supportsNode(node: ts.Node): boolean {\n        return node.kind === ts.SyntaxKind.ConstructorType;\n    }\n    createType(node: ts.Node, context: Context, reference?: ReferenceType): BaseType | undefined {\n        return new StringType(); // Treat constructors as strings in this example\n    }\n}\n```\n\n2. Then we add the parser as a child to the core parser using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyConstructorParser } from \"./my-constructor-parser.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst program = createProgram(config);\n\n// We configure the parser an add our custom parser to it.\nconst parser = createParser(program, config, (prs) => {\n    prs.addNodeParser(new MyConstructorParser());\n});\n\nconst formatter = createFormatter(config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n## Options\n\n```\n-p, --path 'index.ts'\n    The path to the TypeScript source file. If this is not provided, the type will be searched in the project specified in the `.tsconfig`.\n\n-t, --type 'My.Type.Name'\n    The type the generated schema will represent. If omitted, the generated schema will contain all\n    types found in the files matching path. The same is true if '*' is specified.\n\n-i, --id 'generatedSchemaId'\n    The `$id` of the generated schema. If omitted, there will be no `$id`.\n\n-e, --expose <all|none|export>\n    all: Create shared $ref definitions for all types.\n    none: Do not create shared $ref definitions.\n    export (default): Create shared $ref definitions only for exported types (not tagged as `@internal`).\n\n-f, --tsconfig 'my/project/tsconfig.json'\n    Use a custom tsconfig file for processing typescript (see https://www.typescriptlang.org/docs/handbook/tsconfig-json.html) instead of the default:\n    {\n        \"compilerOptions\": {\n            \"noEmit\": true,\n            \"emitDecoratorMetadata\": true,\n            \"experimentalDecorators\": true,\n            \"target\": \"ES5\",\n            \"module\": \"CommonJS\",\n            \"strictNullChecks\": false,\n        }\n    }\n\n-j, --jsDoc <extended|none|basic>\n    none: Do not use JsDoc annotations.\n    basic: Read JsDoc annotations to provide schema properties.\n    extended (default): Also read @nullable, and @asType annotations.\n\n--unstable\n    Do not sort properties.\n\n--strict-tuples\n    Do not allow additional items on tuples.\n\n--no-top-ref\n    Do not create a top-level $ref definition.\n\n--no-type-check\n    Skip type checks for better performance.\n\n--no-ref-encode\n    Do not encode references. According to the standard, references must be valid URIs but some tools do not support encoded references.\n\n--validation-keywords\n    Provide additional validation keywords to include.\n\n-o, --out\n    Specify the output file path. Without this option, the generator logs the response in the console.\n\n--additional-properties <true|false>\n    Controls whether or not to allow additional properties for objects that have no index signature.\n\n    true: Additional properties are allowed\n    false (default): Additional properties are not allowed\n\n--minify\n    Minify generated schema (default: false)\n```\n\n## Current state\n\n-   `interface` types\n-   `enum` types\n-   `union`, `tuple`, `type[]` types\n-   `Date`, `RegExp`, `URL` types\n-   `string`, `boolean`, `number` types\n-   `\"value\"`, `123`, `true`, `false`, `null`, `undefined` literals\n-   type aliases\n-   generics\n-   `typeof`\n-   `keyof`\n-   conditional types\n\n## Run locally\n\n`yarn --silent run run --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\n## Debug\n\n`yarn --silent run debug --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\nAnd connect via the debugger protocol.\n\n[AST Explorer](https://astexplorer.net/) is amazing for developers of this tool!\n\n## Publish\n\nPublishing is handled by a 2-branch [pre-release process](https://intuit.github.io/auto/docs/generated/shipit#next-branch-default), configured in `publish-auto.yml`. All changes should be based off the default `next` branch, and are published automatically.\n\n-   PRs made into the default branch are auto-deployed to the `next` pre-release tag on NPM. The result can be installed with `npm install ts-json-schema-generator@next`\n    -   When merging into `next`, please use the `squash and merge` strategy.\n-   To release a new stable version, open a PR from `next` into `stable` using this [compare link](https://github.com/vega/ts-json-schema-generator/compare/stable...next).\n    -   When merging from `next` into `stable`, please use the `create a merge commit` strategy.\n",
      "readmeFilename": "README.md",
      "gitHead": "c05565b4ae517ec3982f99a15ee395c7cc87832d",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@1.2.1--canary.1594.c05565b.0",
      "_nodeVersion": "18.14.2",
      "_npmVersion": "9.5.0",
      "dist": {
        "integrity": "sha512-cArMigVDfWwUFjGp9JV31h4mIDVGOBuyS/zw/Ju/eldtfqJHlD9Z7o6BT+1TB9v+Sda+8KMlHTVqbR3DkXjVew==",
        "shasum": "ec1b5559c4293e9a7217d9703a89d119f630635e",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-1.2.1--canary.1594.c05565b.0.tgz",
        "fileCount": 716,
        "unpackedSize": 884742,
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEQCIAiIrBqo/w+v45sL+q5hXW2Q9RiUAGLeWQ4ajORtkldhAiBeeqHx1JaRFjLOOR/otQZU4AJV2/+qvGsemxDRbgofXA=="
          }
        ],
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJkAjrhACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2Vmq7LBAAiYeJorV6dvj3Bpe84hu9zVI1QkBr0DwpoP3zcst97jR5o0qs\r\nyTrco5UBozxSbhc1UeNnKJ/Xu7ul4f0KrITyiz+miZpABelVrGwE+K1jXSNF\r\nUwCij2EbLNuBhmwIEGBHzPMyYTKOgUSMnjpmsyoBPLr3M27kLNnZUGDdE1KG\r\ndQZjP9Pp8s/xopMV9nqFbfU2q7A5QpQ7UvE85BDqyT6zALb0IJg5NXs+FjKY\r\ngHTQej0UHNqs92YK4MRjWRat1FDR/8vlySsY0TuVfqnFwuI2+J+B7WiE25FG\r\n0dARXbJ7lgt2bgdG9WJAB6HJSIH1dK2mu/I2VBxsss+sn96lyJff/3cgDI/F\r\nloeYRQP5PKo+8Rtl+PSryZHHf3O1XnlRZutBYwqycD8gD51ng6FUUJC5NLFx\r\nGIrRZ/3VRwruOQ/ChOLVzYGNIhXYJ2tfufjbz9jO3kfX8NSw/USOuOAdhtSD\r\nJJxN1ywfyrPrLHJa8IyM9KRe3Pyqog4guHngMwM/CI1gN7Ijrx6I3ldxWk+R\r\ngYpq9P61cOWMdnkeP8d4L+OFTl7icP5gjeYK5M9ckMIlO/O4o0aMdgykbVlr\r\nQ9t/5nUANUIzL07+zEKMD7F1YIARVB4UGrqhjPAx2YD0/mabRHmQrRKggwh2\r\nXTURvsmQG0PFIiNRH7w0L7WyNH/r2ghTWlM=\r\n=ld3Z\r\n-----END PGP SIGNATURE-----\r\n"
      },
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "maintainers": [
        {
          "name": "jheer",
          "email": "jeffrey.heer@gmail.com"
        },
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "kanitw",
          "email": "kanitw@gmail.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_1.2.1--canary.1594.c05565b.0_1677867745184_0.1721018357603037"
      },
      "_hasShrinkwrap": false
    },
    "1.2.1--canary.1593.a1dc8a7.0": {
      "name": "ts-json-schema-generator",
      "version": "1.2.1--canary.1593.a1dc8a7.0",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "MooYeol Prescott Lee",
          "email": "mooyoul@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=10.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.11",
        "commander": "^10.0.0",
        "glob": "^8.0.3",
        "json5": "^2.2.1",
        "normalize-path": "^3.0.0",
        "safe-stable-stringify": "^2.4.1",
        "typescript": "~4.9.3"
      },
      "devDependencies": {
        "@auto-it/conventional-commits": "^10.37.6",
        "@auto-it/first-time-contributor": "^10.37.6",
        "@babel/core": "^7.20.5",
        "@babel/preset-env": "^7.20.2",
        "@babel/preset-typescript": "^7.18.6",
        "@types/glob": "^8.0.0",
        "@types/jest": "^29.2.3",
        "@types/node": "^18.11.10",
        "@types/normalize-path": "^3.0.0",
        "@typescript-eslint/eslint-plugin": "^5.45.0",
        "@typescript-eslint/parser": "^5.45.0",
        "ajv": "^8.11.2",
        "ajv-formats": "^2.1.1",
        "auto": "^10.37.6",
        "chai": "^4.3.7",
        "cross-env": "^7.0.3",
        "eslint": "^8.29.0",
        "eslint-config-prettier": "^8.5.0",
        "eslint-plugin-prettier": "^4.2.1",
        "jest": "^29.3.1",
        "jest-junit": "^15.0.0",
        "prettier": "^2.8.0",
        "ts-node": "^10.9.1",
        "vega": "^5.22.1",
        "vega-lite": "^5.6.0"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint \"{src,test,factory}/**/*.ts\"",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "cross-env FAST_TEST=1 jest test/ --verbose",
        "test:coverage": "yarn jest test/ --collectCoverage=true",
        "test:update": "cross-env UPDATE_SCHEMA=true yarn test:fast",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node-transpile-only ts-json-schema-generator.ts",
        "release": "yarn build && auto shipit"
      },
      "readme": "# ts-json-schema-generator\n\n![Test](https://github.com/vega/ts-json-schema-generator/workflows/Test/badge.svg)\n[![codecov](https://codecov.io/gh/vega/ts-json-schema-generator/branch/master/graph/badge.svg)](https://codecov.io/gh/vega/ts-json-schema-generator)\n[![npm version](https://img.shields.io/npm/v/ts-json-schema-generator.svg)](https://www.npmjs.com/package/ts-json-schema-generator)\n\nExtended version of [https://github.com/xiag-ag/typescript-to-json-schema](https://github.com/xiag-ag/typescript-to-json-schema).\n\nInspired by [`YousefED/typescript-json-schema`](https://github.com/YousefED/typescript-json-schema). Here's the differences list:\n\n-   this implementation avoids the use of `typeChecker.getTypeAtLocation()` (so probably it keeps correct type aliases)\n-   processing AST and formatting JSON schema have been split into two independent steps\n-   not exported types, interfaces, enums are not exposed in the `definitions` section in the JSON schema\n\n## Contributors\n\nThis project is made possible by a [community of contributors](https://github.com/vega/ts-json-schema-generator/graphs/contributors). We welcome contributions of any kind (issues, code, documentation, examples, tests,...). Please read our [code of conduct](https://vega.github.io/vega/about/code-of-conduct).\n\n## CLI Usage\n\nRun the schema generator with npx:\n\n```bash\nnpx ts-json-schema-generator --path 'my/project/**/*.ts' --type 'My.Type.Name'\n```\n\nOr install the package and then run it\n\n```bash\nnpm install --save ts-json-schema-generator\n./node_modules/.bin/ts-json-schema-generator --path 'my/project/**/*.ts' --type 'My.Type.Name'\n```\n\nNote that different platforms (e.g. Windows) may use different path separators so you may have to adjust the command above.\n\nAlso note that you need to quote paths with `*` as otherwise the shell will expand the paths and therefore only pass the first path to the generator.\n\n## Programmatic Usage\n\n```js\n// main.js\n\nconst tsj = require(\"ts-json-schema-generator\");\nconst fs = require(\"fs\");\n\n/** @type {import('ts-json-schema-generator/dist/src/Config').Config} */\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst output_path = \"path/to/output/file\";\n\nconst schema = tsj.createGenerator(config).createSchema(config.type);\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\nRun the schema generator via `node main.js`.\n\n### Custom formatting\n\nExtending the built-in formatting is possible by creating a custom formatter and adding it to the main formatter:\n\n1. First we create a formatter, in this case for formatting function types:\n\n```ts\n// my-function-formatter.ts\nimport { BaseType, Definition, FunctionType, SubTypeFormatter } from \"ts-json-schema-generator\";\nimport ts from \"typescript\";\n\nexport class MyFunctionTypeFormatter implements SubTypeFormatter {\n    // You can skip this line if you don't need childTypeFormatter\n    public constructor(private childTypeFormatter: TypeFormatter) {}\n\n    public supportsType(type: FunctionType): boolean {\n        return type instanceof FunctionType;\n    }\n\n    public getDefinition(type: FunctionType): Definition {\n        // Return a custom schema for the function property.\n        return {\n            type: \"object\",\n            properties: {\n                isFunction: {\n                    type: \"boolean\",\n                    const: true,\n                },\n            },\n        };\n    }\n\n    // If this type does NOT HAVE children, generally all you need is:\n    public getChildren(type: FunctionType): BaseType[] {\n        return [];\n    }\n\n    // However, if children ARE supported, you'll need something similar to\n    // this (see src/TypeFormatter/{Array,Definition,etc}.ts for some examples):\n    public getChildren(type: FunctionType): BaseType[] {\n        return this.childTypeFormatter.getChildren(type.getType());\n    }\n}\n```\n\n2. Then we add the formatter as a child to the core formatter using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyFunctionTypeFormatter } from \"./my-function-formatter.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\n// We configure the formatter an add our custom formatter to it.\nconst formatter = createFormatter(config, (fmt, circularReferenceTypeFormatter) => {\n    // If your formatter DOES NOT support children, e.g. getChildren() { return [] }:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter());\n    // If your formatter DOES support children, you'll need this reference too:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter(circularReferenceTypeFormatter));\n});\n\nconst program = createProgram(config);\nconst parser = createParser(program, config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n### Custom parsing\n\nSimilar to custom formatting, extending the built-in parsing works practically the same way:\n\n1. First we create a parser, in this case for parsing construct types:\n\n```ts\n// my-constructor-parser.ts\nimport { Context, StringType, ReferenceType, BaseType, SubNodeParser } from \"ts-json-schema-generator\";\n// use typescript exported by TJS to avoid version conflict\nimport ts from \"ts-json-schema-generator\";\n\nexport class MyConstructorParser implements SubNodeParser {\n    supportsNode(node: ts.Node): boolean {\n        return node.kind === ts.SyntaxKind.ConstructorType;\n    }\n    createType(node: ts.Node, context: Context, reference?: ReferenceType): BaseType | undefined {\n        return new StringType(); // Treat constructors as strings in this example\n    }\n}\n```\n\n2. Then we add the parser as a child to the core parser using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyConstructorParser } from \"./my-constructor-parser.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst program = createProgram(config);\n\n// We configure the parser an add our custom parser to it.\nconst parser = createParser(program, config, (prs) => {\n    prs.addNodeParser(new MyConstructorParser());\n});\n\nconst formatter = createFormatter(config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n## Options\n\n```\n-p, --path 'index.ts'\n    The path to the TypeScript source file. If this is not provided, the type will be searched in the project specified in the `.tsconfig`.\n\n-t, --type 'My.Type.Name'\n    The type the generated schema will represent. If omitted, the generated schema will contain all\n    types found in the files matching path. The same is true if '*' is specified.\n\n-i, --id 'generatedSchemaId'\n    The `$id` of the generated schema. If omitted, there will be no `$id`.\n\n-e, --expose <all|none|export>\n    all: Create shared $ref definitions for all types.\n    none: Do not create shared $ref definitions.\n    export (default): Create shared $ref definitions only for exported types (not tagged as `@internal`).\n\n-f, --tsconfig 'my/project/tsconfig.json'\n    Use a custom tsconfig file for processing typescript (see https://www.typescriptlang.org/docs/handbook/tsconfig-json.html) instead of the default:\n    {\n        \"compilerOptions\": {\n            \"noEmit\": true,\n            \"emitDecoratorMetadata\": true,\n            \"experimentalDecorators\": true,\n            \"target\": \"ES5\",\n            \"module\": \"CommonJS\",\n            \"strictNullChecks\": false,\n        }\n    }\n\n-j, --jsDoc <extended|none|basic>\n    none: Do not use JsDoc annotations.\n    basic: Read JsDoc annotations to provide schema properties.\n    extended (default): Also read @nullable, and @asType annotations.\n\n--unstable\n    Do not sort properties.\n\n--strict-tuples\n    Do not allow additional items on tuples.\n\n--no-top-ref\n    Do not create a top-level $ref definition.\n\n--no-type-check\n    Skip type checks for better performance.\n\n--no-ref-encode\n    Do not encode references. According to the standard, references must be valid URIs but some tools do not support encoded references.\n\n--validation-keywords\n    Provide additional validation keywords to include.\n\n-o, --out\n    Specify the output file path. Without this option, the generator logs the response in the console.\n\n--additional-properties <true|false>\n    Controls whether or not to allow additional properties for objects that have no index signature.\n\n    true: Additional properties are allowed\n    false (default): Additional properties are not allowed\n\n--minify\n    Minify generated schema (default: false)\n```\n\n## Current state\n\n-   `interface` types\n-   `enum` types\n-   `union`, `tuple`, `type[]` types\n-   `Date`, `RegExp`, `URL` types\n-   `string`, `boolean`, `number` types\n-   `\"value\"`, `123`, `true`, `false`, `null`, `undefined` literals\n-   type aliases\n-   generics\n-   `typeof`\n-   `keyof`\n-   conditional types\n\n## Run locally\n\n`yarn --silent run run --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\n## Debug\n\n`yarn --silent run debug --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\nAnd connect via the debugger protocol.\n\n[AST Explorer](https://astexplorer.net/) is amazing for developers of this tool!\n\n## Publish\n\nPublishing is handled by a 2-branch [pre-release process](https://intuit.github.io/auto/docs/generated/shipit#next-branch-default), configured in `publish-auto.yml`. All changes should be based off the default `next` branch, and are published automatically.\n\n-   PRs made into the default branch are auto-deployed to the `next` pre-release tag on NPM. The result can be installed with `npm install ts-json-schema-generator@next`\n    -   When merging into `next`, please use the `squash and merge` strategy.\n-   To release a new stable version, open a PR from `next` into `stable` using this [compare link](https://github.com/vega/ts-json-schema-generator/compare/stable...next).\n    -   When merging from `next` into `stable`, please use the `create a merge commit` strategy.\n",
      "readmeFilename": "README.md",
      "gitHead": "a1dc8a7e2fb8c8692a7daa8a53d0db7149fcb2fb",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@1.2.1--canary.1593.a1dc8a7.0",
      "_nodeVersion": "18.14.2",
      "_npmVersion": "9.5.0",
      "dist": {
        "integrity": "sha512-B9yG6wtNRLvaOqhK7/KAmlhAWM4XQlrb+fZedf75QYZChKTlEThCvRSf+2d4CHV4QtyJ8rPOn6lqdMvbpr+4Vg==",
        "shasum": "2f9d5d5934d82b0b3bb5b78c81360cd129db6e0b",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-1.2.1--canary.1593.a1dc8a7.0.tgz",
        "fileCount": 716,
        "unpackedSize": 885497,
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIGgxjVffIQpKO9P7xLysJCSbKRMN2RWsxPETW41A/Ni6AiEA0+Ps8WnzVMXPFmL3EiEhShk2a3soPW0uVzvggOxwJgE="
          }
        ],
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJkAjrvACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2VmpIGg/7Bc4uuTBhmzGmLaU+CUF91HshekClBujh9nKHrrYaXttwZspP\r\nv3/uYE/dTqVxGVylbH/1XDv4RRvkGYWT0FGWxU/z9FLAQSEpYoo+Afn1uUsA\r\n+nxK2UidI4KSZFPszS5DGidARrCeHlv+Fw0oIGuXFajZzAgiUWJ2G7CTxEMS\r\nLMr7OhCeU9W++KVOFZxkzXAYl6G0J20rui1s7893omWk1ah4Rxz+513VcX5H\r\nMEiAI6sxZo+7By1OGOp37F2OIZcp4pGK7dAY5DZYLBYysczMZU4utgOnAXKF\r\n3mnX1EOKpdQl0lmBGcMfJ9UDlJ82w7nRea4LwQjbNkeLYRXJgotXb7AoFSLt\r\nGn3HIQlOmSkkdFPruvE0fA0BpXy16GjAbTz7XbOVLtXHW6MCrECMpg/sfGaK\r\n+1zd5DVh6BYSChIIvrzhBqTK4rxCrBkQf0rR7zSKzrSzDYPJ/J6ANTPyv1fQ\r\nwWi5GdRVrEwphGh3RvYlm9rfEYiczLb6pIiCaBYon/sRueVhl/CghQ3g7kTg\r\nTMoYLeG2o5AA9F/cR4NHDOXLtTPKalq4KOCo8mf6hUw6UFqMHovLbyFSHnkF\r\n0MjXEUoalk716SeyJe0BYvaJTCTffD3IyaGcM8FVdPQwk4vPcboNrMdRxXo+\r\noCabofN7EVWQs30pXuwv04iko/yOECxBo5U=\r\n=9VRF\r\n-----END PGP SIGNATURE-----\r\n"
      },
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "maintainers": [
        {
          "name": "jheer",
          "email": "jeffrey.heer@gmail.com"
        },
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "kanitw",
          "email": "kanitw@gmail.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_1.2.1--canary.1593.a1dc8a7.0_1677867759168_0.3516205925530953"
      },
      "_hasShrinkwrap": false
    },
    "1.3.0-next.2": {
      "name": "ts-json-schema-generator",
      "version": "1.3.0-next.2",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "MooYeol Prescott Lee",
          "email": "mooyoul@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=10.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.11",
        "commander": "^10.0.0",
        "glob": "^8.0.3",
        "json5": "^2.2.1",
        "normalize-path": "^3.0.0",
        "safe-stable-stringify": "^2.4.1",
        "typescript": "~4.9.3"
      },
      "devDependencies": {
        "@auto-it/conventional-commits": "^10.37.6",
        "@auto-it/first-time-contributor": "^10.37.6",
        "@babel/core": "^7.20.5",
        "@babel/preset-env": "^7.20.2",
        "@babel/preset-typescript": "^7.18.6",
        "@types/glob": "^8.0.0",
        "@types/jest": "^29.2.3",
        "@types/node": "^18.11.10",
        "@types/normalize-path": "^3.0.0",
        "@typescript-eslint/eslint-plugin": "^5.45.0",
        "@typescript-eslint/parser": "^5.45.0",
        "ajv": "^8.11.2",
        "ajv-formats": "^2.1.1",
        "auto": "^10.37.6",
        "chai": "^4.3.7",
        "cross-env": "^7.0.3",
        "eslint": "^8.29.0",
        "eslint-config-prettier": "^8.5.0",
        "eslint-plugin-prettier": "^4.2.1",
        "jest": "^29.3.1",
        "jest-junit": "^15.0.0",
        "prettier": "^2.8.0",
        "ts-node": "^10.9.1",
        "vega": "^5.22.1",
        "vega-lite": "^5.6.0"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint \"{src,test,factory}/**/*.ts\"",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "cross-env FAST_TEST=1 jest test/ --verbose",
        "test:coverage": "yarn jest test/ --collectCoverage=true",
        "test:update": "cross-env UPDATE_SCHEMA=true yarn test:fast",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node-transpile-only ts-json-schema-generator.ts",
        "release": "yarn build && auto shipit"
      },
      "readme": "# ts-json-schema-generator\n\n![Test](https://github.com/vega/ts-json-schema-generator/workflows/Test/badge.svg)\n[![codecov](https://codecov.io/gh/vega/ts-json-schema-generator/branch/master/graph/badge.svg)](https://codecov.io/gh/vega/ts-json-schema-generator)\n[![npm version](https://img.shields.io/npm/v/ts-json-schema-generator.svg)](https://www.npmjs.com/package/ts-json-schema-generator)\n\nExtended version of [https://github.com/xiag-ag/typescript-to-json-schema](https://github.com/xiag-ag/typescript-to-json-schema).\n\nInspired by [`YousefED/typescript-json-schema`](https://github.com/YousefED/typescript-json-schema). Here's the differences list:\n\n-   this implementation avoids the use of `typeChecker.getTypeAtLocation()` (so probably it keeps correct type aliases)\n-   processing AST and formatting JSON schema have been split into two independent steps\n-   not exported types, interfaces, enums are not exposed in the `definitions` section in the JSON schema\n\n## Contributors\n\nThis project is made possible by a [community of contributors](https://github.com/vega/ts-json-schema-generator/graphs/contributors). We welcome contributions of any kind (issues, code, documentation, examples, tests,...). Please read our [code of conduct](https://vega.github.io/vega/about/code-of-conduct).\n\n## CLI Usage\n\nRun the schema generator with npx:\n\n```bash\nnpx ts-json-schema-generator --path 'my/project/**/*.ts' --type 'My.Type.Name'\n```\n\nOr install the package and then run it\n\n```bash\nnpm install --save ts-json-schema-generator\n./node_modules/.bin/ts-json-schema-generator --path 'my/project/**/*.ts' --type 'My.Type.Name'\n```\n\nNote that different platforms (e.g. Windows) may use different path separators so you may have to adjust the command above.\n\nAlso note that you need to quote paths with `*` as otherwise the shell will expand the paths and therefore only pass the first path to the generator.\n\n## Programmatic Usage\n\n```js\n// main.js\n\nconst tsj = require(\"ts-json-schema-generator\");\nconst fs = require(\"fs\");\n\n/** @type {import('ts-json-schema-generator/dist/src/Config').Config} */\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst output_path = \"path/to/output/file\";\n\nconst schema = tsj.createGenerator(config).createSchema(config.type);\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\nRun the schema generator via `node main.js`.\n\n### Custom formatting\n\nExtending the built-in formatting is possible by creating a custom formatter and adding it to the main formatter:\n\n1. First we create a formatter, in this case for formatting function types:\n\n```ts\n// my-function-formatter.ts\nimport { BaseType, Definition, FunctionType, SubTypeFormatter } from \"ts-json-schema-generator\";\nimport ts from \"typescript\";\n\nexport class MyFunctionTypeFormatter implements SubTypeFormatter {\n    // You can skip this line if you don't need childTypeFormatter\n    public constructor(private childTypeFormatter: TypeFormatter) {}\n\n    public supportsType(type: FunctionType): boolean {\n        return type instanceof FunctionType;\n    }\n\n    public getDefinition(type: FunctionType): Definition {\n        // Return a custom schema for the function property.\n        return {\n            type: \"object\",\n            properties: {\n                isFunction: {\n                    type: \"boolean\",\n                    const: true,\n                },\n            },\n        };\n    }\n\n    // If this type does NOT HAVE children, generally all you need is:\n    public getChildren(type: FunctionType): BaseType[] {\n        return [];\n    }\n\n    // However, if children ARE supported, you'll need something similar to\n    // this (see src/TypeFormatter/{Array,Definition,etc}.ts for some examples):\n    public getChildren(type: FunctionType): BaseType[] {\n        return this.childTypeFormatter.getChildren(type.getType());\n    }\n}\n```\n\n2. Then we add the formatter as a child to the core formatter using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyFunctionTypeFormatter } from \"./my-function-formatter.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\n// We configure the formatter an add our custom formatter to it.\nconst formatter = createFormatter(config, (fmt, circularReferenceTypeFormatter) => {\n    // If your formatter DOES NOT support children, e.g. getChildren() { return [] }:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter());\n    // If your formatter DOES support children, you'll need this reference too:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter(circularReferenceTypeFormatter));\n});\n\nconst program = createProgram(config);\nconst parser = createParser(program, config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n### Custom parsing\n\nSimilar to custom formatting, extending the built-in parsing works practically the same way:\n\n1. First we create a parser, in this case for parsing construct types:\n\n```ts\n// my-constructor-parser.ts\nimport { Context, StringType, ReferenceType, BaseType, SubNodeParser } from \"ts-json-schema-generator\";\n// use typescript exported by TJS to avoid version conflict\nimport ts from \"ts-json-schema-generator\";\n\nexport class MyConstructorParser implements SubNodeParser {\n    supportsNode(node: ts.Node): boolean {\n        return node.kind === ts.SyntaxKind.ConstructorType;\n    }\n    createType(node: ts.Node, context: Context, reference?: ReferenceType): BaseType | undefined {\n        return new StringType(); // Treat constructors as strings in this example\n    }\n}\n```\n\n2. Then we add the parser as a child to the core parser using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyConstructorParser } from \"./my-constructor-parser.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst program = createProgram(config);\n\n// We configure the parser an add our custom parser to it.\nconst parser = createParser(program, config, (prs) => {\n    prs.addNodeParser(new MyConstructorParser());\n});\n\nconst formatter = createFormatter(config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n## Options\n\n```\n-p, --path 'index.ts'\n    The path to the TypeScript source file. If this is not provided, the type will be searched in the project specified in the `.tsconfig`.\n\n-t, --type 'My.Type.Name'\n    The type the generated schema will represent. If omitted, the generated schema will contain all\n    types found in the files matching path. The same is true if '*' is specified.\n\n-i, --id 'generatedSchemaId'\n    The `$id` of the generated schema. If omitted, there will be no `$id`.\n\n-e, --expose <all|none|export>\n    all: Create shared $ref definitions for all types.\n    none: Do not create shared $ref definitions.\n    export (default): Create shared $ref definitions only for exported types (not tagged as `@internal`).\n\n-f, --tsconfig 'my/project/tsconfig.json'\n    Use a custom tsconfig file for processing typescript (see https://www.typescriptlang.org/docs/handbook/tsconfig-json.html) instead of the default:\n    {\n        \"compilerOptions\": {\n            \"noEmit\": true,\n            \"emitDecoratorMetadata\": true,\n            \"experimentalDecorators\": true,\n            \"target\": \"ES5\",\n            \"module\": \"CommonJS\",\n            \"strictNullChecks\": false,\n        }\n    }\n\n-j, --jsDoc <extended|none|basic>\n    none: Do not use JsDoc annotations.\n    basic: Read JsDoc annotations to provide schema properties.\n    extended (default): Also read @nullable, and @asType annotations.\n\n--unstable\n    Do not sort properties.\n\n--strict-tuples\n    Do not allow additional items on tuples.\n\n--no-top-ref\n    Do not create a top-level $ref definition.\n\n--no-type-check\n    Skip type checks for better performance.\n\n--no-ref-encode\n    Do not encode references. According to the standard, references must be valid URIs but some tools do not support encoded references.\n\n--validation-keywords\n    Provide additional validation keywords to include.\n\n-o, --out\n    Specify the output file path. Without this option, the generator logs the response in the console.\n\n--additional-properties <true|false>\n    Controls whether or not to allow additional properties for objects that have no index signature.\n\n    true: Additional properties are allowed\n    false (default): Additional properties are not allowed\n\n--minify\n    Minify generated schema (default: false)\n```\n\n## Current state\n\n-   `interface` types\n-   `enum` types\n-   `union`, `tuple`, `type[]` types\n-   `Date`, `RegExp`, `URL` types\n-   `string`, `boolean`, `number` types\n-   `\"value\"`, `123`, `true`, `false`, `null`, `undefined` literals\n-   type aliases\n-   generics\n-   `typeof`\n-   `keyof`\n-   conditional types\n\n## Run locally\n\n`yarn --silent run run --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\n## Debug\n\n`yarn --silent run debug --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\nAnd connect via the debugger protocol.\n\n[AST Explorer](https://astexplorer.net/) is amazing for developers of this tool!\n\n## Publish\n\nPublishing is handled by a 2-branch [pre-release process](https://intuit.github.io/auto/docs/generated/shipit#next-branch-default), configured in `publish-auto.yml`. All changes should be based off the default `next` branch, and are published automatically.\n\n-   PRs made into the default branch are auto-deployed to the `next` pre-release tag on NPM. The result can be installed with `npm install ts-json-schema-generator@next`\n    -   When merging into `next`, please use the `squash and merge` strategy.\n-   To release a new stable version, open a PR from `next` into `stable` using this [compare link](https://github.com/vega/ts-json-schema-generator/compare/stable...next).\n    -   When merging from `next` into `stable`, please use the `create a merge commit` strategy.\n",
      "readmeFilename": "README.md",
      "gitHead": "fc08d8908eebe3087d9ec54f405c482065ef4acd",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@1.3.0-next.2",
      "_nodeVersion": "18.14.2",
      "_npmVersion": "9.5.0",
      "dist": {
        "integrity": "sha512-hvBtA00buRcptv8zkZHB06AltdkHAJ/IS6HuyQwuB7QUBzrrCdUr3NYE+CGdb8sWi7ISHYDWJJsKFdKq7Jwedw==",
        "shasum": "0eabdbaa7ea3ef2782b334a06ec7ed8f402d844f",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-1.3.0-next.2.tgz",
        "fileCount": 716,
        "unpackedSize": 885465,
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEYCIQD0P5wVN0jsFEkkMZT35n1IfZIZsrtpA8QDjURYv5WpcAIhAN7OiIKWMHFjj3IYwbo4HQiELTlm9hRSVH49//KTcOOs"
          }
        ],
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJkAkAjACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2Vmpjjw//e9Ok83vFNMIL/FE6XelqRnaGZxDDFHKtw2c1E8RyHVaEL+IX\r\nVlQG1S8KPN6epXFPxmvaOsP5fWS6ThMnLfT7TJf3EN4jK71AQ2M0Lk7pOtbe\r\n+7bm/k1nE8jIwPDhu/+LRHRMUOxBkQwV5c5hfrQisWV8aEMaqHxo7aIrtPPg\r\n+Sl4LPQI625OYyt/NtPVFRLAF7nT48alu5svvu4WZ4bgflVWNFcNhgN/1WjF\r\n/pIYe+7ua+X6wU1SHikKfM3M7RwbhsiYXmgq6kFLae1ACxaPV2bYpvE3niRa\r\nEontODH3XE/pobcZ410/sR0Oy8rZdTlb2QqdOL8TisNMpvsiJ8oWxZi0jT1a\r\nG/peIKkXWu1BtRmJ9g6unHbrneXV2ie3M4Tbp1hoJinN44KMATwVY52UQHph\r\nxOrLwnugZic3UC0O26ffg9rcBec95ngI9aO+ggwL8k+HDpslCQXaYZ6nEdeu\r\nr+43EVu961M3s9bkEmvO+Fm+UODztQbM677tykdqVmwp2fPo6PrkMqVHAgAa\r\nhwpCdlAaqtxvGbB0/VyX8eH1oF1eX4pIC3YEEvo2stII14mlHbDoNwhX94wi\r\nRRp+gEkENl6yjTwFshg/G9/VRbequiJOJQPi0qipdsav86QsVCXFuur+s5IL\r\nUuhIjdqhrrlpe4uO0xjqGnZPgZ0BviGI2bg=\r\n=5hjK\r\n-----END PGP SIGNATURE-----\r\n"
      },
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "maintainers": [
        {
          "name": "jheer",
          "email": "jeffrey.heer@gmail.com"
        },
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "kanitw",
          "email": "kanitw@gmail.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_1.3.0-next.2_1677869091246_0.9355304353857852"
      },
      "_hasShrinkwrap": false
    },
    "1.3.0--canary.1612.745acbd.0": {
      "name": "ts-json-schema-generator",
      "version": "1.3.0--canary.1612.745acbd.0",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "MooYeol Prescott Lee",
          "email": "mooyoul@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=10.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.11",
        "commander": "^10.0.0",
        "glob": "^8.0.3",
        "json5": "^2.2.3",
        "normalize-path": "^3.0.0",
        "safe-stable-stringify": "^2.4.2",
        "typescript": "~5.0.2"
      },
      "devDependencies": {
        "@auto-it/conventional-commits": "^10.43.0",
        "@auto-it/first-time-contributor": "^10.43.0",
        "@babel/core": "^7.21.3",
        "@babel/preset-env": "^7.20.2",
        "@babel/preset-typescript": "^7.21.0",
        "@types/glob": "^8.1.0",
        "@types/jest": "^29.5.0",
        "@types/node": "^18.15.3",
        "@types/normalize-path": "^3.0.0",
        "@typescript-eslint/eslint-plugin": "^5.55.0",
        "@typescript-eslint/parser": "^5.55.0",
        "ajv": "^8.12.0",
        "ajv-formats": "^2.1.1",
        "auto": "^10.43.0",
        "chai": "^4.3.7",
        "cross-env": "^7.0.3",
        "eslint": "^8.36.0",
        "eslint-config-prettier": "^8.7.0",
        "eslint-plugin-prettier": "^4.2.1",
        "jest": "^29.5.0",
        "jest-junit": "^15.0.0",
        "prettier": "^2.8.4",
        "ts-node": "^10.9.1",
        "vega": "^5.22.1",
        "vega-lite": "^5.6.0"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint \"{src,test,factory}/**/*.ts\"",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "cross-env FAST_TEST=1 jest test/ --verbose",
        "test:coverage": "yarn jest test/ --collectCoverage=true",
        "test:update": "cross-env UPDATE_SCHEMA=true yarn test:fast",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node-transpile-only ts-json-schema-generator.ts",
        "release": "yarn build && auto shipit"
      },
      "readme": "# ts-json-schema-generator\n\n![Test](https://github.com/vega/ts-json-schema-generator/workflows/Test/badge.svg)\n[![codecov](https://codecov.io/gh/vega/ts-json-schema-generator/branch/master/graph/badge.svg)](https://codecov.io/gh/vega/ts-json-schema-generator)\n[![npm version](https://img.shields.io/npm/v/ts-json-schema-generator.svg)](https://www.npmjs.com/package/ts-json-schema-generator)\n\nExtended version of [https://github.com/xiag-ag/typescript-to-json-schema](https://github.com/xiag-ag/typescript-to-json-schema).\n\nInspired by [`YousefED/typescript-json-schema`](https://github.com/YousefED/typescript-json-schema). Here's the differences list:\n\n-   this implementation avoids the use of `typeChecker.getTypeAtLocation()` (so probably it keeps correct type aliases)\n-   processing AST and formatting JSON schema have been split into two independent steps\n-   not exported types, interfaces, enums are not exposed in the `definitions` section in the JSON schema\n\n## Contributors\n\nThis project is made possible by a [community of contributors](https://github.com/vega/ts-json-schema-generator/graphs/contributors). We welcome contributions of any kind (issues, code, documentation, examples, tests,...). Please read our [code of conduct](https://vega.github.io/vega/about/code-of-conduct).\n\n## CLI Usage\n\nRun the schema generator with npx:\n\n```bash\nnpx ts-json-schema-generator --path 'my/project/**/*.ts' --type 'My.Type.Name'\n```\n\nOr install the package and then run it\n\n```bash\nnpm install --save ts-json-schema-generator\n./node_modules/.bin/ts-json-schema-generator --path 'my/project/**/*.ts' --type 'My.Type.Name'\n```\n\nNote that different platforms (e.g. Windows) may use different path separators so you may have to adjust the command above.\n\nAlso note that you need to quote paths with `*` as otherwise the shell will expand the paths and therefore only pass the first path to the generator.\n\n## Programmatic Usage\n\n```js\n// main.js\n\nconst tsj = require(\"ts-json-schema-generator\");\nconst fs = require(\"fs\");\n\n/** @type {import('ts-json-schema-generator/dist/src/Config').Config} */\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst output_path = \"path/to/output/file\";\n\nconst schema = tsj.createGenerator(config).createSchema(config.type);\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\nRun the schema generator via `node main.js`.\n\n### Custom formatting\n\nExtending the built-in formatting is possible by creating a custom formatter and adding it to the main formatter:\n\n1. First we create a formatter, in this case for formatting function types:\n\n```ts\n// my-function-formatter.ts\nimport { BaseType, Definition, FunctionType, SubTypeFormatter } from \"ts-json-schema-generator\";\nimport ts from \"typescript\";\n\nexport class MyFunctionTypeFormatter implements SubTypeFormatter {\n    // You can skip this line if you don't need childTypeFormatter\n    public constructor(private childTypeFormatter: TypeFormatter) {}\n\n    public supportsType(type: FunctionType): boolean {\n        return type instanceof FunctionType;\n    }\n\n    public getDefinition(type: FunctionType): Definition {\n        // Return a custom schema for the function property.\n        return {\n            type: \"object\",\n            properties: {\n                isFunction: {\n                    type: \"boolean\",\n                    const: true,\n                },\n            },\n        };\n    }\n\n    // If this type does NOT HAVE children, generally all you need is:\n    public getChildren(type: FunctionType): BaseType[] {\n        return [];\n    }\n\n    // However, if children ARE supported, you'll need something similar to\n    // this (see src/TypeFormatter/{Array,Definition,etc}.ts for some examples):\n    public getChildren(type: FunctionType): BaseType[] {\n        return this.childTypeFormatter.getChildren(type.getType());\n    }\n}\n```\n\n2. Then we add the formatter as a child to the core formatter using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyFunctionTypeFormatter } from \"./my-function-formatter.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\n// We configure the formatter an add our custom formatter to it.\nconst formatter = createFormatter(config, (fmt, circularReferenceTypeFormatter) => {\n    // If your formatter DOES NOT support children, e.g. getChildren() { return [] }:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter());\n    // If your formatter DOES support children, you'll need this reference too:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter(circularReferenceTypeFormatter));\n});\n\nconst program = createProgram(config);\nconst parser = createParser(program, config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n### Custom parsing\n\nSimilar to custom formatting, extending the built-in parsing works practically the same way:\n\n1. First we create a parser, in this case for parsing construct types:\n\n```ts\n// my-constructor-parser.ts\nimport { Context, StringType, ReferenceType, BaseType, SubNodeParser } from \"ts-json-schema-generator\";\n// use typescript exported by TJS to avoid version conflict\nimport ts from \"ts-json-schema-generator\";\n\nexport class MyConstructorParser implements SubNodeParser {\n    supportsNode(node: ts.Node): boolean {\n        return node.kind === ts.SyntaxKind.ConstructorType;\n    }\n    createType(node: ts.Node, context: Context, reference?: ReferenceType): BaseType | undefined {\n        return new StringType(); // Treat constructors as strings in this example\n    }\n}\n```\n\n2. Then we add the parser as a child to the core parser using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyConstructorParser } from \"./my-constructor-parser.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst program = createProgram(config);\n\n// We configure the parser an add our custom parser to it.\nconst parser = createParser(program, config, (prs) => {\n    prs.addNodeParser(new MyConstructorParser());\n});\n\nconst formatter = createFormatter(config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n## Options\n\n```\n-p, --path 'index.ts'\n    The path to the TypeScript source file. If this is not provided, the type will be searched in the project specified in the `.tsconfig`.\n\n-t, --type 'My.Type.Name'\n    The type the generated schema will represent. If omitted, the generated schema will contain all\n    types found in the files matching path. The same is true if '*' is specified.\n\n-i, --id 'generatedSchemaId'\n    The `$id` of the generated schema. If omitted, there will be no `$id`.\n\n-e, --expose <all|none|export>\n    all: Create shared $ref definitions for all types.\n    none: Do not create shared $ref definitions.\n    export (default): Create shared $ref definitions only for exported types (not tagged as `@internal`).\n\n-f, --tsconfig 'my/project/tsconfig.json'\n    Use a custom tsconfig file for processing typescript (see https://www.typescriptlang.org/docs/handbook/tsconfig-json.html) instead of the default:\n    {\n        \"compilerOptions\": {\n            \"noEmit\": true,\n            \"emitDecoratorMetadata\": true,\n            \"experimentalDecorators\": true,\n            \"target\": \"ES5\",\n            \"module\": \"CommonJS\",\n            \"strictNullChecks\": false,\n        }\n    }\n\n-j, --jsDoc <extended|none|basic>\n    none: Do not use JsDoc annotations.\n    basic: Read JsDoc annotations to provide schema properties.\n    extended (default): Also read @nullable, and @asType annotations.\n\n--unstable\n    Do not sort properties.\n\n--strict-tuples\n    Do not allow additional items on tuples.\n\n--no-top-ref\n    Do not create a top-level $ref definition.\n\n--no-type-check\n    Skip type checks for better performance.\n\n--no-ref-encode\n    Do not encode references. According to the standard, references must be valid URIs but some tools do not support encoded references.\n\n--validation-keywords\n    Provide additional validation keywords to include.\n\n-o, --out\n    Specify the output file path. Without this option, the generator logs the response in the console.\n\n--additional-properties <true|false>\n    Controls whether or not to allow additional properties for objects that have no index signature.\n\n    true: Additional properties are allowed\n    false (default): Additional properties are not allowed\n\n--minify\n    Minify generated schema (default: false)\n```\n\n## Current state\n\n-   `interface` types\n-   `enum` types\n-   `union`, `tuple`, `type[]` types\n-   `Date`, `RegExp`, `URL` types\n-   `string`, `boolean`, `number` types\n-   `\"value\"`, `123`, `true`, `false`, `null`, `undefined` literals\n-   type aliases\n-   generics\n-   `typeof`\n-   `keyof`\n-   conditional types\n\n## Run locally\n\n`yarn --silent run run --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\n## Debug\n\n`yarn --silent run debug --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\nAnd connect via the debugger protocol.\n\n[AST Explorer](https://astexplorer.net/) is amazing for developers of this tool!\n\n## Publish\n\nPublishing is handled by a 2-branch [pre-release process](https://intuit.github.io/auto/docs/generated/shipit#next-branch-default), configured in `publish-auto.yml`. All changes should be based off the default `next` branch, and are published automatically.\n\n-   PRs made into the default branch are auto-deployed to the `next` pre-release tag on NPM. The result can be installed with `npm install ts-json-schema-generator@next`\n    -   When merging into `next`, please use the `squash and merge` strategy.\n-   To release a new stable version, open a PR from `next` into `stable` using this [compare link](https://github.com/vega/ts-json-schema-generator/compare/stable...next).\n    -   When merging from `next` into `stable`, please use the `create a merge commit` strategy.\n",
      "readmeFilename": "README.md",
      "gitHead": "745acbdad4c610ec1edb683284b9922bad65e4bc",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@1.3.0--canary.1612.745acbd.0",
      "_nodeVersion": "18.15.0",
      "_npmVersion": "9.5.0",
      "dist": {
        "integrity": "sha512-F6ZiMFOB+xhDFL/I1wYnVM2ioCfQDp4tUM/lhPD6Zcb+BA5bySqllK/DqctGJtUk+Gs71WenB5YCfdKVew9Xyg==",
        "shasum": "9027b7a72d70bdb6c25d574968d72e8a97b434aa",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-1.3.0--canary.1612.745acbd.0.tgz",
        "fileCount": 716,
        "unpackedSize": 886371,
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEYCIQCHXx3dFjzn2G4m7NchvH2+xSBAbGJPyfjRceOdF/4nGgIhAOlQNshp3NwPumvQ8rSkHzPuOEKLXDFyNIBY1gEER2KN"
          }
        ],
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJkE7V2ACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2VmrZfQ//Wg2wo4l5KRTAXnh7OfoEK936X46y8MyBKT1bXqp33H5rGYnK\r\nLtCi+sBCu95paIX7oSpCyX6cw7L3rxFJbS+5ne+BQEt2GoueHM0kRSV2daaT\r\ny0xlr6NkiiNR9c9nw1yQM0Jnw5S284+qztJ6ZWR39iHt90ih4GQq8eroGcZ3\r\nt5Y9DBipSom4JRg0LuptOQL2R0S7LWgOCrCXUACABshhT8CjJ62/A+7CA7vf\r\nMCTzGwrBcS9XwWVOfP7I4Oqrt9NGcTRcVPLsOY4TsXXht8edspNarDBG/5AM\r\nK7ikM3Qpc5maA07EJyXgEWX3CgjyXulDJV4+oPoKAU8ljjFcbXaoDcnY2n9u\r\nTmFAl3kCuP3tcuk29LPR/lO6HuQNeVHnpiV8CBpqePDaIYZywOMmYOwG3VXA\r\nirVoM+9MzDdYKIEwl0lZZfsaMumiwxg/YTr4IsRFB876JeDSWlo0rcbXRLKs\r\ntjbP/0rgYwc+9j5AzSCol22gnIoOO3mwNTuu5P38bVEwUN3SHBiy5/wA7H77\r\nYMKz0ryQhUrvR58pQ3hJw/lY0wVxCuJ3UJZk7Ahdo0Pcu/sSVf4S5RzgkdEt\r\nPOUS4jH2j0nugMRu2zLYLzugQbtqupgdyxI7w2gXoU1iri2K/ciHSd+5SvWW\r\n97PcEcijYaV+o3Zsdd2XerSdy4TIBTU2j2Y=\r\n=hvRb\r\n-----END PGP SIGNATURE-----\r\n"
      },
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "maintainers": [
        {
          "name": "jheer",
          "email": "jeffrey.heer@gmail.com"
        },
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "kanitw",
          "email": "kanitw@gmail.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_1.3.0--canary.1612.745acbd.0_1679013237872_0.3340696063254609"
      },
      "_hasShrinkwrap": false
    },
    "1.3.0-next.3": {
      "name": "ts-json-schema-generator",
      "version": "1.3.0-next.3",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "MooYeol Prescott Lee",
          "email": "mooyoul@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=10.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.11",
        "commander": "^10.0.0",
        "glob": "^8.0.3",
        "json5": "^2.2.3",
        "normalize-path": "^3.0.0",
        "safe-stable-stringify": "^2.4.2",
        "typescript": "~5.0.2"
      },
      "devDependencies": {
        "@auto-it/conventional-commits": "^10.43.0",
        "@auto-it/first-time-contributor": "^10.43.0",
        "@babel/core": "^7.21.3",
        "@babel/preset-env": "^7.20.2",
        "@babel/preset-typescript": "^7.21.0",
        "@types/glob": "^8.1.0",
        "@types/jest": "^29.5.0",
        "@types/node": "^18.15.3",
        "@types/normalize-path": "^3.0.0",
        "@typescript-eslint/eslint-plugin": "^5.55.0",
        "@typescript-eslint/parser": "^5.55.0",
        "ajv": "^8.12.0",
        "ajv-formats": "^2.1.1",
        "auto": "^10.43.0",
        "chai": "^4.3.7",
        "cross-env": "^7.0.3",
        "eslint": "^8.36.0",
        "eslint-config-prettier": "^8.7.0",
        "eslint-plugin-prettier": "^4.2.1",
        "jest": "^29.5.0",
        "jest-junit": "^15.0.0",
        "prettier": "^2.8.4",
        "ts-node": "^10.9.1",
        "vega": "^5.22.1",
        "vega-lite": "^5.6.0"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint \"{src,test,factory}/**/*.ts\"",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "cross-env FAST_TEST=1 jest test/ --verbose",
        "test:coverage": "yarn jest test/ --collectCoverage=true",
        "test:update": "cross-env UPDATE_SCHEMA=true yarn test:fast",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node-transpile-only ts-json-schema-generator.ts",
        "release": "yarn build && auto shipit"
      },
      "readme": "# ts-json-schema-generator\n\n![Test](https://github.com/vega/ts-json-schema-generator/workflows/Test/badge.svg)\n[![codecov](https://codecov.io/gh/vega/ts-json-schema-generator/branch/master/graph/badge.svg)](https://codecov.io/gh/vega/ts-json-schema-generator)\n[![npm version](https://img.shields.io/npm/v/ts-json-schema-generator.svg)](https://www.npmjs.com/package/ts-json-schema-generator)\n\nExtended version of [https://github.com/xiag-ag/typescript-to-json-schema](https://github.com/xiag-ag/typescript-to-json-schema).\n\nInspired by [`YousefED/typescript-json-schema`](https://github.com/YousefED/typescript-json-schema). Here's the differences list:\n\n-   this implementation avoids the use of `typeChecker.getTypeAtLocation()` (so probably it keeps correct type aliases)\n-   processing AST and formatting JSON schema have been split into two independent steps\n-   not exported types, interfaces, enums are not exposed in the `definitions` section in the JSON schema\n\n## Contributors\n\nThis project is made possible by a [community of contributors](https://github.com/vega/ts-json-schema-generator/graphs/contributors). We welcome contributions of any kind (issues, code, documentation, examples, tests,...). Please read our [code of conduct](https://vega.github.io/vega/about/code-of-conduct).\n\n## CLI Usage\n\nRun the schema generator with npx:\n\n```bash\nnpx ts-json-schema-generator --path 'my/project/**/*.ts' --type 'My.Type.Name'\n```\n\nOr install the package and then run it\n\n```bash\nnpm install --save ts-json-schema-generator\n./node_modules/.bin/ts-json-schema-generator --path 'my/project/**/*.ts' --type 'My.Type.Name'\n```\n\nNote that different platforms (e.g. Windows) may use different path separators so you may have to adjust the command above.\n\nAlso note that you need to quote paths with `*` as otherwise the shell will expand the paths and therefore only pass the first path to the generator.\n\n## Programmatic Usage\n\n```js\n// main.js\n\nconst tsj = require(\"ts-json-schema-generator\");\nconst fs = require(\"fs\");\n\n/** @type {import('ts-json-schema-generator/dist/src/Config').Config} */\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst output_path = \"path/to/output/file\";\n\nconst schema = tsj.createGenerator(config).createSchema(config.type);\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\nRun the schema generator via `node main.js`.\n\n### Custom formatting\n\nExtending the built-in formatting is possible by creating a custom formatter and adding it to the main formatter:\n\n1. First we create a formatter, in this case for formatting function types:\n\n```ts\n// my-function-formatter.ts\nimport { BaseType, Definition, FunctionType, SubTypeFormatter } from \"ts-json-schema-generator\";\nimport ts from \"typescript\";\n\nexport class MyFunctionTypeFormatter implements SubTypeFormatter {\n    // You can skip this line if you don't need childTypeFormatter\n    public constructor(private childTypeFormatter: TypeFormatter) {}\n\n    public supportsType(type: FunctionType): boolean {\n        return type instanceof FunctionType;\n    }\n\n    public getDefinition(type: FunctionType): Definition {\n        // Return a custom schema for the function property.\n        return {\n            type: \"object\",\n            properties: {\n                isFunction: {\n                    type: \"boolean\",\n                    const: true,\n                },\n            },\n        };\n    }\n\n    // If this type does NOT HAVE children, generally all you need is:\n    public getChildren(type: FunctionType): BaseType[] {\n        return [];\n    }\n\n    // However, if children ARE supported, you'll need something similar to\n    // this (see src/TypeFormatter/{Array,Definition,etc}.ts for some examples):\n    public getChildren(type: FunctionType): BaseType[] {\n        return this.childTypeFormatter.getChildren(type.getType());\n    }\n}\n```\n\n2. Then we add the formatter as a child to the core formatter using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyFunctionTypeFormatter } from \"./my-function-formatter.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\n// We configure the formatter an add our custom formatter to it.\nconst formatter = createFormatter(config, (fmt, circularReferenceTypeFormatter) => {\n    // If your formatter DOES NOT support children, e.g. getChildren() { return [] }:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter());\n    // If your formatter DOES support children, you'll need this reference too:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter(circularReferenceTypeFormatter));\n});\n\nconst program = createProgram(config);\nconst parser = createParser(program, config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n### Custom parsing\n\nSimilar to custom formatting, extending the built-in parsing works practically the same way:\n\n1. First we create a parser, in this case for parsing construct types:\n\n```ts\n// my-constructor-parser.ts\nimport { Context, StringType, ReferenceType, BaseType, SubNodeParser } from \"ts-json-schema-generator\";\n// use typescript exported by TJS to avoid version conflict\nimport ts from \"ts-json-schema-generator\";\n\nexport class MyConstructorParser implements SubNodeParser {\n    supportsNode(node: ts.Node): boolean {\n        return node.kind === ts.SyntaxKind.ConstructorType;\n    }\n    createType(node: ts.Node, context: Context, reference?: ReferenceType): BaseType | undefined {\n        return new StringType(); // Treat constructors as strings in this example\n    }\n}\n```\n\n2. Then we add the parser as a child to the core parser using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyConstructorParser } from \"./my-constructor-parser.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst program = createProgram(config);\n\n// We configure the parser an add our custom parser to it.\nconst parser = createParser(program, config, (prs) => {\n    prs.addNodeParser(new MyConstructorParser());\n});\n\nconst formatter = createFormatter(config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n## Options\n\n```\n-p, --path 'index.ts'\n    The path to the TypeScript source file. If this is not provided, the type will be searched in the project specified in the `.tsconfig`.\n\n-t, --type 'My.Type.Name'\n    The type the generated schema will represent. If omitted, the generated schema will contain all\n    types found in the files matching path. The same is true if '*' is specified.\n\n-i, --id 'generatedSchemaId'\n    The `$id` of the generated schema. If omitted, there will be no `$id`.\n\n-e, --expose <all|none|export>\n    all: Create shared $ref definitions for all types.\n    none: Do not create shared $ref definitions.\n    export (default): Create shared $ref definitions only for exported types (not tagged as `@internal`).\n\n-f, --tsconfig 'my/project/tsconfig.json'\n    Use a custom tsconfig file for processing typescript (see https://www.typescriptlang.org/docs/handbook/tsconfig-json.html) instead of the default:\n    {\n        \"compilerOptions\": {\n            \"noEmit\": true,\n            \"emitDecoratorMetadata\": true,\n            \"experimentalDecorators\": true,\n            \"target\": \"ES5\",\n            \"module\": \"CommonJS\",\n            \"strictNullChecks\": false,\n        }\n    }\n\n-j, --jsDoc <extended|none|basic>\n    none: Do not use JsDoc annotations.\n    basic: Read JsDoc annotations to provide schema properties.\n    extended (default): Also read @nullable, and @asType annotations.\n\n--unstable\n    Do not sort properties.\n\n--strict-tuples\n    Do not allow additional items on tuples.\n\n--no-top-ref\n    Do not create a top-level $ref definition.\n\n--no-type-check\n    Skip type checks for better performance.\n\n--no-ref-encode\n    Do not encode references. According to the standard, references must be valid URIs but some tools do not support encoded references.\n\n--validation-keywords\n    Provide additional validation keywords to include.\n\n-o, --out\n    Specify the output file path. Without this option, the generator logs the response in the console.\n\n--additional-properties <true|false>\n    Controls whether or not to allow additional properties for objects that have no index signature.\n\n    true: Additional properties are allowed\n    false (default): Additional properties are not allowed\n\n--minify\n    Minify generated schema (default: false)\n```\n\n## Current state\n\n-   `interface` types\n-   `enum` types\n-   `union`, `tuple`, `type[]` types\n-   `Date`, `RegExp`, `URL` types\n-   `string`, `boolean`, `number` types\n-   `\"value\"`, `123`, `true`, `false`, `null`, `undefined` literals\n-   type aliases\n-   generics\n-   `typeof`\n-   `keyof`\n-   conditional types\n\n## Run locally\n\n`yarn --silent run run --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\n## Debug\n\n`yarn --silent run debug --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\nAnd connect via the debugger protocol.\n\n[AST Explorer](https://astexplorer.net/) is amazing for developers of this tool!\n\n## Publish\n\nPublishing is handled by a 2-branch [pre-release process](https://intuit.github.io/auto/docs/generated/shipit#next-branch-default), configured in `publish-auto.yml`. All changes should be based off the default `next` branch, and are published automatically.\n\n-   PRs made into the default branch are auto-deployed to the `next` pre-release tag on NPM. The result can be installed with `npm install ts-json-schema-generator@next`\n    -   When merging into `next`, please use the `squash and merge` strategy.\n-   To release a new stable version, open a PR from `next` into `stable` using this [compare link](https://github.com/vega/ts-json-schema-generator/compare/stable...next).\n    -   When merging from `next` into `stable`, please use the `create a merge commit` strategy.\n",
      "readmeFilename": "README.md",
      "gitHead": "3f1b8171a1a23993e364e23186541e2f56a5150a",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@1.3.0-next.3",
      "_nodeVersion": "18.15.0",
      "_npmVersion": "9.5.0",
      "dist": {
        "integrity": "sha512-cR1BOs660DLYUXyhk58XM4AbECQd5oU/BNmOi8HSDq2tWeNdSMJcWr6KAxp4kfP6W/vKmSHMLVVTMfSgx5qKxA==",
        "shasum": "28e28465bef6350df585a1c9df8ff06170235cb2",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-1.3.0-next.3.tgz",
        "fileCount": 716,
        "unpackedSize": 886339,
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEYCIQDPLR2IUqDECzbR9dwnT6Pu6ThHtHJ3BYsSuA8liLFkdQIhAI+5SVCoSjNfkGy1OYnhx60k+UXTza0ZXs9LESc+Xj+t"
          }
        ],
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJkE8FzACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2Vmo+Jw//Qb9fcDo+mwzJH8p2he9f0bfAys4rpweKn6PxYFIS5ar8rZdL\r\ngdO2y+3xTkjWzGJsQRGiGm3m6tzWnm7KW6iZd/BTMjxDA7IHlcO2tH/5n4F1\r\nzAkJnr/GlQgYlZ+N5ekR+T07IOoncqT2RkY+zhwjc1Y1oaa0JPKNGORtRhJZ\r\nSiRApszarq99CLog9ntDc+D8Ku6C/IKA4NTU0++pmruYw1iDs9ytMILbsJSI\r\nrSD/bbCDrnD4zyjrOt7CxVZA3z/CbbTQF3thA7gqsVlmjL7Y5/EQDDpr8wB6\r\n8Seae6LQpoqt5+wQT1+Wcc2pidoUGQJuLPei8hT9QnuJP9msUQfF7JfkCmMO\r\n7raDfD5wIQedxsTm7Nxaltipxxgs66Fn9/TXtXiXmxIHv175CJeVjjJLbPNb\r\nwSqdyrPb/evtJVnUApNjQrn5TRfYfMU2WxQOMQlMaFjIhBletoIU5ZwLkgAO\r\n6Nnhvyy4Kxy4qRJrgVTuW9tldVfSoLps91xT5a9janyQ5zN95Dmbc5JcRRoB\r\niZjK67kbKbWLuCNFby5T7RFPPTWB70HAUWa3mrOSM842dpEAUyG95LN+mOfD\r\nlvqO9vHQKXiT9Y1Eafb/oSSpPPPVoDCUL2h/X+G/NZ9/eZUPbEV1h2TyZcdO\r\nTcpuyFYV3Aw3NM0OO9eCGol9XCfP7w2TNg4=\r\n=j5ma\r\n-----END PGP SIGNATURE-----\r\n"
      },
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "maintainers": [
        {
          "name": "jheer",
          "email": "jeffrey.heer@gmail.com"
        },
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "kanitw",
          "email": "kanitw@gmail.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_1.3.0-next.3_1679016306916_0.18740155858781993"
      },
      "_hasShrinkwrap": false
    },
    "1.3.0-next.4": {
      "name": "ts-json-schema-generator",
      "version": "1.3.0-next.4",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "MooYeol Prescott Lee",
          "email": "mooyoul@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=10.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.11",
        "commander": "^10.0.0",
        "glob": "^8.0.3",
        "json5": "^2.2.3",
        "normalize-path": "^3.0.0",
        "safe-stable-stringify": "^2.4.2",
        "typescript": "~5.0.2"
      },
      "devDependencies": {
        "@auto-it/conventional-commits": "^10.43.0",
        "@auto-it/first-time-contributor": "^10.43.0",
        "@babel/core": "^7.21.3",
        "@babel/preset-env": "^7.20.2",
        "@babel/preset-typescript": "^7.21.0",
        "@types/glob": "^8.1.0",
        "@types/jest": "^29.5.0",
        "@types/node": "^18.15.3",
        "@types/normalize-path": "^3.0.0",
        "@typescript-eslint/eslint-plugin": "^5.55.0",
        "@typescript-eslint/parser": "^5.55.0",
        "ajv": "^8.12.0",
        "ajv-formats": "^2.1.1",
        "auto": "^10.43.0",
        "chai": "^4.3.7",
        "cross-env": "^7.0.3",
        "eslint": "^8.36.0",
        "eslint-config-prettier": "^8.7.0",
        "eslint-plugin-prettier": "^4.2.1",
        "jest": "^29.5.0",
        "jest-junit": "^15.0.0",
        "prettier": "^2.8.4",
        "ts-node": "^10.9.1",
        "vega": "^5.22.1",
        "vega-lite": "^5.6.0"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint \"{src,test,factory}/**/*.ts\"",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "cross-env FAST_TEST=1 jest test/ --verbose",
        "test:coverage": "yarn jest test/ --collectCoverage=true",
        "test:update": "cross-env UPDATE_SCHEMA=true yarn test:fast",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node-transpile-only ts-json-schema-generator.ts",
        "release": "yarn build && auto shipit"
      },
      "readme": "# ts-json-schema-generator\n\n![Test](https://github.com/vega/ts-json-schema-generator/workflows/Test/badge.svg)\n[![codecov](https://codecov.io/gh/vega/ts-json-schema-generator/branch/master/graph/badge.svg)](https://codecov.io/gh/vega/ts-json-schema-generator)\n[![npm version](https://img.shields.io/npm/v/ts-json-schema-generator.svg)](https://www.npmjs.com/package/ts-json-schema-generator)\n\nExtended version of [https://github.com/xiag-ag/typescript-to-json-schema](https://github.com/xiag-ag/typescript-to-json-schema).\n\nInspired by [`YousefED/typescript-json-schema`](https://github.com/YousefED/typescript-json-schema). Here's the differences list:\n\n-   this implementation avoids the use of `typeChecker.getTypeAtLocation()` (so probably it keeps correct type aliases)\n-   processing AST and formatting JSON schema have been split into two independent steps\n-   not exported types, interfaces, enums are not exposed in the `definitions` section in the JSON schema\n\n## Contributors\n\nThis project is made possible by a [community of contributors](https://github.com/vega/ts-json-schema-generator/graphs/contributors). We welcome contributions of any kind (issues, code, documentation, examples, tests,...). Please read our [code of conduct](https://vega.github.io/vega/about/code-of-conduct).\n\n## CLI Usage\n\nRun the schema generator with npx:\n\n```bash\nnpx ts-json-schema-generator --path 'my/project/**/*.ts' --type 'My.Type.Name'\n```\n\nOr install the package and then run it\n\n```bash\nnpm install --save ts-json-schema-generator\n./node_modules/.bin/ts-json-schema-generator --path 'my/project/**/*.ts' --type 'My.Type.Name'\n```\n\nNote that different platforms (e.g. Windows) may use different path separators so you may have to adjust the command above.\n\nAlso note that you need to quote paths with `*` as otherwise the shell will expand the paths and therefore only pass the first path to the generator.\n\n## Programmatic Usage\n\n```js\n// main.js\n\nconst tsj = require(\"ts-json-schema-generator\");\nconst fs = require(\"fs\");\n\n/** @type {import('ts-json-schema-generator/dist/src/Config').Config} */\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst output_path = \"path/to/output/file\";\n\nconst schema = tsj.createGenerator(config).createSchema(config.type);\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\nRun the schema generator via `node main.js`.\n\n### Custom formatting\n\nExtending the built-in formatting is possible by creating a custom formatter and adding it to the main formatter:\n\n1. First we create a formatter, in this case for formatting function types:\n\n```ts\n// my-function-formatter.ts\nimport { BaseType, Definition, FunctionType, SubTypeFormatter } from \"ts-json-schema-generator\";\nimport ts from \"typescript\";\n\nexport class MyFunctionTypeFormatter implements SubTypeFormatter {\n    // You can skip this line if you don't need childTypeFormatter\n    public constructor(private childTypeFormatter: TypeFormatter) {}\n\n    public supportsType(type: FunctionType): boolean {\n        return type instanceof FunctionType;\n    }\n\n    public getDefinition(type: FunctionType): Definition {\n        // Return a custom schema for the function property.\n        return {\n            type: \"object\",\n            properties: {\n                isFunction: {\n                    type: \"boolean\",\n                    const: true,\n                },\n            },\n        };\n    }\n\n    // If this type does NOT HAVE children, generally all you need is:\n    public getChildren(type: FunctionType): BaseType[] {\n        return [];\n    }\n\n    // However, if children ARE supported, you'll need something similar to\n    // this (see src/TypeFormatter/{Array,Definition,etc}.ts for some examples):\n    public getChildren(type: FunctionType): BaseType[] {\n        return this.childTypeFormatter.getChildren(type.getType());\n    }\n}\n```\n\n2. Then we add the formatter as a child to the core formatter using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyFunctionTypeFormatter } from \"./my-function-formatter.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\n// We configure the formatter an add our custom formatter to it.\nconst formatter = createFormatter(config, (fmt, circularReferenceTypeFormatter) => {\n    // If your formatter DOES NOT support children, e.g. getChildren() { return [] }:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter());\n    // If your formatter DOES support children, you'll need this reference too:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter(circularReferenceTypeFormatter));\n});\n\nconst program = createProgram(config);\nconst parser = createParser(program, config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n### Custom parsing\n\nSimilar to custom formatting, extending the built-in parsing works practically the same way:\n\n1. First we create a parser, in this case for parsing construct types:\n\n```ts\n// my-constructor-parser.ts\nimport { Context, StringType, ReferenceType, BaseType, SubNodeParser } from \"ts-json-schema-generator\";\n// use typescript exported by TJS to avoid version conflict\nimport ts from \"ts-json-schema-generator\";\n\nexport class MyConstructorParser implements SubNodeParser {\n    supportsNode(node: ts.Node): boolean {\n        return node.kind === ts.SyntaxKind.ConstructorType;\n    }\n    createType(node: ts.Node, context: Context, reference?: ReferenceType): BaseType | undefined {\n        return new StringType(); // Treat constructors as strings in this example\n    }\n}\n```\n\n2. Then we add the parser as a child to the core parser using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyConstructorParser } from \"./my-constructor-parser.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst program = createProgram(config);\n\n// We configure the parser an add our custom parser to it.\nconst parser = createParser(program, config, (prs) => {\n    prs.addNodeParser(new MyConstructorParser());\n});\n\nconst formatter = createFormatter(config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n## Options\n\n```\n-p, --path 'index.ts'\n    The path to the TypeScript source file. If this is not provided, the type will be searched in the project specified in the `.tsconfig`.\n\n-t, --type 'My.Type.Name'\n    The type the generated schema will represent. If omitted, the generated schema will contain all\n    types found in the files matching path. The same is true if '*' is specified.\n\n-i, --id 'generatedSchemaId'\n    The `$id` of the generated schema. If omitted, there will be no `$id`.\n\n-e, --expose <all|none|export>\n    all: Create shared $ref definitions for all types.\n    none: Do not create shared $ref definitions.\n    export (default): Create shared $ref definitions only for exported types (not tagged as `@internal`).\n\n-f, --tsconfig 'my/project/tsconfig.json'\n    Use a custom tsconfig file for processing typescript (see https://www.typescriptlang.org/docs/handbook/tsconfig-json.html) instead of the default:\n    {\n        \"compilerOptions\": {\n            \"noEmit\": true,\n            \"emitDecoratorMetadata\": true,\n            \"experimentalDecorators\": true,\n            \"target\": \"ES5\",\n            \"module\": \"CommonJS\",\n            \"strictNullChecks\": false,\n        }\n    }\n\n-j, --jsDoc <extended|none|basic>\n    none: Do not use JsDoc annotations.\n    basic: Read JsDoc annotations to provide schema properties.\n    extended (default): Also read @nullable, and @asType annotations.\n\n--unstable\n    Do not sort properties.\n\n--strict-tuples\n    Do not allow additional items on tuples.\n\n--no-top-ref\n    Do not create a top-level $ref definition.\n\n--no-type-check\n    Skip type checks for better performance.\n\n--no-ref-encode\n    Do not encode references. According to the standard, references must be valid URIs but some tools do not support encoded references.\n\n--validation-keywords\n    Provide additional validation keywords to include.\n\n-o, --out\n    Specify the output file path. Without this option, the generator logs the response in the console.\n\n--additional-properties <true|false>\n    Controls whether or not to allow additional properties for objects that have no index signature.\n\n    true: Additional properties are allowed\n    false (default): Additional properties are not allowed\n\n--minify\n    Minify generated schema (default: false)\n```\n\n## Current state\n\n-   `interface` types\n-   `enum` types\n-   `union`, `tuple`, `type[]` types\n-   `Date`, `RegExp`, `URL` types\n-   `string`, `boolean`, `number` types\n-   `\"value\"`, `123`, `true`, `false`, `null`, `undefined` literals\n-   type aliases\n-   generics\n-   `typeof`\n-   `keyof`\n-   conditional types\n\n## Run locally\n\n`yarn --silent run run --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\n## Debug\n\n`yarn --silent run debug --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\nAnd connect via the debugger protocol.\n\n[AST Explorer](https://astexplorer.net/) is amazing for developers of this tool!\n\n## Publish\n\nPublishing is handled by a 2-branch [pre-release process](https://intuit.github.io/auto/docs/generated/shipit#next-branch-default), configured in `publish-auto.yml`. All changes should be based off the default `next` branch, and are published automatically.\n\n-   PRs made into the default branch are auto-deployed to the `next` pre-release tag on NPM. The result can be installed with `npm install ts-json-schema-generator@next`\n    -   When merging into `next`, please use the `squash and merge` strategy.\n-   To release a new stable version, open a PR from `next` into `stable` using this [compare link](https://github.com/vega/ts-json-schema-generator/compare/stable...next).\n    -   When merging from `next` into `stable`, please use the `create a merge commit` strategy.\n",
      "readmeFilename": "README.md",
      "gitHead": "4cd4908ab1c3703d70a0e4c11d5b274dbca9aaeb",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@1.3.0-next.4",
      "_nodeVersion": "18.15.0",
      "_npmVersion": "9.5.0",
      "dist": {
        "integrity": "sha512-L2qfBiRIw8pvGa8jCwj5aLMpI8Xiuzze4IwOQ8wnBOGSAkSLJ1fOHGqtX01gte9TfARZ1xeVSqn4WDkTL1N5tQ==",
        "shasum": "3df5212599fede7724f3876dfa251049e425563c",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-1.3.0-next.4.tgz",
        "fileCount": 716,
        "unpackedSize": 886717,
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIQDdryI6s/nIfxePvEAD7ab1qWD36HslkI69X9kby9oPkwIgb/pcHXqWv2Rc8TL7ru+fSE2pov6DdGiHT7psfyaNrwE="
          }
        ],
        "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJkNrb2ACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2Vmp8RQ//VgHRajVmAt3E8+NXBWWa40D5F1ZiEeak2lA4yhRcyOEiA0Ay\r\nOx/bEOMrZlLSsZZTRdLU08chVs+D6V2YN3uPTz9IX55Ry7FymFkbC5JKRBNj\r\nP7SJxF652/ZpYmK6q5X6v1wy0Y+IvaADGFS3E88Kg3ksZ91z9HshYDn5kUOC\r\neo1BP6NzjlSY9cPfjz9tXeGsvWARb/iY2nooUBgIEPfqIl+kMFQ4Jgl6sokV\r\nAaRgsmLiZgC0yDps1mqGU14koxqLD0q/Wfxx9ITC7n81l5P3n6RxBJkBlInl\r\nmtpbXQH02p7enHIJ6I9ogDF+lqsyexNzioxSLv9SKiPQ2zQ88pbA+mo9CB7d\r\ncR8BfdsskF0NnCrb81PxTLifP7uKphkcCcIa+vp4jPB0uWrRtiKHz47w8Wiz\r\nSKh6tLfnT9WjngtSp0+USevnmRgfsPzPMXzEgMj/eL5yQWw+GXlXKmU7V+1f\r\n0mtbkHToFhm5JystI4lPO80SZRodocbiUX7BjQIA0CHkR82zAK8StjDbUxuA\r\nD7SWAOLlPi3Sy1OAn1ATF27onaJfBWXpQ6J3mr+7d6hwMJ1joeTHkb2Cht9s\r\nueC7vtvAufXVdkleFsnKp9Zdn52goOAUwSPk0ORoY9m+f9ZqDsSQ/w+koYaQ\r\njJaB/FE8zVrUsJimYAJWbfJWP5PYTU+BPG0=\r\n=sflY\r\n-----END PGP SIGNATURE-----\r\n"
      },
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "maintainers": [
        {
          "name": "jheer",
          "email": "jeffrey.heer@gmail.com"
        },
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "kanitw",
          "email": "kanitw@gmail.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_1.3.0-next.4_1681307381805_0.12869982357315912"
      },
      "_hasShrinkwrap": false
    },
    "1.3.0-next.5": {
      "name": "ts-json-schema-generator",
      "version": "1.3.0-next.5",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "MooYeol Prescott Lee",
          "email": "mooyoul@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=10.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.11",
        "commander": "^10.0.0",
        "glob": "^8.0.3",
        "json5": "^2.2.3",
        "normalize-path": "^3.0.0",
        "safe-stable-stringify": "^2.4.2",
        "typescript": "~5.0.2"
      },
      "devDependencies": {
        "@auto-it/conventional-commits": "^10.43.0",
        "@auto-it/first-time-contributor": "^10.43.0",
        "@babel/core": "^7.21.3",
        "@babel/preset-env": "^7.20.2",
        "@babel/preset-typescript": "^7.21.0",
        "@types/glob": "^8.1.0",
        "@types/jest": "^29.5.0",
        "@types/node": "^20.1.0",
        "@types/normalize-path": "^3.0.0",
        "@typescript-eslint/eslint-plugin": "^5.55.0",
        "@typescript-eslint/parser": "^5.55.0",
        "ajv": "^8.12.0",
        "ajv-formats": "^2.1.1",
        "auto": "^10.43.0",
        "chai": "^4.3.7",
        "cross-env": "^7.0.3",
        "eslint": "^8.36.0",
        "eslint-config-prettier": "^8.7.0",
        "eslint-plugin-prettier": "^4.2.1",
        "jest": "^29.5.0",
        "jest-junit": "^16.0.0",
        "prettier": "^2.8.4",
        "ts-node": "^10.9.1",
        "vega": "^5.22.1",
        "vega-lite": "^5.6.0"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint \"{src,test,factory}/**/*.ts\"",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "cross-env FAST_TEST=1 jest test/ --verbose",
        "test:coverage": "yarn jest test/ --collectCoverage=true",
        "test:update": "cross-env UPDATE_SCHEMA=true yarn test:fast",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node-transpile-only ts-json-schema-generator.ts",
        "release": "yarn build && auto shipit"
      },
      "readme": "# ts-json-schema-generator\n\n![Test](https://github.com/vega/ts-json-schema-generator/workflows/Test/badge.svg)\n[![codecov](https://codecov.io/gh/vega/ts-json-schema-generator/branch/master/graph/badge.svg)](https://codecov.io/gh/vega/ts-json-schema-generator)\n[![npm version](https://img.shields.io/npm/v/ts-json-schema-generator.svg)](https://www.npmjs.com/package/ts-json-schema-generator)\n\nExtended version of [https://github.com/xiag-ag/typescript-to-json-schema](https://github.com/xiag-ag/typescript-to-json-schema).\n\nInspired by [`YousefED/typescript-json-schema`](https://github.com/YousefED/typescript-json-schema). Here's the differences list:\n\n-   this implementation avoids the use of `typeChecker.getTypeAtLocation()` (so probably it keeps correct type aliases)\n-   processing AST and formatting JSON schema have been split into two independent steps\n-   not exported types, interfaces, enums are not exposed in the `definitions` section in the JSON schema\n\n## Contributors\n\nThis project is made possible by a [community of contributors](https://github.com/vega/ts-json-schema-generator/graphs/contributors). We welcome contributions of any kind (issues, code, documentation, examples, tests,...). Please read our [code of conduct](https://vega.github.io/vega/about/code-of-conduct).\n\n## CLI Usage\n\nRun the schema generator with npx:\n\n```bash\nnpx ts-json-schema-generator --path 'my/project/**/*.ts' --type 'My.Type.Name'\n```\n\nOr install the package and then run it\n\n```bash\nnpm install --save ts-json-schema-generator\n./node_modules/.bin/ts-json-schema-generator --path 'my/project/**/*.ts' --type 'My.Type.Name'\n```\n\nNote that different platforms (e.g. Windows) may use different path separators so you may have to adjust the command above.\n\nAlso note that you need to quote paths with `*` as otherwise the shell will expand the paths and therefore only pass the first path to the generator.\n\n## Programmatic Usage\n\n```js\n// main.js\n\nconst tsj = require(\"ts-json-schema-generator\");\nconst fs = require(\"fs\");\n\n/** @type {import('ts-json-schema-generator/dist/src/Config').Config} */\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst output_path = \"path/to/output/file\";\n\nconst schema = tsj.createGenerator(config).createSchema(config.type);\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\nRun the schema generator via `node main.js`.\n\n### Custom formatting\n\nExtending the built-in formatting is possible by creating a custom formatter and adding it to the main formatter:\n\n1. First we create a formatter, in this case for formatting function types:\n\n```ts\n// my-function-formatter.ts\nimport { BaseType, Definition, FunctionType, SubTypeFormatter } from \"ts-json-schema-generator\";\nimport ts from \"typescript\";\n\nexport class MyFunctionTypeFormatter implements SubTypeFormatter {\n    // You can skip this line if you don't need childTypeFormatter\n    public constructor(private childTypeFormatter: TypeFormatter) {}\n\n    public supportsType(type: FunctionType): boolean {\n        return type instanceof FunctionType;\n    }\n\n    public getDefinition(type: FunctionType): Definition {\n        // Return a custom schema for the function property.\n        return {\n            type: \"object\",\n            properties: {\n                isFunction: {\n                    type: \"boolean\",\n                    const: true,\n                },\n            },\n        };\n    }\n\n    // If this type does NOT HAVE children, generally all you need is:\n    public getChildren(type: FunctionType): BaseType[] {\n        return [];\n    }\n\n    // However, if children ARE supported, you'll need something similar to\n    // this (see src/TypeFormatter/{Array,Definition,etc}.ts for some examples):\n    public getChildren(type: FunctionType): BaseType[] {\n        return this.childTypeFormatter.getChildren(type.getType());\n    }\n}\n```\n\n2. Then we add the formatter as a child to the core formatter using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyFunctionTypeFormatter } from \"./my-function-formatter.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\n// We configure the formatter an add our custom formatter to it.\nconst formatter = createFormatter(config, (fmt, circularReferenceTypeFormatter) => {\n    // If your formatter DOES NOT support children, e.g. getChildren() { return [] }:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter());\n    // If your formatter DOES support children, you'll need this reference too:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter(circularReferenceTypeFormatter));\n});\n\nconst program = createProgram(config);\nconst parser = createParser(program, config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n### Custom parsing\n\nSimilar to custom formatting, extending the built-in parsing works practically the same way:\n\n1. First we create a parser, in this case for parsing construct types:\n\n```ts\n// my-constructor-parser.ts\nimport { Context, StringType, ReferenceType, BaseType, SubNodeParser } from \"ts-json-schema-generator\";\n// use typescript exported by TJS to avoid version conflict\nimport ts from \"ts-json-schema-generator\";\n\nexport class MyConstructorParser implements SubNodeParser {\n    supportsNode(node: ts.Node): boolean {\n        return node.kind === ts.SyntaxKind.ConstructorType;\n    }\n    createType(node: ts.Node, context: Context, reference?: ReferenceType): BaseType | undefined {\n        return new StringType(); // Treat constructors as strings in this example\n    }\n}\n```\n\n2. Then we add the parser as a child to the core parser using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyConstructorParser } from \"./my-constructor-parser.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst program = createProgram(config);\n\n// We configure the parser an add our custom parser to it.\nconst parser = createParser(program, config, (prs) => {\n    prs.addNodeParser(new MyConstructorParser());\n});\n\nconst formatter = createFormatter(config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n## Options\n\n```\n-p, --path 'index.ts'\n    The path to the TypeScript source file. If this is not provided, the type will be searched in the project specified in the `.tsconfig`.\n\n-t, --type 'My.Type.Name'\n    The type the generated schema will represent. If omitted, the generated schema will contain all\n    types found in the files matching path. The same is true if '*' is specified.\n\n-i, --id 'generatedSchemaId'\n    The `$id` of the generated schema. If omitted, there will be no `$id`.\n\n-e, --expose <all|none|export>\n    all: Create shared $ref definitions for all types.\n    none: Do not create shared $ref definitions.\n    export (default): Create shared $ref definitions only for exported types (not tagged as `@internal`).\n\n-f, --tsconfig 'my/project/tsconfig.json'\n    Use a custom tsconfig file for processing typescript (see https://www.typescriptlang.org/docs/handbook/tsconfig-json.html) instead of the default:\n    {\n        \"compilerOptions\": {\n            \"noEmit\": true,\n            \"emitDecoratorMetadata\": true,\n            \"experimentalDecorators\": true,\n            \"target\": \"ES5\",\n            \"module\": \"CommonJS\",\n            \"strictNullChecks\": false,\n        }\n    }\n\n-j, --jsDoc <extended|none|basic>\n    none: Do not use JsDoc annotations.\n    basic: Read JsDoc annotations to provide schema properties.\n    extended (default): Also read @nullable, and @asType annotations.\n\n--unstable\n    Do not sort properties.\n\n--strict-tuples\n    Do not allow additional items on tuples.\n\n--no-top-ref\n    Do not create a top-level $ref definition.\n\n--no-type-check\n    Skip type checks for better performance.\n\n--no-ref-encode\n    Do not encode references. According to the standard, references must be valid URIs but some tools do not support encoded references.\n\n--validation-keywords\n    Provide additional validation keywords to include.\n\n-o, --out\n    Specify the output file path. Without this option, the generator logs the response in the console.\n\n--additional-properties <true|false>\n    Controls whether or not to allow additional properties for objects that have no index signature.\n\n    true: Additional properties are allowed\n    false (default): Additional properties are not allowed\n\n--minify\n    Minify generated schema (default: false)\n```\n\n## Current state\n\n-   `interface` types\n-   `enum` types\n-   `union`, `tuple`, `type[]` types\n-   `Date`, `RegExp`, `URL` types\n-   `string`, `boolean`, `number` types\n-   `\"value\"`, `123`, `true`, `false`, `null`, `undefined` literals\n-   type aliases\n-   generics\n-   `typeof`\n-   `keyof`\n-   conditional types\n\n## Run locally\n\n`yarn --silent run run --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\n## Debug\n\n`yarn --silent run debug --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\nAnd connect via the debugger protocol.\n\n[AST Explorer](https://astexplorer.net/) is amazing for developers of this tool!\n\n## Publish\n\nPublishing is handled by a 2-branch [pre-release process](https://intuit.github.io/auto/docs/generated/shipit#next-branch-default), configured in `publish-auto.yml`. All changes should be based off the default `next` branch, and are published automatically.\n\n-   PRs made into the default branch are auto-deployed to the `next` pre-release tag on NPM. The result can be installed with `npm install ts-json-schema-generator@next`\n    -   When merging into `next`, please use the `squash and merge` strategy.\n-   To release a new stable version, open a PR from `next` into `stable` using this [compare link](https://github.com/vega/ts-json-schema-generator/compare/stable...next).\n    -   When merging from `next` into `stable`, please use the `create a merge commit` strategy.\n",
      "readmeFilename": "README.md",
      "gitHead": "76706862d73d075f24006a3d8ee3a3fda6e510bd",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@1.3.0-next.5",
      "_nodeVersion": "18.16.0",
      "_npmVersion": "9.5.1",
      "dist": {
        "integrity": "sha512-EOcvUTtnF7qaYmBLprnjoAbneLjJZZILRZtR5AXgiPFpmyvbZrpQGoRSE+/vbX/oqlTPr6RuOwT3okuxqGZ92w==",
        "shasum": "09dcf82f9e040f5c2e8561824ef8f612795bd869",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-1.3.0-next.5.tgz",
        "fileCount": 716,
        "unpackedSize": 887084,
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEQCIBnFScYMV/kU8mbMNOkuUQuQhgrHC4uqOGae0Yjjc5UzAiB4RdK3xo9hCPpbNbJ8MwDOZ3BGLAjc3MPZx5UpP/dPwQ=="
          }
        ]
      },
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "maintainers": [
        {
          "name": "jheer",
          "email": "jeffrey.heer@gmail.com"
        },
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "kanitw",
          "email": "kanitw@gmail.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_1.3.0-next.5_1685096718025_0.2463079041490559"
      },
      "_hasShrinkwrap": false
    },
    "1.2.1--canary.1710.488f927.0": {
      "name": "ts-json-schema-generator",
      "version": "1.2.1--canary.1710.488f927.0",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "MooYeol Prescott Lee",
          "email": "mooyoul@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=10.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.12",
        "commander": "^11.0.0",
        "glob": "^10.3.0",
        "json5": "^2.2.3",
        "normalize-path": "^3.0.0",
        "safe-stable-stringify": "^2.4.3",
        "typescript": "~5.1.3"
      },
      "devDependencies": {
        "@auto-it/conventional-commits": "^10.46.0",
        "@auto-it/first-time-contributor": "^10.46.0",
        "@babel/core": "^7.22.5",
        "@babel/preset-env": "^7.22.5",
        "@babel/preset-typescript": "^7.22.5",
        "@types/glob": "^8.1.0",
        "@types/jest": "^29.5.2",
        "@types/node": "^20.3.1",
        "@types/normalize-path": "^3.0.0",
        "@typescript-eslint/eslint-plugin": "^5.60.0",
        "@typescript-eslint/parser": "^5.60.0",
        "ajv": "^8.12.0",
        "ajv-formats": "^2.1.1",
        "auto": "^10.46.0",
        "chai": "^4.3.7",
        "cross-env": "^7.0.3",
        "eslint": "^8.43.0",
        "eslint-config-prettier": "^8.8.0",
        "eslint-plugin-prettier": "^4.2.1",
        "jest": "^29.5.0",
        "jest-junit": "^16.0.0",
        "prettier": "^2.8.8",
        "ts-node": "^10.9.1",
        "vega": "^5.25.0",
        "vega-lite": "^5.11.0"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint \"{src,test,factory}/**/*.ts\"",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "cross-env FAST_TEST=1 jest test/ --verbose",
        "test:coverage": "yarn jest test/ --collectCoverage=true",
        "test:update": "cross-env UPDATE_SCHEMA=true yarn test:fast",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node-transpile-only ts-json-schema-generator.ts",
        "release": "yarn build && auto shipit"
      },
      "readme": "# ts-json-schema-generator\n\n![Test](https://github.com/vega/ts-json-schema-generator/workflows/Test/badge.svg)\n[![codecov](https://codecov.io/gh/vega/ts-json-schema-generator/branch/master/graph/badge.svg)](https://codecov.io/gh/vega/ts-json-schema-generator)\n[![npm version](https://img.shields.io/npm/v/ts-json-schema-generator.svg)](https://www.npmjs.com/package/ts-json-schema-generator)\n\nExtended version of [https://github.com/xiag-ag/typescript-to-json-schema](https://github.com/xiag-ag/typescript-to-json-schema).\n\nInspired by [`YousefED/typescript-json-schema`](https://github.com/YousefED/typescript-json-schema). Here's the differences list:\n\n-   this implementation avoids the use of `typeChecker.getTypeAtLocation()` (so probably it keeps correct type aliases)\n-   processing AST and formatting JSON schema have been split into two independent steps\n-   not exported types, interfaces, enums are not exposed in the `definitions` section in the JSON schema\n\n## Contributors\n\nThis project is made possible by a [community of contributors](https://github.com/vega/ts-json-schema-generator/graphs/contributors). We welcome contributions of any kind (issues, code, documentation, examples, tests,...). Please read our [code of conduct](https://vega.github.io/vega/about/code-of-conduct).\n\n## CLI Usage\n\nRun the schema generator with npx:\n\n```bash\nnpx ts-json-schema-generator --path 'my/project/**/*.ts' --type 'My.Type.Name'\n```\n\nOr install the package and then run it\n\n```bash\nnpm install --save ts-json-schema-generator\n./node_modules/.bin/ts-json-schema-generator --path 'my/project/**/*.ts' --type 'My.Type.Name'\n```\n\nNote that different platforms (e.g. Windows) may use different path separators so you may have to adjust the command above.\n\nAlso note that you need to quote paths with `*` as otherwise the shell will expand the paths and therefore only pass the first path to the generator.\n\n## Programmatic Usage\n\n```js\n// main.js\n\nconst tsj = require(\"ts-json-schema-generator\");\nconst fs = require(\"fs\");\n\n/** @type {import('ts-json-schema-generator/dist/src/Config').Config} */\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst output_path = \"path/to/output/file\";\n\nconst schema = tsj.createGenerator(config).createSchema(config.type);\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\nRun the schema generator via `node main.js`.\n\n### Custom formatting\n\nExtending the built-in formatting is possible by creating a custom formatter and adding it to the main formatter:\n\n1. First we create a formatter, in this case for formatting function types:\n\n```ts\n// my-function-formatter.ts\nimport { BaseType, Definition, FunctionType, SubTypeFormatter } from \"ts-json-schema-generator\";\nimport ts from \"typescript\";\n\nexport class MyFunctionTypeFormatter implements SubTypeFormatter {\n    // You can skip this line if you don't need childTypeFormatter\n    public constructor(private childTypeFormatter: TypeFormatter) {}\n\n    public supportsType(type: FunctionType): boolean {\n        return type instanceof FunctionType;\n    }\n\n    public getDefinition(type: FunctionType): Definition {\n        // Return a custom schema for the function property.\n        return {\n            type: \"object\",\n            properties: {\n                isFunction: {\n                    type: \"boolean\",\n                    const: true,\n                },\n            },\n        };\n    }\n\n    // If this type does NOT HAVE children, generally all you need is:\n    public getChildren(type: FunctionType): BaseType[] {\n        return [];\n    }\n\n    // However, if children ARE supported, you'll need something similar to\n    // this (see src/TypeFormatter/{Array,Definition,etc}.ts for some examples):\n    public getChildren(type: FunctionType): BaseType[] {\n        return this.childTypeFormatter.getChildren(type.getType());\n    }\n}\n```\n\n2. Then we add the formatter as a child to the core formatter using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyFunctionTypeFormatter } from \"./my-function-formatter.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\n// We configure the formatter an add our custom formatter to it.\nconst formatter = createFormatter(config, (fmt, circularReferenceTypeFormatter) => {\n    // If your formatter DOES NOT support children, e.g. getChildren() { return [] }:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter());\n    // If your formatter DOES support children, you'll need this reference too:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter(circularReferenceTypeFormatter));\n});\n\nconst program = createProgram(config);\nconst parser = createParser(program, config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n### Custom parsing\n\nSimilar to custom formatting, extending the built-in parsing works practically the same way:\n\n1. First we create a parser, in this case for parsing construct types:\n\n```ts\n// my-constructor-parser.ts\nimport { Context, StringType, ReferenceType, BaseType, SubNodeParser } from \"ts-json-schema-generator\";\n// use typescript exported by TJS to avoid version conflict\nimport ts from \"ts-json-schema-generator\";\n\nexport class MyConstructorParser implements SubNodeParser {\n    supportsNode(node: ts.Node): boolean {\n        return node.kind === ts.SyntaxKind.ConstructorType;\n    }\n    createType(node: ts.Node, context: Context, reference?: ReferenceType): BaseType | undefined {\n        return new StringType(); // Treat constructors as strings in this example\n    }\n}\n```\n\n2. Then we add the parser as a child to the core parser using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyConstructorParser } from \"./my-constructor-parser.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst program = createProgram(config);\n\n// We configure the parser an add our custom parser to it.\nconst parser = createParser(program, config, (prs) => {\n    prs.addNodeParser(new MyConstructorParser());\n});\n\nconst formatter = createFormatter(config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n## Options\n\n```\n-p, --path 'index.ts'\n    The path to the TypeScript source file. If this is not provided, the type will be searched in the project specified in the `.tsconfig`.\n\n-t, --type 'My.Type.Name'\n    The type the generated schema will represent. If omitted, the generated schema will contain all\n    types found in the files matching path. The same is true if '*' is specified.\n\n-i, --id 'generatedSchemaId'\n    The `$id` of the generated schema. If omitted, there will be no `$id`.\n\n-e, --expose <all|none|export>\n    all: Create shared $ref definitions for all types.\n    none: Do not create shared $ref definitions.\n    export (default): Create shared $ref definitions only for exported types (not tagged as `@internal`).\n\n-f, --tsconfig 'my/project/tsconfig.json'\n    Use a custom tsconfig file for processing typescript (see https://www.typescriptlang.org/docs/handbook/tsconfig-json.html) instead of the default:\n    {\n        \"compilerOptions\": {\n            \"noEmit\": true,\n            \"emitDecoratorMetadata\": true,\n            \"experimentalDecorators\": true,\n            \"target\": \"ES5\",\n            \"module\": \"CommonJS\",\n            \"strictNullChecks\": false,\n        }\n    }\n\n-j, --jsDoc <extended|none|basic>\n    none: Do not use JsDoc annotations.\n    basic: Read JsDoc annotations to provide schema properties.\n    extended (default): Also read @nullable, and @asType annotations.\n\n--unstable\n    Do not sort properties.\n\n--strict-tuples\n    Do not allow additional items on tuples.\n\n--no-top-ref\n    Do not create a top-level $ref definition.\n\n--no-type-check\n    Skip type checks for better performance.\n\n--no-ref-encode\n    Do not encode references. According to the standard, references must be valid URIs but some tools do not support encoded references.\n\n--validation-keywords\n    Provide additional validation keywords to include.\n\n-o, --out\n    Specify the output file path. Without this option, the generator logs the response in the console.\n\n--additional-properties <true|false>\n    Controls whether or not to allow additional properties for objects that have no index signature.\n\n    true: Additional properties are allowed\n    false (default): Additional properties are not allowed\n\n--minify\n    Minify generated schema (default: false)\n```\n\n## Current state\n\n-   `interface` types\n-   `enum` types\n-   `union`, `tuple`, `type[]` types\n-   `Date`, `RegExp`, `URL` types\n-   `string`, `boolean`, `number` types\n-   `\"value\"`, `123`, `true`, `false`, `null`, `undefined` literals\n-   type aliases\n-   generics\n-   `typeof`\n-   `keyof`\n-   conditional types\n\n## Run locally\n\n`yarn --silent run run --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\n## Debug\n\n`yarn --silent run debug --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\nAnd connect via the debugger protocol.\n\n[AST Explorer](https://astexplorer.net/) is amazing for developers of this tool!\n\n## Publish\n\nPublishing is handled by a 2-branch [pre-release process](https://intuit.github.io/auto/docs/generated/shipit#next-branch-default), configured in `publish-auto.yml`. All changes should be based off the default `next` branch, and are published automatically.\n\n-   PRs made into the default branch are auto-deployed to the `next` pre-release tag on NPM. The result can be installed with `npm install ts-json-schema-generator@next`\n    -   When merging into `next`, please use the `squash and merge` strategy.\n-   To release a new stable version, open a PR from `next` into `stable` using this [compare link](https://github.com/vega/ts-json-schema-generator/compare/stable...next).\n    -   When merging from `next` into `stable`, please use the `create a merge commit` strategy.\n",
      "readmeFilename": "README.md",
      "gitHead": "488f9276df18f7b61e3877dc3fe214a10517bd61",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@1.2.1--canary.1710.488f927.0",
      "_nodeVersion": "18.16.0",
      "_npmVersion": "9.5.1",
      "dist": {
        "integrity": "sha512-WU9VC1xHOC+pl+vkk1ZsHjjuz/QhUcHdfBDz/8Q2TZUisK4ezFw7mCJWwsZEt6kdtd0eDh/wrTo2ZuQlwbjfXw==",
        "shasum": "ef12d17cd54a8ad5217c371458f324b0f551056d",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-1.2.1--canary.1710.488f927.0.tgz",
        "fileCount": 716,
        "unpackedSize": 889360,
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIBycdtO689Z59JytACrj+L7vU8RxBmy5OaAUMsBUkXFzAiEA3/JKAsog/0fBXXfwhq2YK26WoqgKqNBMFIKFCGQMRJ0="
          }
        ]
      },
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "maintainers": [
        {
          "name": "jheer",
          "email": "jeffrey.heer@gmail.com"
        },
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "kanitw",
          "email": "kanitw@gmail.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_1.2.1--canary.1710.488f927.0_1687716003791_0.8148678515202086"
      },
      "_hasShrinkwrap": false
    },
    "1.2.1--canary.1710.16eda00.0": {
      "name": "ts-json-schema-generator",
      "version": "1.2.1--canary.1710.16eda00.0",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "MooYeol Prescott Lee",
          "email": "mooyoul@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=10.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.12",
        "commander": "^11.0.0",
        "glob": "^10.3.0",
        "json5": "^2.2.3",
        "normalize-path": "^3.0.0",
        "safe-stable-stringify": "^2.4.3",
        "typescript": "~5.1.3"
      },
      "devDependencies": {
        "@auto-it/conventional-commits": "^10.46.0",
        "@auto-it/first-time-contributor": "^10.46.0",
        "@babel/core": "^7.22.5",
        "@babel/preset-env": "^7.22.5",
        "@babel/preset-typescript": "^7.22.5",
        "@types/glob": "^8.1.0",
        "@types/jest": "^29.5.2",
        "@types/node": "^20.3.1",
        "@types/normalize-path": "^3.0.0",
        "@typescript-eslint/eslint-plugin": "^5.60.0",
        "@typescript-eslint/parser": "^5.60.0",
        "ajv": "^8.12.0",
        "ajv-formats": "^2.1.1",
        "auto": "^10.46.0",
        "chai": "^4.3.7",
        "cross-env": "^7.0.3",
        "eslint": "^8.43.0",
        "eslint-config-prettier": "^8.8.0",
        "eslint-plugin-prettier": "^4.2.1",
        "jest": "^29.5.0",
        "jest-junit": "^16.0.0",
        "prettier": "^2.8.8",
        "ts-node": "^10.9.1",
        "vega": "^5.25.0",
        "vega-lite": "^5.11.0"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint \"{src,test,factory}/**/*.ts\"",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "cross-env FAST_TEST=1 jest test/ --verbose",
        "test:coverage": "yarn jest test/ --collectCoverage=true",
        "test:update": "cross-env UPDATE_SCHEMA=true yarn test:fast",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node-transpile-only ts-json-schema-generator.ts",
        "release": "yarn build && auto shipit"
      },
      "readme": "# ts-json-schema-generator\n\n![Test](https://github.com/vega/ts-json-schema-generator/workflows/Test/badge.svg)\n[![codecov](https://codecov.io/gh/vega/ts-json-schema-generator/branch/master/graph/badge.svg)](https://codecov.io/gh/vega/ts-json-schema-generator)\n[![npm version](https://img.shields.io/npm/v/ts-json-schema-generator.svg)](https://www.npmjs.com/package/ts-json-schema-generator)\n\nExtended version of [https://github.com/xiag-ag/typescript-to-json-schema](https://github.com/xiag-ag/typescript-to-json-schema).\n\nInspired by [`YousefED/typescript-json-schema`](https://github.com/YousefED/typescript-json-schema). Here's the differences list:\n\n-   this implementation avoids the use of `typeChecker.getTypeAtLocation()` (so probably it keeps correct type aliases)\n-   processing AST and formatting JSON schema have been split into two independent steps\n-   not exported types, interfaces, enums are not exposed in the `definitions` section in the JSON schema\n\n## Contributors\n\nThis project is made possible by a [community of contributors](https://github.com/vega/ts-json-schema-generator/graphs/contributors). We welcome contributions of any kind (issues, code, documentation, examples, tests,...). Please read our [code of conduct](https://vega.github.io/vega/about/code-of-conduct).\n\n## CLI Usage\n\nRun the schema generator with npx:\n\n```bash\nnpx ts-json-schema-generator --path 'my/project/**/*.ts' --type 'My.Type.Name'\n```\n\nOr install the package and then run it\n\n```bash\nnpm install --save ts-json-schema-generator\n./node_modules/.bin/ts-json-schema-generator --path 'my/project/**/*.ts' --type 'My.Type.Name'\n```\n\nNote that different platforms (e.g. Windows) may use different path separators so you may have to adjust the command above.\n\nAlso note that you need to quote paths with `*` as otherwise the shell will expand the paths and therefore only pass the first path to the generator.\n\n## Programmatic Usage\n\n```js\n// main.js\n\nconst tsj = require(\"ts-json-schema-generator\");\nconst fs = require(\"fs\");\n\n/** @type {import('ts-json-schema-generator/dist/src/Config').Config} */\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst output_path = \"path/to/output/file\";\n\nconst schema = tsj.createGenerator(config).createSchema(config.type);\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\nRun the schema generator via `node main.js`.\n\n### Custom formatting\n\nExtending the built-in formatting is possible by creating a custom formatter and adding it to the main formatter:\n\n1. First we create a formatter, in this case for formatting function types:\n\n```ts\n// my-function-formatter.ts\nimport { BaseType, Definition, FunctionType, SubTypeFormatter } from \"ts-json-schema-generator\";\nimport ts from \"typescript\";\n\nexport class MyFunctionTypeFormatter implements SubTypeFormatter {\n    // You can skip this line if you don't need childTypeFormatter\n    public constructor(private childTypeFormatter: TypeFormatter) {}\n\n    public supportsType(type: FunctionType): boolean {\n        return type instanceof FunctionType;\n    }\n\n    public getDefinition(type: FunctionType): Definition {\n        // Return a custom schema for the function property.\n        return {\n            type: \"object\",\n            properties: {\n                isFunction: {\n                    type: \"boolean\",\n                    const: true,\n                },\n            },\n        };\n    }\n\n    // If this type does NOT HAVE children, generally all you need is:\n    public getChildren(type: FunctionType): BaseType[] {\n        return [];\n    }\n\n    // However, if children ARE supported, you'll need something similar to\n    // this (see src/TypeFormatter/{Array,Definition,etc}.ts for some examples):\n    public getChildren(type: FunctionType): BaseType[] {\n        return this.childTypeFormatter.getChildren(type.getType());\n    }\n}\n```\n\n2. Then we add the formatter as a child to the core formatter using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyFunctionTypeFormatter } from \"./my-function-formatter.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\n// We configure the formatter an add our custom formatter to it.\nconst formatter = createFormatter(config, (fmt, circularReferenceTypeFormatter) => {\n    // If your formatter DOES NOT support children, e.g. getChildren() { return [] }:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter());\n    // If your formatter DOES support children, you'll need this reference too:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter(circularReferenceTypeFormatter));\n});\n\nconst program = createProgram(config);\nconst parser = createParser(program, config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n### Custom parsing\n\nSimilar to custom formatting, extending the built-in parsing works practically the same way:\n\n1. First we create a parser, in this case for parsing construct types:\n\n```ts\n// my-constructor-parser.ts\nimport { Context, StringType, ReferenceType, BaseType, SubNodeParser } from \"ts-json-schema-generator\";\n// use typescript exported by TJS to avoid version conflict\nimport ts from \"ts-json-schema-generator\";\n\nexport class MyConstructorParser implements SubNodeParser {\n    supportsNode(node: ts.Node): boolean {\n        return node.kind === ts.SyntaxKind.ConstructorType;\n    }\n    createType(node: ts.Node, context: Context, reference?: ReferenceType): BaseType | undefined {\n        return new StringType(); // Treat constructors as strings in this example\n    }\n}\n```\n\n2. Then we add the parser as a child to the core parser using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyConstructorParser } from \"./my-constructor-parser.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst program = createProgram(config);\n\n// We configure the parser an add our custom parser to it.\nconst parser = createParser(program, config, (prs) => {\n    prs.addNodeParser(new MyConstructorParser());\n});\n\nconst formatter = createFormatter(config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n## Options\n\n```\n-p, --path 'index.ts'\n    The path to the TypeScript source file. If this is not provided, the type will be searched in the project specified in the `.tsconfig`.\n\n-t, --type 'My.Type.Name'\n    The type the generated schema will represent. If omitted, the generated schema will contain all\n    types found in the files matching path. The same is true if '*' is specified.\n\n-i, --id 'generatedSchemaId'\n    The `$id` of the generated schema. If omitted, there will be no `$id`.\n\n-e, --expose <all|none|export>\n    all: Create shared $ref definitions for all types.\n    none: Do not create shared $ref definitions.\n    export (default): Create shared $ref definitions only for exported types (not tagged as `@internal`).\n\n-f, --tsconfig 'my/project/tsconfig.json'\n    Use a custom tsconfig file for processing typescript (see https://www.typescriptlang.org/docs/handbook/tsconfig-json.html) instead of the default:\n    {\n        \"compilerOptions\": {\n            \"noEmit\": true,\n            \"emitDecoratorMetadata\": true,\n            \"experimentalDecorators\": true,\n            \"target\": \"ES5\",\n            \"module\": \"CommonJS\",\n            \"strictNullChecks\": false,\n        }\n    }\n\n-j, --jsDoc <extended|none|basic>\n    none: Do not use JsDoc annotations.\n    basic: Read JsDoc annotations to provide schema properties.\n    extended (default): Also read @nullable, and @asType annotations.\n\n--unstable\n    Do not sort properties.\n\n--strict-tuples\n    Do not allow additional items on tuples.\n\n--no-top-ref\n    Do not create a top-level $ref definition.\n\n--no-type-check\n    Skip type checks for better performance.\n\n--no-ref-encode\n    Do not encode references. According to the standard, references must be valid URIs but some tools do not support encoded references.\n\n--validation-keywords\n    Provide additional validation keywords to include.\n\n-o, --out\n    Specify the output file path. Without this option, the generator logs the response in the console.\n\n--additional-properties <true|false>\n    Controls whether or not to allow additional properties for objects that have no index signature.\n\n    true: Additional properties are allowed\n    false (default): Additional properties are not allowed\n\n--minify\n    Minify generated schema (default: false)\n```\n\n## Current state\n\n-   `interface` types\n-   `enum` types\n-   `union`, `tuple`, `type[]` types\n-   `Date`, `RegExp`, `URL` types\n-   `string`, `boolean`, `number` types\n-   `\"value\"`, `123`, `true`, `false`, `null`, `undefined` literals\n-   type aliases\n-   generics\n-   `typeof`\n-   `keyof`\n-   conditional types\n\n## Run locally\n\n`yarn --silent run run --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\n## Debug\n\n`yarn --silent run debug --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\nAnd connect via the debugger protocol.\n\n[AST Explorer](https://astexplorer.net/) is amazing for developers of this tool!\n\n## Publish\n\nPublishing is handled by a 2-branch [pre-release process](https://intuit.github.io/auto/docs/generated/shipit#next-branch-default), configured in `publish-auto.yml`. All changes should be based off the default `next` branch, and are published automatically.\n\n-   PRs made into the default branch are auto-deployed to the `next` pre-release tag on NPM. The result can be installed with `npm install ts-json-schema-generator@next`\n    -   When merging into `next`, please use the `squash and merge` strategy.\n-   To release a new stable version, open a PR from `next` into `stable` using this [compare link](https://github.com/vega/ts-json-schema-generator/compare/stable...next).\n    -   When merging from `next` into `stable`, please use the `create a merge commit` strategy.\n",
      "readmeFilename": "README.md",
      "gitHead": "16eda00fa92baa8c4fda62f3f19ce563b7e2aea6",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@1.2.1--canary.1710.16eda00.0",
      "_nodeVersion": "18.16.0",
      "_npmVersion": "9.5.1",
      "dist": {
        "integrity": "sha512-bfIatZJVTc60HDoxH4Meoy7ri5erN6PvKOidwKYTmWXUzVLNPX0XQQpgP789/KpE5JUsf6O1eGpPXg6P7/PJPg==",
        "shasum": "64601c3fba321bdf09bf091196161247f1c95230",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-1.2.1--canary.1710.16eda00.0.tgz",
        "fileCount": 716,
        "unpackedSize": 889360,
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIQDI1t/k6gJ+MfHO3vPy1AAUj7L1ckY5DLwXKdM7xzL74gIgL+QT/9Unm6pmQU4BvrPygT13qJra2IwZMkSnfiDAcpE="
          }
        ]
      },
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "maintainers": [
        {
          "name": "jheer",
          "email": "jeffrey.heer@gmail.com"
        },
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "kanitw",
          "email": "kanitw@gmail.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_1.2.1--canary.1710.16eda00.0_1687729913019_0.7217126965253613"
      },
      "_hasShrinkwrap": false
    },
    "1.2.1--canary.1710.2f8374c.0": {
      "name": "ts-json-schema-generator",
      "version": "1.2.1--canary.1710.2f8374c.0",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "MooYeol Prescott Lee",
          "email": "mooyoul@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=10.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.12",
        "commander": "^11.0.0",
        "glob": "^8.0.3",
        "json5": "^2.2.3",
        "normalize-path": "^3.0.0",
        "safe-stable-stringify": "^2.4.3",
        "typescript": "~5.1.3"
      },
      "devDependencies": {
        "@auto-it/conventional-commits": "^10.46.0",
        "@auto-it/first-time-contributor": "^10.46.0",
        "@babel/core": "^7.22.5",
        "@babel/preset-env": "^7.22.5",
        "@babel/preset-typescript": "^7.22.5",
        "@types/glob": "^8.1.0",
        "@types/jest": "^29.5.2",
        "@types/node": "^20.3.1",
        "@types/normalize-path": "^3.0.0",
        "@typescript-eslint/eslint-plugin": "^5.60.0",
        "@typescript-eslint/parser": "^5.60.0",
        "ajv": "^8.12.0",
        "ajv-formats": "^2.1.1",
        "auto": "^10.46.0",
        "chai": "^4.3.7",
        "cross-env": "^7.0.3",
        "eslint": "^8.43.0",
        "eslint-config-prettier": "^8.8.0",
        "eslint-plugin-prettier": "^4.2.1",
        "jest": "^29.5.0",
        "jest-junit": "^16.0.0",
        "prettier": "^2.8.8",
        "ts-node": "^10.9.1",
        "vega": "^5.25.0",
        "vega-lite": "^5.11.0"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint \"{src,test,factory}/**/*.ts\"",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "cross-env FAST_TEST=1 jest test/ --verbose",
        "test:coverage": "yarn jest test/ --collectCoverage=true",
        "test:update": "cross-env UPDATE_SCHEMA=true yarn test:fast",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node-transpile-only ts-json-schema-generator.ts",
        "release": "yarn build && auto shipit"
      },
      "readme": "# ts-json-schema-generator\n\n![Test](https://github.com/vega/ts-json-schema-generator/workflows/Test/badge.svg)\n[![codecov](https://codecov.io/gh/vega/ts-json-schema-generator/branch/master/graph/badge.svg)](https://codecov.io/gh/vega/ts-json-schema-generator)\n[![npm version](https://img.shields.io/npm/v/ts-json-schema-generator.svg)](https://www.npmjs.com/package/ts-json-schema-generator)\n\nExtended version of [https://github.com/xiag-ag/typescript-to-json-schema](https://github.com/xiag-ag/typescript-to-json-schema).\n\nInspired by [`YousefED/typescript-json-schema`](https://github.com/YousefED/typescript-json-schema). Here's the differences list:\n\n-   this implementation avoids the use of `typeChecker.getTypeAtLocation()` (so probably it keeps correct type aliases)\n-   processing AST and formatting JSON schema have been split into two independent steps\n-   not exported types, interfaces, enums are not exposed in the `definitions` section in the JSON schema\n\n## Contributors\n\nThis project is made possible by a [community of contributors](https://github.com/vega/ts-json-schema-generator/graphs/contributors). We welcome contributions of any kind (issues, code, documentation, examples, tests,...). Please read our [code of conduct](https://vega.github.io/vega/about/code-of-conduct).\n\n## CLI Usage\n\nRun the schema generator with npx:\n\n```bash\nnpx ts-json-schema-generator --path 'my/project/**/*.ts' --type 'My.Type.Name'\n```\n\nOr install the package and then run it\n\n```bash\nnpm install --save ts-json-schema-generator\n./node_modules/.bin/ts-json-schema-generator --path 'my/project/**/*.ts' --type 'My.Type.Name'\n```\n\nNote that different platforms (e.g. Windows) may use different path separators so you may have to adjust the command above.\n\nAlso note that you need to quote paths with `*` as otherwise the shell will expand the paths and therefore only pass the first path to the generator.\n\n## Programmatic Usage\n\n```js\n// main.js\n\nconst tsj = require(\"ts-json-schema-generator\");\nconst fs = require(\"fs\");\n\n/** @type {import('ts-json-schema-generator/dist/src/Config').Config} */\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst output_path = \"path/to/output/file\";\n\nconst schema = tsj.createGenerator(config).createSchema(config.type);\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\nRun the schema generator via `node main.js`.\n\n### Custom formatting\n\nExtending the built-in formatting is possible by creating a custom formatter and adding it to the main formatter:\n\n1. First we create a formatter, in this case for formatting function types:\n\n```ts\n// my-function-formatter.ts\nimport { BaseType, Definition, FunctionType, SubTypeFormatter } from \"ts-json-schema-generator\";\nimport ts from \"typescript\";\n\nexport class MyFunctionTypeFormatter implements SubTypeFormatter {\n    // You can skip this line if you don't need childTypeFormatter\n    public constructor(private childTypeFormatter: TypeFormatter) {}\n\n    public supportsType(type: FunctionType): boolean {\n        return type instanceof FunctionType;\n    }\n\n    public getDefinition(type: FunctionType): Definition {\n        // Return a custom schema for the function property.\n        return {\n            type: \"object\",\n            properties: {\n                isFunction: {\n                    type: \"boolean\",\n                    const: true,\n                },\n            },\n        };\n    }\n\n    // If this type does NOT HAVE children, generally all you need is:\n    public getChildren(type: FunctionType): BaseType[] {\n        return [];\n    }\n\n    // However, if children ARE supported, you'll need something similar to\n    // this (see src/TypeFormatter/{Array,Definition,etc}.ts for some examples):\n    public getChildren(type: FunctionType): BaseType[] {\n        return this.childTypeFormatter.getChildren(type.getType());\n    }\n}\n```\n\n2. Then we add the formatter as a child to the core formatter using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyFunctionTypeFormatter } from \"./my-function-formatter.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\n// We configure the formatter an add our custom formatter to it.\nconst formatter = createFormatter(config, (fmt, circularReferenceTypeFormatter) => {\n    // If your formatter DOES NOT support children, e.g. getChildren() { return [] }:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter());\n    // If your formatter DOES support children, you'll need this reference too:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter(circularReferenceTypeFormatter));\n});\n\nconst program = createProgram(config);\nconst parser = createParser(program, config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n### Custom parsing\n\nSimilar to custom formatting, extending the built-in parsing works practically the same way:\n\n1. First we create a parser, in this case for parsing construct types:\n\n```ts\n// my-constructor-parser.ts\nimport { Context, StringType, ReferenceType, BaseType, SubNodeParser } from \"ts-json-schema-generator\";\n// use typescript exported by TJS to avoid version conflict\nimport ts from \"ts-json-schema-generator\";\n\nexport class MyConstructorParser implements SubNodeParser {\n    supportsNode(node: ts.Node): boolean {\n        return node.kind === ts.SyntaxKind.ConstructorType;\n    }\n    createType(node: ts.Node, context: Context, reference?: ReferenceType): BaseType | undefined {\n        return new StringType(); // Treat constructors as strings in this example\n    }\n}\n```\n\n2. Then we add the parser as a child to the core parser using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyConstructorParser } from \"./my-constructor-parser.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst program = createProgram(config);\n\n// We configure the parser an add our custom parser to it.\nconst parser = createParser(program, config, (prs) => {\n    prs.addNodeParser(new MyConstructorParser());\n});\n\nconst formatter = createFormatter(config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n## Options\n\n```\n-p, --path 'index.ts'\n    The path to the TypeScript source file. If this is not provided, the type will be searched in the project specified in the `.tsconfig`.\n\n-t, --type 'My.Type.Name'\n    The type the generated schema will represent. If omitted, the generated schema will contain all\n    types found in the files matching path. The same is true if '*' is specified.\n\n-i, --id 'generatedSchemaId'\n    The `$id` of the generated schema. If omitted, there will be no `$id`.\n\n-e, --expose <all|none|export>\n    all: Create shared $ref definitions for all types.\n    none: Do not create shared $ref definitions.\n    export (default): Create shared $ref definitions only for exported types (not tagged as `@internal`).\n\n-f, --tsconfig 'my/project/tsconfig.json'\n    Use a custom tsconfig file for processing typescript (see https://www.typescriptlang.org/docs/handbook/tsconfig-json.html) instead of the default:\n    {\n        \"compilerOptions\": {\n            \"noEmit\": true,\n            \"emitDecoratorMetadata\": true,\n            \"experimentalDecorators\": true,\n            \"target\": \"ES5\",\n            \"module\": \"CommonJS\",\n            \"strictNullChecks\": false,\n        }\n    }\n\n-j, --jsDoc <extended|none|basic>\n    none: Do not use JsDoc annotations.\n    basic: Read JsDoc annotations to provide schema properties.\n    extended (default): Also read @nullable, and @asType annotations.\n\n--unstable\n    Do not sort properties.\n\n--strict-tuples\n    Do not allow additional items on tuples.\n\n--no-top-ref\n    Do not create a top-level $ref definition.\n\n--no-type-check\n    Skip type checks for better performance.\n\n--no-ref-encode\n    Do not encode references. According to the standard, references must be valid URIs but some tools do not support encoded references.\n\n--validation-keywords\n    Provide additional validation keywords to include.\n\n-o, --out\n    Specify the output file path. Without this option, the generator logs the response in the console.\n\n--additional-properties <true|false>\n    Controls whether or not to allow additional properties for objects that have no index signature.\n\n    true: Additional properties are allowed\n    false (default): Additional properties are not allowed\n\n--minify\n    Minify generated schema (default: false)\n```\n\n## Current state\n\n-   `interface` types\n-   `enum` types\n-   `union`, `tuple`, `type[]` types\n-   `Date`, `RegExp`, `URL` types\n-   `string`, `boolean`, `number` types\n-   `\"value\"`, `123`, `true`, `false`, `null`, `undefined` literals\n-   type aliases\n-   generics\n-   `typeof`\n-   `keyof`\n-   conditional types\n\n## Run locally\n\n`yarn --silent run run --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\n## Debug\n\n`yarn --silent run debug --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\nAnd connect via the debugger protocol.\n\n[AST Explorer](https://astexplorer.net/) is amazing for developers of this tool!\n\n## Publish\n\nPublishing is handled by a 2-branch [pre-release process](https://intuit.github.io/auto/docs/generated/shipit#next-branch-default), configured in `publish-auto.yml`. All changes should be based off the default `next` branch, and are published automatically.\n\n-   PRs made into the default branch are auto-deployed to the `next` pre-release tag on NPM. The result can be installed with `npm install ts-json-schema-generator@next`\n    -   When merging into `next`, please use the `squash and merge` strategy.\n-   To release a new stable version, open a PR from `next` into `stable` using this [compare link](https://github.com/vega/ts-json-schema-generator/compare/stable...next).\n    -   When merging from `next` into `stable`, please use the `create a merge commit` strategy.\n",
      "readmeFilename": "README.md",
      "gitHead": "2f8374c6a20b06b1087ad34a73c90a8e945dff4d",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@1.2.1--canary.1710.2f8374c.0",
      "_nodeVersion": "18.16.0",
      "_npmVersion": "9.5.1",
      "dist": {
        "integrity": "sha512-p15qRgvJRrH6pzQTCDosxPyJM5kfRJSkrt73mF5tADLDQGA6I/T+dkvSf/nlMh/lKNd/PYxKnpQ7qVLikiEpow==",
        "shasum": "cbbad895cb3a8177e9ad2b2035bf2318f91ea742",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-1.2.1--canary.1710.2f8374c.0.tgz",
        "fileCount": 716,
        "unpackedSize": 887119,
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIDhUIFmBrzW2yBoZRZ9ck7OUAGhLjs/FtyxyzK6I9rsHAiEA44gcywl6ygU3AaBA9GVVX0hHHAwlIiMnuCceCJbqxvY="
          }
        ]
      },
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "maintainers": [
        {
          "name": "jheer",
          "email": "jeffrey.heer@gmail.com"
        },
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "kanitw",
          "email": "kanitw@gmail.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_1.2.1--canary.1710.2f8374c.0_1687730822553_0.8382741885804363"
      },
      "_hasShrinkwrap": false
    },
    "1.3.0-next.6": {
      "name": "ts-json-schema-generator",
      "version": "1.3.0-next.6",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "MooYeol Prescott Lee",
          "email": "mooyoul@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=10.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.12",
        "commander": "^11.0.0",
        "glob": "^8.0.3",
        "json5": "^2.2.3",
        "normalize-path": "^3.0.0",
        "safe-stable-stringify": "^2.4.3",
        "typescript": "~5.1.3"
      },
      "devDependencies": {
        "@auto-it/conventional-commits": "^10.46.0",
        "@auto-it/first-time-contributor": "^10.46.0",
        "@babel/core": "^7.22.5",
        "@babel/preset-env": "^7.22.5",
        "@babel/preset-typescript": "^7.22.5",
        "@types/glob": "^8.1.0",
        "@types/jest": "^29.5.2",
        "@types/node": "^20.3.1",
        "@types/normalize-path": "^3.0.0",
        "@typescript-eslint/eslint-plugin": "^5.60.0",
        "@typescript-eslint/parser": "^5.60.0",
        "ajv": "^8.12.0",
        "ajv-formats": "^2.1.1",
        "auto": "^10.46.0",
        "chai": "^4.3.7",
        "cross-env": "^7.0.3",
        "eslint": "^8.43.0",
        "eslint-config-prettier": "^8.8.0",
        "eslint-plugin-prettier": "^4.2.1",
        "jest": "^29.5.0",
        "jest-junit": "^16.0.0",
        "prettier": "^2.8.8",
        "ts-node": "^10.9.1",
        "vega": "^5.25.0",
        "vega-lite": "^5.11.0"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint \"{src,test,factory}/**/*.ts\"",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "cross-env FAST_TEST=1 jest test/ --verbose",
        "test:coverage": "yarn jest test/ --collectCoverage=true",
        "test:update": "cross-env UPDATE_SCHEMA=true yarn test:fast",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node-transpile-only ts-json-schema-generator.ts",
        "release": "yarn build && auto shipit"
      },
      "readme": "# ts-json-schema-generator\n\n![Test](https://github.com/vega/ts-json-schema-generator/workflows/Test/badge.svg)\n[![codecov](https://codecov.io/gh/vega/ts-json-schema-generator/branch/master/graph/badge.svg)](https://codecov.io/gh/vega/ts-json-schema-generator)\n[![npm version](https://img.shields.io/npm/v/ts-json-schema-generator.svg)](https://www.npmjs.com/package/ts-json-schema-generator)\n\nExtended version of [https://github.com/xiag-ag/typescript-to-json-schema](https://github.com/xiag-ag/typescript-to-json-schema).\n\nInspired by [`YousefED/typescript-json-schema`](https://github.com/YousefED/typescript-json-schema). Here's the differences list:\n\n-   this implementation avoids the use of `typeChecker.getTypeAtLocation()` (so probably it keeps correct type aliases)\n-   processing AST and formatting JSON schema have been split into two independent steps\n-   not exported types, interfaces, enums are not exposed in the `definitions` section in the JSON schema\n\n## Contributors\n\nThis project is made possible by a [community of contributors](https://github.com/vega/ts-json-schema-generator/graphs/contributors). We welcome contributions of any kind (issues, code, documentation, examples, tests,...). Please read our [code of conduct](https://vega.github.io/vega/about/code-of-conduct).\n\n## CLI Usage\n\nRun the schema generator with npx:\n\n```bash\nnpx ts-json-schema-generator --path 'my/project/**/*.ts' --type 'My.Type.Name'\n```\n\nOr install the package and then run it\n\n```bash\nnpm install --save ts-json-schema-generator\n./node_modules/.bin/ts-json-schema-generator --path 'my/project/**/*.ts' --type 'My.Type.Name'\n```\n\nNote that different platforms (e.g. Windows) may use different path separators so you may have to adjust the command above.\n\nAlso note that you need to quote paths with `*` as otherwise the shell will expand the paths and therefore only pass the first path to the generator.\n\n## Programmatic Usage\n\n```js\n// main.js\n\nconst tsj = require(\"ts-json-schema-generator\");\nconst fs = require(\"fs\");\n\n/** @type {import('ts-json-schema-generator/dist/src/Config').Config} */\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst output_path = \"path/to/output/file\";\n\nconst schema = tsj.createGenerator(config).createSchema(config.type);\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\nRun the schema generator via `node main.js`.\n\n### Custom formatting\n\nExtending the built-in formatting is possible by creating a custom formatter and adding it to the main formatter:\n\n1. First we create a formatter, in this case for formatting function types:\n\n```ts\n// my-function-formatter.ts\nimport { BaseType, Definition, FunctionType, SubTypeFormatter } from \"ts-json-schema-generator\";\nimport ts from \"typescript\";\n\nexport class MyFunctionTypeFormatter implements SubTypeFormatter {\n    // You can skip this line if you don't need childTypeFormatter\n    public constructor(private childTypeFormatter: TypeFormatter) {}\n\n    public supportsType(type: FunctionType): boolean {\n        return type instanceof FunctionType;\n    }\n\n    public getDefinition(type: FunctionType): Definition {\n        // Return a custom schema for the function property.\n        return {\n            type: \"object\",\n            properties: {\n                isFunction: {\n                    type: \"boolean\",\n                    const: true,\n                },\n            },\n        };\n    }\n\n    // If this type does NOT HAVE children, generally all you need is:\n    public getChildren(type: FunctionType): BaseType[] {\n        return [];\n    }\n\n    // However, if children ARE supported, you'll need something similar to\n    // this (see src/TypeFormatter/{Array,Definition,etc}.ts for some examples):\n    public getChildren(type: FunctionType): BaseType[] {\n        return this.childTypeFormatter.getChildren(type.getType());\n    }\n}\n```\n\n2. Then we add the formatter as a child to the core formatter using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyFunctionTypeFormatter } from \"./my-function-formatter.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\n// We configure the formatter an add our custom formatter to it.\nconst formatter = createFormatter(config, (fmt, circularReferenceTypeFormatter) => {\n    // If your formatter DOES NOT support children, e.g. getChildren() { return [] }:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter());\n    // If your formatter DOES support children, you'll need this reference too:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter(circularReferenceTypeFormatter));\n});\n\nconst program = createProgram(config);\nconst parser = createParser(program, config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n### Custom parsing\n\nSimilar to custom formatting, extending the built-in parsing works practically the same way:\n\n1. First we create a parser, in this case for parsing construct types:\n\n```ts\n// my-constructor-parser.ts\nimport { Context, StringType, ReferenceType, BaseType, SubNodeParser } from \"ts-json-schema-generator\";\n// use typescript exported by TJS to avoid version conflict\nimport ts from \"ts-json-schema-generator\";\n\nexport class MyConstructorParser implements SubNodeParser {\n    supportsNode(node: ts.Node): boolean {\n        return node.kind === ts.SyntaxKind.ConstructorType;\n    }\n    createType(node: ts.Node, context: Context, reference?: ReferenceType): BaseType | undefined {\n        return new StringType(); // Treat constructors as strings in this example\n    }\n}\n```\n\n2. Then we add the parser as a child to the core parser using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyConstructorParser } from \"./my-constructor-parser.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst program = createProgram(config);\n\n// We configure the parser an add our custom parser to it.\nconst parser = createParser(program, config, (prs) => {\n    prs.addNodeParser(new MyConstructorParser());\n});\n\nconst formatter = createFormatter(config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n## Options\n\n```\n-p, --path 'index.ts'\n    The path to the TypeScript source file. If this is not provided, the type will be searched in the project specified in the `.tsconfig`.\n\n-t, --type 'My.Type.Name'\n    The type the generated schema will represent. If omitted, the generated schema will contain all\n    types found in the files matching path. The same is true if '*' is specified.\n\n-i, --id 'generatedSchemaId'\n    The `$id` of the generated schema. If omitted, there will be no `$id`.\n\n-e, --expose <all|none|export>\n    all: Create shared $ref definitions for all types.\n    none: Do not create shared $ref definitions.\n    export (default): Create shared $ref definitions only for exported types (not tagged as `@internal`).\n\n-f, --tsconfig 'my/project/tsconfig.json'\n    Use a custom tsconfig file for processing typescript (see https://www.typescriptlang.org/docs/handbook/tsconfig-json.html) instead of the default:\n    {\n        \"compilerOptions\": {\n            \"noEmit\": true,\n            \"emitDecoratorMetadata\": true,\n            \"experimentalDecorators\": true,\n            \"target\": \"ES5\",\n            \"module\": \"CommonJS\",\n            \"strictNullChecks\": false,\n        }\n    }\n\n-j, --jsDoc <extended|none|basic>\n    none: Do not use JsDoc annotations.\n    basic: Read JsDoc annotations to provide schema properties.\n    extended (default): Also read @nullable, and @asType annotations.\n\n--unstable\n    Do not sort properties.\n\n--strict-tuples\n    Do not allow additional items on tuples.\n\n--no-top-ref\n    Do not create a top-level $ref definition.\n\n--no-type-check\n    Skip type checks for better performance.\n\n--no-ref-encode\n    Do not encode references. According to the standard, references must be valid URIs but some tools do not support encoded references.\n\n--validation-keywords\n    Provide additional validation keywords to include.\n\n-o, --out\n    Specify the output file path. Without this option, the generator logs the response in the console.\n\n--additional-properties <true|false>\n    Controls whether or not to allow additional properties for objects that have no index signature.\n\n    true: Additional properties are allowed\n    false (default): Additional properties are not allowed\n\n--minify\n    Minify generated schema (default: false)\n```\n\n## Current state\n\n-   `interface` types\n-   `enum` types\n-   `union`, `tuple`, `type[]` types\n-   `Date`, `RegExp`, `URL` types\n-   `string`, `boolean`, `number` types\n-   `\"value\"`, `123`, `true`, `false`, `null`, `undefined` literals\n-   type aliases\n-   generics\n-   `typeof`\n-   `keyof`\n-   conditional types\n\n## Run locally\n\n`yarn --silent run run --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\n## Debug\n\n`yarn --silent run debug --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\nAnd connect via the debugger protocol.\n\n[AST Explorer](https://astexplorer.net/) is amazing for developers of this tool!\n\n## Publish\n\nPublishing is handled by a 2-branch [pre-release process](https://intuit.github.io/auto/docs/generated/shipit#next-branch-default), configured in `publish-auto.yml`. All changes should be based off the default `next` branch, and are published automatically.\n\n-   PRs made into the default branch are auto-deployed to the `next` pre-release tag on NPM. The result can be installed with `npm install ts-json-schema-generator@next`\n    -   When merging into `next`, please use the `squash and merge` strategy.\n-   To release a new stable version, open a PR from `next` into `stable` using this [compare link](https://github.com/vega/ts-json-schema-generator/compare/stable...next).\n    -   When merging from `next` into `stable`, please use the `create a merge commit` strategy.\n",
      "readmeFilename": "README.md",
      "gitHead": "1e4efa8b309786e7849a65c0ffda0fd793eab9c6",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@1.3.0-next.6",
      "_nodeVersion": "18.16.0",
      "_npmVersion": "9.5.1",
      "dist": {
        "integrity": "sha512-5oEOr1Qf/lSbyMJ/G4Wd7vgluaTAf0gQe5Ii3ejOKhaw7ZIoDAg6sahkZBGmpBG/RAU1xeWNieIH0LtVyRaTWg==",
        "shasum": "feefd8e23dfe133645cb26de9d6512814a838790",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-1.3.0-next.6.tgz",
        "fileCount": 716,
        "unpackedSize": 887087,
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIQCCUkNP50VAgBjdDnpxtBscN4XWiXMIL/dBOq/2Xc+puQIgBXshk7bofP3kV9R1Z+eAJtt3D75AyEkrU7JanuYwN8w="
          }
        ]
      },
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "maintainers": [
        {
          "name": "jheer",
          "email": "jeffrey.heer@gmail.com"
        },
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "kanitw",
          "email": "kanitw@gmail.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_1.3.0-next.6_1687731995458_0.3448821184204365"
      },
      "_hasShrinkwrap": false
    },
    "1.3.0-next.7": {
      "name": "ts-json-schema-generator",
      "version": "1.3.0-next.7",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "MooYeol Prescott Lee",
          "email": "mooyoul@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=10.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.12",
        "commander": "^11.0.0",
        "glob": "^8.0.3",
        "json5": "^2.2.3",
        "normalize-path": "^3.0.0",
        "safe-stable-stringify": "^2.4.3",
        "typescript": "~5.1.3"
      },
      "devDependencies": {
        "@auto-it/conventional-commits": "^10.46.0",
        "@auto-it/first-time-contributor": "^10.46.0",
        "@babel/core": "^7.22.5",
        "@babel/preset-env": "^7.22.5",
        "@babel/preset-typescript": "^7.22.5",
        "@types/glob": "^8.1.0",
        "@types/jest": "^29.5.2",
        "@types/node": "^20.3.1",
        "@types/normalize-path": "^3.0.0",
        "@typescript-eslint/eslint-plugin": "^5.60.0",
        "@typescript-eslint/parser": "^5.60.0",
        "ajv": "^8.12.0",
        "ajv-formats": "^2.1.1",
        "auto": "^10.46.0",
        "chai": "^4.3.7",
        "cross-env": "^7.0.3",
        "eslint": "^8.43.0",
        "eslint-config-prettier": "^8.8.0",
        "eslint-plugin-prettier": "^4.2.1",
        "jest": "^29.5.0",
        "jest-junit": "^16.0.0",
        "prettier": "^2.8.8",
        "ts-node": "^10.9.1",
        "vega": "^5.25.0",
        "vega-lite": "^5.11.0"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint \"{src,test,factory}/**/*.ts\"",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "cross-env FAST_TEST=1 jest test/ --verbose",
        "test:coverage": "yarn jest test/ --collectCoverage=true",
        "test:update": "cross-env UPDATE_SCHEMA=true yarn test:fast",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node-transpile-only ts-json-schema-generator.ts",
        "release": "yarn build && auto shipit"
      },
      "readme": "# ts-json-schema-generator\n\n![Test](https://github.com/vega/ts-json-schema-generator/workflows/Test/badge.svg)\n[![codecov](https://codecov.io/gh/vega/ts-json-schema-generator/branch/master/graph/badge.svg)](https://codecov.io/gh/vega/ts-json-schema-generator)\n[![npm version](https://img.shields.io/npm/v/ts-json-schema-generator.svg)](https://www.npmjs.com/package/ts-json-schema-generator)\n\nExtended version of [https://github.com/xiag-ag/typescript-to-json-schema](https://github.com/xiag-ag/typescript-to-json-schema).\n\nInspired by [`YousefED/typescript-json-schema`](https://github.com/YousefED/typescript-json-schema). Here's the differences list:\n\n-   this implementation avoids the use of `typeChecker.getTypeAtLocation()` (so probably it keeps correct type aliases)\n-   processing AST and formatting JSON schema have been split into two independent steps\n-   not exported types, interfaces, enums are not exposed in the `definitions` section in the JSON schema\n\n## Contributors\n\nThis project is made possible by a [community of contributors](https://github.com/vega/ts-json-schema-generator/graphs/contributors). We welcome contributions of any kind (issues, code, documentation, examples, tests,...). Please read our [code of conduct](https://vega.github.io/vega/about/code-of-conduct).\n\n## CLI Usage\n\nRun the schema generator with npx:\n\n```bash\nnpx ts-json-schema-generator --path 'my/project/**/*.ts' --type 'My.Type.Name'\n```\n\nOr install the package and then run it\n\n```bash\nnpm install --save ts-json-schema-generator\n./node_modules/.bin/ts-json-schema-generator --path 'my/project/**/*.ts' --type 'My.Type.Name'\n```\n\nNote that different platforms (e.g. Windows) may use different path separators so you may have to adjust the command above.\n\nAlso note that you need to quote paths with `*` as otherwise the shell will expand the paths and therefore only pass the first path to the generator.\n\n## Programmatic Usage\n\n```js\n// main.js\n\nconst tsj = require(\"ts-json-schema-generator\");\nconst fs = require(\"fs\");\n\n/** @type {import('ts-json-schema-generator/dist/src/Config').Config} */\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst output_path = \"path/to/output/file\";\n\nconst schema = tsj.createGenerator(config).createSchema(config.type);\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\nRun the schema generator via `node main.js`.\n\n### Custom formatting\n\nExtending the built-in formatting is possible by creating a custom formatter and adding it to the main formatter:\n\n1. First we create a formatter, in this case for formatting function types:\n\n```ts\n// my-function-formatter.ts\nimport { BaseType, Definition, FunctionType, SubTypeFormatter } from \"ts-json-schema-generator\";\nimport ts from \"typescript\";\n\nexport class MyFunctionTypeFormatter implements SubTypeFormatter {\n    // You can skip this line if you don't need childTypeFormatter\n    public constructor(private childTypeFormatter: TypeFormatter) {}\n\n    public supportsType(type: FunctionType): boolean {\n        return type instanceof FunctionType;\n    }\n\n    public getDefinition(type: FunctionType): Definition {\n        // Return a custom schema for the function property.\n        return {\n            type: \"object\",\n            properties: {\n                isFunction: {\n                    type: \"boolean\",\n                    const: true,\n                },\n            },\n        };\n    }\n\n    // If this type does NOT HAVE children, generally all you need is:\n    public getChildren(type: FunctionType): BaseType[] {\n        return [];\n    }\n\n    // However, if children ARE supported, you'll need something similar to\n    // this (see src/TypeFormatter/{Array,Definition,etc}.ts for some examples):\n    public getChildren(type: FunctionType): BaseType[] {\n        return this.childTypeFormatter.getChildren(type.getType());\n    }\n}\n```\n\n2. Then we add the formatter as a child to the core formatter using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyFunctionTypeFormatter } from \"./my-function-formatter.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\n// We configure the formatter an add our custom formatter to it.\nconst formatter = createFormatter(config, (fmt, circularReferenceTypeFormatter) => {\n    // If your formatter DOES NOT support children, e.g. getChildren() { return [] }:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter());\n    // If your formatter DOES support children, you'll need this reference too:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter(circularReferenceTypeFormatter));\n});\n\nconst program = createProgram(config);\nconst parser = createParser(program, config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n### Custom parsing\n\nSimilar to custom formatting, extending the built-in parsing works practically the same way:\n\n1. First we create a parser, in this case for parsing construct types:\n\n```ts\n// my-constructor-parser.ts\nimport { Context, StringType, ReferenceType, BaseType, SubNodeParser } from \"ts-json-schema-generator\";\n// use typescript exported by TJS to avoid version conflict\nimport ts from \"ts-json-schema-generator\";\n\nexport class MyConstructorParser implements SubNodeParser {\n    supportsNode(node: ts.Node): boolean {\n        return node.kind === ts.SyntaxKind.ConstructorType;\n    }\n    createType(node: ts.Node, context: Context, reference?: ReferenceType): BaseType | undefined {\n        return new StringType(); // Treat constructors as strings in this example\n    }\n}\n```\n\n2. Then we add the parser as a child to the core parser using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyConstructorParser } from \"./my-constructor-parser.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst program = createProgram(config);\n\n// We configure the parser an add our custom parser to it.\nconst parser = createParser(program, config, (prs) => {\n    prs.addNodeParser(new MyConstructorParser());\n});\n\nconst formatter = createFormatter(config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n## Options\n\n```\n-p, --path 'index.ts'\n    The path to the TypeScript source file. If this is not provided, the type will be searched in the project specified in the `.tsconfig`.\n\n-t, --type 'My.Type.Name'\n    The type the generated schema will represent. If omitted, the generated schema will contain all\n    types found in the files matching path. The same is true if '*' is specified.\n\n-i, --id 'generatedSchemaId'\n    The `$id` of the generated schema. If omitted, there will be no `$id`.\n\n-e, --expose <all|none|export>\n    all: Create shared $ref definitions for all types.\n    none: Do not create shared $ref definitions.\n    export (default): Create shared $ref definitions only for exported types (not tagged as `@internal`).\n\n-f, --tsconfig 'my/project/tsconfig.json'\n    Use a custom tsconfig file for processing typescript (see https://www.typescriptlang.org/docs/handbook/tsconfig-json.html) instead of the default:\n    {\n        \"compilerOptions\": {\n            \"noEmit\": true,\n            \"emitDecoratorMetadata\": true,\n            \"experimentalDecorators\": true,\n            \"target\": \"ES5\",\n            \"module\": \"CommonJS\",\n            \"strictNullChecks\": false,\n        }\n    }\n\n-j, --jsDoc <extended|none|basic>\n    none: Do not use JsDoc annotations.\n    basic: Read JsDoc annotations to provide schema properties.\n    extended (default): Also read @nullable, and @asType annotations.\n\n--unstable\n    Do not sort properties.\n\n--strict-tuples\n    Do not allow additional items on tuples.\n\n--no-top-ref\n    Do not create a top-level $ref definition.\n\n--no-type-check\n    Skip type checks for better performance.\n\n--no-ref-encode\n    Do not encode references. According to the standard, references must be valid URIs but some tools do not support encoded references.\n\n--validation-keywords\n    Provide additional validation keywords to include.\n\n-o, --out\n    Specify the output file path. Without this option, the generator logs the response in the console.\n\n--additional-properties <true|false>\n    Controls whether or not to allow additional properties for objects that have no index signature.\n\n    true: Additional properties are allowed\n    false (default): Additional properties are not allowed\n\n--minify\n    Minify generated schema (default: false)\n```\n\n## Current state\n\n-   `interface` types\n-   `enum` types\n-   `union`, `tuple`, `type[]` types\n-   `Date`, `RegExp`, `URL` types\n-   `string`, `boolean`, `number` types\n-   `\"value\"`, `123`, `true`, `false`, `null`, `undefined` literals\n-   type aliases\n-   generics\n-   `typeof`\n-   `keyof`\n-   conditional types\n\n## Run locally\n\n`yarn --silent run run --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\n## Debug\n\n`yarn --silent run debug --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\nAnd connect via the debugger protocol.\n\n[AST Explorer](https://astexplorer.net/) is amazing for developers of this tool!\n\n## Publish\n\nPublishing is handled by a 2-branch [pre-release process](https://intuit.github.io/auto/docs/generated/shipit#next-branch-default), configured in `publish-auto.yml`. All changes should be based off the default `next` branch, and are published automatically.\n\n-   PRs made into the default branch are auto-deployed to the `next` pre-release tag on NPM. The result can be installed with `npm install ts-json-schema-generator@next`\n    -   When merging into `next`, please use the `squash and merge` strategy.\n-   To release a new stable version, open a PR from `next` into `stable` using this [compare link](https://github.com/vega/ts-json-schema-generator/compare/stable...next).\n    -   When merging from `next` into `stable`, please use the `create a merge commit` strategy.\n",
      "readmeFilename": "README.md",
      "gitHead": "d9ad8ba1af2ac119181879b6f1693c5c9874057b",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@1.3.0-next.7",
      "_nodeVersion": "18.16.1",
      "_npmVersion": "9.5.1",
      "dist": {
        "integrity": "sha512-jCL4T4X1+2oxXCnYeYAJMkC+y/qJQRXKHs7rUOpvdPH8FMXJt+e43v2TLyvZ1/08Qgu46+bWj3AinXMM6nZIuQ==",
        "shasum": "cc950f2e460ea278c54d5b0f9fd74281eacedb79",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-1.3.0-next.7.tgz",
        "fileCount": 716,
        "unpackedSize": 887586,
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIG2JWLOSacMK1Y+zPqTkFcnDEF76STKlch71R/7w3IInAiEA7yaLhK0t3R2Nu+ggkC/aaXfW/Wi6JgWmVZrmLDh5CyM="
          }
        ]
      },
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "maintainers": [
        {
          "name": "jheer",
          "email": "jeffrey.heer@gmail.com"
        },
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "kanitw",
          "email": "kanitw@gmail.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_1.3.0-next.7_1688514534611_0.12000396059846263"
      },
      "_hasShrinkwrap": false
    },
    "1.3.0-next.8": {
      "name": "ts-json-schema-generator",
      "version": "1.3.0-next.8",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "MooYeol Prescott Lee",
          "email": "mooyoul@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=10.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.12",
        "commander": "^11.0.0",
        "glob": "^8.0.3",
        "json5": "^2.2.3",
        "normalize-path": "^3.0.0",
        "safe-stable-stringify": "^2.4.3",
        "typescript": "~5.1.6"
      },
      "devDependencies": {
        "@auto-it/conventional-commits": "^11.0.0",
        "@auto-it/first-time-contributor": "^11.0.0",
        "@babel/core": "^7.22.9",
        "@babel/preset-env": "^7.22.9",
        "@babel/preset-typescript": "^7.22.5",
        "@types/glob": "^8.1.0",
        "@types/jest": "^29.5.3",
        "@types/node": "^20.4.5",
        "@types/normalize-path": "^3.0.0",
        "@typescript-eslint/eslint-plugin": "^6.2.1",
        "@typescript-eslint/parser": "^6.2.1",
        "ajv": "^8.12.0",
        "ajv-formats": "^2.1.1",
        "auto": "^11.0.0",
        "chai": "^4.3.7",
        "cross-env": "^7.0.3",
        "eslint": "^8.46.0",
        "eslint-config-prettier": "^8.9.0",
        "eslint-plugin-prettier": "^5.0.0",
        "jest": "^29.6.2",
        "jest-junit": "^16.0.0",
        "prettier": "^3.0.0",
        "ts-node": "^10.9.1",
        "vega": "^5.25.0",
        "vega-lite": "^5.14.1"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint \"{src,test,factory}/**/*.ts\"",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "cross-env FAST_TEST=1 jest test/ --verbose",
        "test:coverage": "yarn jest test/ --collectCoverage=true",
        "test:update": "cross-env UPDATE_SCHEMA=true yarn test:fast",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node-transpile-only ts-json-schema-generator.ts",
        "release": "yarn build && auto shipit"
      },
      "readme": "# ts-json-schema-generator\n\n![Test](https://github.com/vega/ts-json-schema-generator/workflows/Test/badge.svg)\n[![codecov](https://codecov.io/gh/vega/ts-json-schema-generator/branch/master/graph/badge.svg)](https://codecov.io/gh/vega/ts-json-schema-generator)\n[![npm version](https://img.shields.io/npm/v/ts-json-schema-generator.svg)](https://www.npmjs.com/package/ts-json-schema-generator)\n\nExtended version of [https://github.com/xiag-ag/typescript-to-json-schema](https://github.com/xiag-ag/typescript-to-json-schema).\n\nInspired by [`YousefED/typescript-json-schema`](https://github.com/YousefED/typescript-json-schema). Here's the differences list:\n\n-   this implementation avoids the use of `typeChecker.getTypeAtLocation()` (so probably it keeps correct type aliases)\n-   processing AST and formatting JSON schema have been split into two independent steps\n-   not exported types, interfaces, enums are not exposed in the `definitions` section in the JSON schema\n\n## Contributors\n\nThis project is made possible by a [community of contributors](https://github.com/vega/ts-json-schema-generator/graphs/contributors). We welcome contributions of any kind (issues, code, documentation, examples, tests,...). Please read our [code of conduct](https://vega.github.io/vega/about/code-of-conduct).\n\n## CLI Usage\n\nRun the schema generator with npx:\n\n```bash\nnpx ts-json-schema-generator --path 'my/project/**/*.ts' --type 'My.Type.Name'\n```\n\nOr install the package and then run it\n\n```bash\nnpm install --save ts-json-schema-generator\n./node_modules/.bin/ts-json-schema-generator --path 'my/project/**/*.ts' --type 'My.Type.Name'\n```\n\nNote that different platforms (e.g. Windows) may use different path separators so you may have to adjust the command above.\n\nAlso note that you need to quote paths with `*` as otherwise the shell will expand the paths and therefore only pass the first path to the generator.\n\n## Programmatic Usage\n\n```js\n// main.js\n\nconst tsj = require(\"ts-json-schema-generator\");\nconst fs = require(\"fs\");\n\n/** @type {import('ts-json-schema-generator/dist/src/Config').Config} */\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst output_path = \"path/to/output/file\";\n\nconst schema = tsj.createGenerator(config).createSchema(config.type);\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\nRun the schema generator via `node main.js`.\n\n### Custom formatting\n\nExtending the built-in formatting is possible by creating a custom formatter and adding it to the main formatter:\n\n1. First we create a formatter, in this case for formatting function types:\n\n```ts\n// my-function-formatter.ts\nimport { BaseType, Definition, FunctionType, SubTypeFormatter } from \"ts-json-schema-generator\";\nimport ts from \"typescript\";\n\nexport class MyFunctionTypeFormatter implements SubTypeFormatter {\n    // You can skip this line if you don't need childTypeFormatter\n    public constructor(private childTypeFormatter: TypeFormatter) {}\n\n    public supportsType(type: FunctionType): boolean {\n        return type instanceof FunctionType;\n    }\n\n    public getDefinition(type: FunctionType): Definition {\n        // Return a custom schema for the function property.\n        return {\n            type: \"object\",\n            properties: {\n                isFunction: {\n                    type: \"boolean\",\n                    const: true,\n                },\n            },\n        };\n    }\n\n    // If this type does NOT HAVE children, generally all you need is:\n    public getChildren(type: FunctionType): BaseType[] {\n        return [];\n    }\n\n    // However, if children ARE supported, you'll need something similar to\n    // this (see src/TypeFormatter/{Array,Definition,etc}.ts for some examples):\n    public getChildren(type: FunctionType): BaseType[] {\n        return this.childTypeFormatter.getChildren(type.getType());\n    }\n}\n```\n\n2. Then we add the formatter as a child to the core formatter using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyFunctionTypeFormatter } from \"./my-function-formatter.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\n// We configure the formatter an add our custom formatter to it.\nconst formatter = createFormatter(config, (fmt, circularReferenceTypeFormatter) => {\n    // If your formatter DOES NOT support children, e.g. getChildren() { return [] }:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter());\n    // If your formatter DOES support children, you'll need this reference too:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter(circularReferenceTypeFormatter));\n});\n\nconst program = createProgram(config);\nconst parser = createParser(program, config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n### Custom parsing\n\nSimilar to custom formatting, extending the built-in parsing works practically the same way:\n\n1. First we create a parser, in this case for parsing construct types:\n\n```ts\n// my-constructor-parser.ts\nimport { Context, StringType, ReferenceType, BaseType, SubNodeParser } from \"ts-json-schema-generator\";\n// use typescript exported by TJS to avoid version conflict\nimport ts from \"ts-json-schema-generator\";\n\nexport class MyConstructorParser implements SubNodeParser {\n    supportsNode(node: ts.Node): boolean {\n        return node.kind === ts.SyntaxKind.ConstructorType;\n    }\n    createType(node: ts.Node, context: Context, reference?: ReferenceType): BaseType | undefined {\n        return new StringType(); // Treat constructors as strings in this example\n    }\n}\n```\n\n2. Then we add the parser as a child to the core parser using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyConstructorParser } from \"./my-constructor-parser.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst program = createProgram(config);\n\n// We configure the parser an add our custom parser to it.\nconst parser = createParser(program, config, (prs) => {\n    prs.addNodeParser(new MyConstructorParser());\n});\n\nconst formatter = createFormatter(config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n## Options\n\n```\n-p, --path 'index.ts'\n    The path to the TypeScript source file. If this is not provided, the type will be searched in the project specified in the `.tsconfig`.\n\n-t, --type 'My.Type.Name'\n    The type the generated schema will represent. If omitted, the generated schema will contain all\n    types found in the files matching path. The same is true if '*' is specified.\n\n-i, --id 'generatedSchemaId'\n    The `$id` of the generated schema. If omitted, there will be no `$id`.\n\n-e, --expose <all|none|export>\n    all: Create shared $ref definitions for all types.\n    none: Do not create shared $ref definitions.\n    export (default): Create shared $ref definitions only for exported types (not tagged as `@internal`).\n\n-f, --tsconfig 'my/project/tsconfig.json'\n    Use a custom tsconfig file for processing typescript (see https://www.typescriptlang.org/docs/handbook/tsconfig-json.html) instead of the default:\n    {\n        \"compilerOptions\": {\n            \"noEmit\": true,\n            \"emitDecoratorMetadata\": true,\n            \"experimentalDecorators\": true,\n            \"target\": \"ES5\",\n            \"module\": \"CommonJS\",\n            \"strictNullChecks\": false,\n        }\n    }\n\n-j, --jsDoc <extended|none|basic>\n    none: Do not use JsDoc annotations.\n    basic: Read JsDoc annotations to provide schema properties.\n    extended (default): Also read @nullable, and @asType annotations.\n\n--unstable\n    Do not sort properties.\n\n--strict-tuples\n    Do not allow additional items on tuples.\n\n--no-top-ref\n    Do not create a top-level $ref definition.\n\n--no-type-check\n    Skip type checks for better performance.\n\n--no-ref-encode\n    Do not encode references. According to the standard, references must be valid URIs but some tools do not support encoded references.\n\n--validation-keywords\n    Provide additional validation keywords to include.\n\n-o, --out\n    Specify the output file path. Without this option, the generator logs the response in the console.\n\n--additional-properties <true|false>\n    Controls whether or not to allow additional properties for objects that have no index signature.\n\n    true: Additional properties are allowed\n    false (default): Additional properties are not allowed\n\n--minify\n    Minify generated schema (default: false)\n```\n\n## Current state\n\n-   `interface` types\n-   `enum` types\n-   `union`, `tuple`, `type[]` types\n-   `Date`, `RegExp`, `URL` types\n-   `string`, `boolean`, `number` types\n-   `\"value\"`, `123`, `true`, `false`, `null`, `undefined` literals\n-   type aliases\n-   generics\n-   `typeof`\n-   `keyof`\n-   conditional types\n\n## Run locally\n\n`yarn --silent run run --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\n## Debug\n\n`yarn --silent run debug --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\nAnd connect via the debugger protocol.\n\n[AST Explorer](https://astexplorer.net/) is amazing for developers of this tool!\n\n## Publish\n\nPublishing is handled by a 2-branch [pre-release process](https://intuit.github.io/auto/docs/generated/shipit#next-branch-default), configured in `publish-auto.yml`. All changes should be based off the default `next` branch, and are published automatically.\n\n-   PRs made into the default branch are auto-deployed to the `next` pre-release tag on NPM. The result can be installed with `npm install ts-json-schema-generator@next`\n    -   When merging into `next`, please use the `squash and merge` strategy.\n-   To release a new stable version, open a PR from `next` into `stable` using this [compare link](https://github.com/vega/ts-json-schema-generator/compare/stable...next).\n    -   When merging from `next` into `stable`, please use the `create a merge commit` strategy.\n",
      "readmeFilename": "README.md",
      "gitHead": "8c740b877ad6689156d1c05179705b6780a908ca",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@1.3.0-next.8",
      "_nodeVersion": "18.17.0",
      "_npmVersion": "9.6.7",
      "dist": {
        "integrity": "sha512-4ox0wgPOFMsMC+ZAFq8uQvfoguOGiH/Ir4h7e+eg3p+AgYTJg2LH3cBPx/v6lZQPb2280BpXYaNZeRjTjLHKIw==",
        "shasum": "0c3861254e211700047fcb5c4c1e830ed244f4c6",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-1.3.0-next.8.tgz",
        "fileCount": 716,
        "unpackedSize": 888574,
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIQCOLr31sSWOMAN4RXYIqk9NfFracQ0FI4xtKr266nhOGAIgQ/kub7/djzNaO2h+QMNizQWNvylGEOBttfiSeUtbn/k="
          }
        ]
      },
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "maintainers": [
        {
          "name": "jheer",
          "email": "jeffrey.heer@gmail.com"
        },
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "kanitw",
          "email": "kanitw@gmail.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_1.3.0-next.8_1690981026362_0.4153050129108624"
      },
      "_hasShrinkwrap": false
    },
    "1.3.0-next.9": {
      "name": "ts-json-schema-generator",
      "version": "1.3.0-next.9",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "MooYeol Prescott Lee",
          "email": "mooyoul@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=10.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.12",
        "commander": "^11.0.0",
        "glob": "^8.0.3",
        "json5": "^2.2.3",
        "normalize-path": "^3.0.0",
        "safe-stable-stringify": "^2.4.3",
        "typescript": "~5.1.6"
      },
      "devDependencies": {
        "@auto-it/conventional-commits": "^11.0.0",
        "@auto-it/first-time-contributor": "^11.0.0",
        "@babel/core": "^7.22.9",
        "@babel/preset-env": "^7.22.9",
        "@babel/preset-typescript": "^7.22.5",
        "@types/glob": "^8.1.0",
        "@types/jest": "^29.5.3",
        "@types/node": "^20.4.5",
        "@types/normalize-path": "^3.0.0",
        "@typescript-eslint/eslint-plugin": "^6.2.1",
        "@typescript-eslint/parser": "^6.2.1",
        "ajv": "^8.12.0",
        "ajv-formats": "^2.1.1",
        "auto": "^11.0.0",
        "chai": "^4.3.7",
        "cross-env": "^7.0.3",
        "eslint": "^8.46.0",
        "eslint-config-prettier": "^9.0.0",
        "eslint-plugin-prettier": "^5.0.0",
        "jest": "^29.6.2",
        "jest-junit": "^16.0.0",
        "prettier": "^3.0.0",
        "ts-node": "^10.9.1",
        "vega": "^5.25.0",
        "vega-lite": "^5.14.1"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint \"{src,test,factory}/**/*.ts\"",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "cross-env FAST_TEST=1 jest test/ --verbose",
        "test:coverage": "yarn jest test/ --collectCoverage=true",
        "test:update": "cross-env UPDATE_SCHEMA=true yarn test:fast",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node-transpile-only ts-json-schema-generator.ts",
        "release": "yarn build && auto shipit"
      },
      "readme": "# ts-json-schema-generator\n\n![Test](https://github.com/vega/ts-json-schema-generator/workflows/Test/badge.svg)\n[![codecov](https://codecov.io/gh/vega/ts-json-schema-generator/branch/master/graph/badge.svg)](https://codecov.io/gh/vega/ts-json-schema-generator)\n[![npm version](https://img.shields.io/npm/v/ts-json-schema-generator.svg)](https://www.npmjs.com/package/ts-json-schema-generator)\n\nExtended version of [https://github.com/xiag-ag/typescript-to-json-schema](https://github.com/xiag-ag/typescript-to-json-schema).\n\nInspired by [`YousefED/typescript-json-schema`](https://github.com/YousefED/typescript-json-schema). Here's the differences list:\n\n-   this implementation avoids the use of `typeChecker.getTypeAtLocation()` (so probably it keeps correct type aliases)\n-   processing AST and formatting JSON schema have been split into two independent steps\n-   not exported types, interfaces, enums are not exposed in the `definitions` section in the JSON schema\n\n## Contributors\n\nThis project is made possible by a [community of contributors](https://github.com/vega/ts-json-schema-generator/graphs/contributors). We welcome contributions of any kind (issues, code, documentation, examples, tests,...). Please read our [code of conduct](https://vega.github.io/vega/about/code-of-conduct).\n\n## CLI Usage\n\nRun the schema generator with npx:\n\n```bash\nnpx ts-json-schema-generator --path 'my/project/**/*.ts' --type 'My.Type.Name'\n```\n\nOr install the package and then run it\n\n```bash\nnpm install --save ts-json-schema-generator\n./node_modules/.bin/ts-json-schema-generator --path 'my/project/**/*.ts' --type 'My.Type.Name'\n```\n\nNote that different platforms (e.g. Windows) may use different path separators so you may have to adjust the command above.\n\nAlso note that you need to quote paths with `*` as otherwise the shell will expand the paths and therefore only pass the first path to the generator.\n\n## Programmatic Usage\n\n```js\n// main.js\n\nconst tsj = require(\"ts-json-schema-generator\");\nconst fs = require(\"fs\");\n\n/** @type {import('ts-json-schema-generator/dist/src/Config').Config} */\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst output_path = \"path/to/output/file\";\n\nconst schema = tsj.createGenerator(config).createSchema(config.type);\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\nRun the schema generator via `node main.js`.\n\n### Custom formatting\n\nExtending the built-in formatting is possible by creating a custom formatter and adding it to the main formatter:\n\n1. First we create a formatter, in this case for formatting function types:\n\n```ts\n// my-function-formatter.ts\nimport { BaseType, Definition, FunctionType, SubTypeFormatter } from \"ts-json-schema-generator\";\nimport ts from \"typescript\";\n\nexport class MyFunctionTypeFormatter implements SubTypeFormatter {\n    // You can skip this line if you don't need childTypeFormatter\n    public constructor(private childTypeFormatter: TypeFormatter) {}\n\n    public supportsType(type: FunctionType): boolean {\n        return type instanceof FunctionType;\n    }\n\n    public getDefinition(type: FunctionType): Definition {\n        // Return a custom schema for the function property.\n        return {\n            type: \"object\",\n            properties: {\n                isFunction: {\n                    type: \"boolean\",\n                    const: true,\n                },\n            },\n        };\n    }\n\n    // If this type does NOT HAVE children, generally all you need is:\n    public getChildren(type: FunctionType): BaseType[] {\n        return [];\n    }\n\n    // However, if children ARE supported, you'll need something similar to\n    // this (see src/TypeFormatter/{Array,Definition,etc}.ts for some examples):\n    public getChildren(type: FunctionType): BaseType[] {\n        return this.childTypeFormatter.getChildren(type.getType());\n    }\n}\n```\n\n2. Then we add the formatter as a child to the core formatter using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyFunctionTypeFormatter } from \"./my-function-formatter.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\n// We configure the formatter an add our custom formatter to it.\nconst formatter = createFormatter(config, (fmt, circularReferenceTypeFormatter) => {\n    // If your formatter DOES NOT support children, e.g. getChildren() { return [] }:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter());\n    // If your formatter DOES support children, you'll need this reference too:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter(circularReferenceTypeFormatter));\n});\n\nconst program = createProgram(config);\nconst parser = createParser(program, config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n### Custom parsing\n\nSimilar to custom formatting, extending the built-in parsing works practically the same way:\n\n1. First we create a parser, in this case for parsing construct types:\n\n```ts\n// my-constructor-parser.ts\nimport { Context, StringType, ReferenceType, BaseType, SubNodeParser } from \"ts-json-schema-generator\";\n// use typescript exported by TJS to avoid version conflict\nimport ts from \"ts-json-schema-generator\";\n\nexport class MyConstructorParser implements SubNodeParser {\n    supportsNode(node: ts.Node): boolean {\n        return node.kind === ts.SyntaxKind.ConstructorType;\n    }\n    createType(node: ts.Node, context: Context, reference?: ReferenceType): BaseType | undefined {\n        return new StringType(); // Treat constructors as strings in this example\n    }\n}\n```\n\n2. Then we add the parser as a child to the core parser using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyConstructorParser } from \"./my-constructor-parser.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst program = createProgram(config);\n\n// We configure the parser an add our custom parser to it.\nconst parser = createParser(program, config, (prs) => {\n    prs.addNodeParser(new MyConstructorParser());\n});\n\nconst formatter = createFormatter(config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n## Options\n\n```\n-p, --path 'index.ts'\n    The path to the TypeScript source file. If this is not provided, the type will be searched in the project specified in the `.tsconfig`.\n\n-t, --type 'My.Type.Name'\n    The type the generated schema will represent. If omitted, the generated schema will contain all\n    types found in the files matching path. The same is true if '*' is specified.\n\n-i, --id 'generatedSchemaId'\n    The `$id` of the generated schema. If omitted, there will be no `$id`.\n\n-e, --expose <all|none|export>\n    all: Create shared $ref definitions for all types.\n    none: Do not create shared $ref definitions.\n    export (default): Create shared $ref definitions only for exported types (not tagged as `@internal`).\n\n-f, --tsconfig 'my/project/tsconfig.json'\n    Use a custom tsconfig file for processing typescript (see https://www.typescriptlang.org/docs/handbook/tsconfig-json.html) instead of the default:\n    {\n        \"compilerOptions\": {\n            \"noEmit\": true,\n            \"emitDecoratorMetadata\": true,\n            \"experimentalDecorators\": true,\n            \"target\": \"ES5\",\n            \"module\": \"CommonJS\",\n            \"strictNullChecks\": false,\n        }\n    }\n\n-j, --jsDoc <extended|none|basic>\n    none: Do not use JsDoc annotations.\n    basic: Read JsDoc annotations to provide schema properties.\n    extended (default): Also read @nullable, and @asType annotations.\n\n--unstable\n    Do not sort properties.\n\n--strict-tuples\n    Do not allow additional items on tuples.\n\n--no-top-ref\n    Do not create a top-level $ref definition.\n\n--no-type-check\n    Skip type checks for better performance.\n\n--no-ref-encode\n    Do not encode references. According to the standard, references must be valid URIs but some tools do not support encoded references.\n\n--validation-keywords\n    Provide additional validation keywords to include.\n\n-o, --out\n    Specify the output file path. Without this option, the generator logs the response in the console.\n\n--additional-properties <true|false>\n    Controls whether or not to allow additional properties for objects that have no index signature.\n\n    true: Additional properties are allowed\n    false (default): Additional properties are not allowed\n\n--minify\n    Minify generated schema (default: false)\n```\n\n## Current state\n\n-   `interface` types\n-   `enum` types\n-   `union`, `tuple`, `type[]` types\n-   `Date`, `RegExp`, `URL` types\n-   `string`, `boolean`, `number` types\n-   `\"value\"`, `123`, `true`, `false`, `null`, `undefined` literals\n-   type aliases\n-   generics\n-   `typeof`\n-   `keyof`\n-   conditional types\n\n## Run locally\n\n`yarn --silent run run --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\n## Debug\n\n`yarn --silent run debug --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\nAnd connect via the debugger protocol.\n\n[AST Explorer](https://astexplorer.net/) is amazing for developers of this tool!\n\n## Publish\n\nPublishing is handled by a 2-branch [pre-release process](https://intuit.github.io/auto/docs/generated/shipit#next-branch-default), configured in `publish-auto.yml`. All changes should be based off the default `next` branch, and are published automatically.\n\n-   PRs made into the default branch are auto-deployed to the `next` pre-release tag on NPM. The result can be installed with `npm install ts-json-schema-generator@next`\n    -   When merging into `next`, please use the `squash and merge` strategy.\n-   To release a new stable version, open a PR from `next` into `stable` using this [compare link](https://github.com/vega/ts-json-schema-generator/compare/stable...next).\n    -   When merging from `next` into `stable`, please use the `create a merge commit` strategy.\n",
      "readmeFilename": "README.md",
      "gitHead": "18648b2cee9ce7a0c20f311049f30b57efdd14e4",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@1.3.0-next.9",
      "_nodeVersion": "18.17.0",
      "_npmVersion": "9.6.7",
      "dist": {
        "integrity": "sha512-gIAAayNOU5cXdPfODaTGYe2ZAXPqN6D5zz2Vz08hG8P9W8tZ6V7adMOiDlicqJe0NY2aOjwN+3ODXmtROLbL4A==",
        "shasum": "08225d89cd3e50361fefd68db12e178f74a39d33",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-1.3.0-next.9.tgz",
        "fileCount": 720,
        "unpackedSize": 891636,
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIQD8t4x4CloIH1mT8y2lV3Kk2/Z1G1773T8N4foRxax/pAIgYxzo3ej2QsVB3xDHyoMyJ30XRONGBjm208pvhGK7IeU="
          }
        ]
      },
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "maintainers": [
        {
          "name": "jheer",
          "email": "jeffrey.heer@gmail.com"
        },
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "kanitw",
          "email": "kanitw@gmail.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_1.3.0-next.9_1692031334930_0.6331193221545934"
      },
      "_hasShrinkwrap": false
    },
    "1.3.0": {
      "name": "ts-json-schema-generator",
      "version": "1.3.0",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "MooYeol Prescott Lee",
          "email": "mooyoul@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=10.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.12",
        "commander": "^11.0.0",
        "glob": "^8.0.3",
        "json5": "^2.2.3",
        "normalize-path": "^3.0.0",
        "safe-stable-stringify": "^2.4.3",
        "typescript": "~5.1.6"
      },
      "devDependencies": {
        "@auto-it/conventional-commits": "^11.0.0",
        "@auto-it/first-time-contributor": "^11.0.0",
        "@babel/core": "^7.22.9",
        "@babel/preset-env": "^7.22.9",
        "@babel/preset-typescript": "^7.22.5",
        "@types/glob": "^8.1.0",
        "@types/jest": "^29.5.3",
        "@types/node": "^20.4.5",
        "@types/normalize-path": "^3.0.0",
        "@typescript-eslint/eslint-plugin": "^6.2.1",
        "@typescript-eslint/parser": "^6.2.1",
        "ajv": "^8.12.0",
        "ajv-formats": "^2.1.1",
        "auto": "^11.0.0",
        "chai": "^4.3.7",
        "cross-env": "^7.0.3",
        "eslint": "^8.46.0",
        "eslint-config-prettier": "^9.0.0",
        "eslint-plugin-prettier": "^5.0.0",
        "jest": "^29.6.2",
        "jest-junit": "^16.0.0",
        "prettier": "^3.0.0",
        "ts-node": "^10.9.1",
        "vega": "^5.25.0",
        "vega-lite": "^5.14.1"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint \"{src,test,factory}/**/*.ts\"",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "cross-env FAST_TEST=1 jest test/ --verbose",
        "test:coverage": "yarn jest test/ --collectCoverage=true",
        "test:update": "cross-env UPDATE_SCHEMA=true yarn test:fast",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node-transpile-only ts-json-schema-generator.ts",
        "release": "yarn build && auto shipit"
      },
      "gitHead": "26a35568c33f62f97d6bfdc96278dbdfdc947b18",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_id": "ts-json-schema-generator@1.3.0",
      "_nodeVersion": "18.17.0",
      "_npmVersion": "9.6.7",
      "dist": {
        "integrity": "sha512-Y2smEgpxtWat8ICaLbUENXZ/o/SqvVy85X48V/7qOarOTu6XgVs+lr6k0OPFljVhZX5gEMrGPT3q7Ql7JKnexw==",
        "shasum": "0d5c672cce47e4c438323e3bd85f2be72f62d0ac",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-1.3.0.tgz",
        "fileCount": 720,
        "unpackedSize": 891622,
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIQCmkwMnbPQpEmibxYB/XE8vLrS+XyWISkbAOnkOI1un0gIgaxflfPVrAvedXHDBYeptVxTeHIPOna4cEnDEYhfam7o="
          }
        ]
      },
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "maintainers": [
        {
          "name": "jheer",
          "email": "jeffrey.heer@gmail.com"
        },
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "kanitw",
          "email": "kanitw@gmail.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_1.3.0_1692031416473_0.06536121300745079"
      },
      "_hasShrinkwrap": false
    },
    "1.4.0-next.0": {
      "name": "ts-json-schema-generator",
      "version": "1.4.0-next.0",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "MooYeol Prescott Lee",
          "email": "mooyoul@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=10.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.12",
        "commander": "^11.0.0",
        "glob": "^8.0.3",
        "json5": "^2.2.3",
        "normalize-path": "^3.0.0",
        "safe-stable-stringify": "^2.4.3",
        "typescript": "~5.2.2"
      },
      "devDependencies": {
        "@auto-it/conventional-commits": "^11.0.0",
        "@auto-it/first-time-contributor": "^11.0.0",
        "@babel/core": "^7.22.9",
        "@babel/preset-env": "^7.22.9",
        "@babel/preset-typescript": "^7.22.5",
        "@types/glob": "^8.1.0",
        "@types/jest": "^29.5.3",
        "@types/node": "^20.4.5",
        "@types/normalize-path": "^3.0.0",
        "@typescript-eslint/eslint-plugin": "^6.2.1",
        "@typescript-eslint/parser": "^6.2.1",
        "ajv": "^8.12.0",
        "ajv-formats": "^2.1.1",
        "auto": "^11.0.0",
        "chai": "^4.3.7",
        "cross-env": "^7.0.3",
        "eslint": "^8.46.0",
        "eslint-config-prettier": "^9.0.0",
        "eslint-plugin-prettier": "^5.0.0",
        "jest": "^29.6.2",
        "jest-junit": "^16.0.0",
        "prettier": "^3.0.0",
        "ts-node": "^10.9.1",
        "vega": "^5.25.0",
        "vega-lite": "^5.14.1"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint \"{src,test,factory}/**/*.ts\"",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "cross-env FAST_TEST=1 jest test/ --verbose",
        "test:coverage": "yarn jest test/ --collectCoverage=true",
        "test:update": "cross-env UPDATE_SCHEMA=true yarn test:fast",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node-transpile-only ts-json-schema-generator.ts",
        "release": "yarn build && auto shipit"
      },
      "packageManager": "yarn@1.22.19",
      "_id": "ts-json-schema-generator@1.4.0-next.0",
      "readme": "# ts-json-schema-generator\n\n![Test](https://github.com/vega/ts-json-schema-generator/workflows/Test/badge.svg)\n[![codecov](https://codecov.io/gh/vega/ts-json-schema-generator/branch/master/graph/badge.svg)](https://codecov.io/gh/vega/ts-json-schema-generator)\n[![npm version](https://img.shields.io/npm/v/ts-json-schema-generator.svg)](https://www.npmjs.com/package/ts-json-schema-generator)\n\nExtended version of [https://github.com/xiag-ag/typescript-to-json-schema](https://github.com/xiag-ag/typescript-to-json-schema).\n\nInspired by [`YousefED/typescript-json-schema`](https://github.com/YousefED/typescript-json-schema). Here's the differences list:\n\n-   this implementation avoids the use of `typeChecker.getTypeAtLocation()` (so probably it keeps correct type aliases)\n-   processing AST and formatting JSON schema have been split into two independent steps\n-   not exported types, interfaces, enums are not exposed in the `definitions` section in the JSON schema\n\n## Contributors\n\nThis project is made possible by a [community of contributors](https://github.com/vega/ts-json-schema-generator/graphs/contributors). We welcome contributions of any kind (issues, code, documentation, examples, tests,...). Please read our [code of conduct](https://vega.github.io/vega/about/code-of-conduct).\n\n## CLI Usage\n\nRun the schema generator with npx:\n\n```bash\nnpx ts-json-schema-generator --path 'my/project/**/*.ts' --type 'My.Type.Name'\n```\n\nOr install the package and then run it\n\n```bash\nnpm install --save ts-json-schema-generator\n./node_modules/.bin/ts-json-schema-generator --path 'my/project/**/*.ts' --type 'My.Type.Name'\n```\n\nNote that different platforms (e.g. Windows) may use different path separators so you may have to adjust the command above.\n\nAlso note that you need to quote paths with `*` as otherwise the shell will expand the paths and therefore only pass the first path to the generator.\n\n## Programmatic Usage\n\n```js\n// main.js\n\nconst tsj = require(\"ts-json-schema-generator\");\nconst fs = require(\"fs\");\n\n/** @type {import('ts-json-schema-generator/dist/src/Config').Config} */\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst output_path = \"path/to/output/file\";\n\nconst schema = tsj.createGenerator(config).createSchema(config.type);\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\nRun the schema generator via `node main.js`.\n\n### Custom formatting\n\nExtending the built-in formatting is possible by creating a custom formatter and adding it to the main formatter:\n\n1. First we create a formatter, in this case for formatting function types:\n\n```ts\n// my-function-formatter.ts\nimport { BaseType, Definition, FunctionType, SubTypeFormatter } from \"ts-json-schema-generator\";\nimport ts from \"typescript\";\n\nexport class MyFunctionTypeFormatter implements SubTypeFormatter {\n    // You can skip this line if you don't need childTypeFormatter\n    public constructor(private childTypeFormatter: TypeFormatter) {}\n\n    public supportsType(type: FunctionType): boolean {\n        return type instanceof FunctionType;\n    }\n\n    public getDefinition(type: FunctionType): Definition {\n        // Return a custom schema for the function property.\n        return {\n            type: \"object\",\n            properties: {\n                isFunction: {\n                    type: \"boolean\",\n                    const: true,\n                },\n            },\n        };\n    }\n\n    // If this type does NOT HAVE children, generally all you need is:\n    public getChildren(type: FunctionType): BaseType[] {\n        return [];\n    }\n\n    // However, if children ARE supported, you'll need something similar to\n    // this (see src/TypeFormatter/{Array,Definition,etc}.ts for some examples):\n    public getChildren(type: FunctionType): BaseType[] {\n        return this.childTypeFormatter.getChildren(type.getType());\n    }\n}\n```\n\n2. Then we add the formatter as a child to the core formatter using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyFunctionTypeFormatter } from \"./my-function-formatter.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\n// We configure the formatter an add our custom formatter to it.\nconst formatter = createFormatter(config, (fmt, circularReferenceTypeFormatter) => {\n    // If your formatter DOES NOT support children, e.g. getChildren() { return [] }:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter());\n    // If your formatter DOES support children, you'll need this reference too:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter(circularReferenceTypeFormatter));\n});\n\nconst program = createProgram(config);\nconst parser = createParser(program, config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n### Custom parsing\n\nSimilar to custom formatting, extending the built-in parsing works practically the same way:\n\n1. First we create a parser, in this case for parsing construct types:\n\n```ts\n// my-constructor-parser.ts\nimport { Context, StringType, ReferenceType, BaseType, SubNodeParser } from \"ts-json-schema-generator\";\n// use typescript exported by TJS to avoid version conflict\nimport ts from \"ts-json-schema-generator\";\n\nexport class MyConstructorParser implements SubNodeParser {\n    supportsNode(node: ts.Node): boolean {\n        return node.kind === ts.SyntaxKind.ConstructorType;\n    }\n    createType(node: ts.Node, context: Context, reference?: ReferenceType): BaseType | undefined {\n        return new StringType(); // Treat constructors as strings in this example\n    }\n}\n```\n\n2. Then we add the parser as a child to the core parser using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyConstructorParser } from \"./my-constructor-parser.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst program = createProgram(config);\n\n// We configure the parser an add our custom parser to it.\nconst parser = createParser(program, config, (prs) => {\n    prs.addNodeParser(new MyConstructorParser());\n});\n\nconst formatter = createFormatter(config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n## Options\n\n```\n-p, --path 'index.ts'\n    The path to the TypeScript source file. If this is not provided, the type will be searched in the project specified in the `.tsconfig`.\n\n-t, --type 'My.Type.Name'\n    The type the generated schema will represent. If omitted, the generated schema will contain all\n    types found in the files matching path. The same is true if '*' is specified.\n\n-i, --id 'generatedSchemaId'\n    The `$id` of the generated schema. If omitted, there will be no `$id`.\n\n-e, --expose <all|none|export>\n    all: Create shared $ref definitions for all types.\n    none: Do not create shared $ref definitions.\n    export (default): Create shared $ref definitions only for exported types (not tagged as `@internal`).\n\n-f, --tsconfig 'my/project/tsconfig.json'\n    Use a custom tsconfig file for processing typescript (see https://www.typescriptlang.org/docs/handbook/tsconfig-json.html) instead of the default:\n    {\n        \"compilerOptions\": {\n            \"noEmit\": true,\n            \"emitDecoratorMetadata\": true,\n            \"experimentalDecorators\": true,\n            \"target\": \"ES5\",\n            \"module\": \"CommonJS\",\n            \"strictNullChecks\": false,\n        }\n    }\n\n-j, --jsDoc <extended|none|basic>\n    none: Do not use JsDoc annotations.\n    basic: Read JsDoc annotations to provide schema properties.\n    extended (default): Also read @nullable, and @asType annotations.\n\n--unstable\n    Do not sort properties.\n\n--strict-tuples\n    Do not allow additional items on tuples.\n\n--no-top-ref\n    Do not create a top-level $ref definition.\n\n--no-type-check\n    Skip type checks for better performance.\n\n--no-ref-encode\n    Do not encode references. According to the standard, references must be valid URIs but some tools do not support encoded references.\n\n--validation-keywords\n    Provide additional validation keywords to include.\n\n-o, --out\n    Specify the output file path. Without this option, the generator logs the response in the console.\n\n--additional-properties <true|false>\n    Controls whether or not to allow additional properties for objects that have no index signature.\n\n    true: Additional properties are allowed\n    false (default): Additional properties are not allowed\n\n--minify\n    Minify generated schema (default: false)\n```\n\n## Current state\n\n-   `interface` types\n-   `enum` types\n-   `union`, `tuple`, `type[]` types\n-   `Date`, `RegExp`, `URL` types\n-   `string`, `boolean`, `number` types\n-   `\"value\"`, `123`, `true`, `false`, `null`, `undefined` literals\n-   type aliases\n-   generics\n-   `typeof`\n-   `keyof`\n-   conditional types\n\n## Run locally\n\n`yarn --silent run run --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\n## Debug\n\n`yarn --silent run debug --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\nAnd connect via the debugger protocol.\n\n[AST Explorer](https://astexplorer.net/) is amazing for developers of this tool!\n\n## Publish\n\nPublishing is handled by a 2-branch [pre-release process](https://intuit.github.io/auto/docs/generated/shipit#next-branch-default), configured in `publish-auto.yml`. All changes should be based off the default `next` branch, and are published automatically.\n\n-   PRs made into the default branch are auto-deployed to the `next` pre-release tag on NPM. The result can be installed with `npm install ts-json-schema-generator@next`\n    -   When merging into `next`, please use the `squash and merge` strategy.\n-   To release a new stable version, open a PR from `next` into `stable` using this [compare link](https://github.com/vega/ts-json-schema-generator/compare/stable...next).\n    -   When merging from `next` into `stable`, please use the `create a merge commit` strategy.\n",
      "readmeFilename": "README.md",
      "gitHead": "47eb93c4aa8918a27cc3a65be73298c2985d629d",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_nodeVersion": "18.18.0",
      "_npmVersion": "9.8.1",
      "dist": {
        "integrity": "sha512-DCPta/SFuxpsyfgNYgY0iKx3sjwyWrLEcAzjhbQaYsfmPAPrHPIo0yyKvlctcKojvOcsljXpMWK4B6sYWSwaog==",
        "shasum": "e4b058800263176176cc625fc66c3383c3980071",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-1.4.0-next.0.tgz",
        "fileCount": 726,
        "unpackedSize": 895604,
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIQCjZIqrEOh22DlzojtzXwVZ7oFwfRZdv2xzF+FjQ9roLgIgLlXCxbvW5TtfkxApKkn2a6KmZUMc9TUwzNKey5khmv4="
          }
        ]
      },
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "maintainers": [
        {
          "name": "jheer",
          "email": "jeffrey.heer@gmail.com"
        },
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "kanitw",
          "email": "kanitw@gmail.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_1.4.0-next.0_1697378273221_0.10775764347706374"
      },
      "_hasShrinkwrap": false
    },
    "1.4.0-next.1": {
      "name": "ts-json-schema-generator",
      "version": "1.4.0-next.1",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "MooYeol Prescott Lee",
          "email": "mooyoul@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=10.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.12",
        "commander": "^11.0.0",
        "glob": "^8.0.3",
        "json5": "^2.2.3",
        "normalize-path": "^3.0.0",
        "safe-stable-stringify": "^2.4.3",
        "typescript": "~5.2.2"
      },
      "devDependencies": {
        "@auto-it/conventional-commits": "^11.0.0",
        "@auto-it/first-time-contributor": "^11.0.0",
        "@babel/core": "^7.22.9",
        "@babel/preset-env": "^7.22.9",
        "@babel/preset-typescript": "^7.22.5",
        "@types/glob": "^8.1.0",
        "@types/jest": "^29.5.3",
        "@types/node": "^20.4.5",
        "@types/normalize-path": "^3.0.0",
        "@typescript-eslint/eslint-plugin": "^6.2.1",
        "@typescript-eslint/parser": "^6.2.1",
        "ajv": "^8.12.0",
        "ajv-formats": "^2.1.1",
        "auto": "^11.0.0",
        "chai": "^4.3.7",
        "cross-env": "^7.0.3",
        "eslint": "^8.46.0",
        "eslint-config-prettier": "^9.0.0",
        "eslint-plugin-prettier": "^5.0.0",
        "jest": "^29.6.2",
        "jest-junit": "^16.0.0",
        "prettier": "^3.0.0",
        "ts-node": "^10.9.1",
        "vega": "^5.25.0",
        "vega-lite": "^5.14.1"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint \"{src,test,factory}/**/*.ts\"",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "cross-env FAST_TEST=1 jest test/ --verbose",
        "test:coverage": "yarn jest test/ --collectCoverage=true",
        "test:update": "cross-env UPDATE_SCHEMA=true yarn test:fast",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node-transpile-only ts-json-schema-generator.ts",
        "release": "yarn build && auto shipit"
      },
      "packageManager": "yarn@1.22.19",
      "_id": "ts-json-schema-generator@1.4.0-next.1",
      "readme": "# ts-json-schema-generator\n\n![Test](https://github.com/vega/ts-json-schema-generator/workflows/Test/badge.svg)\n[![codecov](https://codecov.io/gh/vega/ts-json-schema-generator/branch/master/graph/badge.svg)](https://codecov.io/gh/vega/ts-json-schema-generator)\n[![npm version](https://img.shields.io/npm/v/ts-json-schema-generator.svg)](https://www.npmjs.com/package/ts-json-schema-generator)\n\nExtended version of [https://github.com/xiag-ag/typescript-to-json-schema](https://github.com/xiag-ag/typescript-to-json-schema).\n\nInspired by [`YousefED/typescript-json-schema`](https://github.com/YousefED/typescript-json-schema). Here's the differences list:\n\n-   this implementation avoids the use of `typeChecker.getTypeAtLocation()` (so probably it keeps correct type aliases)\n-   processing AST and formatting JSON schema have been split into two independent steps\n-   not exported types, interfaces, enums are not exposed in the `definitions` section in the JSON schema\n\n## Contributors\n\nThis project is made possible by a [community of contributors](https://github.com/vega/ts-json-schema-generator/graphs/contributors). We welcome contributions of any kind (issues, code, documentation, examples, tests,...). Please read our [code of conduct](https://vega.github.io/vega/about/code-of-conduct).\n\n## CLI Usage\n\nRun the schema generator with npx:\n\n```bash\nnpx ts-json-schema-generator --path 'my/project/**/*.ts' --type 'My.Type.Name'\n```\n\nOr install the package and then run it\n\n```bash\nnpm install --save ts-json-schema-generator\n./node_modules/.bin/ts-json-schema-generator --path 'my/project/**/*.ts' --type 'My.Type.Name'\n```\n\nNote that different platforms (e.g. Windows) may use different path separators so you may have to adjust the command above.\n\nAlso note that you need to quote paths with `*` as otherwise the shell will expand the paths and therefore only pass the first path to the generator.\n\n## Programmatic Usage\n\n```js\n// main.js\n\nconst tsj = require(\"ts-json-schema-generator\");\nconst fs = require(\"fs\");\n\n/** @type {import('ts-json-schema-generator/dist/src/Config').Config} */\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst output_path = \"path/to/output/file\";\n\nconst schema = tsj.createGenerator(config).createSchema(config.type);\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\nRun the schema generator via `node main.js`.\n\n### Custom formatting\n\nExtending the built-in formatting is possible by creating a custom formatter and adding it to the main formatter:\n\n1. First we create a formatter, in this case for formatting function types:\n\n```ts\n// my-function-formatter.ts\nimport { BaseType, Definition, FunctionType, SubTypeFormatter } from \"ts-json-schema-generator\";\nimport ts from \"typescript\";\n\nexport class MyFunctionTypeFormatter implements SubTypeFormatter {\n    // You can skip this line if you don't need childTypeFormatter\n    public constructor(private childTypeFormatter: TypeFormatter) {}\n\n    public supportsType(type: FunctionType): boolean {\n        return type instanceof FunctionType;\n    }\n\n    public getDefinition(type: FunctionType): Definition {\n        // Return a custom schema for the function property.\n        return {\n            type: \"object\",\n            properties: {\n                isFunction: {\n                    type: \"boolean\",\n                    const: true,\n                },\n            },\n        };\n    }\n\n    // If this type does NOT HAVE children, generally all you need is:\n    public getChildren(type: FunctionType): BaseType[] {\n        return [];\n    }\n\n    // However, if children ARE supported, you'll need something similar to\n    // this (see src/TypeFormatter/{Array,Definition,etc}.ts for some examples):\n    public getChildren(type: FunctionType): BaseType[] {\n        return this.childTypeFormatter.getChildren(type.getType());\n    }\n}\n```\n\n2. Then we add the formatter as a child to the core formatter using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyFunctionTypeFormatter } from \"./my-function-formatter.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\n// We configure the formatter an add our custom formatter to it.\nconst formatter = createFormatter(config, (fmt, circularReferenceTypeFormatter) => {\n    // If your formatter DOES NOT support children, e.g. getChildren() { return [] }:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter());\n    // If your formatter DOES support children, you'll need this reference too:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter(circularReferenceTypeFormatter));\n});\n\nconst program = createProgram(config);\nconst parser = createParser(program, config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n### Custom parsing\n\nSimilar to custom formatting, extending the built-in parsing works practically the same way:\n\n1. First we create a parser, in this case for parsing construct types:\n\n```ts\n// my-constructor-parser.ts\nimport { Context, StringType, ReferenceType, BaseType, SubNodeParser } from \"ts-json-schema-generator\";\n// use typescript exported by TJS to avoid version conflict\nimport ts from \"ts-json-schema-generator\";\n\nexport class MyConstructorParser implements SubNodeParser {\n    supportsNode(node: ts.Node): boolean {\n        return node.kind === ts.SyntaxKind.ConstructorType;\n    }\n    createType(node: ts.Node, context: Context, reference?: ReferenceType): BaseType | undefined {\n        return new StringType(); // Treat constructors as strings in this example\n    }\n}\n```\n\n2. Then we add the parser as a child to the core parser using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyConstructorParser } from \"./my-constructor-parser.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst program = createProgram(config);\n\n// We configure the parser an add our custom parser to it.\nconst parser = createParser(program, config, (prs) => {\n    prs.addNodeParser(new MyConstructorParser());\n});\n\nconst formatter = createFormatter(config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n## Options\n\n```\n-p, --path 'index.ts'\n    The path to the TypeScript source file. If this is not provided, the type will be searched in the project specified in the `.tsconfig`.\n\n-t, --type 'My.Type.Name'\n    The type the generated schema will represent. If omitted, the generated schema will contain all\n    types found in the files matching path. The same is true if '*' is specified.\n\n-i, --id 'generatedSchemaId'\n    The `$id` of the generated schema. If omitted, there will be no `$id`.\n\n-e, --expose <all|none|export>\n    all: Create shared $ref definitions for all types.\n    none: Do not create shared $ref definitions.\n    export (default): Create shared $ref definitions only for exported types (not tagged as `@internal`).\n\n-f, --tsconfig 'my/project/tsconfig.json'\n    Use a custom tsconfig file for processing typescript (see https://www.typescriptlang.org/docs/handbook/tsconfig-json.html) instead of the default:\n    {\n        \"compilerOptions\": {\n            \"noEmit\": true,\n            \"emitDecoratorMetadata\": true,\n            \"experimentalDecorators\": true,\n            \"target\": \"ES5\",\n            \"module\": \"CommonJS\",\n            \"strictNullChecks\": false,\n        }\n    }\n\n-j, --jsDoc <extended|none|basic>\n    none: Do not use JsDoc annotations.\n    basic: Read JsDoc annotations to provide schema properties.\n    extended (default): Also read @nullable, and @asType annotations.\n\n--unstable\n    Do not sort properties.\n\n--strict-tuples\n    Do not allow additional items on tuples.\n\n--no-top-ref\n    Do not create a top-level $ref definition.\n\n--no-type-check\n    Skip type checks for better performance.\n\n--no-ref-encode\n    Do not encode references. According to the standard, references must be valid URIs but some tools do not support encoded references.\n\n--validation-keywords\n    Provide additional validation keywords to include.\n\n-o, --out\n    Specify the output file path. Without this option, the generator logs the response in the console.\n\n--additional-properties <true|false>\n    Controls whether or not to allow additional properties for objects that have no index signature.\n\n    true: Additional properties are allowed\n    false (default): Additional properties are not allowed\n\n--minify\n    Minify generated schema (default: false)\n```\n\n## Current state\n\n-   `interface` types\n-   `enum` types\n-   `union`, `tuple`, `type[]` types\n-   `Date`, `RegExp`, `URL` types\n-   `string`, `boolean`, `number` types\n-   `\"value\"`, `123`, `true`, `false`, `null`, `undefined` literals\n-   type aliases\n-   generics\n-   `typeof`\n-   `keyof`\n-   conditional types\n\n## Run locally\n\n`yarn --silent run run --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\n## Debug\n\n`yarn --silent run debug --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\nAnd connect via the debugger protocol.\n\n[AST Explorer](https://astexplorer.net/) is amazing for developers of this tool!\n\n## Publish\n\nPublishing is handled by a 2-branch [pre-release process](https://intuit.github.io/auto/docs/generated/shipit#next-branch-default), configured in `publish-auto.yml`. All changes should be based off the default `next` branch, and are published automatically.\n\n-   PRs made into the default branch are auto-deployed to the `next` pre-release tag on NPM. The result can be installed with `npm install ts-json-schema-generator@next`\n    -   When merging into `next`, please use the `squash and merge` strategy.\n-   To release a new stable version, open a PR from `next` into `stable` using this [compare link](https://github.com/vega/ts-json-schema-generator/compare/stable...next).\n    -   When merging from `next` into `stable`, please use the `create a merge commit` strategy.\n",
      "readmeFilename": "README.md",
      "gitHead": "2ec470ef7f5b2036741893f359fa7decc3e7aa5e",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_nodeVersion": "18.18.0",
      "_npmVersion": "9.8.1",
      "dist": {
        "integrity": "sha512-aZMvOQQcp7EtCjeY1XMPDlATswavw3qv8RJ3kxgBnfzRFN0i+VhBKbzFxnd1d4PYSzlvyaZ/BgsvkEaZR7oohw==",
        "shasum": "47aab130e96b1896ceaa0653a75bc378a31d1cf7",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-1.4.0-next.1.tgz",
        "fileCount": 726,
        "unpackedSize": 897673,
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEQCIDwf4JPl89bQMopDkPZkT+sUZ3KtLK6NhUQtXhRzWTWAAiBNwX6eXQRp/4gdtCYdZsDk7GPP46af7n/VIbSwZRMJOg=="
          }
        ]
      },
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "maintainers": [
        {
          "name": "jheer",
          "email": "jeffrey.heer@gmail.com"
        },
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "kanitw",
          "email": "kanitw@gmail.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_1.4.0-next.1_1697418351455_0.6851848449118694"
      },
      "_hasShrinkwrap": false
    },
    "1.4.0": {
      "name": "ts-json-schema-generator",
      "version": "1.4.0",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "MooYeol Prescott Lee",
          "email": "mooyoul@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=10.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.12",
        "commander": "^11.0.0",
        "glob": "^8.0.3",
        "json5": "^2.2.3",
        "normalize-path": "^3.0.0",
        "safe-stable-stringify": "^2.4.3",
        "typescript": "~5.2.2"
      },
      "devDependencies": {
        "@auto-it/conventional-commits": "^11.0.0",
        "@auto-it/first-time-contributor": "^11.0.0",
        "@babel/core": "^7.22.9",
        "@babel/preset-env": "^7.22.9",
        "@babel/preset-typescript": "^7.22.5",
        "@types/glob": "^8.1.0",
        "@types/jest": "^29.5.3",
        "@types/node": "^20.4.5",
        "@types/normalize-path": "^3.0.0",
        "@typescript-eslint/eslint-plugin": "^6.2.1",
        "@typescript-eslint/parser": "^6.2.1",
        "ajv": "^8.12.0",
        "ajv-formats": "^2.1.1",
        "auto": "^11.0.0",
        "chai": "^4.3.7",
        "cross-env": "^7.0.3",
        "eslint": "^8.46.0",
        "eslint-config-prettier": "^9.0.0",
        "eslint-plugin-prettier": "^5.0.0",
        "jest": "^29.6.2",
        "jest-junit": "^16.0.0",
        "prettier": "^3.0.0",
        "ts-node": "^10.9.1",
        "vega": "^5.25.0",
        "vega-lite": "^5.14.1"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint \"{src,test,factory}/**/*.ts\"",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "cross-env FAST_TEST=1 jest test/ --verbose",
        "test:coverage": "yarn jest test/ --collectCoverage=true",
        "test:update": "cross-env UPDATE_SCHEMA=true yarn test:fast",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node-transpile-only ts-json-schema-generator.ts",
        "release": "yarn build && auto shipit"
      },
      "packageManager": "yarn@1.22.19",
      "_id": "ts-json-schema-generator@1.4.0",
      "gitHead": "67d95724db3359e6b37fad608b0079ff5dd11280",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_nodeVersion": "18.18.0",
      "_npmVersion": "9.8.1",
      "dist": {
        "integrity": "sha512-wm8vyihmGgYpxrqRshmYkWGNwEk+sf3xV2rUgxv8Ryeh7bSpMO7pZQOht+2rS002eDkFTxR7EwRPXVzrS0WJTg==",
        "shasum": "f341b36792c372d3d09245414a4f3a6efa2697f8",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-1.4.0.tgz",
        "fileCount": 726,
        "unpackedSize": 897659,
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEYCIQDK06PBhIqbD3k+1FOscgM4J7XD26CCUf2fcNdAGUx9AQIhAPsO7qLezCru3hUT6etgrsAIl2pQCteik3eNjkATHpeL"
          }
        ]
      },
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "maintainers": [
        {
          "name": "jheer",
          "email": "jeffrey.heer@gmail.com"
        },
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "kanitw",
          "email": "kanitw@gmail.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_1.4.0_1697418399558_0.6785849208942332"
      },
      "_hasShrinkwrap": false
    },
    "1.4.1-next.0": {
      "name": "ts-json-schema-generator",
      "version": "1.4.1-next.0",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "MooYeol Prescott Lee",
          "email": "mooyoul@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=10.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.12",
        "commander": "^11.0.0",
        "glob": "^8.0.3",
        "json5": "^2.2.3",
        "normalize-path": "^3.0.0",
        "safe-stable-stringify": "^2.4.3",
        "typescript": "~5.3.2"
      },
      "devDependencies": {
        "@auto-it/conventional-commits": "^11.0.0",
        "@auto-it/first-time-contributor": "^11.0.0",
        "@babel/core": "^7.22.9",
        "@babel/preset-env": "^7.22.9",
        "@babel/preset-typescript": "^7.22.5",
        "@types/glob": "^8.1.0",
        "@types/jest": "^29.5.3",
        "@types/node": "^20.4.5",
        "@types/normalize-path": "^3.0.0",
        "@typescript-eslint/eslint-plugin": "^6.2.1",
        "@typescript-eslint/parser": "^6.2.1",
        "ajv": "^8.12.0",
        "ajv-formats": "^2.1.1",
        "auto": "^11.0.0",
        "chai": "^4.3.7",
        "cross-env": "^7.0.3",
        "eslint": "^8.46.0",
        "eslint-config-prettier": "^9.0.0",
        "eslint-plugin-prettier": "^5.0.0",
        "jest": "^29.6.2",
        "jest-junit": "^16.0.0",
        "prettier": "^3.0.0",
        "ts-node": "^10.9.1",
        "vega": "^5.25.0",
        "vega-lite": "^5.14.1"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint \"{src,test,factory}/**/*.ts\"",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "cross-env FAST_TEST=1 jest test/ --verbose",
        "test:coverage": "yarn jest test/ --collectCoverage=true",
        "test:update": "cross-env UPDATE_SCHEMA=true yarn test:fast",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node-transpile-only ts-json-schema-generator.ts",
        "release": "yarn build && auto shipit"
      },
      "packageManager": "yarn@1.22.19",
      "_id": "ts-json-schema-generator@1.4.1-next.0",
      "readme": "# ts-json-schema-generator\n\n![Test](https://github.com/vega/ts-json-schema-generator/workflows/Test/badge.svg)\n[![codecov](https://codecov.io/gh/vega/ts-json-schema-generator/branch/master/graph/badge.svg)](https://codecov.io/gh/vega/ts-json-schema-generator)\n[![npm version](https://img.shields.io/npm/v/ts-json-schema-generator.svg)](https://www.npmjs.com/package/ts-json-schema-generator)\n\nExtended version of [https://github.com/xiag-ag/typescript-to-json-schema](https://github.com/xiag-ag/typescript-to-json-schema).\n\nInspired by [`YousefED/typescript-json-schema`](https://github.com/YousefED/typescript-json-schema). Here's the differences list:\n\n-   this implementation avoids the use of `typeChecker.getTypeAtLocation()` (so probably it keeps correct type aliases)\n-   processing AST and formatting JSON schema have been split into two independent steps\n-   not exported types, interfaces, enums are not exposed in the `definitions` section in the JSON schema\n\n## Contributors\n\nThis project is made possible by a [community of contributors](https://github.com/vega/ts-json-schema-generator/graphs/contributors). We welcome contributions of any kind (issues, code, documentation, examples, tests,...). Please read our [code of conduct](https://vega.github.io/vega/about/code-of-conduct).\n\n## CLI Usage\n\nRun the schema generator with npx:\n\n```bash\nnpx ts-json-schema-generator --path 'my/project/**/*.ts' --type 'My.Type.Name'\n```\n\nOr install the package and then run it\n\n```bash\nnpm install --save ts-json-schema-generator\n./node_modules/.bin/ts-json-schema-generator --path 'my/project/**/*.ts' --type 'My.Type.Name'\n```\n\nNote that different platforms (e.g. Windows) may use different path separators so you may have to adjust the command above.\n\nAlso note that you need to quote paths with `*` as otherwise the shell will expand the paths and therefore only pass the first path to the generator.\n\n## Programmatic Usage\n\n```js\n// main.js\n\nconst tsj = require(\"ts-json-schema-generator\");\nconst fs = require(\"fs\");\n\n/** @type {import('ts-json-schema-generator/dist/src/Config').Config} */\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst output_path = \"path/to/output/file\";\n\nconst schema = tsj.createGenerator(config).createSchema(config.type);\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\nRun the schema generator via `node main.js`.\n\n### Custom formatting\n\nExtending the built-in formatting is possible by creating a custom formatter and adding it to the main formatter:\n\n1. First we create a formatter, in this case for formatting function types:\n\n```ts\n// my-function-formatter.ts\nimport { BaseType, Definition, FunctionType, SubTypeFormatter } from \"ts-json-schema-generator\";\nimport ts from \"typescript\";\n\nexport class MyFunctionTypeFormatter implements SubTypeFormatter {\n    // You can skip this line if you don't need childTypeFormatter\n    public constructor(private childTypeFormatter: TypeFormatter) {}\n\n    public supportsType(type: FunctionType): boolean {\n        return type instanceof FunctionType;\n    }\n\n    public getDefinition(type: FunctionType): Definition {\n        // Return a custom schema for the function property.\n        return {\n            type: \"object\",\n            properties: {\n                isFunction: {\n                    type: \"boolean\",\n                    const: true,\n                },\n            },\n        };\n    }\n\n    // If this type does NOT HAVE children, generally all you need is:\n    public getChildren(type: FunctionType): BaseType[] {\n        return [];\n    }\n\n    // However, if children ARE supported, you'll need something similar to\n    // this (see src/TypeFormatter/{Array,Definition,etc}.ts for some examples):\n    public getChildren(type: FunctionType): BaseType[] {\n        return this.childTypeFormatter.getChildren(type.getType());\n    }\n}\n```\n\n2. Then we add the formatter as a child to the core formatter using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyFunctionTypeFormatter } from \"./my-function-formatter.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\n// We configure the formatter an add our custom formatter to it.\nconst formatter = createFormatter(config, (fmt, circularReferenceTypeFormatter) => {\n    // If your formatter DOES NOT support children, e.g. getChildren() { return [] }:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter());\n    // If your formatter DOES support children, you'll need this reference too:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter(circularReferenceTypeFormatter));\n});\n\nconst program = createProgram(config);\nconst parser = createParser(program, config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n### Custom parsing\n\nSimilar to custom formatting, extending the built-in parsing works practically the same way:\n\n1. First we create a parser, in this case for parsing construct types:\n\n```ts\n// my-constructor-parser.ts\nimport { Context, StringType, ReferenceType, BaseType, SubNodeParser } from \"ts-json-schema-generator\";\n// use typescript exported by TJS to avoid version conflict\nimport ts from \"ts-json-schema-generator\";\n\nexport class MyConstructorParser implements SubNodeParser {\n    supportsNode(node: ts.Node): boolean {\n        return node.kind === ts.SyntaxKind.ConstructorType;\n    }\n    createType(node: ts.Node, context: Context, reference?: ReferenceType): BaseType | undefined {\n        return new StringType(); // Treat constructors as strings in this example\n    }\n}\n```\n\n2. Then we add the parser as a child to the core parser using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyConstructorParser } from \"./my-constructor-parser.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst program = createProgram(config);\n\n// We configure the parser an add our custom parser to it.\nconst parser = createParser(program, config, (prs) => {\n    prs.addNodeParser(new MyConstructorParser());\n});\n\nconst formatter = createFormatter(config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n## Options\n\n```\n-p, --path 'index.ts'\n    The path to the TypeScript source file. If this is not provided, the type will be searched in the project specified in the `.tsconfig`.\n\n-t, --type 'My.Type.Name'\n    The type the generated schema will represent. If omitted, the generated schema will contain all\n    types found in the files matching path. The same is true if '*' is specified.\n\n-i, --id 'generatedSchemaId'\n    The `$id` of the generated schema. If omitted, there will be no `$id`.\n\n-e, --expose <all|none|export>\n    all: Create shared $ref definitions for all types.\n    none: Do not create shared $ref definitions.\n    export (default): Create shared $ref definitions only for exported types (not tagged as `@internal`).\n\n-f, --tsconfig 'my/project/tsconfig.json'\n    Use a custom tsconfig file for processing typescript (see https://www.typescriptlang.org/docs/handbook/tsconfig-json.html) instead of the default:\n    {\n        \"compilerOptions\": {\n            \"noEmit\": true,\n            \"emitDecoratorMetadata\": true,\n            \"experimentalDecorators\": true,\n            \"target\": \"ES5\",\n            \"module\": \"CommonJS\",\n            \"strictNullChecks\": false,\n        }\n    }\n\n-j, --jsDoc <extended|none|basic>\n    none: Do not use JsDoc annotations.\n    basic: Read JsDoc annotations to provide schema properties.\n    extended (default): Also read @nullable, and @asType annotations.\n\n--unstable\n    Do not sort properties.\n\n--strict-tuples\n    Do not allow additional items on tuples.\n\n--no-top-ref\n    Do not create a top-level $ref definition.\n\n--no-type-check\n    Skip type checks for better performance.\n\n--no-ref-encode\n    Do not encode references. According to the standard, references must be valid URIs but some tools do not support encoded references.\n\n--validation-keywords\n    Provide additional validation keywords to include.\n\n-o, --out\n    Specify the output file path. Without this option, the generator logs the response in the console.\n\n--additional-properties <true|false>\n    Controls whether or not to allow additional properties for objects that have no index signature.\n\n    true: Additional properties are allowed\n    false (default): Additional properties are not allowed\n\n--minify\n    Minify generated schema (default: false)\n```\n\n## Current state\n\n-   `interface` types\n-   `enum` types\n-   `union`, `tuple`, `type[]` types\n-   `Date`, `RegExp`, `URL` types\n-   `string`, `boolean`, `number` types\n-   `\"value\"`, `123`, `true`, `false`, `null`, `undefined` literals\n-   type aliases\n-   generics\n-   `typeof`\n-   `keyof`\n-   conditional types\n\n## Run locally\n\n`yarn --silent run run --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\n## Debug\n\n`yarn --silent run debug --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\nAnd connect via the debugger protocol.\n\n[AST Explorer](https://astexplorer.net/) is amazing for developers of this tool!\n\n## Publish\n\nPublishing is handled by a 2-branch [pre-release process](https://intuit.github.io/auto/docs/generated/shipit#next-branch-default), configured in `publish-auto.yml`. All changes should be based off the default `next` branch, and are published automatically.\n\n-   PRs made into the default branch are auto-deployed to the `next` pre-release tag on NPM. The result can be installed with `npm install ts-json-schema-generator@next`\n    -   When merging into `next`, please use the `squash and merge` strategy.\n-   To release a new stable version, open a PR from `next` into `stable` using this [compare link](https://github.com/vega/ts-json-schema-generator/compare/stable...next).\n    -   When merging from `next` into `stable`, please use the `create a merge commit` strategy.\n",
      "readmeFilename": "README.md",
      "gitHead": "2c8c088b26a846e3dcb0954353968880caeeff1a",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_nodeVersion": "18.18.2",
      "_npmVersion": "9.8.1",
      "dist": {
        "integrity": "sha512-dHZ+rVbtBhPLMiDXICJ+8RfDrvtzZ9YQYHelaCJC4vUeJHm/w6Le+dg1tZnbtlNY2+lPFkOdZzicuJu0Ms15dA==",
        "shasum": "28bb380c0b8c92605a805d13b8dc466e2d2bda09",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-1.4.1-next.0.tgz",
        "fileCount": 726,
        "unpackedSize": 907478,
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEQCIE0aFMQ+2BQcyB8/WqJXmU35ZwbX9Hq+fq+syqatqygNAiBNnksBldK7A8LT/5337vakfiEskRrTCL5O7ufbjdHkfg=="
          }
        ]
      },
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "maintainers": [
        {
          "name": "jheer",
          "email": "jeffrey.heer@gmail.com"
        },
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "kanitw",
          "email": "kanitw@gmail.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_1.4.1-next.0_1701095945710_0.06664970746186061"
      },
      "_hasShrinkwrap": false
    },
    "1.4.1": {
      "name": "ts-json-schema-generator",
      "version": "1.4.1",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "MooYeol Prescott Lee",
          "email": "mooyoul@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=10.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.12",
        "commander": "^11.0.0",
        "glob": "^8.0.3",
        "json5": "^2.2.3",
        "normalize-path": "^3.0.0",
        "safe-stable-stringify": "^2.4.3",
        "typescript": "~5.3.2"
      },
      "devDependencies": {
        "@auto-it/conventional-commits": "^11.0.0",
        "@auto-it/first-time-contributor": "^11.0.0",
        "@babel/core": "^7.22.9",
        "@babel/preset-env": "^7.22.9",
        "@babel/preset-typescript": "^7.22.5",
        "@types/glob": "^8.1.0",
        "@types/jest": "^29.5.3",
        "@types/node": "^20.4.5",
        "@types/normalize-path": "^3.0.0",
        "@typescript-eslint/eslint-plugin": "^6.2.1",
        "@typescript-eslint/parser": "^6.2.1",
        "ajv": "^8.12.0",
        "ajv-formats": "^2.1.1",
        "auto": "^11.0.0",
        "chai": "^4.3.7",
        "cross-env": "^7.0.3",
        "eslint": "^8.46.0",
        "eslint-config-prettier": "^9.0.0",
        "eslint-plugin-prettier": "^5.0.0",
        "jest": "^29.6.2",
        "jest-junit": "^16.0.0",
        "prettier": "^3.0.0",
        "ts-node": "^10.9.1",
        "vega": "^5.25.0",
        "vega-lite": "^5.14.1"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint \"{src,test,factory}/**/*.ts\"",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "cross-env FAST_TEST=1 jest test/ --verbose",
        "test:coverage": "yarn jest test/ --collectCoverage=true",
        "test:update": "cross-env UPDATE_SCHEMA=true yarn test:fast",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node-transpile-only ts-json-schema-generator.ts",
        "release": "yarn build && auto shipit"
      },
      "packageManager": "yarn@1.22.19",
      "_id": "ts-json-schema-generator@1.4.1",
      "gitHead": "404ea5e24f75c693e2b43a1bc52fd1b899f6a238",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_nodeVersion": "18.18.2",
      "_npmVersion": "9.8.1",
      "dist": {
        "integrity": "sha512-wnhPMtskk9KvsTuU8AYx0TNdm1YrLVUEontT22+jL12JIPqPXdaoxPgsYBhlqDXsR9R9Nm2bJgH5r4IrTMbTSg==",
        "shasum": "83a72dace79c8684b6d0fcad1c7d49c656e985d2",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-1.4.1.tgz",
        "fileCount": 726,
        "unpackedSize": 907464,
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEYCIQCAZRVN3ll5c2U2IaWpzbaVCLR3JnUrx/3RS5OqUVuhDQIhAOI9dkh51tlYEM25pHxotuvg1ZxGSw5mN7J4JU7wdjbF"
          }
        ]
      },
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "maintainers": [
        {
          "name": "jheer",
          "email": "jeffrey.heer@gmail.com"
        },
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "kanitw",
          "email": "kanitw@gmail.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_1.4.1_1701099615290_0.5807363081709518"
      },
      "_hasShrinkwrap": false
    },
    "1.5.0-next.0": {
      "name": "ts-json-schema-generator",
      "version": "1.5.0-next.0",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "MooYeol Prescott Lee",
          "email": "mooyoul@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=10.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.12",
        "commander": "^11.0.0",
        "glob": "^8.0.3",
        "json5": "^2.2.3",
        "normalize-path": "^3.0.0",
        "safe-stable-stringify": "^2.4.3",
        "typescript": "~5.3.2"
      },
      "devDependencies": {
        "@auto-it/conventional-commits": "^11.0.0",
        "@auto-it/first-time-contributor": "^11.0.0",
        "@babel/core": "^7.22.9",
        "@babel/preset-env": "^7.22.9",
        "@babel/preset-typescript": "^7.22.5",
        "@types/glob": "^8.1.0",
        "@types/jest": "^29.5.3",
        "@types/node": "^20.4.5",
        "@types/normalize-path": "^3.0.0",
        "@typescript-eslint/eslint-plugin": "^6.2.1",
        "@typescript-eslint/parser": "^6.2.1",
        "ajv": "^8.12.0",
        "ajv-formats": "^2.1.1",
        "auto": "^11.0.0",
        "chai": "^4.3.7",
        "cross-env": "^7.0.3",
        "eslint": "^8.46.0",
        "eslint-config-prettier": "^9.0.0",
        "eslint-plugin-prettier": "^5.0.0",
        "jest": "^29.6.2",
        "jest-junit": "^16.0.0",
        "prettier": "^3.0.0",
        "ts-node": "^10.9.1",
        "vega": "^5.25.0",
        "vega-lite": "^5.14.1"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint \"{src,test,factory}/**/*.ts\"",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "cross-env FAST_TEST=1 jest test/ --verbose",
        "test:coverage": "yarn jest test/ --collectCoverage=true",
        "test:update": "cross-env UPDATE_SCHEMA=true yarn test:fast",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node-transpile-only ts-json-schema-generator.ts",
        "release": "yarn build && auto shipit"
      },
      "packageManager": "yarn@1.22.19",
      "_id": "ts-json-schema-generator@1.5.0-next.0",
      "readme": "# ts-json-schema-generator\n\n![Test](https://github.com/vega/ts-json-schema-generator/workflows/Test/badge.svg)\n[![codecov](https://codecov.io/gh/vega/ts-json-schema-generator/branch/master/graph/badge.svg)](https://codecov.io/gh/vega/ts-json-schema-generator)\n[![npm version](https://img.shields.io/npm/v/ts-json-schema-generator.svg)](https://www.npmjs.com/package/ts-json-schema-generator)\n\nExtended version of [https://github.com/xiag-ag/typescript-to-json-schema](https://github.com/xiag-ag/typescript-to-json-schema).\n\nInspired by [`YousefED/typescript-json-schema`](https://github.com/YousefED/typescript-json-schema). Here's the differences list:\n\n-   this implementation avoids the use of `typeChecker.getTypeAtLocation()` (so probably it keeps correct type aliases)\n-   processing AST and formatting JSON schema have been split into two independent steps\n-   not exported types, interfaces, enums are not exposed in the `definitions` section in the JSON schema\n\n## Contributors\n\nThis project is made possible by a [community of contributors](https://github.com/vega/ts-json-schema-generator/graphs/contributors). We welcome contributions of any kind (issues, code, documentation, examples, tests,...). Please read our [code of conduct](https://vega.github.io/vega/about/code-of-conduct).\n\n## CLI Usage\n\nRun the schema generator with npx:\n\n```bash\nnpx ts-json-schema-generator --path 'my/project/**/*.ts' --type 'My.Type.Name'\n```\n\nOr install the package and then run it\n\n```bash\nnpm install --save ts-json-schema-generator\n./node_modules/.bin/ts-json-schema-generator --path 'my/project/**/*.ts' --type 'My.Type.Name'\n```\n\nNote that different platforms (e.g. Windows) may use different path separators so you may have to adjust the command above.\n\nAlso note that you need to quote paths with `*` as otherwise the shell will expand the paths and therefore only pass the first path to the generator.\n\n## Programmatic Usage\n\n```js\n// main.js\n\nconst tsj = require(\"ts-json-schema-generator\");\nconst fs = require(\"fs\");\n\n/** @type {import('ts-json-schema-generator/dist/src/Config').Config} */\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst output_path = \"path/to/output/file\";\n\nconst schema = tsj.createGenerator(config).createSchema(config.type);\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\nRun the schema generator via `node main.js`.\n\n### Custom formatting\n\nExtending the built-in formatting is possible by creating a custom formatter and adding it to the main formatter:\n\n1. First we create a formatter, in this case for formatting function types:\n\n```ts\n// my-function-formatter.ts\nimport { BaseType, Definition, FunctionType, SubTypeFormatter } from \"ts-json-schema-generator\";\nimport ts from \"typescript\";\n\nexport class MyFunctionTypeFormatter implements SubTypeFormatter {\n    // You can skip this line if you don't need childTypeFormatter\n    public constructor(private childTypeFormatter: TypeFormatter) {}\n\n    public supportsType(type: FunctionType): boolean {\n        return type instanceof FunctionType;\n    }\n\n    public getDefinition(type: FunctionType): Definition {\n        // Return a custom schema for the function property.\n        return {\n            type: \"object\",\n            properties: {\n                isFunction: {\n                    type: \"boolean\",\n                    const: true,\n                },\n            },\n        };\n    }\n\n    // If this type does NOT HAVE children, generally all you need is:\n    public getChildren(type: FunctionType): BaseType[] {\n        return [];\n    }\n\n    // However, if children ARE supported, you'll need something similar to\n    // this (see src/TypeFormatter/{Array,Definition,etc}.ts for some examples):\n    public getChildren(type: FunctionType): BaseType[] {\n        return this.childTypeFormatter.getChildren(type.getType());\n    }\n}\n```\n\n2. Then we add the formatter as a child to the core formatter using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyFunctionTypeFormatter } from \"./my-function-formatter.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\n// We configure the formatter an add our custom formatter to it.\nconst formatter = createFormatter(config, (fmt, circularReferenceTypeFormatter) => {\n    // If your formatter DOES NOT support children, e.g. getChildren() { return [] }:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter());\n    // If your formatter DOES support children, you'll need this reference too:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter(circularReferenceTypeFormatter));\n});\n\nconst program = createProgram(config);\nconst parser = createParser(program, config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n### Custom parsing\n\nSimilar to custom formatting, extending the built-in parsing works practically the same way:\n\n1. First we create a parser, in this case for parsing construct types:\n\n```ts\n// my-constructor-parser.ts\nimport { Context, StringType, ReferenceType, BaseType, SubNodeParser } from \"ts-json-schema-generator\";\n// use typescript exported by TJS to avoid version conflict\nimport ts from \"ts-json-schema-generator\";\n\nexport class MyConstructorParser implements SubNodeParser {\n    supportsNode(node: ts.Node): boolean {\n        return node.kind === ts.SyntaxKind.ConstructorType;\n    }\n    createType(node: ts.Node, context: Context, reference?: ReferenceType): BaseType | undefined {\n        return new StringType(); // Treat constructors as strings in this example\n    }\n}\n```\n\n2. Then we add the parser as a child to the core parser using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyConstructorParser } from \"./my-constructor-parser.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst program = createProgram(config);\n\n// We configure the parser an add our custom parser to it.\nconst parser = createParser(program, config, (prs) => {\n    prs.addNodeParser(new MyConstructorParser());\n});\n\nconst formatter = createFormatter(config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n## Options\n\n```\n-p, --path 'index.ts'\n    The path to the TypeScript source file. If this is not provided, the type will be searched in the project specified in the `.tsconfig`.\n\n-t, --type 'My.Type.Name'\n    The type the generated schema will represent. If omitted, the generated schema will contain all\n    types found in the files matching path. The same is true if '*' is specified.\n\n-i, --id 'generatedSchemaId'\n    The `$id` of the generated schema. If omitted, there will be no `$id`.\n\n-e, --expose <all|none|export>\n    all: Create shared $ref definitions for all types.\n    none: Do not create shared $ref definitions.\n    export (default): Create shared $ref definitions only for exported types (not tagged as `@internal`).\n\n-f, --tsconfig 'my/project/tsconfig.json'\n    Use a custom tsconfig file for processing typescript (see https://www.typescriptlang.org/docs/handbook/tsconfig-json.html) instead of the default:\n    {\n        \"compilerOptions\": {\n            \"noEmit\": true,\n            \"emitDecoratorMetadata\": true,\n            \"experimentalDecorators\": true,\n            \"target\": \"ES5\",\n            \"module\": \"CommonJS\",\n            \"strictNullChecks\": false,\n        }\n    }\n\n-j, --jsDoc <extended|none|basic>\n    none: Do not use JsDoc annotations.\n    basic: Read JsDoc annotations to provide schema properties.\n    extended (default): Also read @nullable, and @asType annotations.\n\n--unstable\n    Do not sort properties.\n\n--strict-tuples\n    Do not allow additional items on tuples.\n\n--no-top-ref\n    Do not create a top-level $ref definition.\n\n--no-type-check\n    Skip type checks for better performance.\n\n--no-ref-encode\n    Do not encode references. According to the standard, references must be valid URIs but some tools do not support encoded references.\n\n--validation-keywords\n    Provide additional validation keywords to include.\n\n-o, --out\n    Specify the output file path. Without this option, the generator logs the response in the console.\n\n--additional-properties <true|false>\n    Controls whether or not to allow additional properties for objects that have no index signature.\n\n    true: Additional properties are allowed\n    false (default): Additional properties are not allowed\n\n--minify\n    Minify generated schema (default: false)\n```\n\n## Current state\n\n-   `interface` types\n-   `enum` types\n-   `union`, `tuple`, `type[]` types\n-   `Date`, `RegExp`, `URL` types\n-   `string`, `boolean`, `number` types\n-   `\"value\"`, `123`, `true`, `false`, `null`, `undefined` literals\n-   type aliases\n-   generics\n-   `typeof`\n-   `keyof`\n-   conditional types\n\n## Run locally\n\n`yarn --silent run run --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\n## Debug\n\n`yarn --silent run debug --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\nAnd connect via the debugger protocol.\n\n[AST Explorer](https://astexplorer.net/) is amazing for developers of this tool!\n\n## Publish\n\nPublishing is handled by a 2-branch [pre-release process](https://intuit.github.io/auto/docs/generated/shipit#next-branch-default), configured in `publish-auto.yml`. All changes should be based off the default `next` branch, and are published automatically.\n\n-   PRs made into the default branch are auto-deployed to the `next` pre-release tag on NPM. The result can be installed with `npm install ts-json-schema-generator@next`\n    -   When merging into `next`, please use the `squash and merge` strategy.\n-   To release a new stable version, open a PR from `next` into `stable` using this [compare link](https://github.com/vega/ts-json-schema-generator/compare/stable...next).\n    -   When merging from `next` into `stable`, please use the `create a merge commit` strategy.\n",
      "readmeFilename": "README.md",
      "gitHead": "f5cb7c05951e6fb78f618400455f890e9ed0fed7",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_nodeVersion": "18.18.2",
      "_npmVersion": "9.8.1",
      "dist": {
        "integrity": "sha512-yCg40fq9fFPyx3Q39RDBh16pBQikw3JRd/kwbzq8zSokWhtYes70pd4QCnJiOqh1beLu1bMd2a55AVSvNJpxKw==",
        "shasum": "381a8e71564de34b11fa871b14fab5aca66ef08b",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-1.5.0-next.0.tgz",
        "fileCount": 726,
        "unpackedSize": 907641,
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIQDajqLeoBbYKf+TUEDXd2mxMkWVsW+ybm8/H/Rfq3juKgIgWfx3EZ91Kc/sbCPfP8r7eruJoqXcbH2amAS0K6Faw2U="
          }
        ]
      },
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "maintainers": [
        {
          "name": "jheer",
          "email": "jeffrey.heer@gmail.com"
        },
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "kanitw",
          "email": "kanitw@gmail.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_1.5.0-next.0_1701803362079_0.23775137463678142"
      },
      "_hasShrinkwrap": false
    },
    "1.5.0": {
      "name": "ts-json-schema-generator",
      "version": "1.5.0",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "MooYeol Prescott Lee",
          "email": "mooyoul@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=10.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.12",
        "commander": "^11.0.0",
        "glob": "^8.0.3",
        "json5": "^2.2.3",
        "normalize-path": "^3.0.0",
        "safe-stable-stringify": "^2.4.3",
        "typescript": "~5.3.2"
      },
      "devDependencies": {
        "@auto-it/conventional-commits": "^11.0.0",
        "@auto-it/first-time-contributor": "^11.0.0",
        "@babel/core": "^7.22.9",
        "@babel/preset-env": "^7.22.9",
        "@babel/preset-typescript": "^7.22.5",
        "@types/glob": "^8.1.0",
        "@types/jest": "^29.5.3",
        "@types/node": "^20.4.5",
        "@types/normalize-path": "^3.0.0",
        "@typescript-eslint/eslint-plugin": "^6.2.1",
        "@typescript-eslint/parser": "^6.2.1",
        "ajv": "^8.12.0",
        "ajv-formats": "^2.1.1",
        "auto": "^11.0.0",
        "chai": "^4.3.7",
        "cross-env": "^7.0.3",
        "eslint": "^8.46.0",
        "eslint-config-prettier": "^9.0.0",
        "eslint-plugin-prettier": "^5.0.0",
        "jest": "^29.6.2",
        "jest-junit": "^16.0.0",
        "prettier": "^3.0.0",
        "ts-node": "^10.9.1",
        "vega": "^5.25.0",
        "vega-lite": "^5.14.1"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint \"{src,test,factory}/**/*.ts\"",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "cross-env FAST_TEST=1 jest test/ --verbose",
        "test:coverage": "yarn jest test/ --collectCoverage=true",
        "test:update": "cross-env UPDATE_SCHEMA=true yarn test:fast",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node-transpile-only ts-json-schema-generator.ts",
        "release": "yarn build && auto shipit"
      },
      "packageManager": "yarn@1.22.19",
      "_id": "ts-json-schema-generator@1.5.0",
      "gitHead": "6b44791fdd67ebfdb7e4a36f352ded0d21fd7f86",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_nodeVersion": "18.18.2",
      "_npmVersion": "9.8.1",
      "dist": {
        "integrity": "sha512-RkiaJ6YxGc5EWVPfyHxszTmpGxX8HC2XBvcFlAl1zcvpOG4tjjh+eXioStXJQYTvr9MoK8zCOWzAUlko3K0DiA==",
        "shasum": "9f5cea606c27ebcf13060157542ac1d3b225430f",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-1.5.0.tgz",
        "fileCount": 726,
        "unpackedSize": 907627,
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEQCIERwFmdKIA4EpbXHd4gSVCDWmG6UpefMXGQOvPjINJInAiALvxZg5CqKYOALo5aYvRoL+g9m3sKu6LwBcmFC0O1q2Q=="
          }
        ]
      },
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "maintainers": [
        {
          "name": "jheer",
          "email": "jeffrey.heer@gmail.com"
        },
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "kanitw",
          "email": "kanitw@gmail.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_1.5.0_1701803387248_0.19196895320914775"
      },
      "_hasShrinkwrap": false
    },
    "1.5.1-next.0": {
      "name": "ts-json-schema-generator",
      "version": "1.5.1-next.0",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "MooYeol Prescott Lee",
          "email": "mooyoul@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=10.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.12",
        "commander": "^11.0.0",
        "glob": "^8.0.3",
        "json5": "^2.2.3",
        "normalize-path": "^3.0.0",
        "safe-stable-stringify": "^2.4.3",
        "typescript": "~5.3.2"
      },
      "devDependencies": {
        "@auto-it/conventional-commits": "^11.0.0",
        "@auto-it/first-time-contributor": "^11.0.0",
        "@babel/core": "^7.22.9",
        "@babel/preset-env": "^7.22.9",
        "@babel/preset-typescript": "^7.22.5",
        "@types/glob": "^8.1.0",
        "@types/jest": "^29.5.3",
        "@types/node": "^20.4.5",
        "@types/normalize-path": "^3.0.0",
        "@typescript-eslint/eslint-plugin": "^6.2.1",
        "@typescript-eslint/parser": "^6.2.1",
        "ajv": "^8.12.0",
        "ajv-formats": "^2.1.1",
        "auto": "^11.0.0",
        "chai": "^4.3.7",
        "cross-env": "^7.0.3",
        "eslint": "^8.46.0",
        "eslint-config-prettier": "^9.0.0",
        "eslint-plugin-prettier": "^5.0.0",
        "jest": "^29.6.2",
        "jest-junit": "^16.0.0",
        "prettier": "^3.0.0",
        "ts-node": "^10.9.1",
        "vega": "^5.25.0",
        "vega-lite": "^5.14.1"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint \"{src,test,factory}/**/*.ts\"",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "cross-env FAST_TEST=1 jest test/ --verbose",
        "test:coverage": "yarn jest test/ --collectCoverage=true",
        "test:update": "cross-env UPDATE_SCHEMA=true yarn test:fast",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node-transpile-only ts-json-schema-generator.ts",
        "release": "yarn build && auto shipit"
      },
      "packageManager": "yarn@1.22.19",
      "_id": "ts-json-schema-generator@1.5.1-next.0",
      "readme": "# ts-json-schema-generator\n\n![Test](https://github.com/vega/ts-json-schema-generator/workflows/Test/badge.svg)\n[![codecov](https://codecov.io/gh/vega/ts-json-schema-generator/branch/master/graph/badge.svg)](https://codecov.io/gh/vega/ts-json-schema-generator)\n[![npm version](https://img.shields.io/npm/v/ts-json-schema-generator.svg)](https://www.npmjs.com/package/ts-json-schema-generator)\n\nExtended version of [https://github.com/xiag-ag/typescript-to-json-schema](https://github.com/xiag-ag/typescript-to-json-schema).\n\nInspired by [`YousefED/typescript-json-schema`](https://github.com/YousefED/typescript-json-schema). Here's the differences list:\n\n-   this implementation avoids the use of `typeChecker.getTypeAtLocation()` (so probably it keeps correct type aliases)\n-   processing AST and formatting JSON schema have been split into two independent steps\n-   not exported types, interfaces, enums are not exposed in the `definitions` section in the JSON schema\n\n## Contributors\n\nThis project is made possible by a [community of contributors](https://github.com/vega/ts-json-schema-generator/graphs/contributors). We welcome contributions of any kind (issues, code, documentation, examples, tests,...). Please read our [code of conduct](https://vega.github.io/vega/about/code-of-conduct).\n\n## CLI Usage\n\nRun the schema generator with npx:\n\n```bash\nnpx ts-json-schema-generator --path 'my/project/**/*.ts' --type 'My.Type.Name'\n```\n\nOr install the package and then run it\n\n```bash\nnpm install --save ts-json-schema-generator\n./node_modules/.bin/ts-json-schema-generator --path 'my/project/**/*.ts' --type 'My.Type.Name'\n```\n\nNote that different platforms (e.g. Windows) may use different path separators so you may have to adjust the command above.\n\nAlso note that you need to quote paths with `*` as otherwise the shell will expand the paths and therefore only pass the first path to the generator.\n\n## Programmatic Usage\n\n```js\n// main.js\n\nconst tsj = require(\"ts-json-schema-generator\");\nconst fs = require(\"fs\");\n\n/** @type {import('ts-json-schema-generator/dist/src/Config').Config} */\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst output_path = \"path/to/output/file\";\n\nconst schema = tsj.createGenerator(config).createSchema(config.type);\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\nRun the schema generator via `node main.js`.\n\n### Custom formatting\n\nExtending the built-in formatting is possible by creating a custom formatter and adding it to the main formatter:\n\n1. First we create a formatter, in this case for formatting function types:\n\n```ts\n// my-function-formatter.ts\nimport { BaseType, Definition, FunctionType, SubTypeFormatter } from \"ts-json-schema-generator\";\nimport ts from \"typescript\";\n\nexport class MyFunctionTypeFormatter implements SubTypeFormatter {\n    // You can skip this line if you don't need childTypeFormatter\n    public constructor(private childTypeFormatter: TypeFormatter) {}\n\n    public supportsType(type: FunctionType): boolean {\n        return type instanceof FunctionType;\n    }\n\n    public getDefinition(type: FunctionType): Definition {\n        // Return a custom schema for the function property.\n        return {\n            type: \"object\",\n            properties: {\n                isFunction: {\n                    type: \"boolean\",\n                    const: true,\n                },\n            },\n        };\n    }\n\n    // If this type does NOT HAVE children, generally all you need is:\n    public getChildren(type: FunctionType): BaseType[] {\n        return [];\n    }\n\n    // However, if children ARE supported, you'll need something similar to\n    // this (see src/TypeFormatter/{Array,Definition,etc}.ts for some examples):\n    public getChildren(type: FunctionType): BaseType[] {\n        return this.childTypeFormatter.getChildren(type.getType());\n    }\n}\n```\n\n2. Then we add the formatter as a child to the core formatter using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyFunctionTypeFormatter } from \"./my-function-formatter.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\n// We configure the formatter an add our custom formatter to it.\nconst formatter = createFormatter(config, (fmt, circularReferenceTypeFormatter) => {\n    // If your formatter DOES NOT support children, e.g. getChildren() { return [] }:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter());\n    // If your formatter DOES support children, you'll need this reference too:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter(circularReferenceTypeFormatter));\n});\n\nconst program = createProgram(config);\nconst parser = createParser(program, config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n### Custom parsing\n\nSimilar to custom formatting, extending the built-in parsing works practically the same way:\n\n1. First we create a parser, in this case for parsing construct types:\n\n```ts\n// my-constructor-parser.ts\nimport { Context, StringType, ReferenceType, BaseType, SubNodeParser } from \"ts-json-schema-generator\";\n// use typescript exported by TJS to avoid version conflict\nimport ts from \"ts-json-schema-generator\";\n\nexport class MyConstructorParser implements SubNodeParser {\n    supportsNode(node: ts.Node): boolean {\n        return node.kind === ts.SyntaxKind.ConstructorType;\n    }\n    createType(node: ts.Node, context: Context, reference?: ReferenceType): BaseType | undefined {\n        return new StringType(); // Treat constructors as strings in this example\n    }\n}\n```\n\n2. Then we add the parser as a child to the core parser using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyConstructorParser } from \"./my-constructor-parser.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst program = createProgram(config);\n\n// We configure the parser an add our custom parser to it.\nconst parser = createParser(program, config, (prs) => {\n    prs.addNodeParser(new MyConstructorParser());\n});\n\nconst formatter = createFormatter(config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n## Options\n\n```\n-p, --path 'index.ts'\n    The path to the TypeScript source file. If this is not provided, the type will be searched in the project specified in the `.tsconfig`.\n\n-t, --type 'My.Type.Name'\n    The type the generated schema will represent. If omitted, the generated schema will contain all\n    types found in the files matching path. The same is true if '*' is specified.\n\n-i, --id 'generatedSchemaId'\n    The `$id` of the generated schema. If omitted, there will be no `$id`.\n\n-e, --expose <all|none|export>\n    all: Create shared $ref definitions for all types.\n    none: Do not create shared $ref definitions.\n    export (default): Create shared $ref definitions only for exported types (not tagged as `@internal`).\n\n-f, --tsconfig 'my/project/tsconfig.json'\n    Use a custom tsconfig file for processing typescript (see https://www.typescriptlang.org/docs/handbook/tsconfig-json.html) instead of the default:\n    {\n        \"compilerOptions\": {\n            \"noEmit\": true,\n            \"emitDecoratorMetadata\": true,\n            \"experimentalDecorators\": true,\n            \"target\": \"ES5\",\n            \"module\": \"CommonJS\",\n            \"strictNullChecks\": false,\n        }\n    }\n\n-j, --jsDoc <extended|none|basic>\n    none: Do not use JsDoc annotations.\n    basic: Read JsDoc annotations to provide schema properties.\n    extended (default): Also read @nullable, and @asType annotations.\n\n--unstable\n    Do not sort properties.\n\n--strict-tuples\n    Do not allow additional items on tuples.\n\n--no-top-ref\n    Do not create a top-level $ref definition.\n\n--no-type-check\n    Skip type checks for better performance.\n\n--no-ref-encode\n    Do not encode references. According to the standard, references must be valid URIs but some tools do not support encoded references.\n\n--validation-keywords\n    Provide additional validation keywords to include.\n\n-o, --out\n    Specify the output file path. Without this option, the generator logs the response in the console.\n\n--additional-properties <true|false>\n    Controls whether or not to allow additional properties for objects that have no index signature.\n\n    true: Additional properties are allowed\n    false (default): Additional properties are not allowed\n\n--minify\n    Minify generated schema (default: false)\n```\n\n## Current state\n\n-   `interface` types\n-   `enum` types\n-   `union`, `tuple`, `type[]` types\n-   `Date`, `RegExp`, `URL` types\n-   `string`, `boolean`, `number` types\n-   `\"value\"`, `123`, `true`, `false`, `null`, `undefined` literals\n-   type aliases\n-   generics\n-   `typeof`\n-   `keyof`\n-   conditional types\n\n## Run locally\n\n`yarn --silent run run --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\n## Debug\n\n`yarn --silent run debug --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\nAnd connect via the debugger protocol.\n\n[AST Explorer](https://astexplorer.net/) is amazing for developers of this tool!\n\n## Publish\n\nPublishing is handled by a 2-branch [pre-release process](https://intuit.github.io/auto/docs/generated/shipit#next-branch-default), configured in `publish-auto.yml`. All changes should be based off the default `next` branch, and are published automatically.\n\n-   PRs made into the default branch are auto-deployed to the `next` pre-release tag on NPM. The result can be installed with `npm install ts-json-schema-generator@next`\n    -   When merging into `next`, please use the `squash and merge` strategy.\n-   To release a new stable version, open a PR from `next` into `stable` using this [compare link](https://github.com/vega/ts-json-schema-generator/compare/stable...next).\n    -   When merging from `next` into `stable`, please use the `create a merge commit` strategy.\n",
      "readmeFilename": "README.md",
      "gitHead": "8bff094392029da0027f10b22f675672b3b3414f",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_nodeVersion": "18.18.2",
      "_npmVersion": "9.8.1",
      "dist": {
        "integrity": "sha512-0O2/SqDi/fxbgZd+o9BYVm4ltmLvW93YrsRvRV5i3cB5pUDn0+T2c4iaj20PkCQmB1x50FJvMFO8+ERKCMUb/Q==",
        "shasum": "91cb255b81b3d23b3b8564e9d95f28733eaae9d6",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-1.5.1-next.0.tgz",
        "fileCount": 726,
        "unpackedSize": 907896,
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEQCH34fMVHSdPMB8K7Lj1WVzAKMLIwcyl5lbR20oBH8zPsCIQDRaFRmnUzZ+wukELI6QU0kBs9SSOkFOOMWCsKYiaQlyA=="
          }
        ]
      },
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "maintainers": [
        {
          "name": "jheer",
          "email": "jeffrey.heer@gmail.com"
        },
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "kanitw",
          "email": "kanitw@gmail.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_1.5.1-next.0_1701868546166_0.9150034101290918"
      },
      "_hasShrinkwrap": false
    },
    "1.5.1--canary.1846.9f69a47.0": {
      "name": "ts-json-schema-generator",
      "version": "1.5.1--canary.1846.9f69a47.0",
      "description": "Generate JSON schema from your Typescript sources",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "bin": {
        "ts-json-schema-generator": "bin/ts-json-schema-generator"
      },
      "author": {
        "name": "Alexander Evtushenko",
        "email": "aevtushenko@xiag.ch"
      },
      "contributors": [
        {
          "name": "Dominik Moritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "MooYeol Prescott Lee",
          "email": "mooyoul@gmail.com"
        }
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/vega/ts-json-schema-generator.git"
      },
      "license": "MIT",
      "keywords": [
        "ts",
        "typescript",
        "json",
        "schema",
        "jsonschema"
      ],
      "engines": {
        "node": ">=10.0.0"
      },
      "dependencies": {
        "@types/json-schema": "^7.0.15",
        "commander": "^11.1.0",
        "glob": "^8.0.3",
        "json5": "^2.2.3",
        "normalize-path": "^3.0.0",
        "safe-stable-stringify": "^2.4.3",
        "typescript": "~5.3.3"
      },
      "devDependencies": {
        "@auto-it/conventional-commits": "^11.0.4",
        "@auto-it/first-time-contributor": "^11.0.4",
        "@babel/core": "^7.23.5",
        "@babel/preset-env": "^7.23.5",
        "@babel/preset-typescript": "^7.23.3",
        "@types/glob": "^8.1.0",
        "@types/jest": "^29.5.11",
        "@types/node": "^20.10.4",
        "@types/normalize-path": "^3.0.2",
        "@typescript-eslint/eslint-plugin": "^6.13.2",
        "@typescript-eslint/parser": "^6.13.2",
        "ajv": "^8.12.0",
        "ajv-formats": "^2.1.1",
        "auto": "^11.0.4",
        "chai": "^5.0.0",
        "cross-env": "^7.0.3",
        "eslint": "^8.55.0",
        "eslint-config-prettier": "^9.1.0",
        "eslint-plugin-prettier": "^5.0.1",
        "jest": "^29.7.0",
        "jest-junit": "^16.0.0",
        "prettier": "^3.1.1",
        "ts-node": "^10.9.2",
        "vega": "^5.27.0",
        "vega-lite": "^5.16.3"
      },
      "scripts": {
        "prepublishOnly": "yarn build",
        "build": "tsc",
        "watch": "tsc -w",
        "lint": "eslint \"{src,test,factory}/**/*.ts\"",
        "format": "yarn lint --fix",
        "test": "jest test/ --verbose",
        "test:fast": "cross-env FAST_TEST=1 jest test/ --verbose",
        "test:coverage": "yarn jest test/ --collectCoverage=true",
        "test:update": "cross-env UPDATE_SCHEMA=true yarn test:fast",
        "debug": "node -r ts-node/register --inspect-brk ts-json-schema-generator.ts",
        "run": "ts-node-transpile-only ts-json-schema-generator.ts",
        "release": "yarn build && auto shipit"
      },
      "packageManager": "yarn@1.22.19",
      "_id": "ts-json-schema-generator@1.5.1--canary.1846.9f69a47.0",
      "readme": "# ts-json-schema-generator\n\n![Test](https://github.com/vega/ts-json-schema-generator/workflows/Test/badge.svg)\n[![codecov](https://codecov.io/gh/vega/ts-json-schema-generator/branch/master/graph/badge.svg)](https://codecov.io/gh/vega/ts-json-schema-generator)\n[![npm version](https://img.shields.io/npm/v/ts-json-schema-generator.svg)](https://www.npmjs.com/package/ts-json-schema-generator)\n\nExtended version of [https://github.com/xiag-ag/typescript-to-json-schema](https://github.com/xiag-ag/typescript-to-json-schema).\n\nInspired by [`YousefED/typescript-json-schema`](https://github.com/YousefED/typescript-json-schema). Here's the differences list:\n\n-   this implementation avoids the use of `typeChecker.getTypeAtLocation()` (so probably it keeps correct type aliases)\n-   processing AST and formatting JSON schema have been split into two independent steps\n-   not exported types, interfaces, enums are not exposed in the `definitions` section in the JSON schema\n\n## Contributors\n\nThis project is made possible by a [community of contributors](https://github.com/vega/ts-json-schema-generator/graphs/contributors). We welcome contributions of any kind (issues, code, documentation, examples, tests,...). Please read our [code of conduct](https://vega.github.io/vega/about/code-of-conduct).\n\n## CLI Usage\n\nRun the schema generator with npx:\n\n```bash\nnpx ts-json-schema-generator --path 'my/project/**/*.ts' --type 'My.Type.Name'\n```\n\nOr install the package and then run it\n\n```bash\nnpm install --save ts-json-schema-generator\n./node_modules/.bin/ts-json-schema-generator --path 'my/project/**/*.ts' --type 'My.Type.Name'\n```\n\nNote that different platforms (e.g. Windows) may use different path separators so you may have to adjust the command above.\n\nAlso note that you need to quote paths with `*` as otherwise the shell will expand the paths and therefore only pass the first path to the generator.\n\n## Programmatic Usage\n\n```js\n// main.js\n\nconst tsj = require(\"ts-json-schema-generator\");\nconst fs = require(\"fs\");\n\n/** @type {import('ts-json-schema-generator/dist/src/Config').Config} */\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst output_path = \"path/to/output/file\";\n\nconst schema = tsj.createGenerator(config).createSchema(config.type);\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\nRun the schema generator via `node main.js`.\n\n### Custom formatting\n\nExtending the built-in formatting is possible by creating a custom formatter and adding it to the main formatter:\n\n1. First we create a formatter, in this case for formatting function types:\n\n```ts\n// my-function-formatter.ts\nimport { BaseType, Definition, FunctionType, SubTypeFormatter } from \"ts-json-schema-generator\";\nimport ts from \"typescript\";\n\nexport class MyFunctionTypeFormatter implements SubTypeFormatter {\n    // You can skip this line if you don't need childTypeFormatter\n    public constructor(private childTypeFormatter: TypeFormatter) {}\n\n    public supportsType(type: FunctionType): boolean {\n        return type instanceof FunctionType;\n    }\n\n    public getDefinition(type: FunctionType): Definition {\n        // Return a custom schema for the function property.\n        return {\n            type: \"object\",\n            properties: {\n                isFunction: {\n                    type: \"boolean\",\n                    const: true,\n                },\n            },\n        };\n    }\n\n    // If this type does NOT HAVE children, generally all you need is:\n    public getChildren(type: FunctionType): BaseType[] {\n        return [];\n    }\n\n    // However, if children ARE supported, you'll need something similar to\n    // this (see src/TypeFormatter/{Array,Definition,etc}.ts for some examples):\n    public getChildren(type: FunctionType): BaseType[] {\n        return this.childTypeFormatter.getChildren(type.getType());\n    }\n}\n```\n\n2. Then we add the formatter as a child to the core formatter using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyFunctionTypeFormatter } from \"./my-function-formatter.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\n// We configure the formatter an add our custom formatter to it.\nconst formatter = createFormatter(config, (fmt, circularReferenceTypeFormatter) => {\n    // If your formatter DOES NOT support children, e.g. getChildren() { return [] }:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter());\n    // If your formatter DOES support children, you'll need this reference too:\n    fmt.addTypeFormatter(new MyFunctionTypeFormatter(circularReferenceTypeFormatter));\n});\n\nconst program = createProgram(config);\nconst parser = createParser(program, config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n### Custom parsing\n\nSimilar to custom formatting, extending the built-in parsing works practically the same way:\n\n1. First we create a parser, in this case for parsing construct types:\n\n```ts\n// my-constructor-parser.ts\nimport { Context, StringType, ReferenceType, BaseType, SubNodeParser } from \"ts-json-schema-generator\";\n// use typescript exported by TJS to avoid version conflict\nimport ts from \"ts-json-schema-generator\";\n\nexport class MyConstructorParser implements SubNodeParser {\n    supportsNode(node: ts.Node): boolean {\n        return node.kind === ts.SyntaxKind.ConstructorType;\n    }\n    createType(node: ts.Node, context: Context, reference?: ReferenceType): BaseType | undefined {\n        return new StringType(); // Treat constructors as strings in this example\n    }\n}\n```\n\n2. Then we add the parser as a child to the core parser using the augmentation callback:\n\n```ts\nimport { createProgram, createParser, SchemaGenerator, createFormatter } from \"ts-json-schema-generator\";\nimport { MyConstructorParser } from \"./my-constructor-parser.ts\";\nimport fs from \"fs\";\n\nconst config = {\n    path: \"path/to/source/file\",\n    tsconfig: \"path/to/tsconfig.json\",\n    type: \"*\", // Or <type-name> if you want to generate schema for that one type only\n};\n\nconst program = createProgram(config);\n\n// We configure the parser an add our custom parser to it.\nconst parser = createParser(program, config, (prs) => {\n    prs.addNodeParser(new MyConstructorParser());\n});\n\nconst formatter = createFormatter(config);\nconst generator = new SchemaGenerator(program, parser, formatter, config);\nconst schema = generator.createSchema(config.type);\n\nconst schemaString = JSON.stringify(schema, null, 2);\nfs.writeFile(output_path, schemaString, (err) => {\n    if (err) throw err;\n});\n```\n\n## Options\n\n```\n-p, --path 'index.ts'\n    The path to the TypeScript source file. If this is not provided, the type will be searched in the project specified in the `.tsconfig`.\n\n-t, --type 'My.Type.Name'\n    The type the generated schema will represent. If omitted, the generated schema will contain all\n    types found in the files matching path. The same is true if '*' is specified.\n\n-i, --id 'generatedSchemaId'\n    The `$id` of the generated schema. If omitted, there will be no `$id`.\n\n-e, --expose <all|none|export>\n    all: Create shared $ref definitions for all types.\n    none: Do not create shared $ref definitions.\n    export (default): Create shared $ref definitions only for exported types (not tagged as `@internal`).\n\n-f, --tsconfig 'my/project/tsconfig.json'\n    Use a custom tsconfig file for processing typescript (see https://www.typescriptlang.org/docs/handbook/tsconfig-json.html) instead of the default:\n    {\n        \"compilerOptions\": {\n            \"noEmit\": true,\n            \"emitDecoratorMetadata\": true,\n            \"experimentalDecorators\": true,\n            \"target\": \"ES5\",\n            \"module\": \"CommonJS\",\n            \"strictNullChecks\": false,\n        }\n    }\n\n-j, --jsDoc <extended|none|basic>\n    none: Do not use JsDoc annotations.\n    basic: Read JsDoc annotations to provide schema properties.\n    extended (default): Also read @nullable, and @asType annotations.\n\n--unstable\n    Do not sort properties.\n\n--strict-tuples\n    Do not allow additional items on tuples.\n\n--no-top-ref\n    Do not create a top-level $ref definition.\n\n--no-type-check\n    Skip type checks for better performance.\n\n--no-ref-encode\n    Do not encode references. According to the standard, references must be valid URIs but some tools do not support encoded references.\n\n--validation-keywords\n    Provide additional validation keywords to include.\n\n-o, --out\n    Specify the output file path. Without this option, the generator logs the response in the console.\n\n--additional-properties <true|false>\n    Controls whether or not to allow additional properties for objects that have no index signature.\n\n    true: Additional properties are allowed\n    false (default): Additional properties are not allowed\n\n--minify\n    Minify generated schema (default: false)\n```\n\n## Current state\n\n-   `interface` types\n-   `enum` types\n-   `union`, `tuple`, `type[]` types\n-   `Date`, `RegExp`, `URL` types\n-   `string`, `boolean`, `number` types\n-   `\"value\"`, `123`, `true`, `false`, `null`, `undefined` literals\n-   type aliases\n-   generics\n-   `typeof`\n-   `keyof`\n-   conditional types\n\n## Run locally\n\n`yarn --silent run run --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\n## Debug\n\n`yarn --silent run debug --path 'test/valid-data/type-mapped-array/*.ts' --type 'MyObject'`\n\nAnd connect via the debugger protocol.\n\n[AST Explorer](https://astexplorer.net/) is amazing for developers of this tool!\n\n## Publish\n\nPublishing is handled by a 2-branch [pre-release process](https://intuit.github.io/auto/docs/generated/shipit#next-branch-default), configured in `publish-auto.yml`. All changes should be based off the default `next` branch, and are published automatically.\n\n-   PRs made into the default branch are auto-deployed to the `next` pre-release tag on NPM. The result can be installed with `npm install ts-json-schema-generator@next`\n    -   When merging into `next`, please use the `squash and merge` strategy.\n-   To release a new stable version, open a PR from `next` into `stable` using this [compare link](https://github.com/vega/ts-json-schema-generator/compare/stable...next).\n    -   When merging from `next` into `stable`, please use the `create a merge commit` strategy.\n",
      "readmeFilename": "README.md",
      "gitHead": "9f69a47f6dd21e99160071a61b9f557313d1131b",
      "bugs": {
        "url": "https://github.com/vega/ts-json-schema-generator/issues"
      },
      "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
      "_nodeVersion": "18.19.0",
      "_npmVersion": "10.2.3",
      "dist": {
        "integrity": "sha512-Y/Ywj8js2YIJci2uYVwQhW3W4eA4jRggsODz+E2mUrhr3pA8zU8CTDTYhY/D5bvEaqU2mKGvN+MP9cSWB7ytVA==",
        "shasum": "1dcc879dfa93896213006205a73d20d9a4497328",
        "tarball": "https://registry.npmjs.org/ts-json-schema-generator/-/ts-json-schema-generator-1.5.1--canary.1846.9f69a47.0.tgz",
        "fileCount": 726,
        "unpackedSize": 904635,
        "signatures": [
          {
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA",
            "sig": "MEUCIDV68pS8gd0Yhzu1x8tfVa8aomIxWbJ+nx0R8C8B482kAiEApbB3cEQ6zhrqNHJVYkeXNeQsmIXoS5o14k6x/UYxvB4="
          }
        ]
      },
      "_npmUser": {
        "name": "domoritz",
        "email": "domoritz@gmail.com"
      },
      "directories": {},
      "maintainers": [
        {
          "name": "jheer",
          "email": "jeffrey.heer@gmail.com"
        },
        {
          "name": "domoritz",
          "email": "domoritz@gmail.com"
        },
        {
          "name": "kanitw",
          "email": "kanitw@gmail.com"
        }
      ],
      "_npmOperationalInternal": {
        "host": "s3://npm-registry-packages",
        "tmp": "tmp/ts-json-schema-generator_1.5.1--canary.1846.9f69a47.0_1704629233564_0.2639694638681631"
      },
      "_hasShrinkwrap": false
    }
  },
  "readme": "",
  "maintainers": [
    {
      "name": "jheer",
      "email": "jeffrey.heer@gmail.com"
    },
    {
      "name": "domoritz",
      "email": "domoritz@gmail.com"
    },
    {
      "name": "kanitw",
      "email": "kanitw@gmail.com"
    }
  ],
  "time": {
    "modified": "2024-01-07T12:07:13.924Z",
    "created": "2017-09-05T17:56:26.865Z",
    "0.9.0": "2017-09-05T17:56:26.865Z",
    "0.10.0": "2017-09-05T18:35:32.863Z",
    "0.11.0": "2017-09-05T21:08:10.039Z",
    "0.12.0": "2017-09-08T05:00:48.916Z",
    "0.13.0": "2017-10-17T05:24:01.613Z",
    "0.14.0": "2017-10-18T22:50:21.899Z",
    "0.15.0": "2017-11-04T00:18:29.829Z",
    "0.16.0": "2017-11-08T23:54:58.757Z",
    "0.18.0": "2017-12-30T23:26:19.408Z",
    "0.19.0": "2018-01-31T22:37:46.358Z",
    "0.20.0": "2018-02-20T20:05:31.472Z",
    "0.21.0": "2018-03-10T18:18:20.614Z",
    "0.22.0": "2018-03-29T18:09:38.182Z",
    "0.23.0": "2018-03-29T18:24:20.276Z",
    "0.24.1": "2018-04-01T00:25:34.533Z",
    "0.24.2": "2018-04-01T00:27:46.379Z",
    "0.24.3": "2018-04-12T14:25:21.048Z",
    "0.24.5": "2018-04-12T14:47:50.731Z",
    "0.24.6": "2018-04-13T13:37:50.745Z",
    "0.24.7": "2018-05-06T18:05:16.441Z",
    "0.25.0": "2018-05-07T03:38:13.807Z",
    "0.25.1": "2018-05-07T04:00:26.958Z",
    "0.26.0": "2018-06-01T22:48:12.813Z",
    "0.27.0": "2018-06-08T17:04:19.165Z",
    "0.28.0": "2018-06-19T22:07:06.141Z",
    "0.28.1": "2018-07-02T23:21:02.213Z",
    "0.28.2": "2018-07-02T23:55:05.793Z",
    "0.29.0": "2018-07-07T01:09:03.276Z",
    "0.30.0": "2018-07-24T19:08:20.386Z",
    "0.31.0": "2018-07-30T18:12:25.427Z",
    "0.32.0": "2018-08-02T16:03:20.669Z",
    "0.33.0": "2018-09-07T23:32:10.925Z",
    "0.34.0": "2018-09-24T23:23:19.572Z",
    "0.35.0": "2018-09-24T23:52:08.869Z",
    "0.35.1": "2018-09-27T20:35:28.916Z",
    "0.36.0": "2018-10-20T07:54:00.044Z",
    "0.36.3": "2018-11-12T19:46:33.403Z",
    "0.37.0": "2018-12-05T03:05:50.141Z",
    "0.37.1": "2018-12-14T19:03:24.216Z",
    "0.38.0": "2018-12-19T23:25:56.755Z",
    "0.38.1": "2018-12-30T07:34:09.834Z",
    "0.39.0": "2019-01-25T18:45:43.869Z",
    "0.40.0": "2019-02-04T22:12:00.509Z",
    "0.41.0": "2019-04-21T05:09:11.760Z",
    "0.42.0": "2019-05-25T22:37:58.909Z",
    "0.43.0": "2019-05-30T15:20:06.659Z",
    "0.44.0": "2019-06-02T17:40:51.672Z",
    "0.45.0": "2019-06-05T15:53:50.852Z",
    "0.46.0": "2019-06-08T03:50:04.747Z",
    "0.47.0": "2019-06-18T00:32:57.885Z",
    "0.48.0": "2019-06-22T20:37:45.594Z",
    "0.49.0": "2019-06-23T19:46:36.761Z",
    "0.50.0": "2019-06-23T20:02:54.907Z",
    "0.50.1": "2019-06-24T15:52:49.950Z",
    "0.50.2": "2019-06-25T15:58:53.863Z",
    "0.51.0": "2019-07-21T14:51:49.466Z",
    "0.52.2": "2019-07-23T07:26:28.006Z",
    "0.52.10": "2019-07-23T13:14:52.076Z",
    "0.52.9": "2019-07-23T13:15:04.078Z",
    "0.52.12": "2019-07-23T22:19:12.131Z",
    "0.32.14": "2019-07-25T10:16:28.396Z",
    "0.52.13": "2019-07-25T10:35:36.447Z",
    "0.52.14": "2019-07-25T11:16:33.307Z",
    "0.53.0": "2019-10-03T17:24:06.839Z",
    "0.54.0": "2019-10-09T00:39:02.866Z",
    "0.55.0": "2019-10-25T23:11:57.742Z",
    "0.56.0": "2019-11-05T22:22:52.588Z",
    "0.57.0": "2019-12-05T01:31:31.024Z",
    "0.58.0": "2019-12-11T00:34:11.962Z",
    "0.58.1": "2019-12-16T23:19:04.913Z",
    "0.59.0": "2020-02-06T05:25:36.210Z",
    "0.60.0": "2020-02-08T01:09:29.655Z",
    "0.61.0": "2020-02-21T01:34:24.849Z",
    "0.61.1": "2020-02-28T22:58:39.453Z",
    "0.62.0": "2020-03-04T02:48:43.206Z",
    "0.63.0": "2020-03-04T22:57:16.670Z",
    "0.64.0": "2020-03-05T18:11:22.945Z",
    "0.65.0": "2020-03-07T01:22:51.370Z",
    "0.66.0": "2020-04-17T21:48:58.570Z",
    "0.67.0": "2020-04-19T00:35:32.849Z",
    "0.67.1": "2020-04-19T00:39:14.279Z",
    "0.68.0": "2020-05-13T16:36:24.711Z",
    "0.68.1": "2020-05-25T18:44:45.291Z",
    "0.69.0": "2020-06-03T17:11:25.047Z",
    "0.70.0": "2020-06-04T18:24:43.924Z",
    "0.70.1": "2020-06-05T04:07:01.186Z",
    "0.70.2": "2020-06-27T20:31:57.974Z",
    "0.71.0": "2020-08-11T21:18:20.556Z",
    "0.71.1": "2020-08-13T01:23:20.059Z",
    "0.71.2": "2020-08-20T17:36:08.717Z",
    "0.72.0": "2020-08-22T17:55:35.550Z",
    "0.72.1": "2020-08-22T17:56:32.563Z",
    "0.73.0": "2020-09-01T21:52:02.827Z",
    "0.74.0": "2020-09-18T20:50:03.858Z",
    "0.75.0": "2020-10-02T17:20:31.300Z",
    "0.76.0": "2020-10-10T04:33:30.498Z",
    "0.76.1": "2020-10-10T15:26:15.697Z",
    "0.77.0": "2020-10-19T02:23:50.913Z",
    "0.78.0": "2020-11-10T16:52:20.536Z",
    "0.79.0": "2020-11-26T20:13:56.519Z",
    "0.80.0": "2020-12-01T15:13:29.232Z",
    "0.80.1": "2020-12-15T08:06:30.375Z",
    "0.81.0": "2020-12-21T22:17:47.486Z",
    "0.82.0": "2020-12-23T12:02:31.193Z",
    "0.83.0": "2021-01-15T22:05:59.219Z",
    "0.83.1": "2021-01-16T12:39:18.458Z",
    "0.83.2": "2021-01-16T12:54:12.831Z",
    "0.84.0": "2021-02-05T13:24:39.629Z",
    "0.85.0": "2021-02-17T11:04:43.753Z",
    "0.86.0": "2021-02-17T13:09:59.786Z",
    "0.86.1": "2021-02-17T18:04:05.020Z",
    "0.87.0": "2021-02-26T12:31:18.806Z",
    "0.88.0": "2021-02-27T14:15:12.398Z",
    "0.89.0": "2021-03-12T16:15:37.538Z",
    "0.89.1": "2021-03-26T18:37:44.349Z",
    "0.89.2": "2021-04-04T23:41:59.279Z",
    "0.89.3": "2021-04-09T21:13:52.582Z",
    "0.90.0": "2021-04-14T19:08:39.831Z",
    "0.91.0": "2021-04-22T15:51:35.993Z",
    "0.92.0": "2021-05-07T22:51:33.799Z",
    "0.93.0": "2021-05-26T20:50:59.377Z",
    "0.94.0": "2021-07-03T21:45:17.699Z",
    "0.94.1": "2021-07-07T22:13:52.780Z",
    "0.94.2--canary.856.f772d29.0": "2021-07-16T01:30:08.723Z",
    "0.94.2--canary.856.e019c4a.0": "2021-07-16T01:52:31.819Z",
    "0.95.0": "2021-07-22T20:26:50.820Z",
    "0.95.1--canary.880.58f5731.0": "2021-07-28T16:55:52.874Z",
    "0.95.1--canary.941.6142f46.0": "2021-09-17T16:18:18.761Z",
    "0.95.1--canary.942.488f6c9.0": "2021-09-17T16:23:27.256Z",
    "0.95.1--canary.941.ae0db8a.0": "2021-09-17T16:39:00.351Z",
    "0.95.1--canary.954.5c1fbdb.0": "2021-09-20T13:04:59.531Z",
    "0.96.0-next.0": "2021-09-23T15:06:05.424Z",
    "0.96.0-next.1": "2021-10-05T01:42:06.351Z",
    "0.96.0-next.2": "2021-10-05T16:27:55.287Z",
    "0.96.0": "2021-10-05T16:56:01.296Z",
    "0.96.1--canary.978.8eee423.0": "2021-10-07T02:40:51.835Z",
    "0.96.1--canary.979.51a876b.0": "2021-10-07T02:49:51.386Z",
    "0.96.1--canary.979.fe4869a.0": "2021-10-07T12:10:22.316Z",
    "0.96.1--canary.982.c7861b4.0": "2021-10-11T14:39:40.077Z",
    "0.97.0-next.0": "2021-10-12T16:36:09.592Z",
    "0.97.0-next.1": "2021-10-14T13:36:33.130Z",
    "0.97.0-next.2": "2021-10-14T13:37:39.202Z",
    "0.97.0-next.3": "2021-10-15T16:04:31.307Z",
    "0.97.0-next.4": "2021-10-24T19:09:52.464Z",
    "0.97.0-next.5": "2021-11-01T13:16:48.601Z",
    "0.97.0": "2021-11-04T16:49:51.530Z",
    "0.97.1--canary.1017.09dac90.0": "2021-11-17T01:06:06.031Z",
    "0.97.1--canary.1017.09dac90.1": "2021-11-17T01:24:16.562Z",
    "0.97.1--canary.1017.f5848fa.0": "2021-11-19T21:44:28.941Z",
    "0.97.1--canary.1017.f5848fa.1": "2021-11-19T21:48:43.487Z",
    "0.97.1--canary.1017.a612074.0": "2021-11-21T14:36:51.394Z",
    "0.98.0--canary.1027.7b60d67.0": "2021-11-21T14:39:18.262Z",
    "0.97.1--canary.1037.b55fd54.0": "2021-11-28T20:29:20.258Z",
    "0.97.1--canary.b6f3ead.0": "2021-11-29T23:22:35.142Z",
    "0.97.1--canary.1039.7266c79.0": "2021-11-29T23:27:45.839Z",
    "0.97.1--canary.1045.b192845.0": "2021-11-30T23:37:22.381Z",
    "0.97.1--canary.1092.074aec1.0": "2022-01-12T23:00:02.676Z",
    "0.97.1--canary.1093.43d6c2f.0": "2022-01-14T01:05:16.114Z",
    "0.97.1-next.0": "2022-01-14T01:17:20.907Z",
    "0.97.1-next.1": "2022-02-08T17:57:57.220Z",
    "0.98.0-next.0": "2022-02-11T17:54:57.981Z",
    "0.98.0-next.1": "2022-02-16T03:10:14.842Z",
    "0.98.0": "2022-02-16T03:42:36.230Z",
    "0.98.1-next.0": "2022-03-11T12:54:22.385Z",
    "0.98.1-next.1": "2022-03-16T19:29:39.160Z",
    "0.98.1-next.2": "2022-03-20T20:17:47.628Z",
    "0.98.1-next.3": "2022-03-21T15:58:54.497Z",
    "0.98.1-next.4": "2022-03-21T16:00:23.369Z",
    "1.0.0": "2022-03-21T16:09:33.335Z",
    "1.0.1-next.0": "2022-03-22T20:40:30.326Z",
    "1.0.1-next.1": "2022-03-30T23:14:12.109Z",
    "1.0.1--canary.9aa9c56.0": "2022-04-06T02:02:27.487Z",
    "1.1.0-next.0": "2022-04-07T12:34:30.499Z",
    "1.0.1--canary.1222.31471bc.0": "2022-04-17T13:30:24.604Z",
    "1.1.0-next.1": "2022-04-17T13:31:43.617Z",
    "1.1.0-next.2": "2022-05-06T18:12:26.982Z",
    "1.1.0-next.3": "2022-05-06T18:13:49.453Z",
    "1.1.0-next.4": "2022-05-25T20:35:45.053Z",
    "1.1.0-next.5": "2022-05-26T13:45:23.181Z",
    "1.0.1--canary.858e8cf.0": "2022-09-21T01:42:57.235Z",
    "1.1.0-next.6": "2022-09-21T02:36:40.863Z",
    "1.0.1--canary.1362.c55cbf2.0": "2022-09-21T02:52:36.958Z",
    "1.1.0": "2022-09-21T03:36:36.460Z",
    "2.0.0-next.0": "2022-09-21T03:36:50.723Z",
    "1.1.1-next.0": "2022-09-22T01:09:56.452Z",
    "1.1.1": "2022-09-22T01:10:46.444Z",
    "1.1.2-next.0": "2022-09-25T02:21:14.889Z",
    "1.1.2": "2022-09-28T20:59:17.242Z",
    "1.2.0-next.0": "2022-10-16T14:04:15.412Z",
    "1.2.0-next.1": "2022-10-17T13:07:11.561Z",
    "1.2.0-next.2": "2022-11-22T13:36:38.660Z",
    "1.2.0-next.3": "2022-12-03T02:52:30.435Z",
    "1.1.3--canary.1487.fdad021.0": "2022-12-03T02:59:29.964Z",
    "1.1.3--canary.1489.d176f88.0": "2022-12-04T14:43:26.277Z",
    "1.1.3--canary.1490.fdad021.0": "2022-12-06T15:33:19.487Z",
    "1.2.0-next.4": "2022-12-09T15:46:12.339Z",
    "1.2.0-next.5": "2022-12-21T04:01:21.865Z",
    "1.2.0-next.6": "2022-12-21T15:08:28.500Z",
    "1.2.0-next.7": "2022-12-22T17:13:52.061Z",
    "1.2.0": "2022-12-22T17:31:50.862Z",
    "1.2.1-next.0": "2023-01-20T16:40:10.833Z",
    "1.2.1-next.1": "2023-01-27T12:53:56.136Z",
    "1.2.1--canary.1546.3e5f67d.0": "2023-01-27T15:12:00.542Z",
    "1.2.1-next.2": "2023-01-31T20:19:25.418Z",
    "1.3.0-next.0": "2023-02-22T01:31:40.077Z",
    "1.2.1--canary.1593.b692d84.0": "2023-03-03T16:43:41.697Z",
    "1.3.0--canary.1593.e6a3b2b.0": "2023-03-03T16:45:11.489Z",
    "1.3.0--canary.1593.8d550bb.0": "2023-03-03T16:47:15.390Z",
    "1.3.0--canary.1594.8aec388.0": "2023-03-03T16:49:12.308Z",
    "1.3.0-next.1": "2023-03-03T18:22:23.314Z",
    "1.2.1--canary.1594.c05565b.0": "2023-03-03T18:22:25.473Z",
    "1.2.1--canary.1593.a1dc8a7.0": "2023-03-03T18:22:39.421Z",
    "1.3.0-next.2": "2023-03-03T18:44:51.407Z",
    "1.3.0--canary.1612.745acbd.0": "2023-03-17T00:33:58.288Z",
    "1.3.0-next.3": "2023-03-17T01:25:07.257Z",
    "1.3.0-next.4": "2023-04-12T13:49:42.135Z",
    "1.3.0-next.5": "2023-05-26T10:25:18.373Z",
    "1.2.1--canary.1710.488f927.0": "2023-06-25T18:00:04.148Z",
    "1.2.1--canary.1710.16eda00.0": "2023-06-25T21:51:53.346Z",
    "1.2.1--canary.1710.2f8374c.0": "2023-06-25T22:07:02.842Z",
    "1.3.0-next.6": "2023-06-25T22:26:35.714Z",
    "1.3.0-next.7": "2023-07-04T23:48:54.890Z",
    "1.3.0-next.8": "2023-08-02T12:57:06.689Z",
    "1.3.0-next.9": "2023-08-14T16:42:15.311Z",
    "1.3.0": "2023-08-14T16:43:36.711Z",
    "1.4.0-next.0": "2023-10-15T13:57:53.514Z",
    "1.4.0-next.1": "2023-10-16T01:05:51.749Z",
    "1.4.0": "2023-10-16T01:06:39.838Z",
    "1.4.1-next.0": "2023-11-27T14:39:05.957Z",
    "1.4.1": "2023-11-27T15:40:15.515Z",
    "1.5.0-next.0": "2023-12-05T19:09:22.318Z",
    "1.5.0": "2023-12-05T19:09:47.541Z",
    "1.5.1-next.0": "2023-12-06T13:15:46.435Z",
    "1.5.1--canary.1846.9f69a47.0": "2024-01-07T12:07:13.758Z"
  },
  "homepage": "https://github.com/vega/ts-json-schema-generator#readme",
  "keywords": [
    "ts",
    "typescript",
    "json",
    "schema",
    "jsonschema"
  ],
  "repository": {
    "type": "git",
    "url": "git+https://github.com/vega/ts-json-schema-generator.git"
  },
  "contributors": [
    {
      "name": "Dominik Moritz",
      "email": "domoritz@gmail.com"
    },
    {
      "name": "MooYeol Prescott Lee",
      "email": "mooyoul@gmail.com"
    }
  ],
  "author": {
    "name": "Alexander Evtushenko",
    "email": "aevtushenko@xiag.ch"
  },
  "bugs": {
    "url": "https://github.com/vega/ts-json-schema-generator/issues"
  },
  "readmeFilename": "",
  "license": "MIT",
  "users": {
    "flumpus-dev": true
  }
}